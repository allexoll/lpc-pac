#![doc = "Peripheral access API for LPC82X microcontrollers (generated using svd2rust v0.13.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.13.0/svd2rust/#peripheral-api"]
#![deny(missing_docs)]
#![deny(warnings)]
#![allow(non_camel_case_types)]
#![no_std]
extern crate bare_metal;
extern crate cortex_m;
#[cfg(feature = "rt")]
extern crate cortex_m_rt;
extern crate vcell;
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r" Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
extern "C" {
    fn SPI0();
    fn SPI1();
    fn UART0();
    fn UART1();
    fn UART2();
    fn I2C1();
    fn I2C0();
    fn SCT();
    fn MRT();
    fn CMP();
    fn WDT();
    fn BOD();
    fn FLASH();
    fn WKT();
    fn ADC_SEQA();
    fn ADC_SEQB();
    fn ADC_THCMP();
    fn ADC_OVR();
    fn DMA();
    fn I2C2();
    fn I2C3();
    fn PIN_INT0();
    fn PIN_INT1();
    fn PIN_INT2();
    fn PIN_INT3();
    fn PIN_INT4();
    fn PIN_INT5();
    fn PIN_INT6();
    fn PIN_INT7();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 32] = [
    Vector { _handler: SPI0 },
    Vector { _handler: SPI1 },
    Vector { _reserved: 0 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: UART2 },
    Vector { _reserved: 0 },
    Vector { _handler: I2C1 },
    Vector { _handler: I2C0 },
    Vector { _handler: SCT },
    Vector { _handler: MRT },
    Vector { _handler: CMP },
    Vector { _handler: WDT },
    Vector { _handler: BOD },
    Vector { _handler: FLASH },
    Vector { _handler: WKT },
    Vector { _handler: ADC_SEQA },
    Vector { _handler: ADC_SEQB },
    Vector {
        _handler: ADC_THCMP,
    },
    Vector { _handler: ADC_OVR },
    Vector { _handler: DMA },
    Vector { _handler: I2C2 },
    Vector { _handler: I2C3 },
    Vector { _reserved: 0 },
    Vector { _handler: PIN_INT0 },
    Vector { _handler: PIN_INT1 },
    Vector { _handler: PIN_INT2 },
    Vector { _handler: PIN_INT3 },
    Vector { _handler: PIN_INT4 },
    Vector { _handler: PIN_INT5 },
    Vector { _handler: PIN_INT6 },
    Vector { _handler: PIN_INT7 },
];
#[doc = r" Macro to override a device specific interrupt handler"]
#[doc = r""]
#[doc = r" # Syntax"]
#[doc = r""]
#[doc = r" ``` ignore"]
#[doc = r" interrupt!("]
#[doc = r"     // Name of the interrupt"]
#[doc = r"     $Name:ident,"]
#[doc = r""]
#[doc = r"     // Path to the interrupt handler (a function)"]
#[doc = r"     $handler:path,"]
#[doc = r""]
#[doc = r"     // Optional, state preserved across invocations of the handler"]
#[doc = r"     state: $State:ty = $initial_state:expr,"]
#[doc = r" );"]
#[doc = r" ```"]
#[doc = r""]
#[doc = r" Where `$Name` must match the name of one of the variants of the `Interrupt`"]
#[doc = r" enum."]
#[doc = r""]
#[doc = r" The handler must have signature `fn()` is no state was associated to it;"]
#[doc = r" otherwise its signature must be `fn(&mut $State)`."]
#[cfg(feature = "rt")]
#[macro_export]
macro_rules! interrupt {
    ($Name:ident, $handler:path,state: $State:ty = $initial_state:expr) => {
        #[allow(unsafe_code)]
        #[deny(private_no_mangle_fns)]
        #[no_mangle]
        pub unsafe extern "C" fn $Name() {
            static mut STATE: $State = $initial_state;
            let _ = $crate::Interrupt::$Name;
            let f: fn(&mut $State) = $handler;
            f(&mut STATE)
        }
    };
    ($Name:ident, $handler:path) => {
        #[allow(unsafe_code)]
        #[deny(private_no_mangle_fns)]
        #[no_mangle]
        pub unsafe extern "C" fn $Name() {
            let _ = $crate::Interrupt::$Name;
            let f: fn() = $handler;
            f()
        }
    };
}
#[doc = r" Enumeration of all the interrupts"]
pub enum Interrupt {
    #[doc = "0 - SPI0"]
    SPI0,
    #[doc = "1 - SPI1"]
    SPI1,
    #[doc = "3 - UART0"]
    UART0,
    #[doc = "4 - UART1"]
    UART1,
    #[doc = "5 - UART2"]
    UART2,
    #[doc = "7 - I2C1"]
    I2C1,
    #[doc = "8 - I2C0"]
    I2C0,
    #[doc = "9 - SCT"]
    SCT,
    #[doc = "10 - MRT"]
    MRT,
    #[doc = "11 - CMP"]
    CMP,
    #[doc = "12 - WDT"]
    WDT,
    #[doc = "13 - BOD"]
    BOD,
    #[doc = "14 - FLASH"]
    FLASH,
    #[doc = "15 - WKT"]
    WKT,
    #[doc = "16 - ADC_SEQA"]
    ADC_SEQA,
    #[doc = "17 - ADC_SEQB"]
    ADC_SEQB,
    #[doc = "18 - ADC_THCMP"]
    ADC_THCMP,
    #[doc = "19 - ADC_OVR"]
    ADC_OVR,
    #[doc = "20 - DMA"]
    DMA,
    #[doc = "21 - I2C2"]
    I2C2,
    #[doc = "22 - I2C3"]
    I2C3,
    #[doc = "24 - PIN_INT0"]
    PIN_INT0,
    #[doc = "25 - PIN_INT1"]
    PIN_INT1,
    #[doc = "26 - PIN_INT2"]
    PIN_INT2,
    #[doc = "27 - PIN_INT3"]
    PIN_INT3,
    #[doc = "28 - PIN_INT4"]
    PIN_INT4,
    #[doc = "29 - PIN_INT5"]
    PIN_INT5,
    #[doc = "30 - PIN_INT6"]
    PIN_INT6,
    #[doc = "31 - PIN_INT7"]
    PIN_INT7,
}
unsafe impl ::bare_metal::Nr for Interrupt {
    #[inline]
    fn nr(&self) -> u8 {
        match *self {
            Interrupt::SPI0 => 0,
            Interrupt::SPI1 => 1,
            Interrupt::UART0 => 3,
            Interrupt::UART1 => 4,
            Interrupt::UART2 => 5,
            Interrupt::I2C1 => 7,
            Interrupt::I2C0 => 8,
            Interrupt::SCT => 9,
            Interrupt::MRT => 10,
            Interrupt::CMP => 11,
            Interrupt::WDT => 12,
            Interrupt::BOD => 13,
            Interrupt::FLASH => 14,
            Interrupt::WKT => 15,
            Interrupt::ADC_SEQA => 16,
            Interrupt::ADC_SEQB => 17,
            Interrupt::ADC_THCMP => 18,
            Interrupt::ADC_OVR => 19,
            Interrupt::DMA => 20,
            Interrupt::I2C2 => 21,
            Interrupt::I2C3 => 22,
            Interrupt::PIN_INT0 => 24,
            Interrupt::PIN_INT1 => 25,
            Interrupt::PIN_INT2 => 26,
            Interrupt::PIN_INT3 => 27,
            Interrupt::PIN_INT4 => 28,
            Interrupt::PIN_INT5 => 29,
            Interrupt::PIN_INT6 => 30,
            Interrupt::PIN_INT7 => 31,
        }
    }
}
#[doc(hidden)]
pub mod interrupt {}
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[doc = "Windowed Watchdog Timer (WWDT)"]
pub struct WWDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDT {}
impl WWDT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const wwdt::RegisterBlock {
        0x4000_0000 as *const _
    }
}
impl Deref for WWDT {
    type Target = wwdt::RegisterBlock;
    fn deref(&self) -> &wwdt::RegisterBlock {
        unsafe { &*WWDT::ptr() }
    }
}
#[doc = "Windowed Watchdog Timer (WWDT)"]
pub mod wwdt {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
        pub mod_: MOD,
        #[doc = "0x04 - Watchdog timer constant register. This 24-bit register determines the time-out value."]
        pub tc: TC,
        #[doc = "0x08 - Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
        pub feed: FEED,
        #[doc = "0x0c - Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer."]
        pub tv: TV,
        _reserved0: [u8; 4usize],
        #[doc = "0x14 - Watchdog Warning Interrupt compare value."]
        pub warnint: WARNINT,
        #[doc = "0x18 - Watchdog Window compare value."]
        pub window: WINDOW,
    }
    #[doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
    pub struct MOD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
    pub mod mod_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MOD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDENR {
            #[doc = "The watchdog timer is stopped."]
            STOPPED,
            #[doc = "The watchdog timer is running."]
            RUNNING,
        }
        impl WDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDENR::STOPPED => false,
                    WDENR::RUNNING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDENR {
                match value {
                    false => WDENR::STOPPED,
                    true => WDENR::RUNNING,
                }
            }
            #[doc = "Checks if the value of the field is `STOPPED`"]
            #[inline]
            pub fn is_stopped(&self) -> bool {
                *self == WDENR::STOPPED
            }
            #[doc = "Checks if the value of the field is `RUNNING`"]
            #[inline]
            pub fn is_running(&self) -> bool {
                *self == WDENR::RUNNING
            }
        }
        #[doc = "Possible values of the field `WDRESET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDRESETR {
            #[doc = "A watchdog timeout will not cause a chip reset."]
            NORESET,
            #[doc = "A watchdog timeout will cause a chip reset."]
            RESET,
        }
        impl WDRESETR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDRESETR::NORESET => false,
                    WDRESETR::RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDRESETR {
                match value {
                    false => WDRESETR::NORESET,
                    true => WDRESETR::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NORESET`"]
            #[inline]
            pub fn is_noreset(&self) -> bool {
                *self == WDRESETR::NORESET
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == WDRESETR::RESET
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDTOFR {
            bits: bool,
        }
        impl WDTOFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDINTR {
            bits: bool,
        }
        impl WDINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WDPROTECT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDPROTECTR {
            #[doc = "The watchdog time-out value (TC) can be changed at any time."]
            UNPROTECTED,
            #[doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW."]
            PROTECTED,
        }
        impl WDPROTECTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDPROTECTR::UNPROTECTED => false,
                    WDPROTECTR::PROTECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDPROTECTR {
                match value {
                    false => WDPROTECTR::UNPROTECTED,
                    true => WDPROTECTR::PROTECTED,
                }
            }
            #[doc = "Checks if the value of the field is `UNPROTECTED`"]
            #[inline]
            pub fn is_unprotected(&self) -> bool {
                *self == WDPROTECTR::UNPROTECTED
            }
            #[doc = "Checks if the value of the field is `PROTECTED`"]
            #[inline]
            pub fn is_protected(&self) -> bool {
                *self == WDPROTECTR::PROTECTED
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: bool,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `WDEN`"]
        pub enum WDENW {
            #[doc = "The watchdog timer is stopped."]
            STOPPED,
            #[doc = "The watchdog timer is running."]
            RUNNING,
        }
        impl WDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDENW::STOPPED => false,
                    WDENW::RUNNING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The watchdog timer is stopped."]
            #[inline]
            pub fn stopped(self) -> &'a mut W {
                self.variant(WDENW::STOPPED)
            }
            #[doc = "The watchdog timer is running."]
            #[inline]
            pub fn running(self) -> &'a mut W {
                self.variant(WDENW::RUNNING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDRESET`"]
        pub enum WDRESETW {
            #[doc = "A watchdog timeout will not cause a chip reset."]
            NORESET,
            #[doc = "A watchdog timeout will cause a chip reset."]
            RESET,
        }
        impl WDRESETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDRESETW::NORESET => false,
                    WDRESETW::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDRESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDRESETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDRESETW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "A watchdog timeout will not cause a chip reset."]
            #[inline]
            pub fn noreset(self) -> &'a mut W {
                self.variant(WDRESETW::NORESET)
            }
            #[doc = "A watchdog timeout will cause a chip reset."]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(WDRESETW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDPROTECT`"]
        pub enum WDPROTECTW {
            #[doc = "The watchdog time-out value (TC) can be changed at any time."]
            UNPROTECTED,
            #[doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW."]
            PROTECTED,
        }
        impl WDPROTECTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDPROTECTW::UNPROTECTED => false,
                    WDPROTECTW::PROTECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDPROTECTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDPROTECTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDPROTECTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The watchdog time-out value (TC) can be changed at any time."]
            #[inline]
            pub fn unprotected(self) -> &'a mut W {
                self.variant(WDPROTECTW::UNPROTECTED)
            }
            #[doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW."]
            #[inline]
            pub fn protected(self) -> &'a mut W {
                self.variant(WDPROTECTW::PROTECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog enable bit. Once this bit has been written with a 1, it cannot be rewritten with a 0."]
            #[inline]
            pub fn wden(&self) -> WDENR {
                WDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0."]
            #[inline]
            pub fn wdreset(&self) -> WDRESETR {
                WDRESETR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1."]
            #[inline]
            pub fn wdtof(&self) -> WDTOFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDTOFR { bits }
            }
            #[doc = "Bit 3 - Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software."]
            #[inline]
            pub fn wdint(&self) -> WDINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDINTR { bits }
            }
            #[doc = "Bit 4 - Watchdog update mode. This bit can be set once by software and is only cleared by a reset."]
            #[inline]
            pub fn wdprotect(&self) -> WDPROTECTR {
                WDPROTECTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - A 1 in this bit prevents disabling or powering down the watchdog oscillator. This bit can be set once by software and is only cleared by any reset."]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Watchdog enable bit. Once this bit has been written with a 1, it cannot be rewritten with a 0."]
            #[inline]
            pub fn wden(&mut self) -> _WDENW {
                _WDENW { w: self }
            }
            #[doc = "Bit 1 - Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0."]
            #[inline]
            pub fn wdreset(&mut self) -> _WDRESETW {
                _WDRESETW { w: self }
            }
            #[doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1."]
            #[inline]
            pub fn wdtof(&mut self) -> _WDTOFW {
                _WDTOFW { w: self }
            }
            #[doc = "Bit 3 - Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software."]
            #[inline]
            pub fn wdint(&mut self) -> _WDINTW {
                _WDINTW { w: self }
            }
            #[doc = "Bit 4 - Watchdog update mode. This bit can be set once by software and is only cleared by a reset."]
            #[inline]
            pub fn wdprotect(&mut self) -> _WDPROTECTW {
                _WDPROTECTW { w: self }
            }
            #[doc = "Bit 5 - A 1 in this bit prevents disabling or powering down the watchdog oscillator. This bit can be set once by software and is only cleared by any reset."]
            #[inline]
            pub fn lock(&mut self) -> _LOCKW {
                _LOCKW { w: self }
            }
        }
    }
    #[doc = "Watchdog timer constant register. This 24-bit register determines the time-out value."]
    pub struct TC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog timer constant register. This 24-bit register determines the time-out value."]
    pub mod tc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Watchdog time-out value."]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Watchdog time-out value."]
            #[inline]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
    pub struct FEED {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
    pub mod feed {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FEED {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FEEDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Feed value should be 0xAA followed by 0x55."]
            #[inline]
            pub fn feed(&mut self) -> _FEEDW {
                _FEEDW { w: self }
            }
        }
    }
    #[doc = "Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer."]
    pub struct TV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer."]
    pub mod tv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::TV {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Counter timer value."]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
    }
    #[doc = "Watchdog Warning Interrupt compare value."]
    pub struct WARNINT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog Warning Interrupt compare value."]
    pub mod warnint {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WARNINT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WARNINTR {
            bits: u16,
        }
        impl WARNINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WARNINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WARNINTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Watchdog warning interrupt compare value."]
            #[inline]
            pub fn warnint(&self) -> WARNINTR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                WARNINTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - Watchdog warning interrupt compare value."]
            #[inline]
            pub fn warnint(&mut self) -> _WARNINTW {
                _WARNINTW { w: self }
            }
        }
    }
    #[doc = "Watchdog Window compare value."]
    pub struct WINDOW {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog Window compare value."]
    pub mod window {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WINDOW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINDOWR {
            bits: u32,
        }
        impl WINDOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINDOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINDOWW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Watchdog window value."]
            #[inline]
            pub fn window(&self) -> WINDOWR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WINDOWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x00ff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Watchdog window value."]
            #[inline]
            pub fn window(&mut self) -> _WINDOWW {
                _WINDOWW { w: self }
            }
        }
    }
}
#[doc = "Multi-Rate Timer (MRT)"]
pub struct MRT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MRT {}
impl MRT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const mrt::RegisterBlock {
        0x4000_4000 as *const _
    }
}
impl Deref for MRT {
    type Target = mrt::RegisterBlock;
    fn deref(&self) -> &mrt::RegisterBlock {
        unsafe { &*MRT::ptr() }
    }
}
#[doc = "Multi-Rate Timer (MRT)"]
pub mod mrt {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval0: INTVAL,
        #[doc = "0x04 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer0: TIMER,
        #[doc = "0x08 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl0: CTRL,
        #[doc = "0x0c - MRT0 Status register."]
        pub stat0: STAT,
        #[doc = "0x10 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval1: INTVAL,
        #[doc = "0x14 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer1: TIMER,
        #[doc = "0x18 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl1: CTRL,
        #[doc = "0x1c - MRT0 Status register."]
        pub stat1: STAT,
        #[doc = "0x20 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval2: INTVAL,
        #[doc = "0x24 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer2: TIMER,
        #[doc = "0x28 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl2: CTRL,
        #[doc = "0x2c - MRT0 Status register."]
        pub stat2: STAT,
        #[doc = "0x30 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval3: INTVAL,
        #[doc = "0x34 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer3: TIMER,
        #[doc = "0x38 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl3: CTRL,
        #[doc = "0x3c - MRT0 Status register."]
        pub stat3: STAT,
        _reserved0: [u8; 180usize],
        #[doc = "0xf4 - Idle channel register. This register returns the number of the first idle channel."]
        pub idle_ch: IDLE_CH,
        #[doc = "0xf8 - Global interrupt flag register"]
        pub irq_flag: IRQ_FLAG,
    }
    #[doc = "MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
    pub struct INTVAL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
    pub mod intval {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTVAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IVALUER {
            bits: u32,
        }
        impl IVALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `LOAD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOADR {
            #[doc = "No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected."]
            NO_FORCE_LOAD_THE_L,
            #[doc = "Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running."]
            FORCE_LOAD_THE_INTV,
        }
        impl LOADR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOADR::NO_FORCE_LOAD_THE_L => false,
                    LOADR::FORCE_LOAD_THE_INTV => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOADR {
                match value {
                    false => LOADR::NO_FORCE_LOAD_THE_L,
                    true => LOADR::FORCE_LOAD_THE_INTV,
                }
            }
            #[doc = "Checks if the value of the field is `NO_FORCE_LOAD_THE_L`"]
            #[inline]
            pub fn is_no_force_load_the_l(&self) -> bool {
                *self == LOADR::NO_FORCE_LOAD_THE_L
            }
            #[doc = "Checks if the value of the field is `FORCE_LOAD_THE_INTV`"]
            #[inline]
            pub fn is_force_load_the_intv(&self) -> bool {
                *self == LOADR::FORCE_LOAD_THE_INTV
            }
        }
        #[doc = r" Proxy"]
        pub struct _IVALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IVALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x7fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOAD`"]
        pub enum LOADW {
            #[doc = "No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected."]
            NO_FORCE_LOAD_THE_L,
            #[doc = "Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running."]
            FORCE_LOAD_THE_INTV,
        }
        impl LOADW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOADW::NO_FORCE_LOAD_THE_L => false,
                    LOADW::FORCE_LOAD_THE_INTV => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOADW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LOADW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected."]
            #[inline]
            pub fn no_force_load_the_l(self) -> &'a mut W {
                self.variant(LOADW::NO_FORCE_LOAD_THE_L)
            }
            #[doc = "Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running."]
            #[inline]
            pub fn force_load_the_intv(self) -> &'a mut W {
                self.variant(LOADW::FORCE_LOAD_THE_INTV)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:30 - Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately. If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval."]
            #[inline]
            pub fn ivalue(&self) -> IVALUER {
                let bits = {
                    const MASK: u32 = 0x7fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                IVALUER { bits }
            }
            #[doc = "Bit 31 - Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0."]
            #[inline]
            pub fn load(&self) -> LOADR {
                LOADR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:30 - Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately. If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval."]
            #[inline]
            pub fn ivalue(&mut self) -> _IVALUEW {
                _IVALUEW { w: self }
            }
            #[doc = "Bit 31 - Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0."]
            #[inline]
            pub fn load(&mut self) -> _LOADW {
                _LOADW { w: self }
            }
        }
    }
    #[doc = "MRT0 Timer register. This register reads the value of the down-counter."]
    pub struct TIMER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "MRT0 Timer register. This register reads the value of the down-counter."]
    pub mod timer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::TIMER {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u32,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:30 - Holds the current timer value of the down-counter. The initial value is loaded as IVALUE - 1 from the TIME_INTVALn register either at the end of the time interval if the LOAD bit in TIME_INTVALn is 0 and the timer is in repeat mode or immediately if LOAD = 1. When the timer is in idle state, reading this bit fields returns -1 (0x7FFF FFFF)."]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u32 = 0x7fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                VALUER { bits }
            }
        }
    }
    #[doc = "MRT0 Control register. This register controls the MRT0 modes."]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "MRT0 Control register. This register controls the MRT0 modes."]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTENR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl INTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INTENR::DISABLE_ => false,
                    INTENR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INTENR {
                match value {
                    false => INTENR::DISABLE_,
                    true => INTENR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline]
            pub fn is_disable_(&self) -> bool {
                *self == INTENR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline]
            pub fn is_enable_(&self) -> bool {
                *self == INTENR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Repeat interrupt mode."]
            REPEAT_INTERRUPT_MOD,
            #[doc = "One-shot interrupt mode."]
            ONE_SHOT_INTERRUPT_M,
            #[doc = "One-shot bus stall mode."]
            ONE_SHOT_BUS_STALL_M,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::REPEAT_INTERRUPT_MOD => 0,
                    MODER::ONE_SHOT_INTERRUPT_M => 0x01,
                    MODER::ONE_SHOT_BUS_STALL_M => 0x02,
                    MODER::RESERVED_ => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::REPEAT_INTERRUPT_MOD,
                    1 => MODER::ONE_SHOT_INTERRUPT_M,
                    2 => MODER::ONE_SHOT_BUS_STALL_M,
                    3 => MODER::RESERVED_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `REPEAT_INTERRUPT_MOD`"]
            #[inline]
            pub fn is_repeat_interrupt_mod(&self) -> bool {
                *self == MODER::REPEAT_INTERRUPT_MOD
            }
            #[doc = "Checks if the value of the field is `ONE_SHOT_INTERRUPT_M`"]
            #[inline]
            pub fn is_one_shot_interrupt_m(&self) -> bool {
                *self == MODER::ONE_SHOT_INTERRUPT_M
            }
            #[doc = "Checks if the value of the field is `ONE_SHOT_BUS_STALL_M`"]
            #[inline]
            pub fn is_one_shot_bus_stall_m(&self) -> bool {
                *self == MODER::ONE_SHOT_BUS_STALL_M
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline]
            pub fn is_reserved_(&self) -> bool {
                *self == MODER::RESERVED_
            }
        }
        #[doc = "Values that can be written to the field `INTEN`"]
        pub enum INTENW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl INTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INTENW::DISABLE_ => false,
                    INTENW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable_(self) -> &'a mut W {
                self.variant(INTENW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable_(self) -> &'a mut W {
                self.variant(INTENW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Repeat interrupt mode."]
            REPEAT_INTERRUPT_MOD,
            #[doc = "One-shot interrupt mode."]
            ONE_SHOT_INTERRUPT_M,
            #[doc = "One-shot bus stall mode."]
            ONE_SHOT_BUS_STALL_M,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::REPEAT_INTERRUPT_MOD => 0,
                    MODEW::ONE_SHOT_INTERRUPT_M => 1,
                    MODEW::ONE_SHOT_BUS_STALL_M => 2,
                    MODEW::RESERVED_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Repeat interrupt mode."]
            #[inline]
            pub fn repeat_interrupt_mod(self) -> &'a mut W {
                self.variant(MODEW::REPEAT_INTERRUPT_MOD)
            }
            #[doc = "One-shot interrupt mode."]
            #[inline]
            pub fn one_shot_interrupt_m(self) -> &'a mut W {
                self.variant(MODEW::ONE_SHOT_INTERRUPT_M)
            }
            #[doc = "One-shot bus stall mode."]
            #[inline]
            pub fn one_shot_bus_stall_m(self) -> &'a mut W {
                self.variant(MODEW::ONE_SHOT_BUS_STALL_M)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(MODEW::RESERVED_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable the TIMERn interrupt."]
            #[inline]
            pub fn inten(&self) -> INTENR {
                INTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:2 - Selects timer mode."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable the TIMERn interrupt."]
            #[inline]
            pub fn inten(&mut self) -> _INTENW {
                _INTENW { w: self }
            }
            #[doc = "Bits 1:2 - Selects timer mode."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
        }
    }
    #[doc = "MRT0 Status register."]
    pub struct STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "MRT0 Status register."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INTFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTFLAGR {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl INTFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INTFLAGR::NO_PENDING_INTERRUPT => false,
                    INTFLAGR::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INTFLAGR {
                match value {
                    false => INTFLAGR::NO_PENDING_INTERRUPT,
                    true => INTFLAGR::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == INTFLAGR::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == INTFLAGR::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `RUN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RUNR {
            #[doc = "Idle state. TIMERn is stopped."]
            IDLE_STATE_TIMERN_I,
            #[doc = "Running. TIMERn is running."]
            RUNNING_TIMERN_IS_R,
        }
        impl RUNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RUNR::IDLE_STATE_TIMERN_I => false,
                    RUNR::RUNNING_TIMERN_IS_R => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RUNR {
                match value {
                    false => RUNR::IDLE_STATE_TIMERN_I,
                    true => RUNR::RUNNING_TIMERN_IS_R,
                }
            }
            #[doc = "Checks if the value of the field is `IDLE_STATE_TIMERN_I`"]
            #[inline]
            pub fn is_idle_state_timern_i(&self) -> bool {
                *self == RUNR::IDLE_STATE_TIMERN_I
            }
            #[doc = "Checks if the value of the field is `RUNNING_TIMERN_IS_R`"]
            #[inline]
            pub fn is_running_timern_is_r(&self) -> bool {
                *self == RUNR::RUNNING_TIMERN_IS_R
            }
        }
        #[doc = "Values that can be written to the field `INTFLAG`"]
        pub enum INTFLAGW {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl INTFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INTFLAGW::NO_PENDING_INTERRUPT => false,
                    INTFLAGW::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INTFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(INTFLAGW::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(INTFLAGW::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RUN`"]
        pub enum RUNW {
            #[doc = "Idle state. TIMERn is stopped."]
            IDLE_STATE_TIMERN_I,
            #[doc = "Running. TIMERn is running."]
            RUNNING_TIMERN_IS_R,
        }
        impl RUNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RUNW::IDLE_STATE_TIMERN_I => false,
                    RUNW::RUNNING_TIMERN_IS_R => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RUNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Idle state. TIMERn is stopped."]
            #[inline]
            pub fn idle_state_timern_i(self) -> &'a mut W {
                self.variant(RUNW::IDLE_STATE_TIMERN_I)
            }
            #[doc = "Running. TIMERn is running."]
            #[inline]
            pub fn running_timern_is_r(self) -> &'a mut W {
                self.variant(RUNW::RUNNING_TIMERN_IS_R)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Monitors the interrupt flag."]
            #[inline]
            pub fn intflag(&self) -> INTFLAGR {
                INTFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Indicates the state of TIMERn. This bit is read-only."]
            #[inline]
            pub fn run(&self) -> RUNR {
                RUNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Monitors the interrupt flag."]
            #[inline]
            pub fn intflag(&mut self) -> _INTFLAGW {
                _INTFLAGW { w: self }
            }
            #[doc = "Bit 1 - Indicates the state of TIMERn. This bit is read-only."]
            #[inline]
            pub fn run(&mut self) -> _RUNW {
                _RUNW { w: self }
            }
        }
    }
    #[doc = "Idle channel register. This register returns the number of the first idle channel."]
    pub struct IDLE_CH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Idle channel register. This register returns the number of the first idle channel."]
    pub mod idle_ch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IDLE_CH {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANR {
            bits: u8,
        }
        impl CHANR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:7 - Idle channel. Reading the CHAN bits, returns the lowest idle timer channel. If all timer channels are running, CHAN = ."]
            #[inline]
            pub fn chan(&self) -> CHANR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHANR { bits }
            }
        }
    }
    #[doc = "Global interrupt flag register"]
    pub struct IRQ_FLAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Global interrupt flag register"]
    pub mod irq_flag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRQ_FLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `GFLAG0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG0R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG0R::NO_PENDING_INTERRUPT => false,
                    GFLAG0R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GFLAG0R {
                match value {
                    false => GFLAG0R::NO_PENDING_INTERRUPT,
                    true => GFLAG0R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG0R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG0R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `GFLAG1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG1R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER1 has reached the end of the time interval. If the INTEN bit in the CONTROL1 register is also set to 1, the interrupt for timer channel 1 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG1R::NO_PENDING_INTERRUPT => false,
                    GFLAG1R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GFLAG1R {
                match value {
                    false => GFLAG1R::NO_PENDING_INTERRUPT,
                    true => GFLAG1R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG1R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG1R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `GFLAG2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG2R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER2 has reached the end of the time interval. If the INTEN bit in the CONTROL2 register is also set to 1, the interrupt for timer channel 2 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG2R::NO_PENDING_INTERRUPT => false,
                    GFLAG2R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GFLAG2R {
                match value {
                    false => GFLAG2R::NO_PENDING_INTERRUPT,
                    true => GFLAG2R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG2R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG2R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `GFLAG3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG3R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER3 has reached the end of the time interval. If the INTEN bit in the CONTROL3 register is also set to 1, the interrupt for timer channel 3 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG3R::NO_PENDING_INTERRUPT => false,
                    GFLAG3R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GFLAG3R {
                match value {
                    false => GFLAG3R::NO_PENDING_INTERRUPT,
                    true => GFLAG3R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG3R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG3R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Values that can be written to the field `GFLAG0`"]
        pub enum GFLAG0W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG0W::NO_PENDING_INTERRUPT => false,
                    GFLAG0W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GFLAG0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG0W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG0W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GFLAG1`"]
        pub enum GFLAG1W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER1 has reached the end of the time interval. If the INTEN bit in the CONTROL1 register is also set to 1, the interrupt for timer channel 1 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG1W::NO_PENDING_INTERRUPT => false,
                    GFLAG1W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GFLAG1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG1W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER1 has reached the end of the time interval. If the INTEN bit in the CONTROL1 register is also set to 1, the interrupt for timer channel 1 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG1W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GFLAG2`"]
        pub enum GFLAG2W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER2 has reached the end of the time interval. If the INTEN bit in the CONTROL2 register is also set to 1, the interrupt for timer channel 2 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG2W::NO_PENDING_INTERRUPT => false,
                    GFLAG2W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GFLAG2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG2W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER2 has reached the end of the time interval. If the INTEN bit in the CONTROL2 register is also set to 1, the interrupt for timer channel 2 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG2W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GFLAG3`"]
        pub enum GFLAG3W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER3 has reached the end of the time interval. If the INTEN bit in the CONTROL3 register is also set to 1, the interrupt for timer channel 3 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG3W::NO_PENDING_INTERRUPT => false,
                    GFLAG3W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GFLAG3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG3W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER3 has reached the end of the time interval. If the INTEN bit in the CONTROL3 register is also set to 1, the interrupt for timer channel 3 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG3W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Monitors the interrupt flag of TIMER0."]
            #[inline]
            pub fn gflag0(&self) -> GFLAG0R {
                GFLAG0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Monitors the interrupt flag of TIMER1."]
            #[inline]
            pub fn gflag1(&self) -> GFLAG1R {
                GFLAG1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Monitors the interrupt flag of TIMER2."]
            #[inline]
            pub fn gflag2(&self) -> GFLAG2R {
                GFLAG2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Monitors the interrupt flag of TIMER3."]
            #[inline]
            pub fn gflag3(&self) -> GFLAG3R {
                GFLAG3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Monitors the interrupt flag of TIMER0."]
            #[inline]
            pub fn gflag0(&mut self) -> _GFLAG0W {
                _GFLAG0W { w: self }
            }
            #[doc = "Bit 1 - Monitors the interrupt flag of TIMER1."]
            #[inline]
            pub fn gflag1(&mut self) -> _GFLAG1W {
                _GFLAG1W { w: self }
            }
            #[doc = "Bit 2 - Monitors the interrupt flag of TIMER2."]
            #[inline]
            pub fn gflag2(&mut self) -> _GFLAG2W {
                _GFLAG2W { w: self }
            }
            #[doc = "Bit 3 - Monitors the interrupt flag of TIMER3."]
            #[inline]
            pub fn gflag3(&mut self) -> _GFLAG3W {
                _GFLAG3W { w: self }
            }
        }
    }
}
#[doc = "Self wake-up timer (WKT)"]
pub struct WKT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WKT {}
impl WKT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const wkt::RegisterBlock {
        0x4000_8000 as *const _
    }
}
impl Deref for WKT {
    type Target = wkt::RegisterBlock;
    fn deref(&self) -> &wkt::RegisterBlock {
        unsafe { &*WKT::ptr() }
    }
}
#[doc = "Self wake-up timer (WKT)"]
pub mod wkt {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Self wake-up timer control register."]
        pub ctrl: CTRL,
        _reserved0: [u8; 8usize],
        #[doc = "0x0c - Counter register."]
        pub count: COUNT,
    }
    #[doc = "Self wake-up timer control register."]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Self wake-up timer control register."]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CLKSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKSELR {
            #[doc = "Divided IRC clock. This clock runs at 750 kHz and provides time-out periods of up to approximately 95 minutes in 1.33 us increments. This clock is not available in most low-power modes and must not be selected if the timer is to be used to wake up from one of these modes."]
            DIVIDED_IRC_CLOCK_T,
            #[doc = "Low power clock. This is the (nominally) 10 kHz clock and provides time-out periods of up to approximately 119 hours in 100 CTS can be from the input pin, or fs increments. The accuracy of this clock is limited to +/- 45 % over temperature and processing. This clock is available in all power modes. Prior to use, the low-power oscillator must be enabled. The oscillator must also be set to remain active in Deep power-down if needed."]
            LOW_POWER_CLOCK_THI,
        }
        impl CLKSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CLKSELR::DIVIDED_IRC_CLOCK_T => false,
                    CLKSELR::LOW_POWER_CLOCK_THI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CLKSELR {
                match value {
                    false => CLKSELR::DIVIDED_IRC_CLOCK_T,
                    true => CLKSELR::LOW_POWER_CLOCK_THI,
                }
            }
            #[doc = "Checks if the value of the field is `DIVIDED_IRC_CLOCK_T`"]
            #[inline]
            pub fn is_divided_irc_clock_t(&self) -> bool {
                *self == CLKSELR::DIVIDED_IRC_CLOCK_T
            }
            #[doc = "Checks if the value of the field is `LOW_POWER_CLOCK_THI`"]
            #[inline]
            pub fn is_low_power_clock_thi(&self) -> bool {
                *self == CLKSELR::LOW_POWER_CLOCK_THI
            }
        }
        #[doc = "Possible values of the field `ALARMFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALARMFLAGR {
            #[doc = "No time-out. The self wake-up timer has not timed out. Writing a 0 to has no effect."]
            NO_TIME_OUT_THE_SEL,
            #[doc = "Time-out. The self wake-up timer has timed out. This flag generates an interrupt request which can wake up the part from any low power mode not deep power-down. Writing a 1 clears this status bit and the interrupt too?"]
            TIME_OUT_THE_SELF_W,
        }
        impl ALARMFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ALARMFLAGR::NO_TIME_OUT_THE_SEL => false,
                    ALARMFLAGR::TIME_OUT_THE_SELF_W => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ALARMFLAGR {
                match value {
                    false => ALARMFLAGR::NO_TIME_OUT_THE_SEL,
                    true => ALARMFLAGR::TIME_OUT_THE_SELF_W,
                }
            }
            #[doc = "Checks if the value of the field is `NO_TIME_OUT_THE_SEL`"]
            #[inline]
            pub fn is_no_time_out_the_sel(&self) -> bool {
                *self == ALARMFLAGR::NO_TIME_OUT_THE_SEL
            }
            #[doc = "Checks if the value of the field is `TIME_OUT_THE_SELF_W`"]
            #[inline]
            pub fn is_time_out_the_self_w(&self) -> bool {
                *self == ALARMFLAGR::TIME_OUT_THE_SELF_W
            }
        }
        #[doc = "Possible values of the field `CLEARCTR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLEARCTRR {
            #[doc = "No effect. Reading this bit always returns 0."]
            NO_EFFECT_READING_T,
            #[doc = "Clear the counter. Counting is halted until a new count value is loaded."]
            CLEAR_THE_COUNTER_C,
        }
        impl CLEARCTRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CLEARCTRR::NO_EFFECT_READING_T => false,
                    CLEARCTRR::CLEAR_THE_COUNTER_C => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CLEARCTRR {
                match value {
                    false => CLEARCTRR::NO_EFFECT_READING_T,
                    true => CLEARCTRR::CLEAR_THE_COUNTER_C,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_READING_T`"]
            #[inline]
            pub fn is_no_effect_reading_t(&self) -> bool {
                *self == CLEARCTRR::NO_EFFECT_READING_T
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_COUNTER_C`"]
            #[inline]
            pub fn is_clear_the_counter_c(&self) -> bool {
                *self == CLEARCTRR::CLEAR_THE_COUNTER_C
            }
        }
        #[doc = "Possible values of the field `SEL_EXTCLK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEL_EXTCLKR {
            #[doc = "Internal. The clock source is the internal clock selected by the CLKSEL bit."]
            INTERNAL,
            #[doc = "External. The self-wake-up timer uses the external WKTCLKIN pin."]
            EXTERNAL,
        }
        impl SEL_EXTCLKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SEL_EXTCLKR::INTERNAL => false,
                    SEL_EXTCLKR::EXTERNAL => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SEL_EXTCLKR {
                match value {
                    false => SEL_EXTCLKR::INTERNAL,
                    true => SEL_EXTCLKR::EXTERNAL,
                }
            }
            #[doc = "Checks if the value of the field is `INTERNAL`"]
            #[inline]
            pub fn is_internal(&self) -> bool {
                *self == SEL_EXTCLKR::INTERNAL
            }
            #[doc = "Checks if the value of the field is `EXTERNAL`"]
            #[inline]
            pub fn is_external(&self) -> bool {
                *self == SEL_EXTCLKR::EXTERNAL
            }
        }
        #[doc = "Values that can be written to the field `CLKSEL`"]
        pub enum CLKSELW {
            #[doc = "Divided IRC clock. This clock runs at 750 kHz and provides time-out periods of up to approximately 95 minutes in 1.33 us increments. This clock is not available in most low-power modes and must not be selected if the timer is to be used to wake up from one of these modes."]
            DIVIDED_IRC_CLOCK_T,
            #[doc = "Low power clock. This is the (nominally) 10 kHz clock and provides time-out periods of up to approximately 119 hours in 100 CTS can be from the input pin, or fs increments. The accuracy of this clock is limited to +/- 45 % over temperature and processing. This clock is available in all power modes. Prior to use, the low-power oscillator must be enabled. The oscillator must also be set to remain active in Deep power-down if needed."]
            LOW_POWER_CLOCK_THI,
        }
        impl CLKSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLKSELW::DIVIDED_IRC_CLOCK_T => false,
                    CLKSELW::LOW_POWER_CLOCK_THI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLKSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Divided IRC clock. This clock runs at 750 kHz and provides time-out periods of up to approximately 95 minutes in 1.33 us increments. This clock is not available in most low-power modes and must not be selected if the timer is to be used to wake up from one of these modes."]
            #[inline]
            pub fn divided_irc_clock_t(self) -> &'a mut W {
                self.variant(CLKSELW::DIVIDED_IRC_CLOCK_T)
            }
            #[doc = "Low power clock. This is the (nominally) 10 kHz clock and provides time-out periods of up to approximately 119 hours in 100 CTS can be from the input pin, or fs increments. The accuracy of this clock is limited to +/- 45 % over temperature and processing. This clock is available in all power modes. Prior to use, the low-power oscillator must be enabled. The oscillator must also be set to remain active in Deep power-down if needed."]
            #[inline]
            pub fn low_power_clock_thi(self) -> &'a mut W {
                self.variant(CLKSELW::LOW_POWER_CLOCK_THI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ALARMFLAG`"]
        pub enum ALARMFLAGW {
            #[doc = "No time-out. The self wake-up timer has not timed out. Writing a 0 to has no effect."]
            NO_TIME_OUT_THE_SEL,
            #[doc = "Time-out. The self wake-up timer has timed out. This flag generates an interrupt request which can wake up the part from any low power mode not deep power-down. Writing a 1 clears this status bit and the interrupt too?"]
            TIME_OUT_THE_SELF_W,
        }
        impl ALARMFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ALARMFLAGW::NO_TIME_OUT_THE_SEL => false,
                    ALARMFLAGW::TIME_OUT_THE_SELF_W => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALARMFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALARMFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ALARMFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No time-out. The self wake-up timer has not timed out. Writing a 0 to has no effect."]
            #[inline]
            pub fn no_time_out_the_sel(self) -> &'a mut W {
                self.variant(ALARMFLAGW::NO_TIME_OUT_THE_SEL)
            }
            #[doc = "Time-out. The self wake-up timer has timed out. This flag generates an interrupt request which can wake up the part from any low power mode not deep power-down. Writing a 1 clears this status bit and the interrupt too?"]
            #[inline]
            pub fn time_out_the_self_w(self) -> &'a mut W {
                self.variant(ALARMFLAGW::TIME_OUT_THE_SELF_W)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLEARCTR`"]
        pub enum CLEARCTRW {
            #[doc = "No effect. Reading this bit always returns 0."]
            NO_EFFECT_READING_T,
            #[doc = "Clear the counter. Counting is halted until a new count value is loaded."]
            CLEAR_THE_COUNTER_C,
        }
        impl CLEARCTRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLEARCTRW::NO_EFFECT_READING_T => false,
                    CLEARCTRW::CLEAR_THE_COUNTER_C => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLEARCTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLEARCTRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLEARCTRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect. Reading this bit always returns 0."]
            #[inline]
            pub fn no_effect_reading_t(self) -> &'a mut W {
                self.variant(CLEARCTRW::NO_EFFECT_READING_T)
            }
            #[doc = "Clear the counter. Counting is halted until a new count value is loaded."]
            #[inline]
            pub fn clear_the_counter_c(self) -> &'a mut W {
                self.variant(CLEARCTRW::CLEAR_THE_COUNTER_C)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SEL_EXTCLK`"]
        pub enum SEL_EXTCLKW {
            #[doc = "Internal. The clock source is the internal clock selected by the CLKSEL bit."]
            INTERNAL,
            #[doc = "External. The self-wake-up timer uses the external WKTCLKIN pin."]
            EXTERNAL,
        }
        impl SEL_EXTCLKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SEL_EXTCLKW::INTERNAL => false,
                    SEL_EXTCLKW::EXTERNAL => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEL_EXTCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEL_EXTCLKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SEL_EXTCLKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Internal. The clock source is the internal clock selected by the CLKSEL bit."]
            #[inline]
            pub fn internal(self) -> &'a mut W {
                self.variant(SEL_EXTCLKW::INTERNAL)
            }
            #[doc = "External. The self-wake-up timer uses the external WKTCLKIN pin."]
            #[inline]
            pub fn external(self) -> &'a mut W {
                self.variant(SEL_EXTCLKW::EXTERNAL)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Select the self wake-up timer clock source."]
            #[inline]
            pub fn clksel(&self) -> CLKSELR {
                CLKSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Wake-up or alarm timer flag."]
            #[inline]
            pub fn alarmflag(&self) -> ALARMFLAGR {
                ALARMFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Clears the self wake-up timer."]
            #[inline]
            pub fn clearctr(&self) -> CLEARCTRR {
                CLEARCTRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Select external or internal clock source for the self-wake-up timer. The internal clock source is selected by the CLKSEL bit in this register if SET_EXTCLK is set to internal."]
            #[inline]
            pub fn sel_extclk(&self) -> SEL_EXTCLKR {
                SEL_EXTCLKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Select the self wake-up timer clock source."]
            #[inline]
            pub fn clksel(&mut self) -> _CLKSELW {
                _CLKSELW { w: self }
            }
            #[doc = "Bit 1 - Wake-up or alarm timer flag."]
            #[inline]
            pub fn alarmflag(&mut self) -> _ALARMFLAGW {
                _ALARMFLAGW { w: self }
            }
            #[doc = "Bit 2 - Clears the self wake-up timer."]
            #[inline]
            pub fn clearctr(&mut self) -> _CLEARCTRW {
                _CLEARCTRW { w: self }
            }
            #[doc = "Bit 3 - Select external or internal clock source for the self-wake-up timer. The internal clock source is selected by the CLKSEL bit in this register if SET_EXTCLK is set to internal."]
            #[inline]
            pub fn sel_extclk(&mut self) -> _SEL_EXTCLKW {
                _SEL_EXTCLKW { w: self }
            }
        }
    }
    #[doc = "Counter register."]
    pub struct COUNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Counter register."]
    pub mod count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u32,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - A write to this register pre-loads start count value into the timer and starts the count-down sequence. A read reflects the current value of the timer."]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - A write to this register pre-loads start count value into the timer and starts the count-down sequence. A read reflects the current value of the timer."]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
}
#[doc = "Switch matrix (SWM)"]
pub struct SWM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SWM {}
impl SWM {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const swm::RegisterBlock {
        0x4000_c000 as *const _
    }
}
impl Deref for SWM {
    type Target = swm::RegisterBlock;
    fn deref(&self) -> &swm::RegisterBlock {
        unsafe { &*SWM::ptr() }
    }
}
#[doc = "Switch matrix (SWM)"]
pub mod swm {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS."]
        pub pinassign0: PINASSIGN0,
        #[doc = "0x04 - Pin assign register 1. Assign movable functions U0_SCLK, U1_TXD, U1_RXD, U1_RTS."]
        pub pinassign1: PINASSIGN1,
        #[doc = "0x08 - Pin assign register 2. Assign movable functions U1_CTS, U1_SCLK, U2_TXD, U2_RXD."]
        pub pinassign2: PINASSIGN2,
        #[doc = "0x0c - Pin assign register 3. Assign movable function U2_RTS, U2_CTS, U2_SCLK, SPI0_SCK."]
        pub pinassign3: PINASSIGN3,
        #[doc = "0x10 - Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL0, SPI0_SSEL1."]
        pub pinassign4: PINASSIGN4,
        #[doc = "0x14 - Pin assign register 5. Assign movable functions SPI0_SSEL2, SPI0_SSEL3, SPI1_SCK, SPI1_MOSI"]
        pub pinassign5: PINASSIGN5,
        #[doc = "0x18 - Pin assign register 6. Assign movable functions SPI1_MISO, SPI1_SSEL0, SPI1_SSEL1, SCT0_IN0."]
        pub pinassign6: PINASSIGN6,
        #[doc = "0x1c - Pin assign register 7. Assign movable functions SCT_IN1, SCT_IN2, SCT_IN3, SCT_OUT0."]
        pub pinassign7: PINASSIGN7,
        #[doc = "0x20 - Pin assign register 8. Assign movable functions SCT_OUT1, SCT_OUT2, SCT_OUT3, SCT_OUT4."]
        pub pinassign8: PINASSIGN8,
        #[doc = "0x24 - Pin assign register 9. Assign movable functions SCT_OUT5, I2C1_SDA, I2C1_SCL, I2C2_SDA."]
        pub pinassign9: PINASSIGN9,
        #[doc = "0x28 - Pin assign register 10. Assign movable functions I2C2_SCL, I2C3_SDA, I2C3_SCL, ADC_PINTRIG0."]
        pub pinassign10: PINASSIGN10,
        #[doc = "0x2c - Pin assign register 11. Assign movable functions ADC_PINTRIG1, ACMP_O, CLKOUT, GPIO_INT_BMAT"]
        pub pinassign11: PINASSIGN11,
        _reserved0: [u8; 400usize],
        #[doc = "0x1c0 - Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP."]
        pub pinenable0: PINENABLE0,
    }
    #[doc = "Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS."]
    pub struct PINASSIGN0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS."]
    pub mod pinassign0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_TXD_OR {
            bits: u8,
        }
        impl U0_TXD_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_RXD_IR {
            bits: u8,
        }
        impl U0_RXD_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_RTS_OR {
            bits: u8,
        }
        impl U0_RTS_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_CTS_IR {
            bits: u8,
        }
        impl U0_CTS_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_TXD_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_TXD_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_RXD_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_RXD_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_RTS_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_RTS_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_CTS_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_CTS_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U0_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_txd_o(&self) -> U0_TXD_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_TXD_OR { bits }
            }
            #[doc = "Bits 8:15 - U0_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_rxd_i(&self) -> U0_RXD_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_RXD_IR { bits }
            }
            #[doc = "Bits 16:23 - U0_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_rts_o(&self) -> U0_RTS_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_RTS_OR { bits }
            }
            #[doc = "Bits 24:31 - U0_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_cts_i(&self) -> U0_CTS_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_CTS_IR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U0_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_txd_o(&mut self) -> _U0_TXD_OW {
                _U0_TXD_OW { w: self }
            }
            #[doc = "Bits 8:15 - U0_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_rxd_i(&mut self) -> _U0_RXD_IW {
                _U0_RXD_IW { w: self }
            }
            #[doc = "Bits 16:23 - U0_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_rts_o(&mut self) -> _U0_RTS_OW {
                _U0_RTS_OW { w: self }
            }
            #[doc = "Bits 24:31 - U0_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_cts_i(&mut self) -> _U0_CTS_IW {
                _U0_CTS_IW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 1. Assign movable functions U0_SCLK, U1_TXD, U1_RXD, U1_RTS."]
    pub struct PINASSIGN1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 1. Assign movable functions U0_SCLK, U1_TXD, U1_RXD, U1_RTS."]
    pub mod pinassign1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_SCLK_IOR {
            bits: u8,
        }
        impl U0_SCLK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_TXD_OR {
            bits: u8,
        }
        impl U1_TXD_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_RXD_IR {
            bits: u8,
        }
        impl U1_RXD_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_RTS_OR {
            bits: u8,
        }
        impl U1_RTS_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_SCLK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_SCLK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_TXD_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_TXD_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_RXD_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_RXD_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_RTS_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_RTS_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U0_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_sclk_io(&self) -> U0_SCLK_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_SCLK_IOR { bits }
            }
            #[doc = "Bits 8:15 - U1_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_txd_o(&self) -> U1_TXD_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_TXD_OR { bits }
            }
            #[doc = "Bits 16:23 - U1_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_rxd_i(&self) -> U1_RXD_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_RXD_IR { bits }
            }
            #[doc = "Bits 24:31 - U1_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_rts_o(&self) -> U1_RTS_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_RTS_OR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U0_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u0_sclk_io(&mut self) -> _U0_SCLK_IOW {
                _U0_SCLK_IOW { w: self }
            }
            #[doc = "Bits 8:15 - U1_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_txd_o(&mut self) -> _U1_TXD_OW {
                _U1_TXD_OW { w: self }
            }
            #[doc = "Bits 16:23 - U1_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_rxd_i(&mut self) -> _U1_RXD_IW {
                _U1_RXD_IW { w: self }
            }
            #[doc = "Bits 24:31 - U1_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_rts_o(&mut self) -> _U1_RTS_OW {
                _U1_RTS_OW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 2. Assign movable functions U1_CTS, U1_SCLK, U2_TXD, U2_RXD."]
    pub struct PINASSIGN2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 2. Assign movable functions U1_CTS, U1_SCLK, U2_TXD, U2_RXD."]
    pub mod pinassign2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_CTS_IR {
            bits: u8,
        }
        impl U1_CTS_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_SCLK_IOR {
            bits: u8,
        }
        impl U1_SCLK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_TXD_OR {
            bits: u8,
        }
        impl U2_TXD_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_RXD_IR {
            bits: u8,
        }
        impl U2_RXD_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_CTS_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_CTS_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_SCLK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_SCLK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_TXD_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_TXD_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_RXD_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_RXD_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U1_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_cts_i(&self) -> U1_CTS_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_CTS_IR { bits }
            }
            #[doc = "Bits 8:15 - U1_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_sclk_io(&self) -> U1_SCLK_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_SCLK_IOR { bits }
            }
            #[doc = "Bits 16:23 - U2_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_txd_o(&self) -> U2_TXD_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_TXD_OR { bits }
            }
            #[doc = "Bits 24:31 - U2_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_rxd_i(&self) -> U2_RXD_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_RXD_IR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U1_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_cts_i(&mut self) -> _U1_CTS_IW {
                _U1_CTS_IW { w: self }
            }
            #[doc = "Bits 8:15 - U1_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u1_sclk_io(&mut self) -> _U1_SCLK_IOW {
                _U1_SCLK_IOW { w: self }
            }
            #[doc = "Bits 16:23 - U2_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_txd_o(&mut self) -> _U2_TXD_OW {
                _U2_TXD_OW { w: self }
            }
            #[doc = "Bits 24:31 - U2_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_rxd_i(&mut self) -> _U2_RXD_IW {
                _U2_RXD_IW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 3. Assign movable function U2_RTS, U2_CTS, U2_SCLK, SPI0_SCK."]
    pub struct PINASSIGN3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 3. Assign movable function U2_RTS, U2_CTS, U2_SCLK, SPI0_SCK."]
    pub mod pinassign3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_RTS_OR {
            bits: u8,
        }
        impl U2_RTS_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_CTS_IR {
            bits: u8,
        }
        impl U2_CTS_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_SCLK_IOR {
            bits: u8,
        }
        impl U2_SCLK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_SCK_IOR {
            bits: u8,
        }
        impl SPI0_SCK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_RTS_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_RTS_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_CTS_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_CTS_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_SCLK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_SCLK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_SCK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_SCK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U2_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_rts_o(&self) -> U2_RTS_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_RTS_OR { bits }
            }
            #[doc = "Bits 8:15 - U2_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_cts_i(&self) -> U2_CTS_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_CTS_IR { bits }
            }
            #[doc = "Bits 16:23 - U2_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_sclk_io(&self) -> U2_SCLK_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_SCLK_IOR { bits }
            }
            #[doc = "Bits 24:31 - SPI0_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_sck_io(&self) -> SPI0_SCK_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_SCK_IOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U2_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_rts_o(&mut self) -> _U2_RTS_OW {
                _U2_RTS_OW { w: self }
            }
            #[doc = "Bits 8:15 - U2_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_cts_i(&mut self) -> _U2_CTS_IW {
                _U2_CTS_IW { w: self }
            }
            #[doc = "Bits 16:23 - U2_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn u2_sclk_io(&mut self) -> _U2_SCLK_IOW {
                _U2_SCLK_IOW { w: self }
            }
            #[doc = "Bits 24:31 - SPI0_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_sck_io(&mut self) -> _SPI0_SCK_IOW {
                _SPI0_SCK_IOW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL0, SPI0_SSEL1."]
    pub struct PINASSIGN4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL0, SPI0_SSEL1."]
    pub mod pinassign4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_MOSI_IOR {
            bits: u8,
        }
        impl SPI0_MOSI_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_MISO_IOR {
            bits: u8,
        }
        impl SPI0_MISO_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_SSEL0_IOR {
            bits: u8,
        }
        impl SPI0_SSEL0_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_SSEL1_IOR {
            bits: u8,
        }
        impl SPI0_SSEL1_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_MOSI_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_MOSI_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_MISO_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_MISO_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_SSEL0_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_SSEL0_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_SSEL1_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_SSEL1_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SPI0_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_mosi_io(&self) -> SPI0_MOSI_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_MOSI_IOR { bits }
            }
            #[doc = "Bits 8:15 - SPI0_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_miso_io(&self) -> SPI0_MISO_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_MISO_IOR { bits }
            }
            #[doc = "Bits 16:23 - SPI0_SSEL0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel0_io(&self) -> SPI0_SSEL0_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_SSEL0_IOR { bits }
            }
            #[doc = "Bits 24:31 - SPI0_SSEL1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel1_io(&self) -> SPI0_SSEL1_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_SSEL1_IOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SPI0_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_mosi_io(&mut self) -> _SPI0_MOSI_IOW {
                _SPI0_MOSI_IOW { w: self }
            }
            #[doc = "Bits 8:15 - SPI0_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_miso_io(&mut self) -> _SPI0_MISO_IOW {
                _SPI0_MISO_IOW { w: self }
            }
            #[doc = "Bits 16:23 - SPI0_SSEL0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel0_io(&mut self) -> _SPI0_SSEL0_IOW {
                _SPI0_SSEL0_IOW { w: self }
            }
            #[doc = "Bits 24:31 - SPI0_SSEL1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel1_io(&mut self) -> _SPI0_SSEL1_IOW {
                _SPI0_SSEL1_IOW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 5. Assign movable functions SPI0_SSEL2, SPI0_SSEL3, SPI1_SCK, SPI1_MOSI"]
    pub struct PINASSIGN5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 5. Assign movable functions SPI0_SSEL2, SPI0_SSEL3, SPI1_SCK, SPI1_MOSI"]
    pub mod pinassign5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_SSEL2_IOR {
            bits: u8,
        }
        impl SPI0_SSEL2_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_SSEL3_IOR {
            bits: u8,
        }
        impl SPI0_SSEL3_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_SCK_IOR {
            bits: u8,
        }
        impl SPI1_SCK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_MOSI_IOR {
            bits: u8,
        }
        impl SPI1_MOSI_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_SSEL2_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_SSEL2_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_SSEL3_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_SSEL3_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_SCK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_SCK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_MOSI_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_MOSI_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SPI0_SSEL2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel2_io(&self) -> SPI0_SSEL2_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_SSEL2_IOR { bits }
            }
            #[doc = "Bits 8:15 - SPI0_SSEL3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel3_io(&self) -> SPI0_SSEL3_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_SSEL3_IOR { bits }
            }
            #[doc = "Bits 16:23 - SPI1_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_sck_io(&self) -> SPI1_SCK_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_SCK_IOR { bits }
            }
            #[doc = "Bits 24:31 - SPI1_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_mosi_io(&self) -> SPI1_MOSI_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_MOSI_IOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SPI0_SSEL2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel2_io(&mut self) -> _SPI0_SSEL2_IOW {
                _SPI0_SSEL2_IOW { w: self }
            }
            #[doc = "Bits 8:15 - SPI0_SSEL3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi0_ssel3_io(&mut self) -> _SPI0_SSEL3_IOW {
                _SPI0_SSEL3_IOW { w: self }
            }
            #[doc = "Bits 16:23 - SPI1_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_sck_io(&mut self) -> _SPI1_SCK_IOW {
                _SPI1_SCK_IOW { w: self }
            }
            #[doc = "Bits 24:31 - SPI1_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_mosi_io(&mut self) -> _SPI1_MOSI_IOW {
                _SPI1_MOSI_IOW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 6. Assign movable functions SPI1_MISO, SPI1_SSEL0, SPI1_SSEL1, SCT0_IN0."]
    pub struct PINASSIGN6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 6. Assign movable functions SPI1_MISO, SPI1_SSEL0, SPI1_SSEL1, SCT0_IN0."]
    pub mod pinassign6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_MISO_IOR {
            bits: u8,
        }
        impl SPI1_MISO_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_SSEL0_IOR {
            bits: u8,
        }
        impl SPI1_SSEL0_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_SSEL1_IOR {
            bits: u8,
        }
        impl SPI1_SSEL1_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_IN0_IR {
            bits: u8,
        }
        impl SCT_IN0_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_MISO_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_MISO_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_SSEL0_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_SSEL0_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_SSEL1_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_SSEL1_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_IN0_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_IN0_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SPI1_MISO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_miso_io(&self) -> SPI1_MISO_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_MISO_IOR { bits }
            }
            #[doc = "Bits 8:15 - SPI1_SSEL0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_ssel0_io(&self) -> SPI1_SSEL0_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_SSEL0_IOR { bits }
            }
            #[doc = "Bits 16:23 - SPI1_SSEL1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_ssel1_io(&self) -> SPI1_SSEL1_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_SSEL1_IOR { bits }
            }
            #[doc = "Bits 24:31 - SCT_IN0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in0_i(&self) -> SCT_IN0_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_IN0_IR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SPI1_MISO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_miso_io(&mut self) -> _SPI1_MISO_IOW {
                _SPI1_MISO_IOW { w: self }
            }
            #[doc = "Bits 8:15 - SPI1_SSEL0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_ssel0_io(&mut self) -> _SPI1_SSEL0_IOW {
                _SPI1_SSEL0_IOW { w: self }
            }
            #[doc = "Bits 16:23 - SPI1_SSEL1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn spi1_ssel1_io(&mut self) -> _SPI1_SSEL1_IOW {
                _SPI1_SSEL1_IOW { w: self }
            }
            #[doc = "Bits 24:31 - SCT_IN0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in0_i(&mut self) -> _SCT_IN0_IW {
                _SCT_IN0_IW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 7. Assign movable functions SCT_IN1, SCT_IN2, SCT_IN3, SCT_OUT0."]
    pub struct PINASSIGN7 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 7. Assign movable functions SCT_IN1, SCT_IN2, SCT_IN3, SCT_OUT0."]
    pub mod pinassign7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_IN1_IR {
            bits: u8,
        }
        impl SCT_IN1_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_IN2_IR {
            bits: u8,
        }
        impl SCT_IN2_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_IN3_IR {
            bits: u8,
        }
        impl SCT_IN3_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_OUT0_OR {
            bits: u8,
        }
        impl SCT_OUT0_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_IN1_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_IN1_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_IN2_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_IN2_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_IN3_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_IN3_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_OUT0_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_OUT0_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SCT_IN1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in1_i(&self) -> SCT_IN1_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_IN1_IR { bits }
            }
            #[doc = "Bits 8:15 - SCT_IN2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in2_i(&self) -> SCT_IN2_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_IN2_IR { bits }
            }
            #[doc = "Bits 16:23 - SCT_IN3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in3_i(&self) -> SCT_IN3_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_IN3_IR { bits }
            }
            #[doc = "Bits 24:31 - SCT_OUT0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out0_o(&self) -> SCT_OUT0_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_OUT0_OR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SCT_IN1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in1_i(&mut self) -> _SCT_IN1_IW {
                _SCT_IN1_IW { w: self }
            }
            #[doc = "Bits 8:15 - SCT_IN2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in2_i(&mut self) -> _SCT_IN2_IW {
                _SCT_IN2_IW { w: self }
            }
            #[doc = "Bits 16:23 - SCT_IN3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_in3_i(&mut self) -> _SCT_IN3_IW {
                _SCT_IN3_IW { w: self }
            }
            #[doc = "Bits 24:31 - SCT_OUT0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out0_o(&mut self) -> _SCT_OUT0_OW {
                _SCT_OUT0_OW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 8. Assign movable functions SCT_OUT1, SCT_OUT2, SCT_OUT3, SCT_OUT4."]
    pub struct PINASSIGN8 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 8. Assign movable functions SCT_OUT1, SCT_OUT2, SCT_OUT3, SCT_OUT4."]
    pub mod pinassign8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_OUT1_OR {
            bits: u8,
        }
        impl SCT_OUT1_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_OUT2_OR {
            bits: u8,
        }
        impl SCT_OUT2_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_OUT3_OR {
            bits: u8,
        }
        impl SCT_OUT3_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_OUT4_OR {
            bits: u8,
        }
        impl SCT_OUT4_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_OUT1_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_OUT1_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_OUT2_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_OUT2_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_OUT3_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_OUT3_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_OUT4_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_OUT4_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SCT_OUT1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out1_o(&self) -> SCT_OUT1_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_OUT1_OR { bits }
            }
            #[doc = "Bits 8:15 - SCT_OUT2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out2_o(&self) -> SCT_OUT2_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_OUT2_OR { bits }
            }
            #[doc = "Bits 16:23 - SCT_OUT3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out3_o(&self) -> SCT_OUT3_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_OUT3_OR { bits }
            }
            #[doc = "Bits 24:31 - SCT_OUT4 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out4_o(&self) -> SCT_OUT4_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_OUT4_OR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SCT_OUT1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out1_o(&mut self) -> _SCT_OUT1_OW {
                _SCT_OUT1_OW { w: self }
            }
            #[doc = "Bits 8:15 - SCT_OUT2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out2_o(&mut self) -> _SCT_OUT2_OW {
                _SCT_OUT2_OW { w: self }
            }
            #[doc = "Bits 16:23 - SCT_OUT3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out3_o(&mut self) -> _SCT_OUT3_OW {
                _SCT_OUT3_OW { w: self }
            }
            #[doc = "Bits 24:31 - SCT_OUT4 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out4_o(&mut self) -> _SCT_OUT4_OW {
                _SCT_OUT4_OW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 9. Assign movable functions SCT_OUT5, I2C1_SDA, I2C1_SCL, I2C2_SDA."]
    pub struct PINASSIGN9 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 9. Assign movable functions SCT_OUT5, I2C1_SDA, I2C1_SCL, I2C2_SDA."]
    pub mod pinassign9 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN9 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCT_OUT5_OR {
            bits: u8,
        }
        impl SCT_OUT5_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C1_SDA_IOR {
            bits: u8,
        }
        impl I2C1_SDA_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C1_SCL_IOR {
            bits: u8,
        }
        impl I2C1_SCL_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C2_SDA_IOR {
            bits: u8,
        }
        impl I2C2_SDA_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_OUT5_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_OUT5_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1_SDA_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1_SDA_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1_SCL_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1_SCL_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2_SDA_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2_SDA_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SCT_OUT5 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out5_o(&self) -> SCT_OUT5_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCT_OUT5_OR { bits }
            }
            #[doc = "Bits 8:15 - I2C1_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c1_sda_io(&self) -> I2C1_SDA_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C1_SDA_IOR { bits }
            }
            #[doc = "Bits 16:23 - I2C1_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c1_scl_io(&self) -> I2C1_SCL_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C1_SCL_IOR { bits }
            }
            #[doc = "Bits 24:31 - I2C1_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c2_sda_io(&self) -> I2C2_SDA_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C2_SDA_IOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SCT_OUT5 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn sct_out5_o(&mut self) -> _SCT_OUT5_OW {
                _SCT_OUT5_OW { w: self }
            }
            #[doc = "Bits 8:15 - I2C1_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c1_sda_io(&mut self) -> _I2C1_SDA_IOW {
                _I2C1_SDA_IOW { w: self }
            }
            #[doc = "Bits 16:23 - I2C1_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c1_scl_io(&mut self) -> _I2C1_SCL_IOW {
                _I2C1_SCL_IOW { w: self }
            }
            #[doc = "Bits 24:31 - I2C1_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c2_sda_io(&mut self) -> _I2C2_SDA_IOW {
                _I2C2_SDA_IOW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 10. Assign movable functions I2C2_SCL, I2C3_SDA, I2C3_SCL, ADC_PINTRIG0."]
    pub struct PINASSIGN10 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 10. Assign movable functions I2C2_SCL, I2C3_SDA, I2C3_SCL, ADC_PINTRIG0."]
    pub mod pinassign10 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN10 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C2_SCL_IOR {
            bits: u8,
        }
        impl I2C2_SCL_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C3_SDA_IOR {
            bits: u8,
        }
        impl I2C3_SDA_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C3_SCL_IOR {
            bits: u8,
        }
        impl I2C3_SCL_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADC_PINTRIG0_IR {
            bits: u8,
        }
        impl ADC_PINTRIG0_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2_SCL_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2_SCL_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C3_SDA_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C3_SDA_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C3_SCL_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C3_SCL_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_PINTRIG0_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_PINTRIG0_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - I2C1_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c2_scl_io(&self) -> I2C2_SCL_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C2_SCL_IOR { bits }
            }
            #[doc = "Bits 8:15 - I2C3_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c3_sda_io(&self) -> I2C3_SDA_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C3_SDA_IOR { bits }
            }
            #[doc = "Bits 16:23 - I2C3_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c3_scl_io(&self) -> I2C3_SCL_IOR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C3_SCL_IOR { bits }
            }
            #[doc = "Bits 24:31 - ADC_PINTRIG0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn adc_pintrig0_i(&self) -> ADC_PINTRIG0_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADC_PINTRIG0_IR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - I2C1_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c2_scl_io(&mut self) -> _I2C2_SCL_IOW {
                _I2C2_SCL_IOW { w: self }
            }
            #[doc = "Bits 8:15 - I2C3_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c3_sda_io(&mut self) -> _I2C3_SDA_IOW {
                _I2C3_SDA_IOW { w: self }
            }
            #[doc = "Bits 16:23 - I2C3_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn i2c3_scl_io(&mut self) -> _I2C3_SCL_IOW {
                _I2C3_SCL_IOW { w: self }
            }
            #[doc = "Bits 24:31 - ADC_PINTRIG0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn adc_pintrig0_i(&mut self) -> _ADC_PINTRIG0_IW {
                _ADC_PINTRIG0_IW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 11. Assign movable functions ADC_PINTRIG1, ACMP_O, CLKOUT, GPIO_INT_BMAT"]
    pub struct PINASSIGN11 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin assign register 11. Assign movable functions ADC_PINTRIG1, ACMP_O, CLKOUT, GPIO_INT_BMAT"]
    pub mod pinassign11 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN11 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADC_PINTRIG1_IR {
            bits: u8,
        }
        impl ADC_PINTRIG1_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACMP_O_OR {
            bits: u8,
        }
        impl ACMP_O_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKOUT_OR {
            bits: u8,
        }
        impl CLKOUT_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPIO_INT_BMAT_OR {
            bits: u8,
        }
        impl GPIO_INT_BMAT_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_PINTRIG1_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_PINTRIG1_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_O_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_O_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKOUT_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKOUT_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIO_INT_BMAT_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIO_INT_BMAT_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - ADC_PINTRIG1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn adc_pintrig1_i(&self) -> ADC_PINTRIG1_IR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADC_PINTRIG1_IR { bits }
            }
            #[doc = "Bits 8:15 - ACMP_O function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn acmp_o_o(&self) -> ACMP_O_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACMP_O_OR { bits }
            }
            #[doc = "Bits 16:23 - CLKOUT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn clkout_o(&self) -> CLKOUT_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKOUT_OR { bits }
            }
            #[doc = "Bits 24:31 - GPIO_INT_BMAT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn gpio_int_bmat_o(&self) -> GPIO_INT_BMAT_OR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GPIO_INT_BMAT_OR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - ADC_PINTRIG1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn adc_pintrig1_i(&mut self) -> _ADC_PINTRIG1_IW {
                _ADC_PINTRIG1_IW { w: self }
            }
            #[doc = "Bits 8:15 - ACMP_O function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn acmp_o_o(&mut self) -> _ACMP_O_OW {
                _ACMP_O_OW { w: self }
            }
            #[doc = "Bits 16:23 - CLKOUT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn clkout_o(&mut self) -> _CLKOUT_OW {
                _CLKOUT_OW { w: self }
            }
            #[doc = "Bits 24:31 - GPIO_INT_BMAT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_28 (= 0x1C)."]
            #[inline]
            pub fn gpio_int_bmat_o(&mut self) -> _GPIO_INT_BMAT_OW {
                _GPIO_INT_BMAT_OW { w: self }
            }
        }
    }
    #[doc = "Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP."]
    pub struct PINENABLE0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP."]
    pub mod pinenable0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINENABLE0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ACMP_I1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_I1R {
            #[doc = "ACMP_I1 enabled on pin PIO0_00."]
            ACMP_I1_ENABLED_ON_P,
            #[doc = "ACMP_I1 disabled."]
            ACMP_I1_DISABLED,
        }
        impl ACMP_I1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_I1R::ACMP_I1_ENABLED_ON_P => false,
                    ACMP_I1R::ACMP_I1_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMP_I1R {
                match value {
                    false => ACMP_I1R::ACMP_I1_ENABLED_ON_P,
                    true => ACMP_I1R::ACMP_I1_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ACMP_I1_ENABLED_ON_P`"]
            #[inline]
            pub fn is_acmp_i1_enabled_on_p(&self) -> bool {
                *self == ACMP_I1R::ACMP_I1_ENABLED_ON_P
            }
            #[doc = "Checks if the value of the field is `ACMP_I1_DISABLED`"]
            #[inline]
            pub fn is_acmp_i1_disabled(&self) -> bool {
                *self == ACMP_I1R::ACMP_I1_DISABLED
            }
        }
        #[doc = "Possible values of the field `ACMP_I2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_I2R {
            #[doc = "ACMP_I2 enabled on pin PIO0_1."]
            ACMP_I2_ENABLED_ON_P,
            #[doc = "ACMP_I2 disabled."]
            ACMP_I2_DISABLED,
        }
        impl ACMP_I2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_I2R::ACMP_I2_ENABLED_ON_P => false,
                    ACMP_I2R::ACMP_I2_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMP_I2R {
                match value {
                    false => ACMP_I2R::ACMP_I2_ENABLED_ON_P,
                    true => ACMP_I2R::ACMP_I2_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ACMP_I2_ENABLED_ON_P`"]
            #[inline]
            pub fn is_acmp_i2_enabled_on_p(&self) -> bool {
                *self == ACMP_I2R::ACMP_I2_ENABLED_ON_P
            }
            #[doc = "Checks if the value of the field is `ACMP_I2_DISABLED`"]
            #[inline]
            pub fn is_acmp_i2_disabled(&self) -> bool {
                *self == ACMP_I2R::ACMP_I2_DISABLED
            }
        }
        #[doc = "Possible values of the field `ACMP_I3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_I3R {
            #[doc = "ACMP_I3 enabled on pin PIO0_14."]
            ACMP_I3_ENABLED_ON_P,
            #[doc = "ACMP_I3 disabled."]
            ACMP_I3_DISABLED,
        }
        impl ACMP_I3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_I3R::ACMP_I3_ENABLED_ON_P => false,
                    ACMP_I3R::ACMP_I3_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMP_I3R {
                match value {
                    false => ACMP_I3R::ACMP_I3_ENABLED_ON_P,
                    true => ACMP_I3R::ACMP_I3_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ACMP_I3_ENABLED_ON_P`"]
            #[inline]
            pub fn is_acmp_i3_enabled_on_p(&self) -> bool {
                *self == ACMP_I3R::ACMP_I3_ENABLED_ON_P
            }
            #[doc = "Checks if the value of the field is `ACMP_I3_DISABLED`"]
            #[inline]
            pub fn is_acmp_i3_disabled(&self) -> bool {
                *self == ACMP_I3R::ACMP_I3_DISABLED
            }
        }
        #[doc = "Possible values of the field `ACMP_I4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_I4R {
            #[doc = "ACMP_I4 enabled on pin PIO0_23."]
            ACMP_I4_ENABLED_ON_P,
            #[doc = "ACMP_I4 disabled."]
            ACMP_I4_DISABLED,
        }
        impl ACMP_I4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_I4R::ACMP_I4_ENABLED_ON_P => false,
                    ACMP_I4R::ACMP_I4_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMP_I4R {
                match value {
                    false => ACMP_I4R::ACMP_I4_ENABLED_ON_P,
                    true => ACMP_I4R::ACMP_I4_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ACMP_I4_ENABLED_ON_P`"]
            #[inline]
            pub fn is_acmp_i4_enabled_on_p(&self) -> bool {
                *self == ACMP_I4R::ACMP_I4_ENABLED_ON_P
            }
            #[doc = "Checks if the value of the field is `ACMP_I4_DISABLED`"]
            #[inline]
            pub fn is_acmp_i4_disabled(&self) -> bool {
                *self == ACMP_I4R::ACMP_I4_DISABLED
            }
        }
        #[doc = "Possible values of the field `SWCLK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWCLKR {
            #[doc = "SWCLK enabled on pin PIO0_3."]
            SWCLK_ENABLED_ON_PIN,
            #[doc = "SWCLK disabled."]
            SWCLK_DISABLED,
        }
        impl SWCLKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SWCLKR::SWCLK_ENABLED_ON_PIN => false,
                    SWCLKR::SWCLK_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SWCLKR {
                match value {
                    false => SWCLKR::SWCLK_ENABLED_ON_PIN,
                    true => SWCLKR::SWCLK_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `SWCLK_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_swclk_enabled_on_pin(&self) -> bool {
                *self == SWCLKR::SWCLK_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `SWCLK_DISABLED`"]
            #[inline]
            pub fn is_swclk_disabled(&self) -> bool {
                *self == SWCLKR::SWCLK_DISABLED
            }
        }
        #[doc = "Possible values of the field `SWDIO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWDIOR {
            #[doc = "SWDIO enabled on pin PIO0_2."]
            SWDIO_ENABLED_ON_PIN,
            #[doc = "SWDIO disabled."]
            SWDIO_DISABLED,
        }
        impl SWDIOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SWDIOR::SWDIO_ENABLED_ON_PIN => false,
                    SWDIOR::SWDIO_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SWDIOR {
                match value {
                    false => SWDIOR::SWDIO_ENABLED_ON_PIN,
                    true => SWDIOR::SWDIO_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `SWDIO_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_swdio_enabled_on_pin(&self) -> bool {
                *self == SWDIOR::SWDIO_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `SWDIO_DISABLED`"]
            #[inline]
            pub fn is_swdio_disabled(&self) -> bool {
                *self == SWDIOR::SWDIO_DISABLED
            }
        }
        #[doc = "Possible values of the field `XTALIN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XTALINR {
            #[doc = "XTALIN enabled on pin PIO0_8."]
            XTALIN_ENABLED_ON_PI,
            #[doc = "XTALIN disabled."]
            XTALIN_DISABLED,
        }
        impl XTALINR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    XTALINR::XTALIN_ENABLED_ON_PI => false,
                    XTALINR::XTALIN_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> XTALINR {
                match value {
                    false => XTALINR::XTALIN_ENABLED_ON_PI,
                    true => XTALINR::XTALIN_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `XTALIN_ENABLED_ON_PI`"]
            #[inline]
            pub fn is_xtalin_enabled_on_pi(&self) -> bool {
                *self == XTALINR::XTALIN_ENABLED_ON_PI
            }
            #[doc = "Checks if the value of the field is `XTALIN_DISABLED`"]
            #[inline]
            pub fn is_xtalin_disabled(&self) -> bool {
                *self == XTALINR::XTALIN_DISABLED
            }
        }
        #[doc = "Possible values of the field `XTALOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XTALOUTR {
            #[doc = "XTALOUT enabled on pin PIO0_9."]
            XTALOUT_ENABLED_ON_P,
            #[doc = "XTALOUT disabled."]
            XTALOUT_DISABLED,
        }
        impl XTALOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    XTALOUTR::XTALOUT_ENABLED_ON_P => false,
                    XTALOUTR::XTALOUT_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> XTALOUTR {
                match value {
                    false => XTALOUTR::XTALOUT_ENABLED_ON_P,
                    true => XTALOUTR::XTALOUT_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `XTALOUT_ENABLED_ON_P`"]
            #[inline]
            pub fn is_xtalout_enabled_on_p(&self) -> bool {
                *self == XTALOUTR::XTALOUT_ENABLED_ON_P
            }
            #[doc = "Checks if the value of the field is `XTALOUT_DISABLED`"]
            #[inline]
            pub fn is_xtalout_disabled(&self) -> bool {
                *self == XTALOUTR::XTALOUT_DISABLED
            }
        }
        #[doc = "Possible values of the field `RESETN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESETNR {
            #[doc = "RESETN enabled on pin PIO0_5."]
            RESETN_ENABLED_ON_PI,
            #[doc = "RESETN disabled."]
            RESETN_DISABLED,
        }
        impl RESETNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RESETNR::RESETN_ENABLED_ON_PI => false,
                    RESETNR::RESETN_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RESETNR {
                match value {
                    false => RESETNR::RESETN_ENABLED_ON_PI,
                    true => RESETNR::RESETN_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `RESETN_ENABLED_ON_PI`"]
            #[inline]
            pub fn is_resetn_enabled_on_pi(&self) -> bool {
                *self == RESETNR::RESETN_ENABLED_ON_PI
            }
            #[doc = "Checks if the value of the field is `RESETN_DISABLED`"]
            #[inline]
            pub fn is_resetn_disabled(&self) -> bool {
                *self == RESETNR::RESETN_DISABLED
            }
        }
        #[doc = "Possible values of the field `CLKIN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKINR {
            #[doc = "CLKIN enabled on pin PIO0_1."]
            CLKIN_ENABLED_ON_PIN,
            #[doc = "CLKIN disabled."]
            CLKIN_DISABLED,
        }
        impl CLKINR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CLKINR::CLKIN_ENABLED_ON_PIN => false,
                    CLKINR::CLKIN_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CLKINR {
                match value {
                    false => CLKINR::CLKIN_ENABLED_ON_PIN,
                    true => CLKINR::CLKIN_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `CLKIN_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_clkin_enabled_on_pin(&self) -> bool {
                *self == CLKINR::CLKIN_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `CLKIN_DISABLED`"]
            #[inline]
            pub fn is_clkin_disabled(&self) -> bool {
                *self == CLKINR::CLKIN_DISABLED
            }
        }
        #[doc = "Possible values of the field `VDDCMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VDDCMPR {
            #[doc = "VDDCMP enabled on pin PIO0_6."]
            VDDCMP_ENABLED_ON_PI,
            #[doc = "VDDCMP disabled."]
            VDDCMP_DISABLED,
        }
        impl VDDCMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    VDDCMPR::VDDCMP_ENABLED_ON_PI => false,
                    VDDCMPR::VDDCMP_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> VDDCMPR {
                match value {
                    false => VDDCMPR::VDDCMP_ENABLED_ON_PI,
                    true => VDDCMPR::VDDCMP_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `VDDCMP_ENABLED_ON_PI`"]
            #[inline]
            pub fn is_vddcmp_enabled_on_pi(&self) -> bool {
                *self == VDDCMPR::VDDCMP_ENABLED_ON_PI
            }
            #[doc = "Checks if the value of the field is `VDDCMP_DISABLED`"]
            #[inline]
            pub fn is_vddcmp_disabled(&self) -> bool {
                *self == VDDCMPR::VDDCMP_DISABLED
            }
        }
        #[doc = "Possible values of the field `I2C0_SDA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C0_SDAR {
            #[doc = "I2C0_SDA enabled on pin PIO0_11."]
            I2C0_SDA_ENABLED_ON,
            #[doc = "I2C0_SDA disabled."]
            I2C0_SDA_DISABLED,
        }
        impl I2C0_SDAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C0_SDAR::I2C0_SDA_ENABLED_ON => false,
                    I2C0_SDAR::I2C0_SDA_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C0_SDAR {
                match value {
                    false => I2C0_SDAR::I2C0_SDA_ENABLED_ON,
                    true => I2C0_SDAR::I2C0_SDA_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `I2C0_SDA_ENABLED_ON`"]
            #[inline]
            pub fn is_i2c0_sda_enabled_on(&self) -> bool {
                *self == I2C0_SDAR::I2C0_SDA_ENABLED_ON
            }
            #[doc = "Checks if the value of the field is `I2C0_SDA_DISABLED`"]
            #[inline]
            pub fn is_i2c0_sda_disabled(&self) -> bool {
                *self == I2C0_SDAR::I2C0_SDA_DISABLED
            }
        }
        #[doc = "Possible values of the field `I2C0_SCL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C0_SCLR {
            #[doc = "I2C0_SCL enabled on pin PIO0_10."]
            I2C0_SCL_ENABLED_ON,
            #[doc = "I2C0_SCL disabled."]
            I2C0_SCL_DISABLED,
        }
        impl I2C0_SCLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C0_SCLR::I2C0_SCL_ENABLED_ON => false,
                    I2C0_SCLR::I2C0_SCL_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C0_SCLR {
                match value {
                    false => I2C0_SCLR::I2C0_SCL_ENABLED_ON,
                    true => I2C0_SCLR::I2C0_SCL_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `I2C0_SCL_ENABLED_ON`"]
            #[inline]
            pub fn is_i2c0_scl_enabled_on(&self) -> bool {
                *self == I2C0_SCLR::I2C0_SCL_ENABLED_ON
            }
            #[doc = "Checks if the value of the field is `I2C0_SCL_DISABLED`"]
            #[inline]
            pub fn is_i2c0_scl_disabled(&self) -> bool {
                *self == I2C0_SCLR::I2C0_SCL_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_0R {
            #[doc = "ADC_0 enabled on pin PIO0_7."]
            ADC_0_ENABLED_ON_PIN,
            #[doc = "ADC_0 disabled."]
            ADC_0_DISABLED,
        }
        impl ADC_0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_0R::ADC_0_ENABLED_ON_PIN => false,
                    ADC_0R::ADC_0_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_0R {
                match value {
                    false => ADC_0R::ADC_0_ENABLED_ON_PIN,
                    true => ADC_0R::ADC_0_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_0_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_0_enabled_on_pin(&self) -> bool {
                *self == ADC_0R::ADC_0_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_0_DISABLED`"]
            #[inline]
            pub fn is_adc_0_disabled(&self) -> bool {
                *self == ADC_0R::ADC_0_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_1R {
            #[doc = "ADC_1 enabled on pin PIO0_6."]
            ADC_1_ENABLED_ON_PIN,
            #[doc = "ADC_1 disabled."]
            ADC_1_DISABLED,
        }
        impl ADC_1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_1R::ADC_1_ENABLED_ON_PIN => false,
                    ADC_1R::ADC_1_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_1R {
                match value {
                    false => ADC_1R::ADC_1_ENABLED_ON_PIN,
                    true => ADC_1R::ADC_1_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_1_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_1_enabled_on_pin(&self) -> bool {
                *self == ADC_1R::ADC_1_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_1_DISABLED`"]
            #[inline]
            pub fn is_adc_1_disabled(&self) -> bool {
                *self == ADC_1R::ADC_1_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_2R {
            #[doc = "ADC_2 enabled on pin PIO0_14."]
            ADC_2_ENABLED_ON_PIN,
            #[doc = "ADC_2 disabled."]
            ADC_2_DISABLED,
        }
        impl ADC_2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_2R::ADC_2_ENABLED_ON_PIN => false,
                    ADC_2R::ADC_2_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_2R {
                match value {
                    false => ADC_2R::ADC_2_ENABLED_ON_PIN,
                    true => ADC_2R::ADC_2_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_2_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_2_enabled_on_pin(&self) -> bool {
                *self == ADC_2R::ADC_2_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_2_DISABLED`"]
            #[inline]
            pub fn is_adc_2_disabled(&self) -> bool {
                *self == ADC_2R::ADC_2_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_3R {
            #[doc = "ADC_3 enabled on pin PIO0_23."]
            ADC_3_ENABLED_ON_PIN,
            #[doc = "ADC_3 disabled."]
            ADC_3_DISABLED,
        }
        impl ADC_3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_3R::ADC_3_ENABLED_ON_PIN => false,
                    ADC_3R::ADC_3_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_3R {
                match value {
                    false => ADC_3R::ADC_3_ENABLED_ON_PIN,
                    true => ADC_3R::ADC_3_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_3_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_3_enabled_on_pin(&self) -> bool {
                *self == ADC_3R::ADC_3_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_3_DISABLED`"]
            #[inline]
            pub fn is_adc_3_disabled(&self) -> bool {
                *self == ADC_3R::ADC_3_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_4R {
            #[doc = "ADC_4 enabled on pin PIO0_22."]
            ADC_4_ENABLED_ON_PIN,
            #[doc = "ADC_4 disabled."]
            ADC_4_DISABLED,
        }
        impl ADC_4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_4R::ADC_4_ENABLED_ON_PIN => false,
                    ADC_4R::ADC_4_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_4R {
                match value {
                    false => ADC_4R::ADC_4_ENABLED_ON_PIN,
                    true => ADC_4R::ADC_4_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_4_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_4_enabled_on_pin(&self) -> bool {
                *self == ADC_4R::ADC_4_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_4_DISABLED`"]
            #[inline]
            pub fn is_adc_4_disabled(&self) -> bool {
                *self == ADC_4R::ADC_4_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_5R {
            #[doc = "ADC_5 enabled on pin PIO0_21."]
            ADC_5_ENABLED_ON_PIN,
            #[doc = "ADC_5 disabled."]
            ADC_5_DISABLED,
        }
        impl ADC_5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_5R::ADC_5_ENABLED_ON_PIN => false,
                    ADC_5R::ADC_5_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_5R {
                match value {
                    false => ADC_5R::ADC_5_ENABLED_ON_PIN,
                    true => ADC_5R::ADC_5_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_5_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_5_enabled_on_pin(&self) -> bool {
                *self == ADC_5R::ADC_5_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_5_DISABLED`"]
            #[inline]
            pub fn is_adc_5_disabled(&self) -> bool {
                *self == ADC_5R::ADC_5_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_6R {
            #[doc = "ADC_6 enabled on pin PIO0_20."]
            ADC_6_ENABLED_ON_PIN,
            #[doc = "ADC_6 disabled."]
            ADC_6_DISABLED,
        }
        impl ADC_6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_6R::ADC_6_ENABLED_ON_PIN => false,
                    ADC_6R::ADC_6_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_6R {
                match value {
                    false => ADC_6R::ADC_6_ENABLED_ON_PIN,
                    true => ADC_6R::ADC_6_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_6_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_6_enabled_on_pin(&self) -> bool {
                *self == ADC_6R::ADC_6_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_6_DISABLED`"]
            #[inline]
            pub fn is_adc_6_disabled(&self) -> bool {
                *self == ADC_6R::ADC_6_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_7R {
            #[doc = "ADC_7 enabled on pin PIO0_19."]
            ADC_7_ENABLED_ON_PIN,
            #[doc = "ADC_7 disabled."]
            ADC_7_DISABLED,
        }
        impl ADC_7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_7R::ADC_7_ENABLED_ON_PIN => false,
                    ADC_7R::ADC_7_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_7R {
                match value {
                    false => ADC_7R::ADC_7_ENABLED_ON_PIN,
                    true => ADC_7R::ADC_7_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_7_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_7_enabled_on_pin(&self) -> bool {
                *self == ADC_7R::ADC_7_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_7_DISABLED`"]
            #[inline]
            pub fn is_adc_7_disabled(&self) -> bool {
                *self == ADC_7R::ADC_7_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_8R {
            #[doc = "ADC_8 enabled on pin PIO0_18."]
            ADC_8_ENABLED_ON_PIN,
            #[doc = "ADC_8 disabled."]
            ADC_8_DISABLED,
        }
        impl ADC_8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_8R::ADC_8_ENABLED_ON_PIN => false,
                    ADC_8R::ADC_8_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_8R {
                match value {
                    false => ADC_8R::ADC_8_ENABLED_ON_PIN,
                    true => ADC_8R::ADC_8_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_8_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_8_enabled_on_pin(&self) -> bool {
                *self == ADC_8R::ADC_8_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_8_DISABLED`"]
            #[inline]
            pub fn is_adc_8_disabled(&self) -> bool {
                *self == ADC_8R::ADC_8_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_9R {
            #[doc = "ADC_9 enabled on pin PIO0_17."]
            ADC_9_ENABLED_ON_PIN,
            #[doc = "ADC_9 disabled."]
            ADC_9_DISABLED,
        }
        impl ADC_9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_9R::ADC_9_ENABLED_ON_PIN => false,
                    ADC_9R::ADC_9_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_9R {
                match value {
                    false => ADC_9R::ADC_9_ENABLED_ON_PIN,
                    true => ADC_9R::ADC_9_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_9_ENABLED_ON_PIN`"]
            #[inline]
            pub fn is_adc_9_enabled_on_pin(&self) -> bool {
                *self == ADC_9R::ADC_9_ENABLED_ON_PIN
            }
            #[doc = "Checks if the value of the field is `ADC_9_DISABLED`"]
            #[inline]
            pub fn is_adc_9_disabled(&self) -> bool {
                *self == ADC_9R::ADC_9_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_10R {
            #[doc = "ADC_10 enabled on pin PIO0_13."]
            ADC_10_ENABLED_ON_PI,
            #[doc = "ADC_10 disabled."]
            ADC_10_DISABLED,
        }
        impl ADC_10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_10R::ADC_10_ENABLED_ON_PI => false,
                    ADC_10R::ADC_10_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_10R {
                match value {
                    false => ADC_10R::ADC_10_ENABLED_ON_PI,
                    true => ADC_10R::ADC_10_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_10_ENABLED_ON_PI`"]
            #[inline]
            pub fn is_adc_10_enabled_on_pi(&self) -> bool {
                *self == ADC_10R::ADC_10_ENABLED_ON_PI
            }
            #[doc = "Checks if the value of the field is `ADC_10_DISABLED`"]
            #[inline]
            pub fn is_adc_10_disabled(&self) -> bool {
                *self == ADC_10R::ADC_10_DISABLED
            }
        }
        #[doc = "Possible values of the field `ADC_11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_11R {
            #[doc = "ADC_11 enabled on pin PIO0_4."]
            ADC_11_ENABLED_ON_PI,
            #[doc = "ADC_11 disabled."]
            ADC_11_DISABLED,
        }
        impl ADC_11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_11R::ADC_11_ENABLED_ON_PI => false,
                    ADC_11R::ADC_11_DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_11R {
                match value {
                    false => ADC_11R::ADC_11_ENABLED_ON_PI,
                    true => ADC_11R::ADC_11_DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ADC_11_ENABLED_ON_PI`"]
            #[inline]
            pub fn is_adc_11_enabled_on_pi(&self) -> bool {
                *self == ADC_11R::ADC_11_ENABLED_ON_PI
            }
            #[doc = "Checks if the value of the field is `ADC_11_DISABLED`"]
            #[inline]
            pub fn is_adc_11_disabled(&self) -> bool {
                *self == ADC_11R::ADC_11_DISABLED
            }
        }
        #[doc = "Values that can be written to the field `ACMP_I1`"]
        pub enum ACMP_I1W {
            #[doc = "ACMP_I1 enabled on pin PIO0_00."]
            ACMP_I1_ENABLED_ON_P,
            #[doc = "ACMP_I1 disabled."]
            ACMP_I1_DISABLED,
        }
        impl ACMP_I1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_I1W::ACMP_I1_ENABLED_ON_P => false,
                    ACMP_I1W::ACMP_I1_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_I1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_I1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMP_I1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ACMP_I1 enabled on pin PIO0_00."]
            #[inline]
            pub fn acmp_i1_enabled_on_p(self) -> &'a mut W {
                self.variant(ACMP_I1W::ACMP_I1_ENABLED_ON_P)
            }
            #[doc = "ACMP_I1 disabled."]
            #[inline]
            pub fn acmp_i1_disabled(self) -> &'a mut W {
                self.variant(ACMP_I1W::ACMP_I1_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP_I2`"]
        pub enum ACMP_I2W {
            #[doc = "ACMP_I2 enabled on pin PIO0_1."]
            ACMP_I2_ENABLED_ON_P,
            #[doc = "ACMP_I2 disabled."]
            ACMP_I2_DISABLED,
        }
        impl ACMP_I2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_I2W::ACMP_I2_ENABLED_ON_P => false,
                    ACMP_I2W::ACMP_I2_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_I2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_I2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMP_I2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ACMP_I2 enabled on pin PIO0_1."]
            #[inline]
            pub fn acmp_i2_enabled_on_p(self) -> &'a mut W {
                self.variant(ACMP_I2W::ACMP_I2_ENABLED_ON_P)
            }
            #[doc = "ACMP_I2 disabled."]
            #[inline]
            pub fn acmp_i2_disabled(self) -> &'a mut W {
                self.variant(ACMP_I2W::ACMP_I2_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP_I3`"]
        pub enum ACMP_I3W {
            #[doc = "ACMP_I3 enabled on pin PIO0_14."]
            ACMP_I3_ENABLED_ON_P,
            #[doc = "ACMP_I3 disabled."]
            ACMP_I3_DISABLED,
        }
        impl ACMP_I3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_I3W::ACMP_I3_ENABLED_ON_P => false,
                    ACMP_I3W::ACMP_I3_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_I3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_I3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMP_I3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ACMP_I3 enabled on pin PIO0_14."]
            #[inline]
            pub fn acmp_i3_enabled_on_p(self) -> &'a mut W {
                self.variant(ACMP_I3W::ACMP_I3_ENABLED_ON_P)
            }
            #[doc = "ACMP_I3 disabled."]
            #[inline]
            pub fn acmp_i3_disabled(self) -> &'a mut W {
                self.variant(ACMP_I3W::ACMP_I3_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP_I4`"]
        pub enum ACMP_I4W {
            #[doc = "ACMP_I4 enabled on pin PIO0_23."]
            ACMP_I4_ENABLED_ON_P,
            #[doc = "ACMP_I4 disabled."]
            ACMP_I4_DISABLED,
        }
        impl ACMP_I4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_I4W::ACMP_I4_ENABLED_ON_P => false,
                    ACMP_I4W::ACMP_I4_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_I4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_I4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMP_I4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ACMP_I4 enabled on pin PIO0_23."]
            #[inline]
            pub fn acmp_i4_enabled_on_p(self) -> &'a mut W {
                self.variant(ACMP_I4W::ACMP_I4_ENABLED_ON_P)
            }
            #[doc = "ACMP_I4 disabled."]
            #[inline]
            pub fn acmp_i4_disabled(self) -> &'a mut W {
                self.variant(ACMP_I4W::ACMP_I4_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWCLK`"]
        pub enum SWCLKW {
            #[doc = "SWCLK enabled on pin PIO0_3."]
            SWCLK_ENABLED_ON_PIN,
            #[doc = "SWCLK disabled."]
            SWCLK_DISABLED,
        }
        impl SWCLKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWCLKW::SWCLK_ENABLED_ON_PIN => false,
                    SWCLKW::SWCLK_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWCLKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWCLKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SWCLK enabled on pin PIO0_3."]
            #[inline]
            pub fn swclk_enabled_on_pin(self) -> &'a mut W {
                self.variant(SWCLKW::SWCLK_ENABLED_ON_PIN)
            }
            #[doc = "SWCLK disabled."]
            #[inline]
            pub fn swclk_disabled(self) -> &'a mut W {
                self.variant(SWCLKW::SWCLK_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWDIO`"]
        pub enum SWDIOW {
            #[doc = "SWDIO enabled on pin PIO0_2."]
            SWDIO_ENABLED_ON_PIN,
            #[doc = "SWDIO disabled."]
            SWDIO_DISABLED,
        }
        impl SWDIOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWDIOW::SWDIO_ENABLED_ON_PIN => false,
                    SWDIOW::SWDIO_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWDIOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWDIOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWDIOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SWDIO enabled on pin PIO0_2."]
            #[inline]
            pub fn swdio_enabled_on_pin(self) -> &'a mut W {
                self.variant(SWDIOW::SWDIO_ENABLED_ON_PIN)
            }
            #[doc = "SWDIO disabled."]
            #[inline]
            pub fn swdio_disabled(self) -> &'a mut W {
                self.variant(SWDIOW::SWDIO_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XTALIN`"]
        pub enum XTALINW {
            #[doc = "XTALIN enabled on pin PIO0_8."]
            XTALIN_ENABLED_ON_PI,
            #[doc = "XTALIN disabled."]
            XTALIN_DISABLED,
        }
        impl XTALINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    XTALINW::XTALIN_ENABLED_ON_PI => false,
                    XTALINW::XTALIN_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: XTALINW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "XTALIN enabled on pin PIO0_8."]
            #[inline]
            pub fn xtalin_enabled_on_pi(self) -> &'a mut W {
                self.variant(XTALINW::XTALIN_ENABLED_ON_PI)
            }
            #[doc = "XTALIN disabled."]
            #[inline]
            pub fn xtalin_disabled(self) -> &'a mut W {
                self.variant(XTALINW::XTALIN_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XTALOUT`"]
        pub enum XTALOUTW {
            #[doc = "XTALOUT enabled on pin PIO0_9."]
            XTALOUT_ENABLED_ON_P,
            #[doc = "XTALOUT disabled."]
            XTALOUT_DISABLED,
        }
        impl XTALOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    XTALOUTW::XTALOUT_ENABLED_ON_P => false,
                    XTALOUTW::XTALOUT_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: XTALOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "XTALOUT enabled on pin PIO0_9."]
            #[inline]
            pub fn xtalout_enabled_on_p(self) -> &'a mut W {
                self.variant(XTALOUTW::XTALOUT_ENABLED_ON_P)
            }
            #[doc = "XTALOUT disabled."]
            #[inline]
            pub fn xtalout_disabled(self) -> &'a mut W {
                self.variant(XTALOUTW::XTALOUT_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RESETN`"]
        pub enum RESETNW {
            #[doc = "RESETN enabled on pin PIO0_5."]
            RESETN_ENABLED_ON_PI,
            #[doc = "RESETN disabled."]
            RESETN_DISABLED,
        }
        impl RESETNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RESETNW::RESETN_ENABLED_ON_PI => false,
                    RESETNW::RESETN_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESETNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RESETN enabled on pin PIO0_5."]
            #[inline]
            pub fn resetn_enabled_on_pi(self) -> &'a mut W {
                self.variant(RESETNW::RESETN_ENABLED_ON_PI)
            }
            #[doc = "RESETN disabled."]
            #[inline]
            pub fn resetn_disabled(self) -> &'a mut W {
                self.variant(RESETNW::RESETN_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKIN`"]
        pub enum CLKINW {
            #[doc = "CLKIN enabled on pin PIO0_1."]
            CLKIN_ENABLED_ON_PIN,
            #[doc = "CLKIN disabled."]
            CLKIN_DISABLED,
        }
        impl CLKINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLKINW::CLKIN_ENABLED_ON_PIN => false,
                    CLKINW::CLKIN_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLKINW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CLKIN enabled on pin PIO0_1."]
            #[inline]
            pub fn clkin_enabled_on_pin(self) -> &'a mut W {
                self.variant(CLKINW::CLKIN_ENABLED_ON_PIN)
            }
            #[doc = "CLKIN disabled."]
            #[inline]
            pub fn clkin_disabled(self) -> &'a mut W {
                self.variant(CLKINW::CLKIN_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `VDDCMP`"]
        pub enum VDDCMPW {
            #[doc = "VDDCMP enabled on pin PIO0_6."]
            VDDCMP_ENABLED_ON_PI,
            #[doc = "VDDCMP disabled."]
            VDDCMP_DISABLED,
        }
        impl VDDCMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    VDDCMPW::VDDCMP_ENABLED_ON_PI => false,
                    VDDCMPW::VDDCMP_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VDDCMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VDDCMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: VDDCMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "VDDCMP enabled on pin PIO0_6."]
            #[inline]
            pub fn vddcmp_enabled_on_pi(self) -> &'a mut W {
                self.variant(VDDCMPW::VDDCMP_ENABLED_ON_PI)
            }
            #[doc = "VDDCMP disabled."]
            #[inline]
            pub fn vddcmp_disabled(self) -> &'a mut W {
                self.variant(VDDCMPW::VDDCMP_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C0_SDA`"]
        pub enum I2C0_SDAW {
            #[doc = "I2C0_SDA enabled on pin PIO0_11."]
            I2C0_SDA_ENABLED_ON,
            #[doc = "I2C0_SDA disabled."]
            I2C0_SDA_DISABLED,
        }
        impl I2C0_SDAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C0_SDAW::I2C0_SDA_ENABLED_ON => false,
                    I2C0_SDAW::I2C0_SDA_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0_SDAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0_SDAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C0_SDAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "I2C0_SDA enabled on pin PIO0_11."]
            #[inline]
            pub fn i2c0_sda_enabled_on(self) -> &'a mut W {
                self.variant(I2C0_SDAW::I2C0_SDA_ENABLED_ON)
            }
            #[doc = "I2C0_SDA disabled."]
            #[inline]
            pub fn i2c0_sda_disabled(self) -> &'a mut W {
                self.variant(I2C0_SDAW::I2C0_SDA_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C0_SCL`"]
        pub enum I2C0_SCLW {
            #[doc = "I2C0_SCL enabled on pin PIO0_10."]
            I2C0_SCL_ENABLED_ON,
            #[doc = "I2C0_SCL disabled."]
            I2C0_SCL_DISABLED,
        }
        impl I2C0_SCLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C0_SCLW::I2C0_SCL_ENABLED_ON => false,
                    I2C0_SCLW::I2C0_SCL_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0_SCLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0_SCLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C0_SCLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "I2C0_SCL enabled on pin PIO0_10."]
            #[inline]
            pub fn i2c0_scl_enabled_on(self) -> &'a mut W {
                self.variant(I2C0_SCLW::I2C0_SCL_ENABLED_ON)
            }
            #[doc = "I2C0_SCL disabled."]
            #[inline]
            pub fn i2c0_scl_disabled(self) -> &'a mut W {
                self.variant(I2C0_SCLW::I2C0_SCL_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_0`"]
        pub enum ADC_0W {
            #[doc = "ADC_0 enabled on pin PIO0_7."]
            ADC_0_ENABLED_ON_PIN,
            #[doc = "ADC_0 disabled."]
            ADC_0_DISABLED,
        }
        impl ADC_0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_0W::ADC_0_ENABLED_ON_PIN => false,
                    ADC_0W::ADC_0_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_0 enabled on pin PIO0_7."]
            #[inline]
            pub fn adc_0_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_0W::ADC_0_ENABLED_ON_PIN)
            }
            #[doc = "ADC_0 disabled."]
            #[inline]
            pub fn adc_0_disabled(self) -> &'a mut W {
                self.variant(ADC_0W::ADC_0_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_1`"]
        pub enum ADC_1W {
            #[doc = "ADC_1 enabled on pin PIO0_6."]
            ADC_1_ENABLED_ON_PIN,
            #[doc = "ADC_1 disabled."]
            ADC_1_DISABLED,
        }
        impl ADC_1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_1W::ADC_1_ENABLED_ON_PIN => false,
                    ADC_1W::ADC_1_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_1 enabled on pin PIO0_6."]
            #[inline]
            pub fn adc_1_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_1W::ADC_1_ENABLED_ON_PIN)
            }
            #[doc = "ADC_1 disabled."]
            #[inline]
            pub fn adc_1_disabled(self) -> &'a mut W {
                self.variant(ADC_1W::ADC_1_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_2`"]
        pub enum ADC_2W {
            #[doc = "ADC_2 enabled on pin PIO0_14."]
            ADC_2_ENABLED_ON_PIN,
            #[doc = "ADC_2 disabled."]
            ADC_2_DISABLED,
        }
        impl ADC_2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_2W::ADC_2_ENABLED_ON_PIN => false,
                    ADC_2W::ADC_2_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_2 enabled on pin PIO0_14."]
            #[inline]
            pub fn adc_2_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_2W::ADC_2_ENABLED_ON_PIN)
            }
            #[doc = "ADC_2 disabled."]
            #[inline]
            pub fn adc_2_disabled(self) -> &'a mut W {
                self.variant(ADC_2W::ADC_2_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_3`"]
        pub enum ADC_3W {
            #[doc = "ADC_3 enabled on pin PIO0_23."]
            ADC_3_ENABLED_ON_PIN,
            #[doc = "ADC_3 disabled."]
            ADC_3_DISABLED,
        }
        impl ADC_3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_3W::ADC_3_ENABLED_ON_PIN => false,
                    ADC_3W::ADC_3_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_3 enabled on pin PIO0_23."]
            #[inline]
            pub fn adc_3_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_3W::ADC_3_ENABLED_ON_PIN)
            }
            #[doc = "ADC_3 disabled."]
            #[inline]
            pub fn adc_3_disabled(self) -> &'a mut W {
                self.variant(ADC_3W::ADC_3_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_4`"]
        pub enum ADC_4W {
            #[doc = "ADC_4 enabled on pin PIO0_22."]
            ADC_4_ENABLED_ON_PIN,
            #[doc = "ADC_4 disabled."]
            ADC_4_DISABLED,
        }
        impl ADC_4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_4W::ADC_4_ENABLED_ON_PIN => false,
                    ADC_4W::ADC_4_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_4 enabled on pin PIO0_22."]
            #[inline]
            pub fn adc_4_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_4W::ADC_4_ENABLED_ON_PIN)
            }
            #[doc = "ADC_4 disabled."]
            #[inline]
            pub fn adc_4_disabled(self) -> &'a mut W {
                self.variant(ADC_4W::ADC_4_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_5`"]
        pub enum ADC_5W {
            #[doc = "ADC_5 enabled on pin PIO0_21."]
            ADC_5_ENABLED_ON_PIN,
            #[doc = "ADC_5 disabled."]
            ADC_5_DISABLED,
        }
        impl ADC_5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_5W::ADC_5_ENABLED_ON_PIN => false,
                    ADC_5W::ADC_5_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_5 enabled on pin PIO0_21."]
            #[inline]
            pub fn adc_5_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_5W::ADC_5_ENABLED_ON_PIN)
            }
            #[doc = "ADC_5 disabled."]
            #[inline]
            pub fn adc_5_disabled(self) -> &'a mut W {
                self.variant(ADC_5W::ADC_5_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_6`"]
        pub enum ADC_6W {
            #[doc = "ADC_6 enabled on pin PIO0_20."]
            ADC_6_ENABLED_ON_PIN,
            #[doc = "ADC_6 disabled."]
            ADC_6_DISABLED,
        }
        impl ADC_6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_6W::ADC_6_ENABLED_ON_PIN => false,
                    ADC_6W::ADC_6_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_6 enabled on pin PIO0_20."]
            #[inline]
            pub fn adc_6_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_6W::ADC_6_ENABLED_ON_PIN)
            }
            #[doc = "ADC_6 disabled."]
            #[inline]
            pub fn adc_6_disabled(self) -> &'a mut W {
                self.variant(ADC_6W::ADC_6_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_7`"]
        pub enum ADC_7W {
            #[doc = "ADC_7 enabled on pin PIO0_19."]
            ADC_7_ENABLED_ON_PIN,
            #[doc = "ADC_7 disabled."]
            ADC_7_DISABLED,
        }
        impl ADC_7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_7W::ADC_7_ENABLED_ON_PIN => false,
                    ADC_7W::ADC_7_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_7 enabled on pin PIO0_19."]
            #[inline]
            pub fn adc_7_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_7W::ADC_7_ENABLED_ON_PIN)
            }
            #[doc = "ADC_7 disabled."]
            #[inline]
            pub fn adc_7_disabled(self) -> &'a mut W {
                self.variant(ADC_7W::ADC_7_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_8`"]
        pub enum ADC_8W {
            #[doc = "ADC_8 enabled on pin PIO0_18."]
            ADC_8_ENABLED_ON_PIN,
            #[doc = "ADC_8 disabled."]
            ADC_8_DISABLED,
        }
        impl ADC_8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_8W::ADC_8_ENABLED_ON_PIN => false,
                    ADC_8W::ADC_8_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_8 enabled on pin PIO0_18."]
            #[inline]
            pub fn adc_8_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_8W::ADC_8_ENABLED_ON_PIN)
            }
            #[doc = "ADC_8 disabled."]
            #[inline]
            pub fn adc_8_disabled(self) -> &'a mut W {
                self.variant(ADC_8W::ADC_8_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_9`"]
        pub enum ADC_9W {
            #[doc = "ADC_9 enabled on pin PIO0_17."]
            ADC_9_ENABLED_ON_PIN,
            #[doc = "ADC_9 disabled."]
            ADC_9_DISABLED,
        }
        impl ADC_9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_9W::ADC_9_ENABLED_ON_PIN => false,
                    ADC_9W::ADC_9_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_9 enabled on pin PIO0_17."]
            #[inline]
            pub fn adc_9_enabled_on_pin(self) -> &'a mut W {
                self.variant(ADC_9W::ADC_9_ENABLED_ON_PIN)
            }
            #[doc = "ADC_9 disabled."]
            #[inline]
            pub fn adc_9_disabled(self) -> &'a mut W {
                self.variant(ADC_9W::ADC_9_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_10`"]
        pub enum ADC_10W {
            #[doc = "ADC_10 enabled on pin PIO0_13."]
            ADC_10_ENABLED_ON_PI,
            #[doc = "ADC_10 disabled."]
            ADC_10_DISABLED,
        }
        impl ADC_10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_10W::ADC_10_ENABLED_ON_PI => false,
                    ADC_10W::ADC_10_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_10 enabled on pin PIO0_13."]
            #[inline]
            pub fn adc_10_enabled_on_pi(self) -> &'a mut W {
                self.variant(ADC_10W::ADC_10_ENABLED_ON_PI)
            }
            #[doc = "ADC_10 disabled."]
            #[inline]
            pub fn adc_10_disabled(self) -> &'a mut W {
                self.variant(ADC_10W::ADC_10_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_11`"]
        pub enum ADC_11W {
            #[doc = "ADC_11 enabled on pin PIO0_4."]
            ADC_11_ENABLED_ON_PI,
            #[doc = "ADC_11 disabled."]
            ADC_11_DISABLED,
        }
        impl ADC_11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_11W::ADC_11_ENABLED_ON_PI => false,
                    ADC_11W::ADC_11_DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ADC_11 enabled on pin PIO0_4."]
            #[inline]
            pub fn adc_11_enabled_on_pi(self) -> &'a mut W {
                self.variant(ADC_11W::ADC_11_ENABLED_ON_PI)
            }
            #[doc = "ADC_11 disabled."]
            #[inline]
            pub fn adc_11_disabled(self) -> &'a mut W {
                self.variant(ADC_11W::ADC_11_DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - ACMP_I1 function select."]
            #[inline]
            pub fn acmp_i1(&self) -> ACMP_I1R {
                ACMP_I1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - ACMP_I2 function select."]
            #[inline]
            pub fn acmp_i2(&self) -> ACMP_I2R {
                ACMP_I2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - ACMP_I3 function select."]
            #[inline]
            pub fn acmp_i3(&self) -> ACMP_I3R {
                ACMP_I3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - ACMP_I4 function select."]
            #[inline]
            pub fn acmp_i4(&self) -> ACMP_I4R {
                ACMP_I4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - SWCLK function select."]
            #[inline]
            pub fn swclk(&self) -> SWCLKR {
                SWCLKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - SWDIO function select."]
            #[inline]
            pub fn swdio(&self) -> SWDIOR {
                SWDIOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - XTALIN function select."]
            #[inline]
            pub fn xtalin(&self) -> XTALINR {
                XTALINR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - XTALOUT function select."]
            #[inline]
            pub fn xtalout(&self) -> XTALOUTR {
                XTALOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - RESETN function select."]
            #[inline]
            pub fn resetn(&self) -> RESETNR {
                RESETNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - CLKIN function select."]
            #[inline]
            pub fn clkin(&self) -> CLKINR {
                CLKINR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - VDDCMP function select."]
            #[inline]
            pub fn vddcmp(&self) -> VDDCMPR {
                VDDCMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - I2C0_SDA function select."]
            #[inline]
            pub fn i2c0_sda(&self) -> I2C0_SDAR {
                I2C0_SDAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - I2C0_SCL function select."]
            #[inline]
            pub fn i2c0_scl(&self) -> I2C0_SCLR {
                I2C0_SCLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - ADC_0 function select."]
            #[inline]
            pub fn adc_0(&self) -> ADC_0R {
                ADC_0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - ADC_1 function select."]
            #[inline]
            pub fn adc_1(&self) -> ADC_1R {
                ADC_1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - ADC_2 function select."]
            #[inline]
            pub fn adc_2(&self) -> ADC_2R {
                ADC_2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - ADC_3 function select."]
            #[inline]
            pub fn adc_3(&self) -> ADC_3R {
                ADC_3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - ADC_4 function select."]
            #[inline]
            pub fn adc_4(&self) -> ADC_4R {
                ADC_4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - ADC_5 function select."]
            #[inline]
            pub fn adc_5(&self) -> ADC_5R {
                ADC_5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - ADC_6 function select."]
            #[inline]
            pub fn adc_6(&self) -> ADC_6R {
                ADC_6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - ADC_7 function select."]
            #[inline]
            pub fn adc_7(&self) -> ADC_7R {
                ADC_7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - ADC_8 function select."]
            #[inline]
            pub fn adc_8(&self) -> ADC_8R {
                ADC_8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - ADC_9 function select."]
            #[inline]
            pub fn adc_9(&self) -> ADC_9R {
                ADC_9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - ADC_10 function select."]
            #[inline]
            pub fn adc_10(&self) -> ADC_10R {
                ADC_10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - ADC_11 function select."]
            #[inline]
            pub fn adc_11(&self) -> ADC_11R {
                ADC_11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_fecf }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - ACMP_I1 function select."]
            #[inline]
            pub fn acmp_i1(&mut self) -> _ACMP_I1W {
                _ACMP_I1W { w: self }
            }
            #[doc = "Bit 1 - ACMP_I2 function select."]
            #[inline]
            pub fn acmp_i2(&mut self) -> _ACMP_I2W {
                _ACMP_I2W { w: self }
            }
            #[doc = "Bit 2 - ACMP_I3 function select."]
            #[inline]
            pub fn acmp_i3(&mut self) -> _ACMP_I3W {
                _ACMP_I3W { w: self }
            }
            #[doc = "Bit 3 - ACMP_I4 function select."]
            #[inline]
            pub fn acmp_i4(&mut self) -> _ACMP_I4W {
                _ACMP_I4W { w: self }
            }
            #[doc = "Bit 4 - SWCLK function select."]
            #[inline]
            pub fn swclk(&mut self) -> _SWCLKW {
                _SWCLKW { w: self }
            }
            #[doc = "Bit 5 - SWDIO function select."]
            #[inline]
            pub fn swdio(&mut self) -> _SWDIOW {
                _SWDIOW { w: self }
            }
            #[doc = "Bit 6 - XTALIN function select."]
            #[inline]
            pub fn xtalin(&mut self) -> _XTALINW {
                _XTALINW { w: self }
            }
            #[doc = "Bit 7 - XTALOUT function select."]
            #[inline]
            pub fn xtalout(&mut self) -> _XTALOUTW {
                _XTALOUTW { w: self }
            }
            #[doc = "Bit 8 - RESETN function select."]
            #[inline]
            pub fn resetn(&mut self) -> _RESETNW {
                _RESETNW { w: self }
            }
            #[doc = "Bit 9 - CLKIN function select."]
            #[inline]
            pub fn clkin(&mut self) -> _CLKINW {
                _CLKINW { w: self }
            }
            #[doc = "Bit 10 - VDDCMP function select."]
            #[inline]
            pub fn vddcmp(&mut self) -> _VDDCMPW {
                _VDDCMPW { w: self }
            }
            #[doc = "Bit 11 - I2C0_SDA function select."]
            #[inline]
            pub fn i2c0_sda(&mut self) -> _I2C0_SDAW {
                _I2C0_SDAW { w: self }
            }
            #[doc = "Bit 12 - I2C0_SCL function select."]
            #[inline]
            pub fn i2c0_scl(&mut self) -> _I2C0_SCLW {
                _I2C0_SCLW { w: self }
            }
            #[doc = "Bit 13 - ADC_0 function select."]
            #[inline]
            pub fn adc_0(&mut self) -> _ADC_0W {
                _ADC_0W { w: self }
            }
            #[doc = "Bit 14 - ADC_1 function select."]
            #[inline]
            pub fn adc_1(&mut self) -> _ADC_1W {
                _ADC_1W { w: self }
            }
            #[doc = "Bit 15 - ADC_2 function select."]
            #[inline]
            pub fn adc_2(&mut self) -> _ADC_2W {
                _ADC_2W { w: self }
            }
            #[doc = "Bit 16 - ADC_3 function select."]
            #[inline]
            pub fn adc_3(&mut self) -> _ADC_3W {
                _ADC_3W { w: self }
            }
            #[doc = "Bit 17 - ADC_4 function select."]
            #[inline]
            pub fn adc_4(&mut self) -> _ADC_4W {
                _ADC_4W { w: self }
            }
            #[doc = "Bit 18 - ADC_5 function select."]
            #[inline]
            pub fn adc_5(&mut self) -> _ADC_5W {
                _ADC_5W { w: self }
            }
            #[doc = "Bit 19 - ADC_6 function select."]
            #[inline]
            pub fn adc_6(&mut self) -> _ADC_6W {
                _ADC_6W { w: self }
            }
            #[doc = "Bit 20 - ADC_7 function select."]
            #[inline]
            pub fn adc_7(&mut self) -> _ADC_7W {
                _ADC_7W { w: self }
            }
            #[doc = "Bit 21 - ADC_8 function select."]
            #[inline]
            pub fn adc_8(&mut self) -> _ADC_8W {
                _ADC_8W { w: self }
            }
            #[doc = "Bit 22 - ADC_9 function select."]
            #[inline]
            pub fn adc_9(&mut self) -> _ADC_9W {
                _ADC_9W { w: self }
            }
            #[doc = "Bit 23 - ADC_10 function select."]
            #[inline]
            pub fn adc_10(&mut self) -> _ADC_10W {
                _ADC_10W { w: self }
            }
            #[doc = "Bit 24 - ADC_11 function select."]
            #[inline]
            pub fn adc_11(&mut self) -> _ADC_11W {
                _ADC_11W { w: self }
            }
        }
    }
}
#[doc = "12-bit Analog-to-Digital Converter (ADC)"]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const adc::RegisterBlock {
        0x4001_c000 as *const _
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    fn deref(&self) -> &adc::RegisterBlock {
        unsafe { &*ADC::ptr() }
    }
}
#[doc = "12-bit Analog-to-Digital Converter (ADC)"]
pub mod adc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - A/D Control Register. Contains the clock divide value, enable bits for each sequence and the A/D power-down bit."]
        pub ctrl: CTRL,
        _reserved0: [u8; 4usize],
        #[doc = "0x08 - A/D Conversion Sequence-A control Register: Controls triggering and channel selection for conversion sequence-A. Also specifies interrupt mode for sequence-A."]
        pub seqa_ctrl: SEQA_CTRL,
        #[doc = "0x0c - A/D Conversion Sequence-B Control Register: Controls triggering and channel selection for conversion sequence-B. Also specifies interrupt mode for sequence-B."]
        pub seqb_ctrl: SEQB_CTRL,
        #[doc = "0x10 - A/D Sequence-A Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-A"]
        pub seqa_gdat: SEQA_GDAT,
        #[doc = "0x14 - A/D Sequence-B Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-B"]
        pub seqb_gdat: SEQB_GDAT,
        _reserved1: [u8; 8usize],
        #[doc = "0x20 - A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0."]
        pub dat: [DAT; 12],
        #[doc = "0x50 - A/D Low Compare Threshold Register 0 : Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0."]
        pub thr0_low: THR0_LOW,
        #[doc = "0x54 - A/D Low Compare Threshold Register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1."]
        pub thr1_low: THR1_LOW,
        #[doc = "0x58 - A/D High Compare Threshold Register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0."]
        pub thr0_high: THR0_HIGH,
        #[doc = "0x5c - A/D High Compare Threshold Register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1."]
        pub thr1_high: THR1_HIGH,
        #[doc = "0x60 - A/D Channel-Threshold Select Register. Specifies which set of threshold compare registers are to be used for each channel"]
        pub chan_thrsel: CHAN_THRSEL,
        #[doc = "0x64 - A/D Interrupt Enable Register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated."]
        pub inten: INTEN,
        #[doc = "0x68 - A/D Flags Register. Contains the four interrupt request flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers)."]
        pub flags: FLAGS,
        #[doc = "0x6c - ADC trim register."]
        pub trm: TRM,
    }
    #[doc = "A/D Control Register. Contains the clock divide value, enable bits for each sequence and the A/D power-down bit."]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Control Register. Contains the clock divide value, enable bits for each sequence and the A/D power-down bit."]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKDIVR {
            bits: u8,
        }
        impl CLKDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `LPWRMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPWRMODER {
            #[doc = "Disabled. The low-power ADC mode is disabled.  The analog circuitry remains activated even when no conversions are requested."]
            DISABLED,
            #[doc = "Enabled. The low-power ADC mode is enabled."]
            ENABLED,
        }
        impl LPWRMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LPWRMODER::DISABLED => false,
                    LPWRMODER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LPWRMODER {
                match value {
                    false => LPWRMODER::DISABLED,
                    true => LPWRMODER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LPWRMODER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == LPWRMODER::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAL_MODER {
            bits: bool,
        }
        impl CAL_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKDIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPWRMODE`"]
        pub enum LPWRMODEW {
            #[doc = "Disabled. The low-power ADC mode is disabled.  The analog circuitry remains activated even when no conversions are requested."]
            DISABLED,
            #[doc = "Enabled. The low-power ADC mode is enabled."]
            ENABLED,
        }
        impl LPWRMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LPWRMODEW::DISABLED => false,
                    LPWRMODEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPWRMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPWRMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LPWRMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The low-power ADC mode is disabled. The analog circuitry remains activated even when no conversions are requested."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPWRMODEW::DISABLED)
            }
            #[doc = "Enabled. The low-power ADC mode is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPWRMODEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAL_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAL_MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - The system clock is divided by this value plus one to produce the sampling clock. The sampling clock should be less than or equal to 30 MHz for 1.2 Msamples/s. Typically, software should program the smallest value in this field that yields this maximum clock rate or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable."]
            #[inline]
            pub fn clkdiv(&self) -> CLKDIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKDIVR { bits }
            }
            #[doc = "Bit 10 - Select low-power ADC mode. The analog circuitry is automatically powered-down when no conversions are taking place. When any (hardware or software) triggering event is detected, the analog circuitry is enabled. After the required start-up time, the requested conversion will be launched. Once the conversion completes, the analog-circuitry will again be powered-down provided no further conversions are pending. Using this mode can save an appreciable amount of current (approximately 2.5 mA) when conversions are required relatively infrequently. The penalty for using this mode is an approximately 15 ADC clock delay, based on the frequency specified in the CLKDIV field, from the time the trigger event occurs until sampling of the A/D input commences. This mode will NOT power-up the ADC when the ADC analog block is powered down in the system control block."]
            #[inline]
            pub fn lpwrmode(&self) -> LPWRMODER {
                LPWRMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Writing a 1 to this bit initiates a self-calibration cycle. This bit will be automatically cleared by hardware after the calibration cycle is complete. Other bits of this register may be written to concurrently with setting this bit, however once this bit has been set no further writes to this register are permitted until the full calibration cycle has ended."]
            #[inline]
            pub fn cal_mode(&self) -> CAL_MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAL_MODER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - The system clock is divided by this value plus one to produce the sampling clock. The sampling clock should be less than or equal to 30 MHz for 1.2 Msamples/s. Typically, software should program the smallest value in this field that yields this maximum clock rate or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable."]
            #[inline]
            pub fn clkdiv(&mut self) -> _CLKDIVW {
                _CLKDIVW { w: self }
            }
            #[doc = "Bit 10 - Select low-power ADC mode. The analog circuitry is automatically powered-down when no conversions are taking place. When any (hardware or software) triggering event is detected, the analog circuitry is enabled. After the required start-up time, the requested conversion will be launched. Once the conversion completes, the analog-circuitry will again be powered-down provided no further conversions are pending. Using this mode can save an appreciable amount of current (approximately 2.5 mA) when conversions are required relatively infrequently. The penalty for using this mode is an approximately 15 ADC clock delay, based on the frequency specified in the CLKDIV field, from the time the trigger event occurs until sampling of the A/D input commences. This mode will NOT power-up the ADC when the ADC analog block is powered down in the system control block."]
            #[inline]
            pub fn lpwrmode(&mut self) -> _LPWRMODEW {
                _LPWRMODEW { w: self }
            }
            #[doc = "Bit 30 - Writing a 1 to this bit initiates a self-calibration cycle. This bit will be automatically cleared by hardware after the calibration cycle is complete. Other bits of this register may be written to concurrently with setting this bit, however once this bit has been set no further writes to this register are permitted until the full calibration cycle has ended."]
            #[inline]
            pub fn cal_mode(&mut self) -> _CAL_MODEW {
                _CAL_MODEW { w: self }
            }
        }
    }
    #[doc = "A/D Conversion Sequence-A control Register: Controls triggering and channel selection for conversion sequence-A. Also specifies interrupt mode for sequence-A."]
    pub struct SEQA_CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Conversion Sequence-A control Register: Controls triggering and channel selection for conversion sequence-A. Also specifies interrupt mode for sequence-A."]
    pub mod seqa_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SEQA_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANNELSR {
            bits: u16,
        }
        impl CHANNELSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRIGGERR {
            bits: u8,
        }
        impl TRIGGERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TRIGPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGPOLR {
            #[doc = "Negative edge. A negative edge launches the conversion sequence on the selected trigger input."]
            NEGATIVE_EDGE,
            #[doc = "Positive edge. A positive edge launches the conversion sequence on the selected trigger input."]
            POSITIVE_EDGE,
        }
        impl TRIGPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TRIGPOLR::NEGATIVE_EDGE => false,
                    TRIGPOLR::POSITIVE_EDGE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TRIGPOLR {
                match value {
                    false => TRIGPOLR::NEGATIVE_EDGE,
                    true => TRIGPOLR::POSITIVE_EDGE,
                }
            }
            #[doc = "Checks if the value of the field is `NEGATIVE_EDGE`"]
            #[inline]
            pub fn is_negative_edge(&self) -> bool {
                *self == TRIGPOLR::NEGATIVE_EDGE
            }
            #[doc = "Checks if the value of the field is `POSITIVE_EDGE`"]
            #[inline]
            pub fn is_positive_edge(&self) -> bool {
                *self == TRIGPOLR::POSITIVE_EDGE
            }
        }
        #[doc = "Possible values of the field `SYNCBYPASS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYNCBYPASSR {
            #[doc = "Enable synchronization. The hardware trigger bypass is not enabled."]
            ENABLE_SYNCHRONIZATI,
            #[doc = "Bypass synchronization. The hardware trigger bypass is enabled."]
            BYPASS_SYNCHRONIZATI,
        }
        impl SYNCBYPASSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYNCBYPASSR::ENABLE_SYNCHRONIZATI => false,
                    SYNCBYPASSR::BYPASS_SYNCHRONIZATI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYNCBYPASSR {
                match value {
                    false => SYNCBYPASSR::ENABLE_SYNCHRONIZATI,
                    true => SYNCBYPASSR::BYPASS_SYNCHRONIZATI,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_SYNCHRONIZATI`"]
            #[inline]
            pub fn is_enable_synchronizati(&self) -> bool {
                *self == SYNCBYPASSR::ENABLE_SYNCHRONIZATI
            }
            #[doc = "Checks if the value of the field is `BYPASS_SYNCHRONIZATI`"]
            #[inline]
            pub fn is_bypass_synchronizati(&self) -> bool {
                *self == SYNCBYPASSR::BYPASS_SYNCHRONIZATI
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BURSTR {
            bits: bool,
        }
        impl BURSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SINGLESTEPR {
            bits: bool,
        }
        impl SINGLESTEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `LOWPRIO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOWPRIOR {
            #[doc = "Low priority. Any B trigger which occurs while an A conversion sequence is active will be ignored and lost."]
            LOW_PRIORITY,
            #[doc = "High priority.  Setting this bit to a 1 will permit any enabled B sequence trigger (including a B sequence software start) to immediately interrupt this sequence and launch a B sequence in it's place. The conversion currently in progress will be terminated.  The A sequence that was interrupted will automatically resume after the B sequence completes. The channel whose conversion was terminated will be re-sampled and the conversion sequence will resume from that point."]
            HIGH_PRIORITY,
        }
        impl LOWPRIOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOWPRIOR::LOW_PRIORITY => false,
                    LOWPRIOR::HIGH_PRIORITY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOWPRIOR {
                match value {
                    false => LOWPRIOR::LOW_PRIORITY,
                    true => LOWPRIOR::HIGH_PRIORITY,
                }
            }
            #[doc = "Checks if the value of the field is `LOW_PRIORITY`"]
            #[inline]
            pub fn is_low_priority(&self) -> bool {
                *self == LOWPRIOR::LOW_PRIORITY
            }
            #[doc = "Checks if the value of the field is `HIGH_PRIORITY`"]
            #[inline]
            pub fn is_high_priority(&self) -> bool {
                *self == LOWPRIOR::HIGH_PRIORITY
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "End of conversion. The sequence A interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence A. This flag will mirror the DATAVALID bit in the SEQA_GDAT register. The OVERRUN bit in the SEQA_GDAT register will contribute to generation of an overrun interrupt if enabled."]
            END_OF_CONVERSION,
            #[doc = "End of sequence. The sequence A interrupt/DMA flag will be set when the entire set of sequence-A conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode.  The OVERRUN bit in the SEQA_GDAT register will NOT contribute to generation of an overrun interrupt/DMA trigger since it is assumed this register may not be utilized in this mode."]
            END_OF_SEQUENCE,
        }
        impl MODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MODER::END_OF_CONVERSION => false,
                    MODER::END_OF_SEQUENCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MODER {
                match value {
                    false => MODER::END_OF_CONVERSION,
                    true => MODER::END_OF_SEQUENCE,
                }
            }
            #[doc = "Checks if the value of the field is `END_OF_CONVERSION`"]
            #[inline]
            pub fn is_end_of_conversion(&self) -> bool {
                *self == MODER::END_OF_CONVERSION
            }
            #[doc = "Checks if the value of the field is `END_OF_SEQUENCE`"]
            #[inline]
            pub fn is_end_of_sequence(&self) -> bool {
                *self == MODER::END_OF_SEQUENCE
            }
        }
        #[doc = "Possible values of the field `SEQA_ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEQA_ENAR {
            #[doc = "Disabled. Sequence A is disabled. Sequence A triggers are ignored. If this bit is cleared while sequence A is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel."]
            DISABLED,
            #[doc = "Enabled. Sequence A is enabled."]
            ENABLED,
        }
        impl SEQA_ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SEQA_ENAR::DISABLED => false,
                    SEQA_ENAR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SEQA_ENAR {
                match value {
                    false => SEQA_ENAR::DISABLED,
                    true => SEQA_ENAR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SEQA_ENAR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SEQA_ENAR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHANNELSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHANNELSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGGERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGGERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TRIGPOL`"]
        pub enum TRIGPOLW {
            #[doc = "Negative edge. A negative edge launches the conversion sequence on the selected trigger input."]
            NEGATIVE_EDGE,
            #[doc = "Positive edge. A positive edge launches the conversion sequence on the selected trigger input."]
            POSITIVE_EDGE,
        }
        impl TRIGPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TRIGPOLW::NEGATIVE_EDGE => false,
                    TRIGPOLW::POSITIVE_EDGE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TRIGPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Negative edge. A negative edge launches the conversion sequence on the selected trigger input."]
            #[inline]
            pub fn negative_edge(self) -> &'a mut W {
                self.variant(TRIGPOLW::NEGATIVE_EDGE)
            }
            #[doc = "Positive edge. A positive edge launches the conversion sequence on the selected trigger input."]
            #[inline]
            pub fn positive_edge(self) -> &'a mut W {
                self.variant(TRIGPOLW::POSITIVE_EDGE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYNCBYPASS`"]
        pub enum SYNCBYPASSW {
            #[doc = "Enable synchronization. The hardware trigger bypass is not enabled."]
            ENABLE_SYNCHRONIZATI,
            #[doc = "Bypass synchronization. The hardware trigger bypass is enabled."]
            BYPASS_SYNCHRONIZATI,
        }
        impl SYNCBYPASSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYNCBYPASSW::ENABLE_SYNCHRONIZATI => false,
                    SYNCBYPASSW::BYPASS_SYNCHRONIZATI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCBYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCBYPASSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYNCBYPASSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable synchronization. The hardware trigger bypass is not enabled."]
            #[inline]
            pub fn enable_synchronizati(self) -> &'a mut W {
                self.variant(SYNCBYPASSW::ENABLE_SYNCHRONIZATI)
            }
            #[doc = "Bypass synchronization. The hardware trigger bypass is enabled."]
            #[inline]
            pub fn bypass_synchronizati(self) -> &'a mut W {
                self.variant(SYNCBYPASSW::BYPASS_SYNCHRONIZATI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BURSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BURSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SINGLESTEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SINGLESTEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOWPRIO`"]
        pub enum LOWPRIOW {
            #[doc = "Low priority. Any B trigger which occurs while an A conversion sequence is active will be ignored and lost."]
            LOW_PRIORITY,
            #[doc = "High priority.  Setting this bit to a 1 will permit any enabled B sequence trigger (including a B sequence software start) to immediately interrupt this sequence and launch a B sequence in it's place. The conversion currently in progress will be terminated.  The A sequence that was interrupted will automatically resume after the B sequence completes. The channel whose conversion was terminated will be re-sampled and the conversion sequence will resume from that point."]
            HIGH_PRIORITY,
        }
        impl LOWPRIOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOWPRIOW::LOW_PRIORITY => false,
                    LOWPRIOW::HIGH_PRIORITY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOWPRIOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOWPRIOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LOWPRIOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low priority. Any B trigger which occurs while an A conversion sequence is active will be ignored and lost."]
            #[inline]
            pub fn low_priority(self) -> &'a mut W {
                self.variant(LOWPRIOW::LOW_PRIORITY)
            }
            #[doc = "High priority. Setting this bit to a 1 will permit any enabled B sequence trigger (including a B sequence software start) to immediately interrupt this sequence and launch a B sequence in it's place. The conversion currently in progress will be terminated. The A sequence that was interrupted will automatically resume after the B sequence completes. The channel whose conversion was terminated will be re-sampled and the conversion sequence will resume from that point."]
            #[inline]
            pub fn high_priority(self) -> &'a mut W {
                self.variant(LOWPRIOW::HIGH_PRIORITY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "End of conversion. The sequence A interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence A. This flag will mirror the DATAVALID bit in the SEQA_GDAT register. The OVERRUN bit in the SEQA_GDAT register will contribute to generation of an overrun interrupt if enabled."]
            END_OF_CONVERSION,
            #[doc = "End of sequence. The sequence A interrupt/DMA flag will be set when the entire set of sequence-A conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode.  The OVERRUN bit in the SEQA_GDAT register will NOT contribute to generation of an overrun interrupt/DMA trigger since it is assumed this register may not be utilized in this mode."]
            END_OF_SEQUENCE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MODEW::END_OF_CONVERSION => false,
                    MODEW::END_OF_SEQUENCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "End of conversion. The sequence A interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence A. This flag will mirror the DATAVALID bit in the SEQA_GDAT register. The OVERRUN bit in the SEQA_GDAT register will contribute to generation of an overrun interrupt if enabled."]
            #[inline]
            pub fn end_of_conversion(self) -> &'a mut W {
                self.variant(MODEW::END_OF_CONVERSION)
            }
            #[doc = "End of sequence. The sequence A interrupt/DMA flag will be set when the entire set of sequence-A conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode. The OVERRUN bit in the SEQA_GDAT register will NOT contribute to generation of an overrun interrupt/DMA trigger since it is assumed this register may not be utilized in this mode."]
            #[inline]
            pub fn end_of_sequence(self) -> &'a mut W {
                self.variant(MODEW::END_OF_SEQUENCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SEQA_ENA`"]
        pub enum SEQA_ENAW {
            #[doc = "Disabled. Sequence A is disabled. Sequence A triggers are ignored. If this bit is cleared while sequence A is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel."]
            DISABLED,
            #[doc = "Enabled. Sequence A is enabled."]
            ENABLED,
        }
        impl SEQA_ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SEQA_ENAW::DISABLED => false,
                    SEQA_ENAW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQA_ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQA_ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SEQA_ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Sequence A is disabled. Sequence A triggers are ignored. If this bit is cleared while sequence A is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SEQA_ENAW::DISABLED)
            }
            #[doc = "Enabled. Sequence A is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SEQA_ENAW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Selects which one or more of the twelve channels will be sampled and converted when this sequence is launched. A 1 in any bit of this field will cause the corresponding channel to be included in the conversion sequence, where bit 0 corresponds to channel 0, bit 1 to channel 1 and so forth. When this conversion sequence is triggered, either by a hardware trigger or via software command, A/D conversions will be performed on each enabled channel, in sequence, beginning with the lowest-ordered channel. This field can ONLY be changed while the SEQA_ENA bit (bit 31) is LOW. It is allowed to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn channels(&self) -> CHANNELSR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CHANNELSR { bits }
            }
            #[doc = "Bits 12:14 - Selects which of the available hardware trigger sources will cause this conversion sequence to be initiated. Program the trigger input number in this field. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigger(&self) -> TRIGGERR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRIGGERR { bits }
            }
            #[doc = "Bit 18 - Select the polarity of the selected input trigger for this conversion sequence. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigpol(&self) -> TRIGPOLR {
                TRIGPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Setting this bit allows the hardware trigger input to bypass synchronization flip-flops stages and therefore shorten the time between the trigger input signal and the start of a conversion. There are slightly different criteria for whether or not this bit can be set depending on the clock operating mode: Synchronous mode: Synchronization may be bypassed (this bit may be set) if the selected trigger source is already synchronous with the main system clock (eg. coming from an on-chip, system-clock-based timer). Whether this bit is set or not, a trigger pulse must be maintained for at least one system clock period. Asynchronous mode: Synchronization may be bypassed (this bit may be set) if it is certain that the duration of a trigger input pulse will be at least one cycle of the ADC clock (regardless of whether the trigger comes from and on-chip or off-chip source). If this bit is NOT set, the trigger pulse must at least be maintained for one system clock period."]
            #[inline]
            pub fn syncbypass(&self) -> SYNCBYPASSR {
                SYNCBYPASSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Writing a 1 to this field will launch one pass through this conversion sequence. The behavior will be identical to a sequence triggered by a hardware trigger. Do not write 1 to this bit if the BURST bit is set. This bit is only set to a 1 momentarily when written to launch a conversion sequence. It will consequently always read-back as a zero."]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 27 - Writing a 1 to this bit will cause this conversion sequence to be continuously cycled through. Other sequence A triggers will be ignored while this bit is set. Repeated conversions can be halted by clearing this bit. The sequence currently in progress will be completed before conversions are terminated."]
            #[inline]
            pub fn burst(&self) -> BURSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BURSTR { bits }
            }
            #[doc = "Bit 28 - When this bit is set, a hardware trigger or a write to the START bit will launch a single conversion on the next channel in the sequence instead of the default response of launching an entire sequence of conversions. Once all of the channels comprising a sequence have been converted, a subsequent trigger will repeat the sequence beginning with the first enabled channel. Interrupt generation will still occur either after each individual conversion or at the end of the entire sequence, depending on the state of the MODE bit."]
            #[inline]
            pub fn singlestep(&self) -> SINGLESTEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SINGLESTEPR { bits }
            }
            #[doc = "Bit 29 - Set priority for sequence A."]
            #[inline]
            pub fn lowprio(&self) -> LOWPRIOR {
                LOWPRIOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Indicates whether the primary method for retrieving conversion results for this sequence will be accomplished via reading the global data register (SEQA_GDAT) at the end of each conversion, or the individual channel result registers at the end of the entire sequence. Impacts when conversion-complete interrupt/DMA triggers for sequence-A will be generated and which overrun conditions contribute to an overrun interrupt as described below:"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Sequence Enable. In order to avoid spuriously triggering the sequence, care should be taken to only set the SEQA_ENA bit when the selected trigger input is in its INACTIVE state (as defined by the TRIGPOL bit). If this condition is not met, the sequence will be triggered immediately upon being enabled."]
            #[inline]
            pub fn seqa_ena(&self) -> SEQA_ENAR {
                SEQA_ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Selects which one or more of the twelve channels will be sampled and converted when this sequence is launched. A 1 in any bit of this field will cause the corresponding channel to be included in the conversion sequence, where bit 0 corresponds to channel 0, bit 1 to channel 1 and so forth. When this conversion sequence is triggered, either by a hardware trigger or via software command, A/D conversions will be performed on each enabled channel, in sequence, beginning with the lowest-ordered channel. This field can ONLY be changed while the SEQA_ENA bit (bit 31) is LOW. It is allowed to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn channels(&mut self) -> _CHANNELSW {
                _CHANNELSW { w: self }
            }
            #[doc = "Bits 12:14 - Selects which of the available hardware trigger sources will cause this conversion sequence to be initiated. Program the trigger input number in this field. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigger(&mut self) -> _TRIGGERW {
                _TRIGGERW { w: self }
            }
            #[doc = "Bit 18 - Select the polarity of the selected input trigger for this conversion sequence. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigpol(&mut self) -> _TRIGPOLW {
                _TRIGPOLW { w: self }
            }
            #[doc = "Bit 19 - Setting this bit allows the hardware trigger input to bypass synchronization flip-flops stages and therefore shorten the time between the trigger input signal and the start of a conversion. There are slightly different criteria for whether or not this bit can be set depending on the clock operating mode: Synchronous mode: Synchronization may be bypassed (this bit may be set) if the selected trigger source is already synchronous with the main system clock (eg. coming from an on-chip, system-clock-based timer). Whether this bit is set or not, a trigger pulse must be maintained for at least one system clock period. Asynchronous mode: Synchronization may be bypassed (this bit may be set) if it is certain that the duration of a trigger input pulse will be at least one cycle of the ADC clock (regardless of whether the trigger comes from and on-chip or off-chip source). If this bit is NOT set, the trigger pulse must at least be maintained for one system clock period."]
            #[inline]
            pub fn syncbypass(&mut self) -> _SYNCBYPASSW {
                _SYNCBYPASSW { w: self }
            }
            #[doc = "Bit 26 - Writing a 1 to this field will launch one pass through this conversion sequence. The behavior will be identical to a sequence triggered by a hardware trigger. Do not write 1 to this bit if the BURST bit is set. This bit is only set to a 1 momentarily when written to launch a conversion sequence. It will consequently always read-back as a zero."]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 27 - Writing a 1 to this bit will cause this conversion sequence to be continuously cycled through. Other sequence A triggers will be ignored while this bit is set. Repeated conversions can be halted by clearing this bit. The sequence currently in progress will be completed before conversions are terminated."]
            #[inline]
            pub fn burst(&mut self) -> _BURSTW {
                _BURSTW { w: self }
            }
            #[doc = "Bit 28 - When this bit is set, a hardware trigger or a write to the START bit will launch a single conversion on the next channel in the sequence instead of the default response of launching an entire sequence of conversions. Once all of the channels comprising a sequence have been converted, a subsequent trigger will repeat the sequence beginning with the first enabled channel. Interrupt generation will still occur either after each individual conversion or at the end of the entire sequence, depending on the state of the MODE bit."]
            #[inline]
            pub fn singlestep(&mut self) -> _SINGLESTEPW {
                _SINGLESTEPW { w: self }
            }
            #[doc = "Bit 29 - Set priority for sequence A."]
            #[inline]
            pub fn lowprio(&mut self) -> _LOWPRIOW {
                _LOWPRIOW { w: self }
            }
            #[doc = "Bit 30 - Indicates whether the primary method for retrieving conversion results for this sequence will be accomplished via reading the global data register (SEQA_GDAT) at the end of each conversion, or the individual channel result registers at the end of the entire sequence. Impacts when conversion-complete interrupt/DMA triggers for sequence-A will be generated and which overrun conditions contribute to an overrun interrupt as described below:"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 31 - Sequence Enable. In order to avoid spuriously triggering the sequence, care should be taken to only set the SEQA_ENA bit when the selected trigger input is in its INACTIVE state (as defined by the TRIGPOL bit). If this condition is not met, the sequence will be triggered immediately upon being enabled."]
            #[inline]
            pub fn seqa_ena(&mut self) -> _SEQA_ENAW {
                _SEQA_ENAW { w: self }
            }
        }
    }
    #[doc = "A/D Conversion Sequence-B Control Register: Controls triggering and channel selection for conversion sequence-B. Also specifies interrupt mode for sequence-B."]
    pub struct SEQB_CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Conversion Sequence-B Control Register: Controls triggering and channel selection for conversion sequence-B. Also specifies interrupt mode for sequence-B."]
    pub mod seqb_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SEQB_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANNELSR {
            bits: u16,
        }
        impl CHANNELSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRIGGERR {
            bits: u8,
        }
        impl TRIGGERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TRIGPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGPOLR {
            #[doc = "Negative edge. A negative edge launches the conversion sequence on the selected trigger input."]
            NEGATIVE_EDGE,
            #[doc = "Positive edge. A positive edge launches the conversion sequence on the selected trigger input."]
            POSITIVE_EDGE,
        }
        impl TRIGPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TRIGPOLR::NEGATIVE_EDGE => false,
                    TRIGPOLR::POSITIVE_EDGE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TRIGPOLR {
                match value {
                    false => TRIGPOLR::NEGATIVE_EDGE,
                    true => TRIGPOLR::POSITIVE_EDGE,
                }
            }
            #[doc = "Checks if the value of the field is `NEGATIVE_EDGE`"]
            #[inline]
            pub fn is_negative_edge(&self) -> bool {
                *self == TRIGPOLR::NEGATIVE_EDGE
            }
            #[doc = "Checks if the value of the field is `POSITIVE_EDGE`"]
            #[inline]
            pub fn is_positive_edge(&self) -> bool {
                *self == TRIGPOLR::POSITIVE_EDGE
            }
        }
        #[doc = "Possible values of the field `SYNCBYPASS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYNCBYPASSR {
            #[doc = "Enable synchronization. The hardware trigger bypass is not enabled."]
            ENABLE_SYNCHRONIZATI,
            #[doc = "Bypass synchronization. The hardware trigger bypass is enabled."]
            BYPASS_SYNCHRONIZATI,
        }
        impl SYNCBYPASSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYNCBYPASSR::ENABLE_SYNCHRONIZATI => false,
                    SYNCBYPASSR::BYPASS_SYNCHRONIZATI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYNCBYPASSR {
                match value {
                    false => SYNCBYPASSR::ENABLE_SYNCHRONIZATI,
                    true => SYNCBYPASSR::BYPASS_SYNCHRONIZATI,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_SYNCHRONIZATI`"]
            #[inline]
            pub fn is_enable_synchronizati(&self) -> bool {
                *self == SYNCBYPASSR::ENABLE_SYNCHRONIZATI
            }
            #[doc = "Checks if the value of the field is `BYPASS_SYNCHRONIZATI`"]
            #[inline]
            pub fn is_bypass_synchronizati(&self) -> bool {
                *self == SYNCBYPASSR::BYPASS_SYNCHRONIZATI
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BURSTR {
            bits: bool,
        }
        impl BURSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SINGLESTEPR {
            bits: bool,
        }
        impl SINGLESTEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "End of conversion. The sequence B interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence B. This flag will mirror the DATAVALID bit in the SEQB_GDAT register.  The OVERRUN bit in the SEQB_GDAT register will contribute to generation of an overrun interrupt if enabled."]
            END_OF_CONVERSION,
            #[doc = "End of sequence. The sequence B interrupt/DMA flag will be set when the entire set of sequence B conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode.   The OVERRUN bit in the SEQB_GDAT register will NOT contribute to generation of an overrun interrupt since it is assumed this register will not be utilized in this mode."]
            END_OF_SEQUENCE,
        }
        impl MODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MODER::END_OF_CONVERSION => false,
                    MODER::END_OF_SEQUENCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MODER {
                match value {
                    false => MODER::END_OF_CONVERSION,
                    true => MODER::END_OF_SEQUENCE,
                }
            }
            #[doc = "Checks if the value of the field is `END_OF_CONVERSION`"]
            #[inline]
            pub fn is_end_of_conversion(&self) -> bool {
                *self == MODER::END_OF_CONVERSION
            }
            #[doc = "Checks if the value of the field is `END_OF_SEQUENCE`"]
            #[inline]
            pub fn is_end_of_sequence(&self) -> bool {
                *self == MODER::END_OF_SEQUENCE
            }
        }
        #[doc = "Possible values of the field `SEQB_ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEQB_ENAR {
            #[doc = "Disabled. Sequence B is disabled. Sequence B triggers are ignored. If this bit is cleared while sequence B is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel."]
            DISABLED,
            #[doc = "Enabled. Sequence B is enabled."]
            ENABLED,
        }
        impl SEQB_ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SEQB_ENAR::DISABLED => false,
                    SEQB_ENAR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SEQB_ENAR {
                match value {
                    false => SEQB_ENAR::DISABLED,
                    true => SEQB_ENAR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SEQB_ENAR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SEQB_ENAR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHANNELSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHANNELSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGGERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGGERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TRIGPOL`"]
        pub enum TRIGPOLW {
            #[doc = "Negative edge. A negative edge launches the conversion sequence on the selected trigger input."]
            NEGATIVE_EDGE,
            #[doc = "Positive edge. A positive edge launches the conversion sequence on the selected trigger input."]
            POSITIVE_EDGE,
        }
        impl TRIGPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TRIGPOLW::NEGATIVE_EDGE => false,
                    TRIGPOLW::POSITIVE_EDGE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TRIGPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Negative edge. A negative edge launches the conversion sequence on the selected trigger input."]
            #[inline]
            pub fn negative_edge(self) -> &'a mut W {
                self.variant(TRIGPOLW::NEGATIVE_EDGE)
            }
            #[doc = "Positive edge. A positive edge launches the conversion sequence on the selected trigger input."]
            #[inline]
            pub fn positive_edge(self) -> &'a mut W {
                self.variant(TRIGPOLW::POSITIVE_EDGE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYNCBYPASS`"]
        pub enum SYNCBYPASSW {
            #[doc = "Enable synchronization. The hardware trigger bypass is not enabled."]
            ENABLE_SYNCHRONIZATI,
            #[doc = "Bypass synchronization. The hardware trigger bypass is enabled."]
            BYPASS_SYNCHRONIZATI,
        }
        impl SYNCBYPASSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYNCBYPASSW::ENABLE_SYNCHRONIZATI => false,
                    SYNCBYPASSW::BYPASS_SYNCHRONIZATI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCBYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCBYPASSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYNCBYPASSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable synchronization. The hardware trigger bypass is not enabled."]
            #[inline]
            pub fn enable_synchronizati(self) -> &'a mut W {
                self.variant(SYNCBYPASSW::ENABLE_SYNCHRONIZATI)
            }
            #[doc = "Bypass synchronization. The hardware trigger bypass is enabled."]
            #[inline]
            pub fn bypass_synchronizati(self) -> &'a mut W {
                self.variant(SYNCBYPASSW::BYPASS_SYNCHRONIZATI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BURSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BURSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SINGLESTEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SINGLESTEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "End of conversion. The sequence B interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence B. This flag will mirror the DATAVALID bit in the SEQB_GDAT register.  The OVERRUN bit in the SEQB_GDAT register will contribute to generation of an overrun interrupt if enabled."]
            END_OF_CONVERSION,
            #[doc = "End of sequence. The sequence B interrupt/DMA flag will be set when the entire set of sequence B conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode.   The OVERRUN bit in the SEQB_GDAT register will NOT contribute to generation of an overrun interrupt since it is assumed this register will not be utilized in this mode."]
            END_OF_SEQUENCE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MODEW::END_OF_CONVERSION => false,
                    MODEW::END_OF_SEQUENCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "End of conversion. The sequence B interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence B. This flag will mirror the DATAVALID bit in the SEQB_GDAT register. The OVERRUN bit in the SEQB_GDAT register will contribute to generation of an overrun interrupt if enabled."]
            #[inline]
            pub fn end_of_conversion(self) -> &'a mut W {
                self.variant(MODEW::END_OF_CONVERSION)
            }
            #[doc = "End of sequence. The sequence B interrupt/DMA flag will be set when the entire set of sequence B conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode. The OVERRUN bit in the SEQB_GDAT register will NOT contribute to generation of an overrun interrupt since it is assumed this register will not be utilized in this mode."]
            #[inline]
            pub fn end_of_sequence(self) -> &'a mut W {
                self.variant(MODEW::END_OF_SEQUENCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SEQB_ENA`"]
        pub enum SEQB_ENAW {
            #[doc = "Disabled. Sequence B is disabled. Sequence B triggers are ignored. If this bit is cleared while sequence B is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel."]
            DISABLED,
            #[doc = "Enabled. Sequence B is enabled."]
            ENABLED,
        }
        impl SEQB_ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SEQB_ENAW::DISABLED => false,
                    SEQB_ENAW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQB_ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQB_ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SEQB_ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Sequence B is disabled. Sequence B triggers are ignored. If this bit is cleared while sequence B is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SEQB_ENAW::DISABLED)
            }
            #[doc = "Enabled. Sequence B is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SEQB_ENAW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Selects which one or more of the twelve channels will be sampled and converted when this sequence is launched. A 1 in any bit of this field will cause the corresponding channel to be included in the conversion sequence, where bit 0 corresponds to channel 0, bit 1 to channel 1 and so forth. When this conversion sequence is triggered, either by a hardware trigger or via software command, A/D conversions will be performed on each enabled channel, in sequence, beginning with the lowest-ordered channel. This field can ONLY be changed while the SEQB_ENA bit (bit 31) is LOW. It is permissible to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn channels(&self) -> CHANNELSR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CHANNELSR { bits }
            }
            #[doc = "Bits 12:14 - Selects which of the available hardware trigger sources will cause this conversion sequence to be initiated. Program the trigger input number in this field. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigger(&self) -> TRIGGERR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRIGGERR { bits }
            }
            #[doc = "Bit 18 - Select the polarity of the selected input trigger for this conversion sequence. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigpol(&self) -> TRIGPOLR {
                TRIGPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Setting this bit allows the hardware trigger input to bypass synchronization flip-flops stages and therefore shorten the time between the trigger input signal and the start of a conversion. There are slightly different criteria for whether or not this bit can be set depending on the clock operating mode: Synchronous mode: Synchronization may be bypassed (this bit may be set) if the selected trigger source is already synchronous with the main system clock (eg. coming from an on-chip, system-clock-based timer). Whether this bit is set or not, a trigger pulse must be maintained for at least one system clock period. Asynchronous mode: Synchronization may be bypassed (this bit may be set) if it is certain that the duration of a trigger input pulse will be at least one cycle of the ADC clock (regardless of whether the trigger comes from and on-chip or off-chip source). If this bit is NOT set, the trigger pulse must at least be maintained for one system clock period."]
            #[inline]
            pub fn syncbypass(&self) -> SYNCBYPASSR {
                SYNCBYPASSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Writing a 1 to this field will launch one pass through this conversion sequence. The behavior will be identical to a sequence triggered by a hardware trigger. Do not write a 1 to this bit if the BURST bit is set. This bit is only set to a 1 momentarily when written-to to launch a conversion sequence. It will consequently always read-back as a zero."]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 27 - Writing a 1 to this bit will cause this conversion sequence to be continuously cycled through. Other B triggers will be ignored while this bit is set. Repeated conversions can be halted by clearing this bit. The sequence currently in progress will be completed before conversions are terminated."]
            #[inline]
            pub fn burst(&self) -> BURSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BURSTR { bits }
            }
            #[doc = "Bit 28 - When this bit is set, a hardware trigger or a write to the START bit will launch a single conversion on the next channel in the sequence instead of the default response of launching an entire sequence of conversions. Once all of the channels comprising a sequence have been converted, a subsequent trigger will repeat the sequence beginning with the first enabled channel. Interrupt generation will still occur either after each individual conversion or at the end of the entire sequence, depending on the state of the MODE bit."]
            #[inline]
            pub fn singlestep(&self) -> SINGLESTEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SINGLESTEPR { bits }
            }
            #[doc = "Bit 30 - Indicates whether the primary method for retrieving conversion results for this sequence will be accomplished via reading the global data register (SEQB_GDAT) at the end of each conversion, or the individual channel result registers at the end of the entire sequence. Impacts when conversion-complete interrupt/DMA trigger for sequence-B will be generated and which overrun conditions contribute to an overrun interrupt as described below:"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Sequence Enable. In order to avoid spuriously triggering the sequence, care should be taken to only set the SEQA_ENA bit when the selected trigger input is in its INACTIVE state (as defined by the TRIGPOL bit). If this condition is not met, the sequence will be triggered immediately upon being enabled."]
            #[inline]
            pub fn seqb_ena(&self) -> SEQB_ENAR {
                SEQB_ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Selects which one or more of the twelve channels will be sampled and converted when this sequence is launched. A 1 in any bit of this field will cause the corresponding channel to be included in the conversion sequence, where bit 0 corresponds to channel 0, bit 1 to channel 1 and so forth. When this conversion sequence is triggered, either by a hardware trigger or via software command, A/D conversions will be performed on each enabled channel, in sequence, beginning with the lowest-ordered channel. This field can ONLY be changed while the SEQB_ENA bit (bit 31) is LOW. It is permissible to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn channels(&mut self) -> _CHANNELSW {
                _CHANNELSW { w: self }
            }
            #[doc = "Bits 12:14 - Selects which of the available hardware trigger sources will cause this conversion sequence to be initiated. Program the trigger input number in this field. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigger(&mut self) -> _TRIGGERW {
                _TRIGGERW { w: self }
            }
            #[doc = "Bit 18 - Select the polarity of the selected input trigger for this conversion sequence. In order to avoid generating a spurious trigger, it is recommended writing to this field only when the SEQA_ENA bit (bit 31) is low. It is safe to change this field and set bit 31 in the same write."]
            #[inline]
            pub fn trigpol(&mut self) -> _TRIGPOLW {
                _TRIGPOLW { w: self }
            }
            #[doc = "Bit 19 - Setting this bit allows the hardware trigger input to bypass synchronization flip-flops stages and therefore shorten the time between the trigger input signal and the start of a conversion. There are slightly different criteria for whether or not this bit can be set depending on the clock operating mode: Synchronous mode: Synchronization may be bypassed (this bit may be set) if the selected trigger source is already synchronous with the main system clock (eg. coming from an on-chip, system-clock-based timer). Whether this bit is set or not, a trigger pulse must be maintained for at least one system clock period. Asynchronous mode: Synchronization may be bypassed (this bit may be set) if it is certain that the duration of a trigger input pulse will be at least one cycle of the ADC clock (regardless of whether the trigger comes from and on-chip or off-chip source). If this bit is NOT set, the trigger pulse must at least be maintained for one system clock period."]
            #[inline]
            pub fn syncbypass(&mut self) -> _SYNCBYPASSW {
                _SYNCBYPASSW { w: self }
            }
            #[doc = "Bit 26 - Writing a 1 to this field will launch one pass through this conversion sequence. The behavior will be identical to a sequence triggered by a hardware trigger. Do not write a 1 to this bit if the BURST bit is set. This bit is only set to a 1 momentarily when written-to to launch a conversion sequence. It will consequently always read-back as a zero."]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 27 - Writing a 1 to this bit will cause this conversion sequence to be continuously cycled through. Other B triggers will be ignored while this bit is set. Repeated conversions can be halted by clearing this bit. The sequence currently in progress will be completed before conversions are terminated."]
            #[inline]
            pub fn burst(&mut self) -> _BURSTW {
                _BURSTW { w: self }
            }
            #[doc = "Bit 28 - When this bit is set, a hardware trigger or a write to the START bit will launch a single conversion on the next channel in the sequence instead of the default response of launching an entire sequence of conversions. Once all of the channels comprising a sequence have been converted, a subsequent trigger will repeat the sequence beginning with the first enabled channel. Interrupt generation will still occur either after each individual conversion or at the end of the entire sequence, depending on the state of the MODE bit."]
            #[inline]
            pub fn singlestep(&mut self) -> _SINGLESTEPW {
                _SINGLESTEPW { w: self }
            }
            #[doc = "Bit 30 - Indicates whether the primary method for retrieving conversion results for this sequence will be accomplished via reading the global data register (SEQB_GDAT) at the end of each conversion, or the individual channel result registers at the end of the entire sequence. Impacts when conversion-complete interrupt/DMA trigger for sequence-B will be generated and which overrun conditions contribute to an overrun interrupt as described below:"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 31 - Sequence Enable. In order to avoid spuriously triggering the sequence, care should be taken to only set the SEQA_ENA bit when the selected trigger input is in its INACTIVE state (as defined by the TRIGPOL bit). If this condition is not met, the sequence will be triggered immediately upon being enabled."]
            #[inline]
            pub fn seqb_ena(&mut self) -> _SEQB_ENAW {
                _SEQB_ENAW { w: self }
            }
        }
    }
    #[doc = "A/D Sequence-A Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-A"]
    pub struct SEQA_GDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Sequence-A Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-A"]
    pub mod seqa_gdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SEQA_GDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESULTR {
            bits: u16,
        }
        impl RESULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMPRANGER {
            bits: u8,
        }
        impl THCMPRANGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMPCROSSR {
            bits: u8,
        }
        impl THCMPCROSSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHNR {
            bits: u8,
        }
        impl CHNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAVALIDR {
            bits: bool,
        }
        impl DATAVALIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESULTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESULTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMPRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMPRANGEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMPCROSSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMPCROSSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHNW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAVALIDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAVALIDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - This field contains the 12-bit A/D conversion result from the most recent conversion performed under conversion sequence associated with this register. The result is the a binary fraction representing the voltage on the currently-selected input channel as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP. DATAVALID = 1 indicates that this result has not yet been read."]
            #[inline]
            pub fn result(&self) -> RESULTR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RESULTR { bits }
            }
            #[doc = "Bits 16:17 - Indicates whether the result of the last conversion performed was above, below or within the range established by the designated threshold comparison registers (THRn_LOW and THRn_HIGH)."]
            #[inline]
            pub fn thcmprange(&self) -> THCMPRANGER {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                THCMPRANGER { bits }
            }
            #[doc = "Bits 18:19 - Indicates whether the result of the last conversion performed represented a crossing of the threshold level established by the designated LOW threshold comparison register (THRn_LOW) and, if so, in what direction the crossing occurred."]
            #[inline]
            pub fn thcmpcross(&self) -> THCMPCROSSR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                THCMPCROSSR { bits }
            }
            #[doc = "Bits 26:29 - These bits contain the channel from which the RESULT bits were converted (e.g. 0000 identifies channel 0, 0001 channel 1...)."]
            #[inline]
            pub fn chn(&self) -> CHNR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHNR { bits }
            }
            #[doc = "Bit 30 - This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read. This bit will contribute to an overrun interrupt request if the MODE bit (in SEQA_CTRL) for the corresponding sequence is set to '0' (and if the overrun interrupt is enabled)."]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 31 - This bit is set to '1' at the end of each conversion when a new result is loaded into the RESULT field. It is cleared whenever this register is read. This bit will cause a conversion-complete interrupt for the corresponding sequence if the MODE bit (in SEQA_CTRL) for that sequence is set to 0 (and if the interrupt is enabled)."]
            #[inline]
            pub fn datavalid(&self) -> DATAVALIDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATAVALIDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - This field contains the 12-bit A/D conversion result from the most recent conversion performed under conversion sequence associated with this register. The result is the a binary fraction representing the voltage on the currently-selected input channel as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP. DATAVALID = 1 indicates that this result has not yet been read."]
            #[inline]
            pub fn result(&mut self) -> _RESULTW {
                _RESULTW { w: self }
            }
            #[doc = "Bits 16:17 - Indicates whether the result of the last conversion performed was above, below or within the range established by the designated threshold comparison registers (THRn_LOW and THRn_HIGH)."]
            #[inline]
            pub fn thcmprange(&mut self) -> _THCMPRANGEW {
                _THCMPRANGEW { w: self }
            }
            #[doc = "Bits 18:19 - Indicates whether the result of the last conversion performed represented a crossing of the threshold level established by the designated LOW threshold comparison register (THRn_LOW) and, if so, in what direction the crossing occurred."]
            #[inline]
            pub fn thcmpcross(&mut self) -> _THCMPCROSSW {
                _THCMPCROSSW { w: self }
            }
            #[doc = "Bits 26:29 - These bits contain the channel from which the RESULT bits were converted (e.g. 0000 identifies channel 0, 0001 channel 1...)."]
            #[inline]
            pub fn chn(&mut self) -> _CHNW {
                _CHNW { w: self }
            }
            #[doc = "Bit 30 - This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read. This bit will contribute to an overrun interrupt request if the MODE bit (in SEQA_CTRL) for the corresponding sequence is set to '0' (and if the overrun interrupt is enabled)."]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 31 - This bit is set to '1' at the end of each conversion when a new result is loaded into the RESULT field. It is cleared whenever this register is read. This bit will cause a conversion-complete interrupt for the corresponding sequence if the MODE bit (in SEQA_CTRL) for that sequence is set to 0 (and if the interrupt is enabled)."]
            #[inline]
            pub fn datavalid(&mut self) -> _DATAVALIDW {
                _DATAVALIDW { w: self }
            }
        }
    }
    #[doc = "A/D Sequence-B Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-B"]
    pub struct SEQB_GDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Sequence-B Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-B"]
    pub mod seqb_gdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SEQB_GDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESULTR {
            bits: u16,
        }
        impl RESULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMPRANGER {
            bits: u8,
        }
        impl THCMPRANGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMPCROSSR {
            bits: u8,
        }
        impl THCMPCROSSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHNR {
            bits: u8,
        }
        impl CHNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAVALIDR {
            bits: bool,
        }
        impl DATAVALIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESULTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESULTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMPRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMPRANGEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMPCROSSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMPCROSSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHNW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAVALIDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAVALIDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - This field contains the 12-bit A/D conversion result from the most recent conversion performed under conversion sequence associated with this register. This will be a binary fraction representing the voltage on the currently-selected input channel as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on V REFP. DATAVALID = 1 indicates that this result has not yet been read."]
            #[inline]
            pub fn result(&self) -> RESULTR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RESULTR { bits }
            }
            #[doc = "Bits 16:17 - Indicates whether the result of the last conversion performed was above, below or within the range established by the designated threshold comparison registers (THRn_LOW and THRn_HIGH). Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved."]
            #[inline]
            pub fn thcmprange(&self) -> THCMPRANGER {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                THCMPRANGER { bits }
            }
            #[doc = "Bits 18:19 - Indicates whether the result of the last conversion performed represented a crossing of the threshold level established by the designated LOW threshold comparison register (THRn_LOW) and, if so, in what direction the crossing occurred. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold."]
            #[inline]
            pub fn thcmpcross(&self) -> THCMPCROSSR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                THCMPCROSSR { bits }
            }
            #[doc = "Bits 26:29 - These bits contain the channel from which the RESULT bits were converted (e.g. 0b0000 identifies channel 0, 0b0001 channel 1...)."]
            #[inline]
            pub fn chn(&self) -> CHNR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHNR { bits }
            }
            #[doc = "Bit 30 - This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read. This bit will contribute to an overrun interrupt request if the MODE bit (in SEQB_CTRL) for the corresponding sequence is set to 0 (and if the overrun interrupt is enabled)."]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 31 - This bit is set to 1 at the end of each conversion when a new result is loaded into the RESULT field. It is cleared whenever this register is read. This bit will cause a conversion-complete interrupt for the corresponding sequence if the MODE bit (in SEQB_CTRL) for that sequence is set to 0 (and if the interrupt is enabled)."]
            #[inline]
            pub fn datavalid(&self) -> DATAVALIDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATAVALIDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - This field contains the 12-bit A/D conversion result from the most recent conversion performed under conversion sequence associated with this register. This will be a binary fraction representing the voltage on the currently-selected input channel as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on V REFP. DATAVALID = 1 indicates that this result has not yet been read."]
            #[inline]
            pub fn result(&mut self) -> _RESULTW {
                _RESULTW { w: self }
            }
            #[doc = "Bits 16:17 - Indicates whether the result of the last conversion performed was above, below or within the range established by the designated threshold comparison registers (THRn_LOW and THRn_HIGH). Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved."]
            #[inline]
            pub fn thcmprange(&mut self) -> _THCMPRANGEW {
                _THCMPRANGEW { w: self }
            }
            #[doc = "Bits 18:19 - Indicates whether the result of the last conversion performed represented a crossing of the threshold level established by the designated LOW threshold comparison register (THRn_LOW) and, if so, in what direction the crossing occurred. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold."]
            #[inline]
            pub fn thcmpcross(&mut self) -> _THCMPCROSSW {
                _THCMPCROSSW { w: self }
            }
            #[doc = "Bits 26:29 - These bits contain the channel from which the RESULT bits were converted (e.g. 0b0000 identifies channel 0, 0b0001 channel 1...)."]
            #[inline]
            pub fn chn(&mut self) -> _CHNW {
                _CHNW { w: self }
            }
            #[doc = "Bit 30 - This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read. This bit will contribute to an overrun interrupt request if the MODE bit (in SEQB_CTRL) for the corresponding sequence is set to 0 (and if the overrun interrupt is enabled)."]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 31 - This bit is set to 1 at the end of each conversion when a new result is loaded into the RESULT field. It is cleared whenever this register is read. This bit will cause a conversion-complete interrupt for the corresponding sequence if the MODE bit (in SEQB_CTRL) for that sequence is set to 0 (and if the interrupt is enabled)."]
            #[inline]
            pub fn datavalid(&mut self) -> _DATAVALIDW {
                _DATAVALIDW { w: self }
            }
        }
    }
    #[doc = "A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0."]
    pub struct DAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0."]
    pub mod dat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESULTR {
            bits: u16,
        }
        impl RESULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMPRANGER {
            bits: u8,
        }
        impl THCMPRANGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMPCROSSR {
            bits: u8,
        }
        impl THCMPCROSSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANNELR {
            bits: u8,
        }
        impl CHANNELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAVALIDR {
            bits: bool,
        }
        impl DATAVALIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP."]
            #[inline]
            pub fn result(&self) -> RESULTR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RESULTR { bits }
            }
            #[doc = "Bits 16:17 - Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved."]
            #[inline]
            pub fn thcmprange(&self) -> THCMPRANGER {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                THCMPRANGER { bits }
            }
            #[doc = "Bits 18:19 - Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold."]
            #[inline]
            pub fn thcmpcross(&self) -> THCMPCROSSR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                THCMPCROSSR { bits }
            }
            #[doc = "Bits 26:29 - This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)"]
            #[inline]
            pub fn channel(&self) -> CHANNELR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHANNELR { bits }
            }
            #[doc = "Bit 30 - This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled."]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 31 - This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled."]
            #[inline]
            pub fn datavalid(&self) -> DATAVALIDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATAVALIDR { bits }
            }
        }
    }
    #[doc = "A/D Low Compare Threshold Register 0 : Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0."]
    pub struct THR0_LOW {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Low Compare Threshold Register 0 : Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0."]
    pub mod thr0_low {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::THR0_LOW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct THRLOWR {
            bits: u16,
        }
        impl THRLOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _THRLOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THRLOWW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - Low threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrlow(&self) -> THRLOWR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                THRLOWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - Low threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrlow(&mut self) -> _THRLOWW {
                _THRLOWW { w: self }
            }
        }
    }
    #[doc = "A/D Low Compare Threshold Register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1."]
    pub struct THR1_LOW {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Low Compare Threshold Register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1."]
    pub mod thr1_low {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::THR1_LOW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct THRLOWR {
            bits: u16,
        }
        impl THRLOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _THRLOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THRLOWW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - Low threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrlow(&self) -> THRLOWR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                THRLOWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - Low threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrlow(&mut self) -> _THRLOWW {
                _THRLOWW { w: self }
            }
        }
    }
    #[doc = "A/D High Compare Threshold Register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0."]
    pub struct THR0_HIGH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D High Compare Threshold Register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0."]
    pub mod thr0_high {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::THR0_HIGH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct THRHIGHR {
            bits: u16,
        }
        impl THRHIGHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _THRHIGHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THRHIGHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - High threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrhigh(&self) -> THRHIGHR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                THRHIGHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - High threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrhigh(&mut self) -> _THRHIGHW {
                _THRHIGHW { w: self }
            }
        }
    }
    #[doc = "A/D High Compare Threshold Register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1."]
    pub struct THR1_HIGH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D High Compare Threshold Register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1."]
    pub mod thr1_high {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::THR1_HIGH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct THRHIGHR {
            bits: u16,
        }
        impl THRHIGHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _THRHIGHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THRHIGHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - High threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrhigh(&self) -> THRHIGHR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                THRHIGHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - High threshold value against which A/D results will be compared"]
            #[inline]
            pub fn thrhigh(&mut self) -> _THRHIGHW {
                _THRHIGHW { w: self }
            }
        }
    }
    #[doc = "A/D Channel-Threshold Select Register. Specifies which set of threshold compare registers are to be used for each channel"]
    pub struct CHAN_THRSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Channel-Threshold Select Register. Specifies which set of threshold compare registers are to be used for each channel"]
    pub mod chan_thrsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHAN_THRSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CH0_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH0_THRSELR {
            #[doc = "Threshold 0. Channel 0 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 0 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH0_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH0_THRSELR::THRESHOLD_0 => false,
                    CH0_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH0_THRSELR {
                match value {
                    false => CH0_THRSELR::THRESHOLD_0,
                    true => CH0_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH0_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH0_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH1_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH1_THRSELR {
            #[doc = "Threshold 0. Channel 1 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 1 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH1_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH1_THRSELR::THRESHOLD_0 => false,
                    CH1_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH1_THRSELR {
                match value {
                    false => CH1_THRSELR::THRESHOLD_0,
                    true => CH1_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH1_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH1_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH2_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH2_THRSELR {
            #[doc = "Threshold 0. Channel 2 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 2 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH2_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH2_THRSELR::THRESHOLD_0 => false,
                    CH2_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH2_THRSELR {
                match value {
                    false => CH2_THRSELR::THRESHOLD_0,
                    true => CH2_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH2_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH2_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH3_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH3_THRSELR {
            #[doc = "Threshold 0. Channel 3 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 3 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH3_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH3_THRSELR::THRESHOLD_0 => false,
                    CH3_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH3_THRSELR {
                match value {
                    false => CH3_THRSELR::THRESHOLD_0,
                    true => CH3_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH3_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH3_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH4_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH4_THRSELR {
            #[doc = "Threshold 0. Channel 4 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 4 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH4_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH4_THRSELR::THRESHOLD_0 => false,
                    CH4_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH4_THRSELR {
                match value {
                    false => CH4_THRSELR::THRESHOLD_0,
                    true => CH4_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH4_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH4_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH5_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH5_THRSELR {
            #[doc = "Threshold 0. Channel 5 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 5 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH5_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH5_THRSELR::THRESHOLD_0 => false,
                    CH5_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH5_THRSELR {
                match value {
                    false => CH5_THRSELR::THRESHOLD_0,
                    true => CH5_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH5_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH5_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH6_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH6_THRSELR {
            #[doc = "Threshold 0. Channel 6 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 6 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH6_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH6_THRSELR::THRESHOLD_0 => false,
                    CH6_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH6_THRSELR {
                match value {
                    false => CH6_THRSELR::THRESHOLD_0,
                    true => CH6_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH6_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH6_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH7_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH7_THRSELR {
            #[doc = "Threshold 0. Channel 7 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 7 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH7_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH7_THRSELR::THRESHOLD_0 => false,
                    CH7_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH7_THRSELR {
                match value {
                    false => CH7_THRSELR::THRESHOLD_0,
                    true => CH7_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH7_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH7_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH8_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH8_THRSELR {
            #[doc = "Threshold 0. Channel 8 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 8 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH8_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH8_THRSELR::THRESHOLD_0 => false,
                    CH8_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH8_THRSELR {
                match value {
                    false => CH8_THRSELR::THRESHOLD_0,
                    true => CH8_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH8_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH8_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH9_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH9_THRSELR {
            #[doc = "Threshold 0. Channel 9 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 9 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH9_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH9_THRSELR::THRESHOLD_0 => false,
                    CH9_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH9_THRSELR {
                match value {
                    false => CH9_THRSELR::THRESHOLD_0,
                    true => CH9_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH9_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH9_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH10_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH10_THRSELR {
            #[doc = "Threshold 0. Channel 10 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 10 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH10_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH10_THRSELR::THRESHOLD_0 => false,
                    CH10_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH10_THRSELR {
                match value {
                    false => CH10_THRSELR::THRESHOLD_0,
                    true => CH10_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH10_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH10_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Possible values of the field `CH11_THRSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH11_THRSELR {
            #[doc = "Threshold 0. Channel 11 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 11 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH11_THRSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH11_THRSELR::THRESHOLD_0 => false,
                    CH11_THRSELR::THRESHOLD_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH11_THRSELR {
                match value {
                    false => CH11_THRSELR::THRESHOLD_0,
                    true => CH11_THRSELR::THRESHOLD_1,
                }
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_0`"]
            #[inline]
            pub fn is_threshold_0(&self) -> bool {
                *self == CH11_THRSELR::THRESHOLD_0
            }
            #[doc = "Checks if the value of the field is `THRESHOLD_1`"]
            #[inline]
            pub fn is_threshold_1(&self) -> bool {
                *self == CH11_THRSELR::THRESHOLD_1
            }
        }
        #[doc = "Values that can be written to the field `CH0_THRSEL`"]
        pub enum CH0_THRSELW {
            #[doc = "Threshold 0. Channel 0 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 0 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH0_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH0_THRSELW::THRESHOLD_0 => false,
                    CH0_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH0_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH0_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH0_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 0 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH0_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 0 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH0_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH1_THRSEL`"]
        pub enum CH1_THRSELW {
            #[doc = "Threshold 0. Channel 1 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 1 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH1_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH1_THRSELW::THRESHOLD_0 => false,
                    CH1_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH1_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 1 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH1_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 1 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH1_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH2_THRSEL`"]
        pub enum CH2_THRSELW {
            #[doc = "Threshold 0. Channel 2 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 2 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH2_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH2_THRSELW::THRESHOLD_0 => false,
                    CH2_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH2_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 2 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH2_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 2 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH2_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH3_THRSEL`"]
        pub enum CH3_THRSELW {
            #[doc = "Threshold 0. Channel 3 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 3 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH3_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH3_THRSELW::THRESHOLD_0 => false,
                    CH3_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH3_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 3 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH3_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 3 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH3_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH4_THRSEL`"]
        pub enum CH4_THRSELW {
            #[doc = "Threshold 0. Channel 4 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 4 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH4_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH4_THRSELW::THRESHOLD_0 => false,
                    CH4_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH4_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 4 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH4_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 4 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH4_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH5_THRSEL`"]
        pub enum CH5_THRSELW {
            #[doc = "Threshold 0. Channel 5 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 5 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH5_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH5_THRSELW::THRESHOLD_0 => false,
                    CH5_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH5_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 5 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH5_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 5 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH5_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH6_THRSEL`"]
        pub enum CH6_THRSELW {
            #[doc = "Threshold 0. Channel 6 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 6 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH6_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH6_THRSELW::THRESHOLD_0 => false,
                    CH6_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH6_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 6 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH6_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 6 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH6_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH7_THRSEL`"]
        pub enum CH7_THRSELW {
            #[doc = "Threshold 0. Channel 7 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 7 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH7_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH7_THRSELW::THRESHOLD_0 => false,
                    CH7_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH7_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH7_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH7_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 7 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH7_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 7 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH7_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH8_THRSEL`"]
        pub enum CH8_THRSELW {
            #[doc = "Threshold 0. Channel 8 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 8 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH8_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH8_THRSELW::THRESHOLD_0 => false,
                    CH8_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH8_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH8_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH8_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 8 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH8_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 8 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH8_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH9_THRSEL`"]
        pub enum CH9_THRSELW {
            #[doc = "Threshold 0. Channel 9 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 9 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH9_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH9_THRSELW::THRESHOLD_0 => false,
                    CH9_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH9_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH9_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH9_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 9 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH9_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 9 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH9_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH10_THRSEL`"]
        pub enum CH10_THRSELW {
            #[doc = "Threshold 0. Channel 10 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 10 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH10_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH10_THRSELW::THRESHOLD_0 => false,
                    CH10_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH10_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH10_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH10_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 10 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH10_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 10 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH10_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH11_THRSEL`"]
        pub enum CH11_THRSELW {
            #[doc = "Threshold 0. Channel 11 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            THRESHOLD_0,
            #[doc = "Threshold 1. Channel 11 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            THRESHOLD_1,
        }
        impl CH11_THRSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH11_THRSELW::THRESHOLD_0 => false,
                    CH11_THRSELW::THRESHOLD_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH11_THRSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH11_THRSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH11_THRSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Threshold 0. Channel 11 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers"]
            #[inline]
            pub fn threshold_0(self) -> &'a mut W {
                self.variant(CH11_THRSELW::THRESHOLD_0)
            }
            #[doc = "Threshold 1. Channel 11 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers"]
            #[inline]
            pub fn threshold_1(self) -> &'a mut W {
                self.variant(CH11_THRSELW::THRESHOLD_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Threshold select by channel."]
            #[inline]
            pub fn ch0_thrsel(&self) -> CH0_THRSELR {
                CH0_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Threshold select by channel."]
            #[inline]
            pub fn ch1_thrsel(&self) -> CH1_THRSELR {
                CH1_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Threshold select by channel."]
            #[inline]
            pub fn ch2_thrsel(&self) -> CH2_THRSELR {
                CH2_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Threshold select by channel."]
            #[inline]
            pub fn ch3_thrsel(&self) -> CH3_THRSELR {
                CH3_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Threshold select by channel."]
            #[inline]
            pub fn ch4_thrsel(&self) -> CH4_THRSELR {
                CH4_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Threshold select by channel."]
            #[inline]
            pub fn ch5_thrsel(&self) -> CH5_THRSELR {
                CH5_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Threshold select by channel."]
            #[inline]
            pub fn ch6_thrsel(&self) -> CH6_THRSELR {
                CH6_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Threshold select by channel."]
            #[inline]
            pub fn ch7_thrsel(&self) -> CH7_THRSELR {
                CH7_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Threshold select by channel."]
            #[inline]
            pub fn ch8_thrsel(&self) -> CH8_THRSELR {
                CH8_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Threshold select by channel."]
            #[inline]
            pub fn ch9_thrsel(&self) -> CH9_THRSELR {
                CH9_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Threshold select by channel."]
            #[inline]
            pub fn ch10_thrsel(&self) -> CH10_THRSELR {
                CH10_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Threshold select by channel."]
            #[inline]
            pub fn ch11_thrsel(&self) -> CH11_THRSELR {
                CH11_THRSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Threshold select by channel."]
            #[inline]
            pub fn ch0_thrsel(&mut self) -> _CH0_THRSELW {
                _CH0_THRSELW { w: self }
            }
            #[doc = "Bit 1 - Threshold select by channel."]
            #[inline]
            pub fn ch1_thrsel(&mut self) -> _CH1_THRSELW {
                _CH1_THRSELW { w: self }
            }
            #[doc = "Bit 2 - Threshold select by channel."]
            #[inline]
            pub fn ch2_thrsel(&mut self) -> _CH2_THRSELW {
                _CH2_THRSELW { w: self }
            }
            #[doc = "Bit 3 - Threshold select by channel."]
            #[inline]
            pub fn ch3_thrsel(&mut self) -> _CH3_THRSELW {
                _CH3_THRSELW { w: self }
            }
            #[doc = "Bit 4 - Threshold select by channel."]
            #[inline]
            pub fn ch4_thrsel(&mut self) -> _CH4_THRSELW {
                _CH4_THRSELW { w: self }
            }
            #[doc = "Bit 5 - Threshold select by channel."]
            #[inline]
            pub fn ch5_thrsel(&mut self) -> _CH5_THRSELW {
                _CH5_THRSELW { w: self }
            }
            #[doc = "Bit 6 - Threshold select by channel."]
            #[inline]
            pub fn ch6_thrsel(&mut self) -> _CH6_THRSELW {
                _CH6_THRSELW { w: self }
            }
            #[doc = "Bit 7 - Threshold select by channel."]
            #[inline]
            pub fn ch7_thrsel(&mut self) -> _CH7_THRSELW {
                _CH7_THRSELW { w: self }
            }
            #[doc = "Bit 8 - Threshold select by channel."]
            #[inline]
            pub fn ch8_thrsel(&mut self) -> _CH8_THRSELW {
                _CH8_THRSELW { w: self }
            }
            #[doc = "Bit 9 - Threshold select by channel."]
            #[inline]
            pub fn ch9_thrsel(&mut self) -> _CH9_THRSELW {
                _CH9_THRSELW { w: self }
            }
            #[doc = "Bit 10 - Threshold select by channel."]
            #[inline]
            pub fn ch10_thrsel(&mut self) -> _CH10_THRSELW {
                _CH10_THRSELW { w: self }
            }
            #[doc = "Bit 11 - Threshold select by channel."]
            #[inline]
            pub fn ch11_thrsel(&mut self) -> _CH11_THRSELW {
                _CH11_THRSELW { w: self }
            }
        }
    }
    #[doc = "A/D Interrupt Enable Register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated."]
    pub struct INTEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Interrupt Enable Register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated."]
    pub mod inten {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEQA_INTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEQA_INTENR {
            #[doc = "Disabled. The sequence A interrupt/DMA trigger is disabled."]
            DISABLED,
            #[doc = "Enabled. The sequence A interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence A, or upon completion of the entire A sequence of conversions, depending on the MODE bit in the SEQA_CTRL register."]
            ENABLED,
        }
        impl SEQA_INTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SEQA_INTENR::DISABLED => false,
                    SEQA_INTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SEQA_INTENR {
                match value {
                    false => SEQA_INTENR::DISABLED,
                    true => SEQA_INTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SEQA_INTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SEQA_INTENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SEQB_INTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEQB_INTENR {
            #[doc = "Disabled. The sequence B interrupt/DMA trigger is disabled."]
            DISABLED,
            #[doc = "Enabled. The sequence B interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence B, or upon completion of the entire B sequence of conversions, depending on the MODE bit in the SEQB_CTRL register."]
            ENABLED,
        }
        impl SEQB_INTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SEQB_INTENR::DISABLED => false,
                    SEQB_INTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SEQB_INTENR {
                match value {
                    false => SEQB_INTENR::DISABLED,
                    true => SEQB_INTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SEQB_INTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SEQB_INTENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `OVR_INTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_INTENR {
            #[doc = "Disabled. The overrun interrupt is disabled."]
            DISABLED,
            #[doc = "Enabled. The overrun interrupt is enabled. Detection of an overrun condition on any of the 12 channel data registers will cause an overrun interrupt request. In addition, if the MODE bit for a particular sequence is 0, then an overrun in the global data register for that sequence will also cause this interrupt request to be asserted."]
            ENABLED,
        }
        impl OVR_INTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVR_INTENR::DISABLED => false,
                    OVR_INTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVR_INTENR {
                match value {
                    false => OVR_INTENR::DISABLED,
                    true => OVR_INTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OVR_INTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OVR_INTENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN0R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN0R::DISABLED => 0,
                    ADCMPINTEN0R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN0R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN0R {
                match value {
                    0 => ADCMPINTEN0R::DISABLED,
                    1 => ADCMPINTEN0R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN0R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN0R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN0R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN1R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN1R::DISABLED => 0,
                    ADCMPINTEN1R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN1R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN1R {
                match value {
                    0 => ADCMPINTEN1R::DISABLED,
                    1 => ADCMPINTEN1R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN1R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN1R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN1R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN2R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN2R::DISABLED => 0,
                    ADCMPINTEN2R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN2R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN2R {
                match value {
                    0 => ADCMPINTEN2R::DISABLED,
                    1 => ADCMPINTEN2R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN2R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN2R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN2R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN3R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN3R::DISABLED => 0,
                    ADCMPINTEN3R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN3R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN3R {
                match value {
                    0 => ADCMPINTEN3R::DISABLED,
                    1 => ADCMPINTEN3R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN3R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN3R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN3R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN4R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN4R::DISABLED => 0,
                    ADCMPINTEN4R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN4R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN4R {
                match value {
                    0 => ADCMPINTEN4R::DISABLED,
                    1 => ADCMPINTEN4R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN4R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN4R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN4R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN5R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN5R::DISABLED => 0,
                    ADCMPINTEN5R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN5R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN5R {
                match value {
                    0 => ADCMPINTEN5R::DISABLED,
                    1 => ADCMPINTEN5R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN5R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN5R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN5R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN6R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN6R::DISABLED => 0,
                    ADCMPINTEN6R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN6R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN6R {
                match value {
                    0 => ADCMPINTEN6R::DISABLED,
                    1 => ADCMPINTEN6R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN6R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN6R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN6R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN7R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN7R::DISABLED => 0,
                    ADCMPINTEN7R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN7R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN7R {
                match value {
                    0 => ADCMPINTEN7R::DISABLED,
                    1 => ADCMPINTEN7R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN7R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN7R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN7R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN8R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN8R::DISABLED => 0,
                    ADCMPINTEN8R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN8R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN8R {
                match value {
                    0 => ADCMPINTEN8R::DISABLED,
                    1 => ADCMPINTEN8R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN8R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN8R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN8R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN8R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN9R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN9R::DISABLED => 0,
                    ADCMPINTEN9R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN9R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN9R {
                match value {
                    0 => ADCMPINTEN9R::DISABLED,
                    1 => ADCMPINTEN9R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN9R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN9R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN9R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN9R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN10R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN10R::DISABLED => 0,
                    ADCMPINTEN10R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN10R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN10R {
                match value {
                    0 => ADCMPINTEN10R::DISABLED,
                    1 => ADCMPINTEN10R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN10R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN10R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN10R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN10R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Possible values of the field `ADCMPINTEN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCMPINTEN11R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN11R::DISABLED => 0,
                    ADCMPINTEN11R::OUTSIDE_THRESHOLD => 0x01,
                    ADCMPINTEN11R::CROSSING_THRESHOLD => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCMPINTEN11R {
                match value {
                    0 => ADCMPINTEN11R::DISABLED,
                    1 => ADCMPINTEN11R::OUTSIDE_THRESHOLD,
                    2 => ADCMPINTEN11R::CROSSING_THRESHOLD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCMPINTEN11R::DISABLED
            }
            #[doc = "Checks if the value of the field is `OUTSIDE_THRESHOLD`"]
            #[inline]
            pub fn is_outside_threshold(&self) -> bool {
                *self == ADCMPINTEN11R::OUTSIDE_THRESHOLD
            }
            #[doc = "Checks if the value of the field is `CROSSING_THRESHOLD`"]
            #[inline]
            pub fn is_crossing_threshold(&self) -> bool {
                *self == ADCMPINTEN11R::CROSSING_THRESHOLD
            }
        }
        #[doc = "Values that can be written to the field `SEQA_INTEN`"]
        pub enum SEQA_INTENW {
            #[doc = "Disabled. The sequence A interrupt/DMA trigger is disabled."]
            DISABLED,
            #[doc = "Enabled. The sequence A interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence A, or upon completion of the entire A sequence of conversions, depending on the MODE bit in the SEQA_CTRL register."]
            ENABLED,
        }
        impl SEQA_INTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SEQA_INTENW::DISABLED => false,
                    SEQA_INTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQA_INTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQA_INTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SEQA_INTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The sequence A interrupt/DMA trigger is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SEQA_INTENW::DISABLED)
            }
            #[doc = "Enabled. The sequence A interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence A, or upon completion of the entire A sequence of conversions, depending on the MODE bit in the SEQA_CTRL register."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SEQA_INTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SEQB_INTEN`"]
        pub enum SEQB_INTENW {
            #[doc = "Disabled. The sequence B interrupt/DMA trigger is disabled."]
            DISABLED,
            #[doc = "Enabled. The sequence B interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence B, or upon completion of the entire B sequence of conversions, depending on the MODE bit in the SEQB_CTRL register."]
            ENABLED,
        }
        impl SEQB_INTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SEQB_INTENW::DISABLED => false,
                    SEQB_INTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQB_INTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQB_INTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SEQB_INTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The sequence B interrupt/DMA trigger is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SEQB_INTENW::DISABLED)
            }
            #[doc = "Enabled. The sequence B interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence B, or upon completion of the entire B sequence of conversions, depending on the MODE bit in the SEQB_CTRL register."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SEQB_INTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVR_INTEN`"]
        pub enum OVR_INTENW {
            #[doc = "Disabled. The overrun interrupt is disabled."]
            DISABLED,
            #[doc = "Enabled. The overrun interrupt is enabled. Detection of an overrun condition on any of the 12 channel data registers will cause an overrun interrupt request. In addition, if the MODE bit for a particular sequence is 0, then an overrun in the global data register for that sequence will also cause this interrupt request to be asserted."]
            ENABLED,
        }
        impl OVR_INTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVR_INTENW::DISABLED => false,
                    OVR_INTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR_INTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR_INTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVR_INTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The overrun interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OVR_INTENW::DISABLED)
            }
            #[doc = "Enabled. The overrun interrupt is enabled. Detection of an overrun condition on any of the 12 channel data registers will cause an overrun interrupt request. In addition, if the MODE bit for a particular sequence is 0, then an overrun in the global data register for that sequence will also cause this interrupt request to be asserted."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OVR_INTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN0`"]
        pub enum ADCMPINTEN0W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN0W::DISABLED => 0,
                    ADCMPINTEN0W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN0W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN0W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN0W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN0W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN1`"]
        pub enum ADCMPINTEN1W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN1W::DISABLED => 0,
                    ADCMPINTEN1W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN1W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN1W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN1W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN1W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN2`"]
        pub enum ADCMPINTEN2W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN2W::DISABLED => 0,
                    ADCMPINTEN2W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN2W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN2W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN2W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN2W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN3`"]
        pub enum ADCMPINTEN3W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN3W::DISABLED => 0,
                    ADCMPINTEN3W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN3W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN3W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN3W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN3W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN4`"]
        pub enum ADCMPINTEN4W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN4W::DISABLED => 0,
                    ADCMPINTEN4W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN4W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN4W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN4W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN4W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN5`"]
        pub enum ADCMPINTEN5W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN5W::DISABLED => 0,
                    ADCMPINTEN5W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN5W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN5W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN5W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN5W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN6`"]
        pub enum ADCMPINTEN6W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN6W::DISABLED => 0,
                    ADCMPINTEN6W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN6W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN6W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN6W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN6W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN7`"]
        pub enum ADCMPINTEN7W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN7W::DISABLED => 0,
                    ADCMPINTEN7W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN7W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN7W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN7W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN7W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN8`"]
        pub enum ADCMPINTEN8W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN8W::DISABLED => 0,
                    ADCMPINTEN8W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN8W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN8W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN8W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN8W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN9`"]
        pub enum ADCMPINTEN9W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN9W::DISABLED => 0,
                    ADCMPINTEN9W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN9W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN9W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN9W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN9W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN10`"]
        pub enum ADCMPINTEN10W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN10W::DISABLED => 0,
                    ADCMPINTEN10W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN10W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN10W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN10W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN10W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCMPINTEN11`"]
        pub enum ADCMPINTEN11W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Outside threshold."]
            OUTSIDE_THRESHOLD,
            #[doc = "Crossing threshold."]
            CROSSING_THRESHOLD,
        }
        impl ADCMPINTEN11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCMPINTEN11W::DISABLED => 0,
                    ADCMPINTEN11W::OUTSIDE_THRESHOLD => 1,
                    ADCMPINTEN11W::CROSSING_THRESHOLD => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCMPINTEN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCMPINTEN11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCMPINTEN11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCMPINTEN11W::DISABLED)
            }
            #[doc = "Outside threshold."]
            #[inline]
            pub fn outside_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN11W::OUTSIDE_THRESHOLD)
            }
            #[doc = "Crossing threshold."]
            #[inline]
            pub fn crossing_threshold(self) -> &'a mut W {
                self.variant(ADCMPINTEN11W::CROSSING_THRESHOLD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Sequence A interrupt enable."]
            #[inline]
            pub fn seqa_inten(&self) -> SEQA_INTENR {
                SEQA_INTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Sequence B interrupt enable."]
            #[inline]
            pub fn seqb_inten(&self) -> SEQB_INTENR {
                SEQB_INTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Overrun interrupt enable."]
            #[inline]
            pub fn ovr_inten(&self) -> OVR_INTENR {
                OVR_INTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 3:4 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten0(&self) -> ADCMPINTEN0R {
                ADCMPINTEN0R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 5:6 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten1(&self) -> ADCMPINTEN1R {
                ADCMPINTEN1R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 7:8 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten2(&self) -> ADCMPINTEN2R {
                ADCMPINTEN2R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 9:10 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten3(&self) -> ADCMPINTEN3R {
                ADCMPINTEN3R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:12 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten4(&self) -> ADCMPINTEN4R {
                ADCMPINTEN4R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:14 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten5(&self) -> ADCMPINTEN5R {
                ADCMPINTEN5R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 15:16 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten6(&self) -> ADCMPINTEN6R {
                ADCMPINTEN6R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 17:18 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten7(&self) -> ADCMPINTEN7R {
                ADCMPINTEN7R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 19:20 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten8(&self) -> ADCMPINTEN8R {
                ADCMPINTEN8R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 21:22 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten9(&self) -> ADCMPINTEN9R {
                ADCMPINTEN9R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 23:24 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten10(&self) -> ADCMPINTEN10R {
                ADCMPINTEN10R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 25:26 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten11(&self) -> ADCMPINTEN11R {
                ADCMPINTEN11R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sequence A interrupt enable."]
            #[inline]
            pub fn seqa_inten(&mut self) -> _SEQA_INTENW {
                _SEQA_INTENW { w: self }
            }
            #[doc = "Bit 1 - Sequence B interrupt enable."]
            #[inline]
            pub fn seqb_inten(&mut self) -> _SEQB_INTENW {
                _SEQB_INTENW { w: self }
            }
            #[doc = "Bit 2 - Overrun interrupt enable."]
            #[inline]
            pub fn ovr_inten(&mut self) -> _OVR_INTENW {
                _OVR_INTENW { w: self }
            }
            #[doc = "Bits 3:4 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten0(&mut self) -> _ADCMPINTEN0W {
                _ADCMPINTEN0W { w: self }
            }
            #[doc = "Bits 5:6 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten1(&mut self) -> _ADCMPINTEN1W {
                _ADCMPINTEN1W { w: self }
            }
            #[doc = "Bits 7:8 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten2(&mut self) -> _ADCMPINTEN2W {
                _ADCMPINTEN2W { w: self }
            }
            #[doc = "Bits 9:10 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten3(&mut self) -> _ADCMPINTEN3W {
                _ADCMPINTEN3W { w: self }
            }
            #[doc = "Bits 11:12 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten4(&mut self) -> _ADCMPINTEN4W {
                _ADCMPINTEN4W { w: self }
            }
            #[doc = "Bits 13:14 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten5(&mut self) -> _ADCMPINTEN5W {
                _ADCMPINTEN5W { w: self }
            }
            #[doc = "Bits 15:16 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten6(&mut self) -> _ADCMPINTEN6W {
                _ADCMPINTEN6W { w: self }
            }
            #[doc = "Bits 17:18 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten7(&mut self) -> _ADCMPINTEN7W {
                _ADCMPINTEN7W { w: self }
            }
            #[doc = "Bits 19:20 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten8(&mut self) -> _ADCMPINTEN8W {
                _ADCMPINTEN8W { w: self }
            }
            #[doc = "Bits 21:22 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten9(&mut self) -> _ADCMPINTEN9W {
                _ADCMPINTEN9W { w: self }
            }
            #[doc = "Bits 23:24 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten10(&mut self) -> _ADCMPINTEN10W {
                _ADCMPINTEN10W { w: self }
            }
            #[doc = "Bits 25:26 - Threshold comparison interrupt enable."]
            #[inline]
            pub fn adcmpinten11(&mut self) -> _ADCMPINTEN11W {
                _ADCMPINTEN11W { w: self }
            }
        }
    }
    #[doc = "A/D Flags Register. Contains the four interrupt request flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers)."]
    pub struct FLAGS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Flags Register. Contains the four interrupt request flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers)."]
    pub mod flags {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FLAGS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP0R {
            bits: bool,
        }
        impl THCMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP1R {
            bits: bool,
        }
        impl THCMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP2R {
            bits: bool,
        }
        impl THCMP2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP3R {
            bits: bool,
        }
        impl THCMP3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP4R {
            bits: bool,
        }
        impl THCMP4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP5R {
            bits: bool,
        }
        impl THCMP5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP6R {
            bits: bool,
        }
        impl THCMP6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP7R {
            bits: bool,
        }
        impl THCMP7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP8R {
            bits: bool,
        }
        impl THCMP8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP9R {
            bits: bool,
        }
        impl THCMP9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP10R {
            bits: bool,
        }
        impl THCMP10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP11R {
            bits: bool,
        }
        impl THCMP11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN0R {
            bits: bool,
        }
        impl OVERRUN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN1R {
            bits: bool,
        }
        impl OVERRUN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN2R {
            bits: bool,
        }
        impl OVERRUN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN3R {
            bits: bool,
        }
        impl OVERRUN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN4R {
            bits: bool,
        }
        impl OVERRUN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN5R {
            bits: bool,
        }
        impl OVERRUN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN6R {
            bits: bool,
        }
        impl OVERRUN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN7R {
            bits: bool,
        }
        impl OVERRUN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN8R {
            bits: bool,
        }
        impl OVERRUN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN9R {
            bits: bool,
        }
        impl OVERRUN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN10R {
            bits: bool,
        }
        impl OVERRUN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN11R {
            bits: bool,
        }
        impl OVERRUN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEQA_OVRR {
            bits: bool,
        }
        impl SEQA_OVRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEQB_OVRR {
            bits: bool,
        }
        impl SEQB_OVRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEQA_INTR {
            bits: bool,
        }
        impl SEQA_INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEQB_INTR {
            bits: bool,
        }
        impl SEQB_INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct THCMP_INTR {
            bits: bool,
        }
        impl THCMP_INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR_INTR {
            bits: bool,
        }
        impl OVR_INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQA_OVRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQA_OVRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQB_OVRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQB_OVRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQA_INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQA_INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEQB_INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEQB_INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _THCMP_INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THCMP_INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR_INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR_INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Threshold comparison event on Channel 0. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp0(&self) -> THCMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP0R { bits }
            }
            #[doc = "Bit 1 - Threshold comparison event on Channel 1. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp1(&self) -> THCMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP1R { bits }
            }
            #[doc = "Bit 2 - Threshold comparison event on Channel 2. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp2(&self) -> THCMP2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP2R { bits }
            }
            #[doc = "Bit 3 - Threshold comparison event on Channel 3. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp3(&self) -> THCMP3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP3R { bits }
            }
            #[doc = "Bit 4 - Threshold comparison event on Channel 4. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp4(&self) -> THCMP4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP4R { bits }
            }
            #[doc = "Bit 5 - Threshold comparison event on Channel 5. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp5(&self) -> THCMP5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP5R { bits }
            }
            #[doc = "Bit 6 - Threshold comparison event on Channel 6. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp6(&self) -> THCMP6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP6R { bits }
            }
            #[doc = "Bit 7 - Threshold comparison event on Channel 7. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp7(&self) -> THCMP7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP7R { bits }
            }
            #[doc = "Bit 8 - Threshold comparison event on Channel 8. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp8(&self) -> THCMP8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP8R { bits }
            }
            #[doc = "Bit 9 - Threshold comparison event on Channel 9. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp9(&self) -> THCMP9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP9R { bits }
            }
            #[doc = "Bit 10 - Threshold comparison event on Channel 10. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp10(&self) -> THCMP10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP10R { bits }
            }
            #[doc = "Bit 11 - Threshold comparison event on Channel 11. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp11(&self) -> THCMP11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP11R { bits }
            }
            #[doc = "Bit 12 - Mirrors the OVERRRUN status flag from the result register for A/D channel 0"]
            #[inline]
            pub fn overrun0(&self) -> OVERRUN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN0R { bits }
            }
            #[doc = "Bit 13 - Mirrors the OVERRRUN status flag from the result register for A/D channel 1"]
            #[inline]
            pub fn overrun1(&self) -> OVERRUN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN1R { bits }
            }
            #[doc = "Bit 14 - Mirrors the OVERRRUN status flag from the result register for A/D channel 2"]
            #[inline]
            pub fn overrun2(&self) -> OVERRUN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN2R { bits }
            }
            #[doc = "Bit 15 - Mirrors the OVERRRUN status flag from the result register for A/D channel 3"]
            #[inline]
            pub fn overrun3(&self) -> OVERRUN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN3R { bits }
            }
            #[doc = "Bit 16 - Mirrors the OVERRRUN status flag from the result register for A/D channel 4"]
            #[inline]
            pub fn overrun4(&self) -> OVERRUN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN4R { bits }
            }
            #[doc = "Bit 17 - Mirrors the OVERRRUN status flag from the result register for A/D channel 5"]
            #[inline]
            pub fn overrun5(&self) -> OVERRUN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN5R { bits }
            }
            #[doc = "Bit 18 - Mirrors the OVERRRUN status flag from the result register for A/D channel 6"]
            #[inline]
            pub fn overrun6(&self) -> OVERRUN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN6R { bits }
            }
            #[doc = "Bit 19 - Mirrors the OVERRRUN status flag from the result register for A/D channel 7"]
            #[inline]
            pub fn overrun7(&self) -> OVERRUN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN7R { bits }
            }
            #[doc = "Bit 20 - Mirrors the OVERRRUN status flag from the result register for A/D channel 8"]
            #[inline]
            pub fn overrun8(&self) -> OVERRUN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN8R { bits }
            }
            #[doc = "Bit 21 - Mirrors the OVERRRUN status flag from the result register for A/D channel 9"]
            #[inline]
            pub fn overrun9(&self) -> OVERRUN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN9R { bits }
            }
            #[doc = "Bit 22 - Mirrors the OVERRRUN status flag from the result register for A/D channel 10"]
            #[inline]
            pub fn overrun10(&self) -> OVERRUN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN10R { bits }
            }
            #[doc = "Bit 23 - Mirrors the OVERRRUN status flag from the result register for A/D channel 11"]
            #[inline]
            pub fn overrun11(&self) -> OVERRUN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN11R { bits }
            }
            #[doc = "Bit 24 - Mirrors the global OVERRUN status flag in the SEQA_GDAT register"]
            #[inline]
            pub fn seqa_ovr(&self) -> SEQA_OVRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SEQA_OVRR { bits }
            }
            #[doc = "Bit 25 - Mirrors the global OVERRUN status flag in the SEQB_GDAT register"]
            #[inline]
            pub fn seqb_ovr(&self) -> SEQB_OVRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SEQB_OVRR { bits }
            }
            #[doc = "Bit 28 - Sequence A interrupt/DMA flag. If the MODE bit in the SEQA_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQA_GDAT), which is set at the end of every A/D conversion performed as part of sequence A. It will be cleared automatically when the SEQA_GDAT register is read. If the MODE bit in the SEQA_CTRL register is 1, this flag will be set upon completion of an entire A sequence. In this case it must be cleared by writing a 1 to this SEQA_INT bit. This interrupt must be enabled in the INTEN register."]
            #[inline]
            pub fn seqa_int(&self) -> SEQA_INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SEQA_INTR { bits }
            }
            #[doc = "Bit 29 - Sequence A interrupt/DMA flag. If the MODE bit in the SEQB_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQB_GDAT), which is set at the end of every A/D conversion performed as part of sequence B. It will be cleared automatically when the SEQB_GDAT register is read. If the MODE bit in the SEQB_CTRL register is 1, this flag will be set upon completion of an entire B sequence. In this case it must be cleared by writing a 1 to this SEQB_INT bit. This interrupt must be enabled in the INTEN register."]
            #[inline]
            pub fn seqb_int(&self) -> SEQB_INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SEQB_INTR { bits }
            }
            #[doc = "Bit 30 - Threshold Comparison Interrupt/DMA flag. This bit will be set if any of the 12 THCMP flags in the lower bits of this register are set to 1 (due to an enabled out-of-range or threshold-crossing event on any channel). Each type of threshold comparison interrupt on each channel must be individually enabled in the INTEN register to cause this interrupt. This bit will be cleared when all of the component flags in bits 11:0 are cleared via writing 1s to those bits."]
            #[inline]
            pub fn thcmp_int(&self) -> THCMP_INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                THCMP_INTR { bits }
            }
            #[doc = "Bit 31 - Overrun Interrupt flag. Any overrun bit in any of the individual channel data registers will cause this interrupt. In addition, if the MODE bit in either of the SEQn_CTRL registers is 0 then the OVERRUN bit in the corresponding SEQn_GDAT register will also cause this interrupt. This interrupt must be enabled in the INTEN register. This bit will be cleared when all of the individual overrun bits have been cleared via reading the corresponding data registers."]
            #[inline]
            pub fn ovr_int(&self) -> OVR_INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR_INTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Threshold comparison event on Channel 0. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp0(&mut self) -> _THCMP0W {
                _THCMP0W { w: self }
            }
            #[doc = "Bit 1 - Threshold comparison event on Channel 1. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp1(&mut self) -> _THCMP1W {
                _THCMP1W { w: self }
            }
            #[doc = "Bit 2 - Threshold comparison event on Channel 2. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp2(&mut self) -> _THCMP2W {
                _THCMP2W { w: self }
            }
            #[doc = "Bit 3 - Threshold comparison event on Channel 3. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp3(&mut self) -> _THCMP3W {
                _THCMP3W { w: self }
            }
            #[doc = "Bit 4 - Threshold comparison event on Channel 4. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp4(&mut self) -> _THCMP4W {
                _THCMP4W { w: self }
            }
            #[doc = "Bit 5 - Threshold comparison event on Channel 5. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp5(&mut self) -> _THCMP5W {
                _THCMP5W { w: self }
            }
            #[doc = "Bit 6 - Threshold comparison event on Channel 6. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp6(&mut self) -> _THCMP6W {
                _THCMP6W { w: self }
            }
            #[doc = "Bit 7 - Threshold comparison event on Channel 7. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp7(&mut self) -> _THCMP7W {
                _THCMP7W { w: self }
            }
            #[doc = "Bit 8 - Threshold comparison event on Channel 8. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp8(&mut self) -> _THCMP8W {
                _THCMP8W { w: self }
            }
            #[doc = "Bit 9 - Threshold comparison event on Channel 9. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp9(&mut self) -> _THCMP9W {
                _THCMP9W { w: self }
            }
            #[doc = "Bit 10 - Threshold comparison event on Channel 10. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp10(&mut self) -> _THCMP10W {
                _THCMP10W { w: self }
            }
            #[doc = "Bit 11 - Threshold comparison event on Channel 11. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1."]
            #[inline]
            pub fn thcmp11(&mut self) -> _THCMP11W {
                _THCMP11W { w: self }
            }
            #[doc = "Bit 12 - Mirrors the OVERRRUN status flag from the result register for A/D channel 0"]
            #[inline]
            pub fn overrun0(&mut self) -> _OVERRUN0W {
                _OVERRUN0W { w: self }
            }
            #[doc = "Bit 13 - Mirrors the OVERRRUN status flag from the result register for A/D channel 1"]
            #[inline]
            pub fn overrun1(&mut self) -> _OVERRUN1W {
                _OVERRUN1W { w: self }
            }
            #[doc = "Bit 14 - Mirrors the OVERRRUN status flag from the result register for A/D channel 2"]
            #[inline]
            pub fn overrun2(&mut self) -> _OVERRUN2W {
                _OVERRUN2W { w: self }
            }
            #[doc = "Bit 15 - Mirrors the OVERRRUN status flag from the result register for A/D channel 3"]
            #[inline]
            pub fn overrun3(&mut self) -> _OVERRUN3W {
                _OVERRUN3W { w: self }
            }
            #[doc = "Bit 16 - Mirrors the OVERRRUN status flag from the result register for A/D channel 4"]
            #[inline]
            pub fn overrun4(&mut self) -> _OVERRUN4W {
                _OVERRUN4W { w: self }
            }
            #[doc = "Bit 17 - Mirrors the OVERRRUN status flag from the result register for A/D channel 5"]
            #[inline]
            pub fn overrun5(&mut self) -> _OVERRUN5W {
                _OVERRUN5W { w: self }
            }
            #[doc = "Bit 18 - Mirrors the OVERRRUN status flag from the result register for A/D channel 6"]
            #[inline]
            pub fn overrun6(&mut self) -> _OVERRUN6W {
                _OVERRUN6W { w: self }
            }
            #[doc = "Bit 19 - Mirrors the OVERRRUN status flag from the result register for A/D channel 7"]
            #[inline]
            pub fn overrun7(&mut self) -> _OVERRUN7W {
                _OVERRUN7W { w: self }
            }
            #[doc = "Bit 20 - Mirrors the OVERRRUN status flag from the result register for A/D channel 8"]
            #[inline]
            pub fn overrun8(&mut self) -> _OVERRUN8W {
                _OVERRUN8W { w: self }
            }
            #[doc = "Bit 21 - Mirrors the OVERRRUN status flag from the result register for A/D channel 9"]
            #[inline]
            pub fn overrun9(&mut self) -> _OVERRUN9W {
                _OVERRUN9W { w: self }
            }
            #[doc = "Bit 22 - Mirrors the OVERRRUN status flag from the result register for A/D channel 10"]
            #[inline]
            pub fn overrun10(&mut self) -> _OVERRUN10W {
                _OVERRUN10W { w: self }
            }
            #[doc = "Bit 23 - Mirrors the OVERRRUN status flag from the result register for A/D channel 11"]
            #[inline]
            pub fn overrun11(&mut self) -> _OVERRUN11W {
                _OVERRUN11W { w: self }
            }
            #[doc = "Bit 24 - Mirrors the global OVERRUN status flag in the SEQA_GDAT register"]
            #[inline]
            pub fn seqa_ovr(&mut self) -> _SEQA_OVRW {
                _SEQA_OVRW { w: self }
            }
            #[doc = "Bit 25 - Mirrors the global OVERRUN status flag in the SEQB_GDAT register"]
            #[inline]
            pub fn seqb_ovr(&mut self) -> _SEQB_OVRW {
                _SEQB_OVRW { w: self }
            }
            #[doc = "Bit 28 - Sequence A interrupt/DMA flag. If the MODE bit in the SEQA_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQA_GDAT), which is set at the end of every A/D conversion performed as part of sequence A. It will be cleared automatically when the SEQA_GDAT register is read. If the MODE bit in the SEQA_CTRL register is 1, this flag will be set upon completion of an entire A sequence. In this case it must be cleared by writing a 1 to this SEQA_INT bit. This interrupt must be enabled in the INTEN register."]
            #[inline]
            pub fn seqa_int(&mut self) -> _SEQA_INTW {
                _SEQA_INTW { w: self }
            }
            #[doc = "Bit 29 - Sequence A interrupt/DMA flag. If the MODE bit in the SEQB_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQB_GDAT), which is set at the end of every A/D conversion performed as part of sequence B. It will be cleared automatically when the SEQB_GDAT register is read. If the MODE bit in the SEQB_CTRL register is 1, this flag will be set upon completion of an entire B sequence. In this case it must be cleared by writing a 1 to this SEQB_INT bit. This interrupt must be enabled in the INTEN register."]
            #[inline]
            pub fn seqb_int(&mut self) -> _SEQB_INTW {
                _SEQB_INTW { w: self }
            }
            #[doc = "Bit 30 - Threshold Comparison Interrupt/DMA flag. This bit will be set if any of the 12 THCMP flags in the lower bits of this register are set to 1 (due to an enabled out-of-range or threshold-crossing event on any channel). Each type of threshold comparison interrupt on each channel must be individually enabled in the INTEN register to cause this interrupt. This bit will be cleared when all of the component flags in bits 11:0 are cleared via writing 1s to those bits."]
            #[inline]
            pub fn thcmp_int(&mut self) -> _THCMP_INTW {
                _THCMP_INTW { w: self }
            }
            #[doc = "Bit 31 - Overrun Interrupt flag. Any overrun bit in any of the individual channel data registers will cause this interrupt. In addition, if the MODE bit in either of the SEQn_CTRL registers is 0 then the OVERRUN bit in the corresponding SEQn_GDAT register will also cause this interrupt. This interrupt must be enabled in the INTEN register. This bit will be cleared when all of the individual overrun bits have been cleared via reading the corresponding data registers."]
            #[inline]
            pub fn ovr_int(&mut self) -> _OVR_INTW {
                _OVR_INTW { w: self }
            }
        }
    }
    #[doc = "ADC trim register."]
    pub struct TRM {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "ADC trim register."]
    pub mod trm {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TRM {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `VRANGE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VRANGER {
            #[doc = "High voltage. VDDA = 2.7 V to 3.6 V."]
            HIGH_VOLTAGE,
            #[doc = "Low voltage. VDDA = 1.8 V to 2.7 V."]
            LOW_VOLTAGE,
        }
        impl VRANGER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    VRANGER::HIGH_VOLTAGE => false,
                    VRANGER::LOW_VOLTAGE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> VRANGER {
                match value {
                    false => VRANGER::HIGH_VOLTAGE,
                    true => VRANGER::LOW_VOLTAGE,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH_VOLTAGE`"]
            #[inline]
            pub fn is_high_voltage(&self) -> bool {
                *self == VRANGER::HIGH_VOLTAGE
            }
            #[doc = "Checks if the value of the field is `LOW_VOLTAGE`"]
            #[inline]
            pub fn is_low_voltage(&self) -> bool {
                *self == VRANGER::LOW_VOLTAGE
            }
        }
        #[doc = "Values that can be written to the field `VRANGE`"]
        pub enum VRANGEW {
            #[doc = "High voltage. VDDA = 2.7 V to 3.6 V."]
            HIGH_VOLTAGE,
            #[doc = "Low voltage. VDDA = 1.8 V to 2.7 V."]
            LOW_VOLTAGE,
        }
        impl VRANGEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    VRANGEW::HIGH_VOLTAGE => false,
                    VRANGEW::LOW_VOLTAGE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VRANGEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: VRANGEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "High voltage. VDDA = 2.7 V to 3.6 V."]
            #[inline]
            pub fn high_voltage(self) -> &'a mut W {
                self.variant(VRANGEW::HIGH_VOLTAGE)
            }
            #[doc = "Low voltage. VDDA = 1.8 V to 2.7 V."]
            #[inline]
            pub fn low_voltage(self) -> &'a mut W {
                self.variant(VRANGEW::LOW_VOLTAGE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 5 - Reserved."]
            #[inline]
            pub fn vrange(&self) -> VRANGER {
                VRANGER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0f00 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 5 - Reserved."]
            #[inline]
            pub fn vrange(&mut self) -> _VRANGEW {
                _VRANGEW { w: self }
            }
        }
    }
}
#[doc = "Power Management Unit (PMU)"]
pub struct PMU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PMU {}
impl PMU {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const pmu::RegisterBlock {
        0x4002_0000 as *const _
    }
}
impl Deref for PMU {
    type Target = pmu::RegisterBlock;
    fn deref(&self) -> &pmu::RegisterBlock {
        unsafe { &*PMU::ptr() }
    }
}
#[doc = "Power Management Unit (PMU)"]
pub mod pmu {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Power control register"]
        pub pcon: PCON,
        #[doc = "0x04 - General purpose register 0"]
        pub gpreg: [GPREG; 4],
        #[doc = "0x14 - Deep power-down control register. Also includes bits for general purpose storage."]
        pub dpdctrl: DPDCTRL,
    }
    #[doc = "Power control register"]
    pub struct PCON {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power control register"]
    pub mod pcon {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PCON {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PMR {
            #[doc = "Default. The part is in active or sleep mode."]
            DEFAULT,
            #[doc = "Deep-sleep mode. ARM WFI will enter Deep-sleep mode."]
            DEEP_SLEEP_MODE,
            #[doc = "Power-down mode. ARM WFI will enter Power-down mode."]
            POWER_DOWN_MODE,
            #[doc = "Deep power-down mode. ARM WFI will enter Deep-power down mode (ARM Cortex-M0+ core powered-down)."]
            DEEP_POWER_DOWN_MODE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PMR::DEFAULT => 0,
                    PMR::DEEP_SLEEP_MODE => 0x01,
                    PMR::POWER_DOWN_MODE => 0x02,
                    PMR::DEEP_POWER_DOWN_MODE => 0x03,
                    PMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PMR {
                match value {
                    0 => PMR::DEFAULT,
                    1 => PMR::DEEP_SLEEP_MODE,
                    2 => PMR::POWER_DOWN_MODE,
                    3 => PMR::DEEP_POWER_DOWN_MODE,
                    i => PMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DEFAULT`"]
            #[inline]
            pub fn is_default(&self) -> bool {
                *self == PMR::DEFAULT
            }
            #[doc = "Checks if the value of the field is `DEEP_SLEEP_MODE`"]
            #[inline]
            pub fn is_deep_sleep_mode(&self) -> bool {
                *self == PMR::DEEP_SLEEP_MODE
            }
            #[doc = "Checks if the value of the field is `POWER_DOWN_MODE`"]
            #[inline]
            pub fn is_power_down_mode(&self) -> bool {
                *self == PMR::POWER_DOWN_MODE
            }
            #[doc = "Checks if the value of the field is `DEEP_POWER_DOWN_MODE`"]
            #[inline]
            pub fn is_deep_power_down_mode(&self) -> bool {
                *self == PMR::DEEP_POWER_DOWN_MODE
            }
        }
        #[doc = r" Value of the field"]
        pub struct NODPDR {
            bits: bool,
        }
        impl NODPDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SLEEPFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLEEPFLAGR {
            #[doc = "Active mode. Read: No power-down mode entered. Part is in Active mode. Write: No effect."]
            ACTIVE_MODE,
            #[doc = "Low power mode. Read: Sleep, Deep-sleep or Power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            LOW_POWER_MODE,
        }
        impl SLEEPFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLEEPFLAGR::ACTIVE_MODE => false,
                    SLEEPFLAGR::LOW_POWER_MODE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLEEPFLAGR {
                match value {
                    false => SLEEPFLAGR::ACTIVE_MODE,
                    true => SLEEPFLAGR::LOW_POWER_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVE_MODE`"]
            #[inline]
            pub fn is_active_mode(&self) -> bool {
                *self == SLEEPFLAGR::ACTIVE_MODE
            }
            #[doc = "Checks if the value of the field is `LOW_POWER_MODE`"]
            #[inline]
            pub fn is_low_power_mode(&self) -> bool {
                *self == SLEEPFLAGR::LOW_POWER_MODE
            }
        }
        #[doc = "Possible values of the field `DPDFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DPDFLAGR {
            #[doc = "Not Deep power-down. Read: Deep power-down mode not entered. Write: No effect."]
            NOT_DEEP_POWER_DOWN,
            #[doc = "Deep power-down. Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            DEEP_POWER_DOWN,
        }
        impl DPDFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DPDFLAGR::NOT_DEEP_POWER_DOWN => false,
                    DPDFLAGR::DEEP_POWER_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DPDFLAGR {
                match value {
                    false => DPDFLAGR::NOT_DEEP_POWER_DOWN,
                    true => DPDFLAGR::DEEP_POWER_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_DEEP_POWER_DOWN`"]
            #[inline]
            pub fn is_not_deep_power_down(&self) -> bool {
                *self == DPDFLAGR::NOT_DEEP_POWER_DOWN
            }
            #[doc = "Checks if the value of the field is `DEEP_POWER_DOWN`"]
            #[inline]
            pub fn is_deep_power_down(&self) -> bool {
                *self == DPDFLAGR::DEEP_POWER_DOWN
            }
        }
        #[doc = "Values that can be written to the field `PM`"]
        pub enum PMW {
            #[doc = "Default. The part is in active or sleep mode."]
            DEFAULT,
            #[doc = "Deep-sleep mode. ARM WFI will enter Deep-sleep mode."]
            DEEP_SLEEP_MODE,
            #[doc = "Power-down mode. ARM WFI will enter Power-down mode."]
            POWER_DOWN_MODE,
            #[doc = "Deep power-down mode. ARM WFI will enter Deep-power down mode (ARM Cortex-M0+ core powered-down)."]
            DEEP_POWER_DOWN_MODE,
        }
        impl PMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PMW::DEFAULT => 0,
                    PMW::DEEP_SLEEP_MODE => 1,
                    PMW::POWER_DOWN_MODE => 2,
                    PMW::DEEP_POWER_DOWN_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Default. The part is in active or sleep mode."]
            #[inline]
            pub fn default(self) -> &'a mut W {
                self.variant(PMW::DEFAULT)
            }
            #[doc = "Deep-sleep mode. ARM WFI will enter Deep-sleep mode."]
            #[inline]
            pub fn deep_sleep_mode(self) -> &'a mut W {
                self.variant(PMW::DEEP_SLEEP_MODE)
            }
            #[doc = "Power-down mode. ARM WFI will enter Power-down mode."]
            #[inline]
            pub fn power_down_mode(self) -> &'a mut W {
                self.variant(PMW::POWER_DOWN_MODE)
            }
            #[doc = "Deep power-down mode. ARM WFI will enter Deep-power down mode (ARM Cortex-M0+ core powered-down)."]
            #[inline]
            pub fn deep_power_down_mode(self) -> &'a mut W {
                self.variant(PMW::DEEP_POWER_DOWN_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NODPDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NODPDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLEEPFLAG`"]
        pub enum SLEEPFLAGW {
            #[doc = "Active mode. Read: No power-down mode entered. Part is in Active mode. Write: No effect."]
            ACTIVE_MODE,
            #[doc = "Low power mode. Read: Sleep, Deep-sleep or Power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            LOW_POWER_MODE,
        }
        impl SLEEPFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLEEPFLAGW::ACTIVE_MODE => false,
                    SLEEPFLAGW::LOW_POWER_MODE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLEEPFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLEEPFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLEEPFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Active mode. Read: No power-down mode entered. Part is in Active mode. Write: No effect."]
            #[inline]
            pub fn active_mode(self) -> &'a mut W {
                self.variant(SLEEPFLAGW::ACTIVE_MODE)
            }
            #[doc = "Low power mode. Read: Sleep, Deep-sleep or Power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            #[inline]
            pub fn low_power_mode(self) -> &'a mut W {
                self.variant(SLEEPFLAGW::LOW_POWER_MODE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DPDFLAG`"]
        pub enum DPDFLAGW {
            #[doc = "Not Deep power-down. Read: Deep power-down mode not entered. Write: No effect."]
            NOT_DEEP_POWER_DOWN,
            #[doc = "Deep power-down. Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            DEEP_POWER_DOWN,
        }
        impl DPDFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DPDFLAGW::NOT_DEEP_POWER_DOWN => false,
                    DPDFLAGW::DEEP_POWER_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPDFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPDFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DPDFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not Deep power-down. Read: Deep power-down mode not entered. Write: No effect."]
            #[inline]
            pub fn not_deep_power_down(self) -> &'a mut W {
                self.variant(DPDFLAGW::NOT_DEEP_POWER_DOWN)
            }
            #[doc = "Deep power-down. Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            #[inline]
            pub fn deep_power_down(self) -> &'a mut W {
                self.variant(DPDFLAGW::DEEP_POWER_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Power mode"]
            #[inline]
            pub fn pm(&self) -> PMR {
                PMR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed. This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked."]
            #[inline]
            pub fn nodpd(&self) -> NODPDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NODPDR { bits }
            }
            #[doc = "Bit 8 - Sleep mode flag"]
            #[inline]
            pub fn sleepflag(&self) -> SLEEPFLAGR {
                SLEEPFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Deep power-down flag"]
            #[inline]
            pub fn dpdflag(&self) -> DPDFLAGR {
                DPDFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Power mode"]
            #[inline]
            pub fn pm(&mut self) -> _PMW {
                _PMW { w: self }
            }
            #[doc = "Bit 3 - A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed. This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked."]
            #[inline]
            pub fn nodpd(&mut self) -> _NODPDW {
                _NODPDW { w: self }
            }
            #[doc = "Bit 8 - Sleep mode flag"]
            #[inline]
            pub fn sleepflag(&mut self) -> _SLEEPFLAGW {
                _SLEEPFLAGW { w: self }
            }
            #[doc = "Bit 11 - Deep power-down flag"]
            #[inline]
            pub fn dpdflag(&mut self) -> _DPDFLAGW {
                _DPDFLAGW { w: self }
            }
        }
    }
    #[doc = "General purpose register 0"]
    pub struct GPREG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "General purpose register 0"]
    pub mod gpreg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GPREG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPDATAR {
            bits: u32,
        }
        impl GPDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPDATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPDATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data retained during Deep power-down mode."]
            #[inline]
            pub fn gpdata(&self) -> GPDATAR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                GPDATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data retained during Deep power-down mode."]
            #[inline]
            pub fn gpdata(&mut self) -> _GPDATAW {
                _GPDATAW { w: self }
            }
        }
    }
    #[doc = "Deep power-down control register. Also includes bits for general purpose storage."]
    pub struct DPDCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Deep power-down control register. Also includes bits for general purpose storage."]
    pub mod dpdctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DPDCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WAKEUPHYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKEUPHYSR {
            #[doc = "Disabled. Hysteresis for WAKEUP pin disabled."]
            DISABLED,
            #[doc = "Enabled. Hysteresis for WAKEUP pin enabled."]
            ENABLED,
        }
        impl WAKEUPHYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WAKEUPHYSR::DISABLED => false,
                    WAKEUPHYSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WAKEUPHYSR {
                match value {
                    false => WAKEUPHYSR::DISABLED,
                    true => WAKEUPHYSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WAKEUPHYSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WAKEUPHYSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `WAKEPAD_DISABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKEPAD_DISABLER {
            #[doc = "Enabled. The wake-up function is enabled on pin PIO0_4."]
            ENABLED,
            #[doc = "Disabled. Setting this bit disables the wake-up function on pin PIO0_4."]
            DISABLED,
        }
        impl WAKEPAD_DISABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WAKEPAD_DISABLER::ENABLED => false,
                    WAKEPAD_DISABLER::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WAKEPAD_DISABLER {
                match value {
                    false => WAKEPAD_DISABLER::ENABLED,
                    true => WAKEPAD_DISABLER::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WAKEPAD_DISABLER::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WAKEPAD_DISABLER::DISABLED
            }
        }
        #[doc = "Possible values of the field `LPOSCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPOSCENR {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl LPOSCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LPOSCENR::DISABLED => false,
                    LPOSCENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LPOSCENR {
                match value {
                    false => LPOSCENR::DISABLED,
                    true => LPOSCENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LPOSCENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == LPOSCENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `LPOSCDPDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPOSCDPDENR {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl LPOSCDPDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LPOSCDPDENR::DISABLED => false,
                    LPOSCDPDENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LPOSCDPDENR {
                match value {
                    false => LPOSCDPDENR::DISABLED,
                    true => LPOSCDPDENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LPOSCDPDENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == LPOSCDPDENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `WAKEUPCLKHYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKEUPCLKHYSR {
            #[doc = "Disabled. Hysteresis for WAKEUP clock pin disabled."]
            DISABLED,
            #[doc = "Enabled. Hysteresis for WAKEUP clock pin enabled."]
            ENABLED,
        }
        impl WAKEUPCLKHYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WAKEUPCLKHYSR::DISABLED => false,
                    WAKEUPCLKHYSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WAKEUPCLKHYSR {
                match value {
                    false => WAKEUPCLKHYSR::DISABLED,
                    true => WAKEUPCLKHYSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WAKEUPCLKHYSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WAKEUPCLKHYSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `WAKECLKPAD_DISABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKECLKPAD_DISABLER {
            #[doc = "Disabled. Setting this bit disables external clock input on pin PIO0_28."]
            DISABLED,
            #[doc = "Enabled. The external clock input for the self wake-up timer is enabled on pin PIO0_28."]
            ENABLED,
        }
        impl WAKECLKPAD_DISABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WAKECLKPAD_DISABLER::DISABLED => false,
                    WAKECLKPAD_DISABLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WAKECLKPAD_DISABLER {
                match value {
                    false => WAKECLKPAD_DISABLER::DISABLED,
                    true => WAKECLKPAD_DISABLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WAKECLKPAD_DISABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WAKECLKPAD_DISABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `WAKEUPHYS`"]
        pub enum WAKEUPHYSW {
            #[doc = "Disabled. Hysteresis for WAKEUP pin disabled."]
            DISABLED,
            #[doc = "Enabled. Hysteresis for WAKEUP pin enabled."]
            ENABLED,
        }
        impl WAKEUPHYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WAKEUPHYSW::DISABLED => false,
                    WAKEUPHYSW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPHYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPHYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAKEUPHYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Hysteresis for WAKEUP pin disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAKEUPHYSW::DISABLED)
            }
            #[doc = "Enabled. Hysteresis for WAKEUP pin enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAKEUPHYSW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAKEPAD_DISABLE`"]
        pub enum WAKEPAD_DISABLEW {
            #[doc = "Enabled. The wake-up function is enabled on pin PIO0_4."]
            ENABLED,
            #[doc = "Disabled. Setting this bit disables the wake-up function on pin PIO0_4."]
            DISABLED,
        }
        impl WAKEPAD_DISABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WAKEPAD_DISABLEW::ENABLED => false,
                    WAKEPAD_DISABLEW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEPAD_DISABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEPAD_DISABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAKEPAD_DISABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled. The wake-up function is enabled on pin PIO0_4."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAKEPAD_DISABLEW::ENABLED)
            }
            #[doc = "Disabled. Setting this bit disables the wake-up function on pin PIO0_4."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAKEPAD_DISABLEW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPOSCEN`"]
        pub enum LPOSCENW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl LPOSCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LPOSCENW::DISABLED => false,
                    LPOSCENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPOSCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPOSCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LPOSCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPOSCENW::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPOSCENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPOSCDPDEN`"]
        pub enum LPOSCDPDENW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl LPOSCDPDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LPOSCDPDENW::DISABLED => false,
                    LPOSCDPDENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPOSCDPDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPOSCDPDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LPOSCDPDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPOSCDPDENW::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPOSCDPDENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAKEUPCLKHYS`"]
        pub enum WAKEUPCLKHYSW {
            #[doc = "Disabled. Hysteresis for WAKEUP clock pin disabled."]
            DISABLED,
            #[doc = "Enabled. Hysteresis for WAKEUP clock pin enabled."]
            ENABLED,
        }
        impl WAKEUPCLKHYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WAKEUPCLKHYSW::DISABLED => false,
                    WAKEUPCLKHYSW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPCLKHYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPCLKHYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAKEUPCLKHYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Hysteresis for WAKEUP clock pin disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAKEUPCLKHYSW::DISABLED)
            }
            #[doc = "Enabled. Hysteresis for WAKEUP clock pin enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAKEUPCLKHYSW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAKECLKPAD_DISABLE`"]
        pub enum WAKECLKPAD_DISABLEW {
            #[doc = "Disabled. Setting this bit disables external clock input on pin PIO0_28."]
            DISABLED,
            #[doc = "Enabled. The external clock input for the self wake-up timer is enabled on pin PIO0_28."]
            ENABLED,
        }
        impl WAKECLKPAD_DISABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WAKECLKPAD_DISABLEW::DISABLED => false,
                    WAKECLKPAD_DISABLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKECLKPAD_DISABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKECLKPAD_DISABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAKECLKPAD_DISABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Setting this bit disables external clock input on pin PIO0_28."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAKECLKPAD_DISABLEW::DISABLED)
            }
            #[doc = "Enabled. The external clock input for the self wake-up timer is enabled on pin PIO0_28."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAKECLKPAD_DISABLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - WAKEUP pin hysteresis enable"]
            #[inline]
            pub fn wakeuphys(&self) -> WAKEUPHYSR {
                WAKEUPHYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - WAKEUP pin disable. Setting this bit disables the wake-up pin, so it can be used for other purposes. Never set this bit if you intend to use a pin to wake up the part from Deep power-down mode. You can only disable the wake-up pin if the self wake-up timer is enabled and configured. Setting this bit is not necessary if Deep power-down mode is not used."]
            #[inline]
            pub fn wakepad_disable(&self) -> WAKEPAD_DISABLER {
                WAKEPAD_DISABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable the low-power oscillator for use with the 10 kHz self wake-up timer clock. You must set this bit if the CLKSEL bit in the self wake-up timer CTRL bit is set. Do not enable the low-power oscillator if the self wake-up timer is clocked by the divided IRC or the external clock input."]
            #[inline]
            pub fn lposcen(&self) -> LPOSCENR {
                LPOSCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable the low-power oscillator in Deep power-down mode. Setting this bit causes the low-power oscillator to remain running during Deep power-down mode provided that bit 2 in this register is set as well. You must set this bit for the self wake-up timer to be able to wake up the part from Deep power-down mode. Do not set this bit unless you use the self wake-up timer with the low-power oscillator clock source to wake up from Deep power-down mode."]
            #[inline]
            pub fn lposcdpden(&self) -> LPOSCDPDENR {
                LPOSCDPDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - External clock input for the self wake-up timer WKTCLKIN hysteresis enable."]
            #[inline]
            pub fn wakeupclkhys(&self) -> WAKEUPCLKHYSR {
                WAKEUPCLKHYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Disable the external clock input for the self wake-up timer. Setting this bit enables the self wake-up timer clock pin WKTCLKLIN. To minimize power consumption, especially in deep power-down mode, disable this clock input when not using the external clock option for the self wake-up timer."]
            #[inline]
            pub fn wakeclkpad_disable(&self) -> WAKECLKPAD_DISABLER {
                WAKECLKPAD_DISABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - WAKEUP pin hysteresis enable"]
            #[inline]
            pub fn wakeuphys(&mut self) -> _WAKEUPHYSW {
                _WAKEUPHYSW { w: self }
            }
            #[doc = "Bit 1 - WAKEUP pin disable. Setting this bit disables the wake-up pin, so it can be used for other purposes. Never set this bit if you intend to use a pin to wake up the part from Deep power-down mode. You can only disable the wake-up pin if the self wake-up timer is enabled and configured. Setting this bit is not necessary if Deep power-down mode is not used."]
            #[inline]
            pub fn wakepad_disable(&mut self) -> _WAKEPAD_DISABLEW {
                _WAKEPAD_DISABLEW { w: self }
            }
            #[doc = "Bit 2 - Enable the low-power oscillator for use with the 10 kHz self wake-up timer clock. You must set this bit if the CLKSEL bit in the self wake-up timer CTRL bit is set. Do not enable the low-power oscillator if the self wake-up timer is clocked by the divided IRC or the external clock input."]
            #[inline]
            pub fn lposcen(&mut self) -> _LPOSCENW {
                _LPOSCENW { w: self }
            }
            #[doc = "Bit 3 - Enable the low-power oscillator in Deep power-down mode. Setting this bit causes the low-power oscillator to remain running during Deep power-down mode provided that bit 2 in this register is set as well. You must set this bit for the self wake-up timer to be able to wake up the part from Deep power-down mode. Do not set this bit unless you use the self wake-up timer with the low-power oscillator clock source to wake up from Deep power-down mode."]
            #[inline]
            pub fn lposcdpden(&mut self) -> _LPOSCDPDENW {
                _LPOSCDPDENW { w: self }
            }
            #[doc = "Bit 4 - External clock input for the self wake-up timer WKTCLKIN hysteresis enable."]
            #[inline]
            pub fn wakeupclkhys(&mut self) -> _WAKEUPCLKHYSW {
                _WAKEUPCLKHYSW { w: self }
            }
            #[doc = "Bit 5 - Disable the external clock input for the self wake-up timer. Setting this bit enables the self wake-up timer clock pin WKTCLKLIN. To minimize power consumption, especially in deep power-down mode, disable this clock input when not using the external clock option for the self wake-up timer."]
            #[inline]
            pub fn wakeclkpad_disable(&mut self) -> _WAKECLKPAD_DISABLEW {
                _WAKECLKPAD_DISABLEW { w: self }
            }
        }
    }
}
#[doc = "Analog comparator"]
pub struct CMP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CMP {}
impl CMP {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const cmp::RegisterBlock {
        0x4002_4000 as *const _
    }
}
impl Deref for CMP {
    type Target = cmp::RegisterBlock;
    fn deref(&self) -> &cmp::RegisterBlock {
        unsafe { &*CMP::ptr() }
    }
}
#[doc = "Analog comparator"]
pub mod cmp {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Comparator control register"]
        pub ctrl: CTRL,
        #[doc = "0x04 - Voltage ladder register"]
        pub lad: LAD,
    }
    #[doc = "Comparator control register"]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Comparator control register"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EDGESEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EDGESELR {
            #[doc = "Falling edges"]
            FALLING_EDGES,
            #[doc = "Rising edges"]
            RISING_EDGES,
            #[doc = "Both edges"]
            BOTH_EDGES_1,
            #[doc = "Both edges"]
            BOTH_EDGES_2,
        }
        impl EDGESELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EDGESELR::FALLING_EDGES => 0,
                    EDGESELR::RISING_EDGES => 0x01,
                    EDGESELR::BOTH_EDGES_1 => 0x02,
                    EDGESELR::BOTH_EDGES_2 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EDGESELR {
                match value {
                    0 => EDGESELR::FALLING_EDGES,
                    1 => EDGESELR::RISING_EDGES,
                    2 => EDGESELR::BOTH_EDGES_1,
                    3 => EDGESELR::BOTH_EDGES_2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES`"]
            #[inline]
            pub fn is_falling_edges(&self) -> bool {
                *self == EDGESELR::FALLING_EDGES
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES`"]
            #[inline]
            pub fn is_rising_edges(&self) -> bool {
                *self == EDGESELR::RISING_EDGES
            }
            #[doc = "Checks if the value of the field is `BOTH_EDGES_1`"]
            #[inline]
            pub fn is_both_edges_1(&self) -> bool {
                *self == EDGESELR::BOTH_EDGES_1
            }
            #[doc = "Checks if the value of the field is `BOTH_EDGES_2`"]
            #[inline]
            pub fn is_both_edges_2(&self) -> bool {
                *self == EDGESELR::BOTH_EDGES_2
            }
        }
        #[doc = "Possible values of the field `COMPSA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPSAR {
            #[doc = "Comparator output is used directly."]
            DIRECT,
            #[doc = "Comparator output is synchronized to the bus clock for output to other modules."]
            SYNC,
        }
        impl COMPSAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPSAR::DIRECT => false,
                    COMPSAR::SYNC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPSAR {
                match value {
                    false => COMPSAR::DIRECT,
                    true => COMPSAR::SYNC,
                }
            }
            #[doc = "Checks if the value of the field is `DIRECT`"]
            #[inline]
            pub fn is_direct(&self) -> bool {
                *self == COMPSAR::DIRECT
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline]
            pub fn is_sync(&self) -> bool {
                *self == COMPSAR::SYNC
            }
        }
        #[doc = "Possible values of the field `COMP_VP_SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP_VP_SELR {
            #[doc = "Voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "ACMP_I3"]
            ACMP_I3,
            #[doc = "ACMP_I4"]
            ACMP_I4,
            #[doc = "Band gap. Internal reference voltage."]
            BAND_GAP,
            #[doc = "ADC_0. ADC channel 0 input."]
            ADC_0,
        }
        impl COMP_VP_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMP_VP_SELR::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VP_SELR::ACMP_I1 => 0x01,
                    COMP_VP_SELR::ACMP_I2 => 0x02,
                    COMP_VP_SELR::ACMP_I3 => 0x03,
                    COMP_VP_SELR::ACMP_I4 => 0x04,
                    COMP_VP_SELR::BAND_GAP => 0x05,
                    COMP_VP_SELR::ADC_0 => 0x06,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> COMP_VP_SELR {
                match value {
                    0 => COMP_VP_SELR::VOLTAGE_LADDER_OUTPU,
                    1 => COMP_VP_SELR::ACMP_I1,
                    2 => COMP_VP_SELR::ACMP_I2,
                    3 => COMP_VP_SELR::ACMP_I3,
                    4 => COMP_VP_SELR::ACMP_I4,
                    5 => COMP_VP_SELR::BAND_GAP,
                    6 => COMP_VP_SELR::ADC_0,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `VOLTAGE_LADDER_OUTPU`"]
            #[inline]
            pub fn is_voltage_ladder_outpu(&self) -> bool {
                *self == COMP_VP_SELR::VOLTAGE_LADDER_OUTPU
            }
            #[doc = "Checks if the value of the field is `ACMP_I1`"]
            #[inline]
            pub fn is_acmp_i1(&self) -> bool {
                *self == COMP_VP_SELR::ACMP_I1
            }
            #[doc = "Checks if the value of the field is `ACMP_I2`"]
            #[inline]
            pub fn is_acmp_i2(&self) -> bool {
                *self == COMP_VP_SELR::ACMP_I2
            }
            #[doc = "Checks if the value of the field is `ACMP_I3`"]
            #[inline]
            pub fn is_acmp_i3(&self) -> bool {
                *self == COMP_VP_SELR::ACMP_I3
            }
            #[doc = "Checks if the value of the field is `ACMP_I4`"]
            #[inline]
            pub fn is_acmp_i4(&self) -> bool {
                *self == COMP_VP_SELR::ACMP_I4
            }
            #[doc = "Checks if the value of the field is `BAND_GAP`"]
            #[inline]
            pub fn is_band_gap(&self) -> bool {
                *self == COMP_VP_SELR::BAND_GAP
            }
            #[doc = "Checks if the value of the field is `ADC_0`"]
            #[inline]
            pub fn is_adc_0(&self) -> bool {
                *self == COMP_VP_SELR::ADC_0
            }
        }
        #[doc = "Possible values of the field `COMP_VM_SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP_VM_SELR {
            #[doc = "Voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "ACMP_I3"]
            ACMP_I3,
            #[doc = "ACMP_I4"]
            ACMP_I4,
            #[doc = "Band gap. Internal reference voltage."]
            BAND_GAP,
            #[doc = "ADC_0. ADC channel 0 input."]
            ADC_0,
        }
        impl COMP_VM_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMP_VM_SELR::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VM_SELR::ACMP_I1 => 0x01,
                    COMP_VM_SELR::ACMP_I2 => 0x02,
                    COMP_VM_SELR::ACMP_I3 => 0x03,
                    COMP_VM_SELR::ACMP_I4 => 0x04,
                    COMP_VM_SELR::BAND_GAP => 0x05,
                    COMP_VM_SELR::ADC_0 => 0x06,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> COMP_VM_SELR {
                match value {
                    0 => COMP_VM_SELR::VOLTAGE_LADDER_OUTPU,
                    1 => COMP_VM_SELR::ACMP_I1,
                    2 => COMP_VM_SELR::ACMP_I2,
                    3 => COMP_VM_SELR::ACMP_I3,
                    4 => COMP_VM_SELR::ACMP_I4,
                    5 => COMP_VM_SELR::BAND_GAP,
                    6 => COMP_VM_SELR::ADC_0,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `VOLTAGE_LADDER_OUTPU`"]
            #[inline]
            pub fn is_voltage_ladder_outpu(&self) -> bool {
                *self == COMP_VM_SELR::VOLTAGE_LADDER_OUTPU
            }
            #[doc = "Checks if the value of the field is `ACMP_I1`"]
            #[inline]
            pub fn is_acmp_i1(&self) -> bool {
                *self == COMP_VM_SELR::ACMP_I1
            }
            #[doc = "Checks if the value of the field is `ACMP_I2`"]
            #[inline]
            pub fn is_acmp_i2(&self) -> bool {
                *self == COMP_VM_SELR::ACMP_I2
            }
            #[doc = "Checks if the value of the field is `ACMP_I3`"]
            #[inline]
            pub fn is_acmp_i3(&self) -> bool {
                *self == COMP_VM_SELR::ACMP_I3
            }
            #[doc = "Checks if the value of the field is `ACMP_I4`"]
            #[inline]
            pub fn is_acmp_i4(&self) -> bool {
                *self == COMP_VM_SELR::ACMP_I4
            }
            #[doc = "Checks if the value of the field is `BAND_GAP`"]
            #[inline]
            pub fn is_band_gap(&self) -> bool {
                *self == COMP_VM_SELR::BAND_GAP
            }
            #[doc = "Checks if the value of the field is `ADC_0`"]
            #[inline]
            pub fn is_adc_0(&self) -> bool {
                *self == COMP_VM_SELR::ADC_0
            }
        }
        #[doc = r" Value of the field"]
        pub struct EDGECLRR {
            bits: bool,
        }
        impl EDGECLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPSTATR {
            bits: bool,
        }
        impl COMPSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEDGER {
            bits: bool,
        }
        impl COMPEDGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "None (the output will switch as the voltages cross)"]
            NONE_THE_OUTPUT_WIL,
            #[doc = "5 mV"]
            _5_MV,
            #[doc = "10 mV"]
            _10_MV,
            #[doc = "20  mV"]
            _20_MV,
        }
        impl HYSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    HYSR::NONE_THE_OUTPUT_WIL => 0,
                    HYSR::_5_MV => 0x01,
                    HYSR::_10_MV => 0x02,
                    HYSR::_20_MV => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> HYSR {
                match value {
                    0 => HYSR::NONE_THE_OUTPUT_WIL,
                    1 => HYSR::_5_MV,
                    2 => HYSR::_10_MV,
                    3 => HYSR::_20_MV,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NONE_THE_OUTPUT_WIL`"]
            #[inline]
            pub fn is_none_the_output_wil(&self) -> bool {
                *self == HYSR::NONE_THE_OUTPUT_WIL
            }
            #[doc = "Checks if the value of the field is `_5_MV`"]
            #[inline]
            pub fn is_5_mv(&self) -> bool {
                *self == HYSR::_5_MV
            }
            #[doc = "Checks if the value of the field is `_10_MV`"]
            #[inline]
            pub fn is_10_mv(&self) -> bool {
                *self == HYSR::_10_MV
            }
            #[doc = "Checks if the value of the field is `_20_MV`"]
            #[inline]
            pub fn is_20_mv(&self) -> bool {
                *self == HYSR::_20_MV
            }
        }
        #[doc = "Values that can be written to the field `EDGESEL`"]
        pub enum EDGESELW {
            #[doc = "Falling edges"]
            FALLING_EDGES,
            #[doc = "Rising edges"]
            RISING_EDGES,
            #[doc = "Both edges"]
            BOTH_EDGES_1,
            #[doc = "Both edges"]
            BOTH_EDGES_2,
        }
        impl EDGESELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EDGESELW::FALLING_EDGES => 0,
                    EDGESELW::RISING_EDGES => 1,
                    EDGESELW::BOTH_EDGES_1 => 2,
                    EDGESELW::BOTH_EDGES_2 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EDGESELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EDGESELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EDGESELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Falling edges"]
            #[inline]
            pub fn falling_edges(self) -> &'a mut W {
                self.variant(EDGESELW::FALLING_EDGES)
            }
            #[doc = "Rising edges"]
            #[inline]
            pub fn rising_edges(self) -> &'a mut W {
                self.variant(EDGESELW::RISING_EDGES)
            }
            #[doc = "Both edges"]
            #[inline]
            pub fn both_edges_1(self) -> &'a mut W {
                self.variant(EDGESELW::BOTH_EDGES_1)
            }
            #[doc = "Both edges"]
            #[inline]
            pub fn both_edges_2(self) -> &'a mut W {
                self.variant(EDGESELW::BOTH_EDGES_2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPSA`"]
        pub enum COMPSAW {
            #[doc = "Comparator output is used directly."]
            DIRECT,
            #[doc = "Comparator output is synchronized to the bus clock for output to other modules."]
            SYNC,
        }
        impl COMPSAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPSAW::DIRECT => false,
                    COMPSAW::SYNC => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPSAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPSAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Comparator output is used directly."]
            #[inline]
            pub fn direct(self) -> &'a mut W {
                self.variant(COMPSAW::DIRECT)
            }
            #[doc = "Comparator output is synchronized to the bus clock for output to other modules."]
            #[inline]
            pub fn sync(self) -> &'a mut W {
                self.variant(COMPSAW::SYNC)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMP_VP_SEL`"]
        pub enum COMP_VP_SELW {
            #[doc = "Voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "ACMP_I3"]
            ACMP_I3,
            #[doc = "ACMP_I4"]
            ACMP_I4,
            #[doc = "Band gap. Internal reference voltage."]
            BAND_GAP,
            #[doc = "ADC_0. ADC channel 0 input."]
            ADC_0,
        }
        impl COMP_VP_SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMP_VP_SELW::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VP_SELW::ACMP_I1 => 1,
                    COMP_VP_SELW::ACMP_I2 => 2,
                    COMP_VP_SELW::ACMP_I3 => 3,
                    COMP_VP_SELW::ACMP_I4 => 4,
                    COMP_VP_SELW::BAND_GAP => 5,
                    COMP_VP_SELW::ADC_0 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP_VP_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP_VP_SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMP_VP_SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Voltage ladder output"]
            #[inline]
            pub fn voltage_ladder_outpu(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::VOLTAGE_LADDER_OUTPU)
            }
            #[doc = "ACMP_I1"]
            #[inline]
            pub fn acmp_i1(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::ACMP_I1)
            }
            #[doc = "ACMP_I2"]
            #[inline]
            pub fn acmp_i2(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::ACMP_I2)
            }
            #[doc = "ACMP_I3"]
            #[inline]
            pub fn acmp_i3(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::ACMP_I3)
            }
            #[doc = "ACMP_I4"]
            #[inline]
            pub fn acmp_i4(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::ACMP_I4)
            }
            #[doc = "Band gap. Internal reference voltage."]
            #[inline]
            pub fn band_gap(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::BAND_GAP)
            }
            #[doc = "ADC_0. ADC channel 0 input."]
            #[inline]
            pub fn adc_0(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::ADC_0)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMP_VM_SEL`"]
        pub enum COMP_VM_SELW {
            #[doc = "Voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "ACMP_I3"]
            ACMP_I3,
            #[doc = "ACMP_I4"]
            ACMP_I4,
            #[doc = "Band gap. Internal reference voltage."]
            BAND_GAP,
            #[doc = "ADC_0. ADC channel 0 input."]
            ADC_0,
        }
        impl COMP_VM_SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMP_VM_SELW::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VM_SELW::ACMP_I1 => 1,
                    COMP_VM_SELW::ACMP_I2 => 2,
                    COMP_VM_SELW::ACMP_I3 => 3,
                    COMP_VM_SELW::ACMP_I4 => 4,
                    COMP_VM_SELW::BAND_GAP => 5,
                    COMP_VM_SELW::ADC_0 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP_VM_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP_VM_SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMP_VM_SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Voltage ladder output"]
            #[inline]
            pub fn voltage_ladder_outpu(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::VOLTAGE_LADDER_OUTPU)
            }
            #[doc = "ACMP_I1"]
            #[inline]
            pub fn acmp_i1(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::ACMP_I1)
            }
            #[doc = "ACMP_I2"]
            #[inline]
            pub fn acmp_i2(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::ACMP_I2)
            }
            #[doc = "ACMP_I3"]
            #[inline]
            pub fn acmp_i3(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::ACMP_I3)
            }
            #[doc = "ACMP_I4"]
            #[inline]
            pub fn acmp_i4(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::ACMP_I4)
            }
            #[doc = "Band gap. Internal reference voltage."]
            #[inline]
            pub fn band_gap(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::BAND_GAP)
            }
            #[doc = "ADC_0. ADC channel 0 input."]
            #[inline]
            pub fn adc_0(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::ADC_0)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EDGECLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EDGECLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEDGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEDGEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "None (the output will switch as the voltages cross)"]
            NONE_THE_OUTPUT_WIL,
            #[doc = "5 mV"]
            _5_MV,
            #[doc = "10 mV"]
            _10_MV,
            #[doc = "20  mV"]
            _20_MV,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HYSW::NONE_THE_OUTPUT_WIL => 0,
                    HYSW::_5_MV => 1,
                    HYSW::_10_MV => 2,
                    HYSW::_20_MV => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "None (the output will switch as the voltages cross)"]
            #[inline]
            pub fn none_the_output_wil(self) -> &'a mut W {
                self.variant(HYSW::NONE_THE_OUTPUT_WIL)
            }
            #[doc = "5 mV"]
            #[inline]
            pub fn _5_mv(self) -> &'a mut W {
                self.variant(HYSW::_5_MV)
            }
            #[doc = "10 mV"]
            #[inline]
            pub fn _10_mv(self) -> &'a mut W {
                self.variant(HYSW::_10_MV)
            }
            #[doc = "20 mV"]
            #[inline]
            pub fn _20_mv(self) -> &'a mut W {
                self.variant(HYSW::_20_MV)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - This field controls which edges on the comparator output set the COMPEDGE bit (bit 23 below):"]
            #[inline]
            pub fn edgesel(&self) -> EDGESELR {
                EDGESELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 6 - Comparator output control"]
            #[inline]
            pub fn compsa(&self) -> COMPSAR {
                COMPSAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:10 - Selects positive voltage input"]
            #[inline]
            pub fn comp_vp_sel(&self) -> COMP_VP_SELR {
                COMP_VP_SELR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:13 - Selects negative voltage input"]
            #[inline]
            pub fn comp_vm_sel(&self) -> COMP_VM_SELR {
                COMP_VM_SELR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 20 - Interrupt clear bit. To clear the COMPEDGE bit and thus negate the interrupt request, toggle the EDGECLR bit by first writing a 1 and then a 0."]
            #[inline]
            pub fn edgeclr(&self) -> EDGECLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EDGECLRR { bits }
            }
            #[doc = "Bit 21 - Comparator status. This bit reflects the state of the comparator output."]
            #[inline]
            pub fn compstat(&self) -> COMPSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMPSTATR { bits }
            }
            #[doc = "Bit 23 - Comparator edge-detect status."]
            #[inline]
            pub fn compedge(&self) -> COMPEDGER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMPEDGER { bits }
            }
            #[doc = "Bits 25:26 - Controls the hysteresis of the comparator. When the comparator is outputting a certain state, this is the difference between the selected signals, in the opposite direction from the state being output, that will switch the output."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - This field controls which edges on the comparator output set the COMPEDGE bit (bit 23 below):"]
            #[inline]
            pub fn edgesel(&mut self) -> _EDGESELW {
                _EDGESELW { w: self }
            }
            #[doc = "Bit 6 - Comparator output control"]
            #[inline]
            pub fn compsa(&mut self) -> _COMPSAW {
                _COMPSAW { w: self }
            }
            #[doc = "Bits 8:10 - Selects positive voltage input"]
            #[inline]
            pub fn comp_vp_sel(&mut self) -> _COMP_VP_SELW {
                _COMP_VP_SELW { w: self }
            }
            #[doc = "Bits 11:13 - Selects negative voltage input"]
            #[inline]
            pub fn comp_vm_sel(&mut self) -> _COMP_VM_SELW {
                _COMP_VM_SELW { w: self }
            }
            #[doc = "Bit 20 - Interrupt clear bit. To clear the COMPEDGE bit and thus negate the interrupt request, toggle the EDGECLR bit by first writing a 1 and then a 0."]
            #[inline]
            pub fn edgeclr(&mut self) -> _EDGECLRW {
                _EDGECLRW { w: self }
            }
            #[doc = "Bit 21 - Comparator status. This bit reflects the state of the comparator output."]
            #[inline]
            pub fn compstat(&mut self) -> _COMPSTATW {
                _COMPSTATW { w: self }
            }
            #[doc = "Bit 23 - Comparator edge-detect status."]
            #[inline]
            pub fn compedge(&mut self) -> _COMPEDGEW {
                _COMPEDGEW { w: self }
            }
            #[doc = "Bits 25:26 - Controls the hysteresis of the comparator. When the comparator is outputting a certain state, this is the difference between the selected signals, in the opposite direction from the state being output, that will switch the output."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
        }
    }
    #[doc = "Voltage ladder register"]
    pub struct LAD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Voltage ladder register"]
    pub mod lad {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LAD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LADENR {
            bits: bool,
        }
        impl LADENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LADSELR {
            bits: u8,
        }
        impl LADSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `LADREF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LADREFR {
            #[doc = "Supply pin VDD"]
            SUPPLY_PIN_VDD,
            #[doc = "VDDCMP pin"]
            VDDCMP_PIN,
        }
        impl LADREFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LADREFR::SUPPLY_PIN_VDD => false,
                    LADREFR::VDDCMP_PIN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LADREFR {
                match value {
                    false => LADREFR::SUPPLY_PIN_VDD,
                    true => LADREFR::VDDCMP_PIN,
                }
            }
            #[doc = "Checks if the value of the field is `SUPPLY_PIN_VDD`"]
            #[inline]
            pub fn is_supply_pin_vdd(&self) -> bool {
                *self == LADREFR::SUPPLY_PIN_VDD
            }
            #[doc = "Checks if the value of the field is `VDDCMP_PIN`"]
            #[inline]
            pub fn is_vddcmp_pin(&self) -> bool {
                *self == LADREFR::VDDCMP_PIN
            }
        }
        #[doc = r" Proxy"]
        pub struct _LADENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LADENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LADSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LADSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LADREF`"]
        pub enum LADREFW {
            #[doc = "Supply pin VDD"]
            SUPPLY_PIN_VDD,
            #[doc = "VDDCMP pin"]
            VDDCMP_PIN,
        }
        impl LADREFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LADREFW::SUPPLY_PIN_VDD => false,
                    LADREFW::VDDCMP_PIN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LADREFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LADREFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LADREFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Supply pin VDD"]
            #[inline]
            pub fn supply_pin_vdd(self) -> &'a mut W {
                self.variant(LADREFW::SUPPLY_PIN_VDD)
            }
            #[doc = "VDDCMP pin"]
            #[inline]
            pub fn vddcmp_pin(self) -> &'a mut W {
                self.variant(LADREFW::VDDCMP_PIN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Voltage ladder enable"]
            #[inline]
            pub fn laden(&self) -> LADENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LADENR { bits }
            }
            #[doc = "Bits 1:5 - Voltage ladder value. The reference voltage Vref depends on the LADREF bit below. 00000 = VSS 00001 = 1 x Vref/31 00010 = 2 x Vref/31 ... 11111 = Vref"]
            #[inline]
            pub fn ladsel(&self) -> LADSELR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LADSELR { bits }
            }
            #[doc = "Bit 6 - Selects the reference voltage Vref for the voltage ladder:"]
            #[inline]
            pub fn ladref(&self) -> LADREFR {
                LADREFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Voltage ladder enable"]
            #[inline]
            pub fn laden(&mut self) -> _LADENW {
                _LADENW { w: self }
            }
            #[doc = "Bits 1:5 - Voltage ladder value. The reference voltage Vref depends on the LADREF bit below. 00000 = VSS 00001 = 1 x Vref/31 00010 = 2 x Vref/31 ... 11111 = Vref"]
            #[inline]
            pub fn ladsel(&mut self) -> _LADSELW {
                _LADSELW { w: self }
            }
            #[doc = "Bit 6 - Selects the reference voltage Vref for the voltage ladder:"]
            #[inline]
            pub fn ladref(&mut self) -> _LADREFW {
                _LADREFW { w: self }
            }
        }
    }
}
#[doc = "DMA trigger mux"]
pub struct DMATRIGMUX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMATRIGMUX {}
impl DMATRIGMUX {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dmatrigmux::RegisterBlock {
        0x4002_8000 as *const _
    }
}
impl Deref for DMATRIGMUX {
    type Target = dmatrigmux::RegisterBlock;
    fn deref(&self) -> &dmatrigmux::RegisterBlock {
        unsafe { &*DMATRIGMUX::ptr() }
    }
}
#[doc = "DMA trigger mux"]
pub mod dmatrigmux {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Input mux register for trigger inputs 0 to 23 connected to DMA channel 0. Selects from ADC, SCT, ACMP, pin interrupts, and DMA requests."]
        pub dma_itrig_inmux: [DMA_ITRIG_INMUX; 18],
    }
    #[doc = "Input mux register for trigger inputs 0 to 23 connected to DMA channel 0. Selects from ADC, SCT, ACMP, pin interrupts, and DMA requests."]
    pub struct DMA_ITRIG_INMUX {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Input mux register for trigger inputs 0 to 23 connected to DMA channel 0. Selects from ADC, SCT, ACMP, pin interrupts, and DMA requests."]
    pub mod dma_itrig_inmux {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_ITRIG_INMUX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INPR {
            #[doc = "ADC_SEQA_IRQ"]
            ADC_SEQA_IRQ,
            #[doc = "ADC_SEQB_IRQ"]
            ADC_SEQB_IRQ,
            #[doc = "SCT_DMA0"]
            SCT_DMA0,
            #[doc = "SCT_DMA1"]
            SCT_DMA1,
            #[doc = "ACMP_O"]
            ACMP_O,
            #[doc = "PININT0"]
            PININT0,
            #[doc = "PININT1"]
            PININT1,
            #[doc = "DMA trigger mux 0. (DMA_INMUX_INMUX0)."]
            DMA_TRIGGER_MUX_0,
            #[doc = "DMA trigger mux 1. (DMA_INMUX_INMUX1)"]
            DMA_TRIGGER_MUX_1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl INPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    INPR::ADC_SEQA_IRQ => 0,
                    INPR::ADC_SEQB_IRQ => 0x01,
                    INPR::SCT_DMA0 => 0x02,
                    INPR::SCT_DMA1 => 0x03,
                    INPR::ACMP_O => 0x04,
                    INPR::PININT0 => 0x05,
                    INPR::PININT1 => 0x06,
                    INPR::DMA_TRIGGER_MUX_0 => 0x07,
                    INPR::DMA_TRIGGER_MUX_1 => 0x08,
                    INPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> INPR {
                match value {
                    0 => INPR::ADC_SEQA_IRQ,
                    1 => INPR::ADC_SEQB_IRQ,
                    2 => INPR::SCT_DMA0,
                    3 => INPR::SCT_DMA1,
                    4 => INPR::ACMP_O,
                    5 => INPR::PININT0,
                    6 => INPR::PININT1,
                    7 => INPR::DMA_TRIGGER_MUX_0,
                    8 => INPR::DMA_TRIGGER_MUX_1,
                    i => INPR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ADC_SEQA_IRQ`"]
            #[inline]
            pub fn is_adc_seqa_irq(&self) -> bool {
                *self == INPR::ADC_SEQA_IRQ
            }
            #[doc = "Checks if the value of the field is `ADC_SEQB_IRQ`"]
            #[inline]
            pub fn is_adc_seqb_irq(&self) -> bool {
                *self == INPR::ADC_SEQB_IRQ
            }
            #[doc = "Checks if the value of the field is `SCT_DMA0`"]
            #[inline]
            pub fn is_sct_dma0(&self) -> bool {
                *self == INPR::SCT_DMA0
            }
            #[doc = "Checks if the value of the field is `SCT_DMA1`"]
            #[inline]
            pub fn is_sct_dma1(&self) -> bool {
                *self == INPR::SCT_DMA1
            }
            #[doc = "Checks if the value of the field is `ACMP_O`"]
            #[inline]
            pub fn is_acmp_o(&self) -> bool {
                *self == INPR::ACMP_O
            }
            #[doc = "Checks if the value of the field is `PININT0`"]
            #[inline]
            pub fn is_pinint0(&self) -> bool {
                *self == INPR::PININT0
            }
            #[doc = "Checks if the value of the field is `PININT1`"]
            #[inline]
            pub fn is_pinint1(&self) -> bool {
                *self == INPR::PININT1
            }
            #[doc = "Checks if the value of the field is `DMA_TRIGGER_MUX_0`"]
            #[inline]
            pub fn is_dma_trigger_mux_0(&self) -> bool {
                *self == INPR::DMA_TRIGGER_MUX_0
            }
            #[doc = "Checks if the value of the field is `DMA_TRIGGER_MUX_1`"]
            #[inline]
            pub fn is_dma_trigger_mux_1(&self) -> bool {
                *self == INPR::DMA_TRIGGER_MUX_1
            }
        }
        #[doc = "Values that can be written to the field `INP`"]
        pub enum INPW {
            #[doc = "ADC_SEQA_IRQ"]
            ADC_SEQA_IRQ,
            #[doc = "ADC_SEQB_IRQ"]
            ADC_SEQB_IRQ,
            #[doc = "SCT_DMA0"]
            SCT_DMA0,
            #[doc = "SCT_DMA1"]
            SCT_DMA1,
            #[doc = "ACMP_O"]
            ACMP_O,
            #[doc = "PININT0"]
            PININT0,
            #[doc = "PININT1"]
            PININT1,
            #[doc = "DMA trigger mux 0. (DMA_INMUX_INMUX0)."]
            DMA_TRIGGER_MUX_0,
            #[doc = "DMA trigger mux 1. (DMA_INMUX_INMUX1)"]
            DMA_TRIGGER_MUX_1,
        }
        impl INPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    INPW::ADC_SEQA_IRQ => 0,
                    INPW::ADC_SEQB_IRQ => 1,
                    INPW::SCT_DMA0 => 2,
                    INPW::SCT_DMA1 => 3,
                    INPW::ACMP_O => 4,
                    INPW::PININT0 => 5,
                    INPW::PININT1 => 6,
                    INPW::DMA_TRIGGER_MUX_0 => 7,
                    INPW::DMA_TRIGGER_MUX_1 => 8,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INPW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "ADC_SEQA_IRQ"]
            #[inline]
            pub fn adc_seqa_irq(self) -> &'a mut W {
                self.variant(INPW::ADC_SEQA_IRQ)
            }
            #[doc = "ADC_SEQB_IRQ"]
            #[inline]
            pub fn adc_seqb_irq(self) -> &'a mut W {
                self.variant(INPW::ADC_SEQB_IRQ)
            }
            #[doc = "SCT_DMA0"]
            #[inline]
            pub fn sct_dma0(self) -> &'a mut W {
                self.variant(INPW::SCT_DMA0)
            }
            #[doc = "SCT_DMA1"]
            #[inline]
            pub fn sct_dma1(self) -> &'a mut W {
                self.variant(INPW::SCT_DMA1)
            }
            #[doc = "ACMP_O"]
            #[inline]
            pub fn acmp_o(self) -> &'a mut W {
                self.variant(INPW::ACMP_O)
            }
            #[doc = "PININT0"]
            #[inline]
            pub fn pinint0(self) -> &'a mut W {
                self.variant(INPW::PININT0)
            }
            #[doc = "PININT1"]
            #[inline]
            pub fn pinint1(self) -> &'a mut W {
                self.variant(INPW::PININT1)
            }
            #[doc = "DMA trigger mux 0. (DMA_INMUX_INMUX0)."]
            #[inline]
            pub fn dma_trigger_mux_0(self) -> &'a mut W {
                self.variant(INPW::DMA_TRIGGER_MUX_0)
            }
            #[doc = "DMA trigger mux 1. (DMA_INMUX_INMUX1)"]
            #[inline]
            pub fn dma_trigger_mux_1(self) -> &'a mut W {
                self.variant(INPW::DMA_TRIGGER_MUX_1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Trigger input number (decimal value) for DMA channel n (n = 0 to 8). All other values are reserved."]
            #[inline]
            pub fn inp(&self) -> INPR {
                INPR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Trigger input number (decimal value) for DMA channel n (n = 0 to 8). All other values are reserved."]
            #[inline]
            pub fn inp(&mut self) -> _INPW {
                _INPW { w: self }
            }
        }
    }
}
#[doc = "Input multiplexing"]
pub struct INPUTMUX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for INPUTMUX {}
impl INPUTMUX {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const inputmux::RegisterBlock {
        0x4002_c000 as *const _
    }
}
impl Deref for INPUTMUX {
    type Target = inputmux::RegisterBlock;
    fn deref(&self) -> &inputmux::RegisterBlock {
        unsafe { &*INPUTMUX::ptr() }
    }
}
#[doc = "Input multiplexing"]
pub mod inputmux {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Input mux register for DMA trigger input 20. Selects from 18 DMA trigger outputs."]
        pub dma_inmux_inmux: [DMA_INMUX_INMUX; 2],
        _reserved0: [u8; 24usize],
        #[doc = "0x20 - Input mux register for SCT input 0"]
        pub sct0_inmux: [SCT0_INMUX; 4],
    }
    #[doc = "Input mux register for DMA trigger input 20. Selects from 18 DMA trigger outputs."]
    pub struct DMA_INMUX_INMUX {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Input mux register for DMA trigger input 20. Selects from 18 DMA trigger outputs."]
    pub mod dma_inmux_inmux {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_INMUX_INMUX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct INPR {
            bits: u8,
        }
        impl INPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - DMA trigger output number (decimal value) for DMA channel n (n = 0 to 17)."]
            #[inline]
            pub fn inp(&self) -> INPR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x1f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - DMA trigger output number (decimal value) for DMA channel n (n = 0 to 17)."]
            #[inline]
            pub fn inp(&mut self) -> _INPW {
                _INPW { w: self }
            }
        }
    }
    #[doc = "Input mux register for SCT input 0"]
    pub struct SCT0_INMUX {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Input mux register for SCT input 0"]
    pub mod sct0_inmux {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCT0_INMUX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INP_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INP_NR {
            #[doc = "SCT_IN0  change the name since this is not the function sct_in0 but the first selection for sct input in the mux.in fact it could be functionally sct_in3 (input 3 of the sct). Assign to pin using the switch matrix."]
            SCT_IN0_CHANGE_THE,
            #[doc = "SCT_IN1. Assign to pin using the switch matrix."]
            SCT_IN1,
            #[doc = "SCT_IN2. Assign to pin using the switch matrix."]
            SCT_IN2,
            #[doc = "SCT_IN3. Assign to pin using the switch matrix."]
            SCT_IN3,
            #[doc = "ADC_THCMP_IRQ"]
            ADC_THCMP_IRQ,
            #[doc = "ACMP_O"]
            ACMP_O,
            #[doc = "ARM_TXEV"]
            ARM_TXEV,
            #[doc = "DEBUG_HALTED"]
            DEBUG_HALTED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl INP_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    INP_NR::SCT_IN0_CHANGE_THE => 0,
                    INP_NR::SCT_IN1 => 0x01,
                    INP_NR::SCT_IN2 => 0x02,
                    INP_NR::SCT_IN3 => 0x03,
                    INP_NR::ADC_THCMP_IRQ => 0x04,
                    INP_NR::ACMP_O => 0x05,
                    INP_NR::ARM_TXEV => 0x06,
                    INP_NR::DEBUG_HALTED => 0x07,
                    INP_NR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> INP_NR {
                match value {
                    0 => INP_NR::SCT_IN0_CHANGE_THE,
                    1 => INP_NR::SCT_IN1,
                    2 => INP_NR::SCT_IN2,
                    3 => INP_NR::SCT_IN3,
                    4 => INP_NR::ADC_THCMP_IRQ,
                    5 => INP_NR::ACMP_O,
                    6 => INP_NR::ARM_TXEV,
                    7 => INP_NR::DEBUG_HALTED,
                    i => INP_NR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SCT_IN0_CHANGE_THE`"]
            #[inline]
            pub fn is_sct_in0_change_the(&self) -> bool {
                *self == INP_NR::SCT_IN0_CHANGE_THE
            }
            #[doc = "Checks if the value of the field is `SCT_IN1`"]
            #[inline]
            pub fn is_sct_in1(&self) -> bool {
                *self == INP_NR::SCT_IN1
            }
            #[doc = "Checks if the value of the field is `SCT_IN2`"]
            #[inline]
            pub fn is_sct_in2(&self) -> bool {
                *self == INP_NR::SCT_IN2
            }
            #[doc = "Checks if the value of the field is `SCT_IN3`"]
            #[inline]
            pub fn is_sct_in3(&self) -> bool {
                *self == INP_NR::SCT_IN3
            }
            #[doc = "Checks if the value of the field is `ADC_THCMP_IRQ`"]
            #[inline]
            pub fn is_adc_thcmp_irq(&self) -> bool {
                *self == INP_NR::ADC_THCMP_IRQ
            }
            #[doc = "Checks if the value of the field is `ACMP_O`"]
            #[inline]
            pub fn is_acmp_o(&self) -> bool {
                *self == INP_NR::ACMP_O
            }
            #[doc = "Checks if the value of the field is `ARM_TXEV`"]
            #[inline]
            pub fn is_arm_txev(&self) -> bool {
                *self == INP_NR::ARM_TXEV
            }
            #[doc = "Checks if the value of the field is `DEBUG_HALTED`"]
            #[inline]
            pub fn is_debug_halted(&self) -> bool {
                *self == INP_NR::DEBUG_HALTED
            }
        }
        #[doc = "Values that can be written to the field `INP_N`"]
        pub enum INP_NW {
            #[doc = "SCT_IN0  change the name since this is not the function sct_in0 but the first selection for sct input in the mux.in fact it could be functionally sct_in3 (input 3 of the sct). Assign to pin using the switch matrix."]
            SCT_IN0_CHANGE_THE,
            #[doc = "SCT_IN1. Assign to pin using the switch matrix."]
            SCT_IN1,
            #[doc = "SCT_IN2. Assign to pin using the switch matrix."]
            SCT_IN2,
            #[doc = "SCT_IN3. Assign to pin using the switch matrix."]
            SCT_IN3,
            #[doc = "ADC_THCMP_IRQ"]
            ADC_THCMP_IRQ,
            #[doc = "ACMP_O"]
            ACMP_O,
            #[doc = "ARM_TXEV"]
            ARM_TXEV,
            #[doc = "DEBUG_HALTED"]
            DEBUG_HALTED,
        }
        impl INP_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    INP_NW::SCT_IN0_CHANGE_THE => 0,
                    INP_NW::SCT_IN1 => 1,
                    INP_NW::SCT_IN2 => 2,
                    INP_NW::SCT_IN3 => 3,
                    INP_NW::ADC_THCMP_IRQ => 4,
                    INP_NW::ACMP_O => 5,
                    INP_NW::ARM_TXEV => 6,
                    INP_NW::DEBUG_HALTED => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INP_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INP_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INP_NW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "SCT_IN0 change the name since this is not the function sct_in0 but the first selection for sct input in the mux.in fact it could be functionally sct_in3 (input 3 of the sct). Assign to pin using the switch matrix."]
            #[inline]
            pub fn sct_in0_change_the(self) -> &'a mut W {
                self.variant(INP_NW::SCT_IN0_CHANGE_THE)
            }
            #[doc = "SCT_IN1. Assign to pin using the switch matrix."]
            #[inline]
            pub fn sct_in1(self) -> &'a mut W {
                self.variant(INP_NW::SCT_IN1)
            }
            #[doc = "SCT_IN2. Assign to pin using the switch matrix."]
            #[inline]
            pub fn sct_in2(self) -> &'a mut W {
                self.variant(INP_NW::SCT_IN2)
            }
            #[doc = "SCT_IN3. Assign to pin using the switch matrix."]
            #[inline]
            pub fn sct_in3(self) -> &'a mut W {
                self.variant(INP_NW::SCT_IN3)
            }
            #[doc = "ADC_THCMP_IRQ"]
            #[inline]
            pub fn adc_thcmp_irq(self) -> &'a mut W {
                self.variant(INP_NW::ADC_THCMP_IRQ)
            }
            #[doc = "ACMP_O"]
            #[inline]
            pub fn acmp_o(self) -> &'a mut W {
                self.variant(INP_NW::ACMP_O)
            }
            #[doc = "ARM_TXEV"]
            #[inline]
            pub fn arm_txev(self) -> &'a mut W {
                self.variant(INP_NW::ARM_TXEV)
            }
            #[doc = "DEBUG_HALTED"]
            #[inline]
            pub fn debug_halted(self) -> &'a mut W {
                self.variant(INP_NW::DEBUG_HALTED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Input number (decimal value) to SCT0 inputs 0 to 3."]
            #[inline]
            pub fn inp_n(&self) -> INP_NR {
                INP_NR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Input number (decimal value) to SCT0 inputs 0 to 3."]
            #[inline]
            pub fn inp_n(&mut self) -> _INP_NW {
                _INP_NW { w: self }
            }
        }
    }
}
#[doc = "Flash controller"]
pub struct FLASHCTRL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASHCTRL {}
impl FLASHCTRL {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const flashctrl::RegisterBlock {
        0x4004_0000 as *const _
    }
}
impl Deref for FLASHCTRL {
    type Target = flashctrl::RegisterBlock;
    fn deref(&self) -> &flashctrl::RegisterBlock {
        unsafe { &*FLASHCTRL::ptr() }
    }
}
#[doc = "Flash controller"]
pub mod flashctrl {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 16usize],
        #[doc = "0x10 - Flash configuration register"]
        pub flashcfg: FLASHCFG,
        _reserved1: [u8; 12usize],
        #[doc = "0x20 - Signature start address register"]
        pub fmsstart: FMSSTART,
        #[doc = "0x24 - Signature stop-address register"]
        pub fmsstop: FMSSTOP,
        _reserved2: [u8; 4usize],
        #[doc = "0x2c - Signature Word"]
        pub fmsw0: FMSW0,
    }
    #[doc = "Flash configuration register"]
    pub struct FLASHCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Flash configuration register"]
    pub mod flashcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FLASHCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FLASHTIM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHTIMR {
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            _1_SYSTEM_CLOCK_FLASH,
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 30 MHz)."]
            _2_SYSTEM_CLOCKS_FLAS,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl FLASHTIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FLASHTIMR::_1_SYSTEM_CLOCK_FLASH => 0,
                    FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS => 0x01,
                    FLASHTIMR::RESERVED_1 => 0x02,
                    FLASHTIMR::RESERVED_2 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FLASHTIMR {
                match value {
                    0 => FLASHTIMR::_1_SYSTEM_CLOCK_FLASH,
                    1 => FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS,
                    2 => FLASHTIMR::RESERVED_1,
                    3 => FLASHTIMR::RESERVED_2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_1_SYSTEM_CLOCK_FLASH`"]
            #[inline]
            pub fn is_1_system_clock_flash(&self) -> bool {
                *self == FLASHTIMR::_1_SYSTEM_CLOCK_FLASH
            }
            #[doc = "Checks if the value of the field is `_2_SYSTEM_CLOCKS_FLAS`"]
            #[inline]
            pub fn is_2_system_clocks_flas(&self) -> bool {
                *self == FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS
            }
            #[doc = "Checks if the value of the field is `RESERVED_1`"]
            #[inline]
            pub fn is_reserved_1(&self) -> bool {
                *self == FLASHTIMR::RESERVED_1
            }
            #[doc = "Checks if the value of the field is `RESERVED_2`"]
            #[inline]
            pub fn is_reserved_2(&self) -> bool {
                *self == FLASHTIMR::RESERVED_2
            }
        }
        #[doc = "Values that can be written to the field `FLASHTIM`"]
        pub enum FLASHTIMW {
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            _1_SYSTEM_CLOCK_FLASH,
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 30 MHz)."]
            _2_SYSTEM_CLOCKS_FLAS,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl FLASHTIMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FLASHTIMW::_1_SYSTEM_CLOCK_FLASH => 0,
                    FLASHTIMW::_2_SYSTEM_CLOCKS_FLAS => 1,
                    FLASHTIMW::RESERVED_1 => 2,
                    FLASHTIMW::RESERVED_2 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHTIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHTIMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASHTIMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            #[inline]
            pub fn _1_system_clock_flash(self) -> &'a mut W {
                self.variant(FLASHTIMW::_1_SYSTEM_CLOCK_FLASH)
            }
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 30 MHz)."]
            #[inline]
            pub fn _2_system_clocks_flas(self) -> &'a mut W {
                self.variant(FLASHTIMW::_2_SYSTEM_CLOCKS_FLAS)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_1(self) -> &'a mut W {
                self.variant(FLASHTIMW::RESERVED_1)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_2(self) -> &'a mut W {
                self.variant(FLASHTIMW::RESERVED_2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access."]
            #[inline]
            pub fn flashtim(&self) -> FLASHTIMR {
                FLASHTIMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access."]
            #[inline]
            pub fn flashtim(&mut self) -> _FLASHTIMW {
                _FLASHTIMW { w: self }
            }
        }
    }
    #[doc = "Signature start address register"]
    pub struct FMSSTART {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Signature start address register"]
    pub mod fmsstart {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FMSSTART {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: u32,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0001_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits[20:4])."]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: u32 = 0x0001_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                STARTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits[20:4])."]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
        }
    }
    #[doc = "Signature stop-address register"]
    pub struct FMSSTOP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Signature stop-address register"]
    pub mod fmsstop {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FMSSTOP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPAR {
            bits: u32,
        }
        impl STOPAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STRTBISTR {
            bits: bool,
        }
        impl STRTBISTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0001_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STRTBISTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STRTBISTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:16 - Stop address for signature generation (the word specified by STOPA is included in the address range). The address is in units of memory words, not bytes. If the option bistprotection=1, bits 2:0 cannot be written and are forced to 111."]
            #[inline]
            pub fn stopa(&self) -> STOPAR {
                let bits = {
                    const MASK: u32 = 0x0001_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                STOPAR { bits }
            }
            #[doc = "Bit 31 - When this bit is written to 1, signature generation starts. At the end of signature generation, this bit is automatically cleared."]
            #[inline]
            pub fn strtbist(&self) -> STRTBISTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STRTBISTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:16 - Stop address for signature generation (the word specified by STOPA is included in the address range). The address is in units of memory words, not bytes. If the option bistprotection=1, bits 2:0 cannot be written and are forced to 111."]
            #[inline]
            pub fn stopa(&mut self) -> _STOPAW {
                _STOPAW { w: self }
            }
            #[doc = "Bit 31 - When this bit is written to 1, signature generation starts. At the end of signature generation, this bit is automatically cleared."]
            #[inline]
            pub fn strtbist(&mut self) -> _STRTBISTW {
                _STRTBISTW { w: self }
            }
        }
    }
    #[doc = "Signature Word"]
    pub struct FMSW0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Signature Word"]
    pub mod fmsw0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FMSW0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIGR {
            bits: u32,
        }
        impl SIGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - 32-bit signature."]
            #[inline]
            pub fn sig(&self) -> SIGR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SIGR { bits }
            }
        }
    }
}
#[doc = "I/O configuration (IOCON)"]
pub struct IOCON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOCON {}
impl IOCON {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const iocon::RegisterBlock {
        0x4004_4000 as *const _
    }
}
impl Deref for IOCON {
    type Target = iocon::RegisterBlock;
    fn deref(&self) -> &iocon::RegisterBlock {
        unsafe { &*IOCON::ptr() }
    }
}
#[doc = "I/O configuration (IOCON)"]
pub mod iocon {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - I/O configuration for pin PIO0_17"]
        pub pio0_17: PIO0_17,
        #[doc = "0x04 - I/O configuration for pin PIO0_13"]
        pub pio0_13: PIO0_13,
        #[doc = "0x08 - I/O configuration for pin PIO0_12"]
        pub pio0_12: PIO0_12,
        #[doc = "0x0c - I/O configuration for pin PIO0_5/RESET"]
        pub pio0_5: PIO0_5,
        #[doc = "0x10 - I/O configuration for pin PIO0_4"]
        pub pio0_4: PIO0_4,
        #[doc = "0x14 - I/O configuration for pin PIO0_3/SWCLK"]
        pub pio0_3: PIO0_3,
        #[doc = "0x18 - I/O configuration for pin PIO0_2/SWDIO"]
        pub pio0_2: PIO0_2,
        #[doc = "0x1c - I/O configuration for pin PIO0_11. This is the pin configuration for the true open-drain pin."]
        pub pio0_11: PIO0_11,
        #[doc = "0x20 - I/O configuration for pin PIO0_10. This is the pin configuration for the true open-drain pin."]
        pub pio0_10: PIO0_10,
        #[doc = "0x24 - I/O configuration for pin PIO0_16"]
        pub pio0_16: PIO0_16,
        #[doc = "0x28 - I/O configuration for pin PIO0_15"]
        pub pio0_15: PIO0_15,
        #[doc = "0x2c - I/O configuration for pin PIO0_17"]
        pub pio0_1: PIO0_1,
        _reserved0: [u8; 4usize],
        #[doc = "0x34 - I/O configuration for pin PIO0_9/XTALOUT"]
        pub pio0_9: PIO0_9,
        #[doc = "0x38 - I/O configuration for pin PIO0_8/XTALIN"]
        pub pio0_8: PIO0_8,
        #[doc = "0x3c - I/O configuration for pin PIO0_7"]
        pub pio0_7: PIO0_7,
        #[doc = "0x40 - I/O configuration for pin PIO0_6/VDDCMP"]
        pub pio0_6: PIO0_6,
        #[doc = "0x44 - I/O configuration for pin PIO0_0/ACMP_I0"]
        pub pio0_0: PIO0_0,
        #[doc = "0x48 - I/O configuration for pin PIO0_14"]
        pub pio0_14: PIO0_14,
        _reserved1: [u8; 4usize],
        #[doc = "0x50 - I/O configuration for pin PIO0_28"]
        pub pio0_28: PIO0_28,
        #[doc = "0x54 - I/O configuration for pin PIO0_27"]
        pub pio0_27: PIO0_27,
        #[doc = "0x58 - I/O configuration for pin PIO0_26"]
        pub pio0_26: PIO0_26,
        #[doc = "0x5c - I/O configuration for pin PIO0_25"]
        pub pio0_25: PIO0_25,
        #[doc = "0x60 - I/O configuration for pin PIO0_24"]
        pub pio0_24: PIO0_24,
        #[doc = "0x64 - I/O configuration for pin PIO0_23/ADC_3"]
        pub pio0_23: PIO0_23,
        #[doc = "0x68 - I/O configuration for pin PIO0_22/ADC_4"]
        pub pio0_22: PIO0_22,
        #[doc = "0x6c - I/O configuration for pin PIO0_21/ACMP_I4/ADC_5"]
        pub pio0_21: PIO0_21,
        #[doc = "0x70 - I/O configuration for pin PIO0_20/ADC_6"]
        pub pio0_20: PIO0_20,
        #[doc = "0x74 - I/O configuration for pin PIO0_19/ADC_7"]
        pub pio0_19: PIO0_19,
        #[doc = "0x78 - I/O configuration for pin PIO0_18/ADC_8"]
        pub pio0_18: PIO0_18,
    }
    #[doc = "I/O configuration for pin PIO0_17"]
    pub struct PIO0_17 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_17"]
    pub mod pio0_17 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_17 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_13"]
    pub struct PIO0_13 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_13"]
    pub mod pio0_13 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_13 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_12"]
    pub struct PIO0_12 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_12"]
    pub mod pio0_12 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_12 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_5/RESET"]
    pub struct PIO0_5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_5/RESET"]
    pub mod pio0_5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_4"]
    pub struct PIO0_4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_4"]
    pub mod pio0_4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_3/SWCLK"]
    pub struct PIO0_3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_3/SWCLK"]
    pub mod pio0_3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_2/SWDIO"]
    pub struct PIO0_2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_2/SWDIO"]
    pub mod pio0_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_11. This is the pin configuration for the true open-drain pin."]
    pub struct PIO0_11 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_11. This is the pin configuration for the true open-drain pin."]
    pub mod pio0_11 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_11 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `I2CMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CMODER {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2CMODER::STANDARD_FAST => 0,
                    I2CMODER::STANDARD_IO => 0x01,
                    I2CMODER::FAST_MODE_PLUS_I2C => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> I2CMODER {
                match value {
                    0 => I2CMODER::STANDARD_FAST,
                    1 => I2CMODER::STANDARD_IO,
                    2 => I2CMODER::FAST_MODE_PLUS_I2C,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_FAST`"]
            #[inline]
            pub fn is_standard_fast(&self) -> bool {
                *self == I2CMODER::STANDARD_FAST
            }
            #[doc = "Checks if the value of the field is `STANDARD_IO`"]
            #[inline]
            pub fn is_standard_io(&self) -> bool {
                *self == I2CMODER::STANDARD_IO
            }
            #[doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`"]
            #[inline]
            pub fn is_fast_mode_plus_i2c(&self) -> bool {
                *self == I2CMODER::FAST_MODE_PLUS_I2C
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2CMODE`"]
        pub enum I2CMODEW {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2CMODEW::STANDARD_FAST => 0,
                    I2CMODEW::STANDARD_IO => 1,
                    I2CMODEW::FAST_MODE_PLUS_I2C => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2CMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Standard mode/ Fast-mode I2C."]
            #[inline]
            pub fn standard_fast(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_FAST)
            }
            #[doc = "Standard I/O functionality"]
            #[inline]
            pub fn standard_io(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_IO)
            }
            #[doc = "Fast-mode Plus I2C"]
            #[inline]
            pub fn fast_mode_plus_i2c(self) -> &'a mut W {
                self.variant(I2CMODEW::FAST_MODE_PLUS_I2C)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&self) -> I2CMODER {
                I2CMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&mut self) -> _I2CMODEW {
                _I2CMODEW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_10. This is the pin configuration for the true open-drain pin."]
    pub struct PIO0_10 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_10. This is the pin configuration for the true open-drain pin."]
    pub mod pio0_10 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_10 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `I2CMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CMODER {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2CMODER::STANDARD_FAST => 0,
                    I2CMODER::STANDARD_IO => 0x01,
                    I2CMODER::FAST_MODE_PLUS_I2C => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> I2CMODER {
                match value {
                    0 => I2CMODER::STANDARD_FAST,
                    1 => I2CMODER::STANDARD_IO,
                    2 => I2CMODER::FAST_MODE_PLUS_I2C,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_FAST`"]
            #[inline]
            pub fn is_standard_fast(&self) -> bool {
                *self == I2CMODER::STANDARD_FAST
            }
            #[doc = "Checks if the value of the field is `STANDARD_IO`"]
            #[inline]
            pub fn is_standard_io(&self) -> bool {
                *self == I2CMODER::STANDARD_IO
            }
            #[doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`"]
            #[inline]
            pub fn is_fast_mode_plus_i2c(&self) -> bool {
                *self == I2CMODER::FAST_MODE_PLUS_I2C
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2CMODE`"]
        pub enum I2CMODEW {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2CMODEW::STANDARD_FAST => 0,
                    I2CMODEW::STANDARD_IO => 1,
                    I2CMODEW::FAST_MODE_PLUS_I2C => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2CMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Standard mode/ Fast-mode I2C."]
            #[inline]
            pub fn standard_fast(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_FAST)
            }
            #[doc = "Standard I/O functionality"]
            #[inline]
            pub fn standard_io(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_IO)
            }
            #[doc = "Fast-mode Plus I2C"]
            #[inline]
            pub fn fast_mode_plus_i2c(self) -> &'a mut W {
                self.variant(I2CMODEW::FAST_MODE_PLUS_I2C)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&self) -> I2CMODER {
                I2CMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&mut self) -> _I2CMODEW {
                _I2CMODEW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_16"]
    pub struct PIO0_16 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_16"]
    pub mod pio0_16 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_16 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_15"]
    pub struct PIO0_15 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_15"]
    pub mod pio0_15 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_15 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_17"]
    pub struct PIO0_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_17"]
    pub mod pio0_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_9/XTALOUT"]
    pub struct PIO0_9 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_9/XTALOUT"]
    pub mod pio0_9 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_9 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_8/XTALIN"]
    pub struct PIO0_8 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_8/XTALIN"]
    pub mod pio0_8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_7"]
    pub struct PIO0_7 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_7"]
    pub mod pio0_7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_6/VDDCMP"]
    pub struct PIO0_6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_6/VDDCMP"]
    pub mod pio0_6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_0/ACMP_I0"]
    pub struct PIO0_0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_0/ACMP_I0"]
    pub mod pio0_0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_14"]
    pub struct PIO0_14 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_14"]
    pub mod pio0_14 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_14 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_28"]
    pub struct PIO0_28 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_28"]
    pub mod pio0_28 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_28 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_27"]
    pub struct PIO0_27 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_27"]
    pub mod pio0_27 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_27 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_26"]
    pub struct PIO0_26 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_26"]
    pub mod pio0_26 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_26 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_25"]
    pub struct PIO0_25 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_25"]
    pub mod pio0_25 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_25 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_24"]
    pub struct PIO0_24 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_24"]
    pub mod pio0_24 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_24 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_23/ADC_3"]
    pub struct PIO0_23 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_23/ADC_3"]
    pub mod pio0_23 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_23 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_22/ADC_4"]
    pub struct PIO0_22 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_22/ADC_4"]
    pub mod pio0_22 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_22 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_21/ACMP_I4/ADC_5"]
    pub struct PIO0_21 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_21/ACMP_I4/ADC_5"]
    pub mod pio0_21 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_21 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_20/ADC_6"]
    pub struct PIO0_20 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_20/ADC_6"]
    pub mod pio0_20 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_20 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_19/ADC_7"]
    pub struct PIO0_19 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_19/ADC_7"]
    pub mod pio0_19 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_19 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_18/ADC_8"]
    pub struct PIO0_18 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_18/ADC_8"]
    pub mod pio0_18 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_18 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED`"]
            #[inline]
            pub fn is_input_not_inverted(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ODR::DISABLE
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER => 0,
                    S_MODER::_1_CLOCK_CYCLE => 0x01,
                    S_MODER::_2_CLOCK_CYCLES => 0x02,
                    S_MODER::_3_CLOCK_CYCLES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER,
                    1 => S_MODER::_1_CLOCK_CYCLE,
                    2 => S_MODER::_2_CLOCK_CYCLES,
                    3 => S_MODER::_3_CLOCK_CYCLES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER`"]
            #[inline]
            pub fn is_bypass_input_filter(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE`"]
            #[inline]
            pub fn is_1_clock_cycle(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_2_clock_cycles(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES`"]
            #[inline]
            pub fn is_3_clock_cycles(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONCLKDIV0 => 0,
                    CLK_DIVR::IOCONCLKDIV1 => 0x01,
                    CLK_DIVR::IOCONCLKDIV2 => 0x02,
                    CLK_DIVR::IOCONCLKDIV3 => 0x03,
                    CLK_DIVR::IOCONCLKDIV4 => 0x04,
                    CLK_DIVR::IOCONCLKDIV5 => 0x05,
                    CLK_DIVR::IOCONCLKDIV6 => 0x06,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONCLKDIV0,
                    1 => CLK_DIVR::IOCONCLKDIV1,
                    2 => CLK_DIVR::IOCONCLKDIV2,
                    3 => CLK_DIVR::IOCONCLKDIV3,
                    4 => CLK_DIVR::IOCONCLKDIV4,
                    5 => CLK_DIVR::IOCONCLKDIV5,
                    6 => CLK_DIVR::IOCONCLKDIV6,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV0`"]
            #[inline]
            pub fn is_ioconclkdiv0(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV0
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV1`"]
            #[inline]
            pub fn is_ioconclkdiv1(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV1
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV2`"]
            #[inline]
            pub fn is_ioconclkdiv2(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV2
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV3`"]
            #[inline]
            pub fn is_ioconclkdiv3(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV3
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV4`"]
            #[inline]
            pub fn is_ioconclkdiv4(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV4
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV5`"]
            #[inline]
            pub fn is_ioconclkdiv5(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV5
            }
            #[doc = "Checks if the value of the field is `IOCONCLKDIV6`"]
            #[inline]
            pub fn is_ioconclkdiv6(&self) -> bool {
                *self == CLK_DIVR::IOCONCLKDIV6
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Enable."]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline]
            pub fn input_not_inverted(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ODW::DISABLE)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER => 0,
                    S_MODEW::_1_CLOCK_CYCLE => 1,
                    S_MODEW::_2_CLOCK_CYCLES => 2,
                    S_MODEW::_3_CLOCK_CYCLES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline]
            pub fn bypass_input_filter(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline]
            pub fn _1_clock_cycle(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline]
            pub fn _2_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline]
            pub fn _3_clock_cycles(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONCLKDIV0."]
            IOCONCLKDIV0,
            #[doc = "IOCONCLKDIV1."]
            IOCONCLKDIV1,
            #[doc = "IOCONCLKDIV2."]
            IOCONCLKDIV2,
            #[doc = "IOCONCLKDIV3."]
            IOCONCLKDIV3,
            #[doc = "IOCONCLKDIV4."]
            IOCONCLKDIV4,
            #[doc = "IOCONCLKDIV5."]
            IOCONCLKDIV5,
            #[doc = "IOCONCLKDIV6."]
            IOCONCLKDIV6,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONCLKDIV0 => 0,
                    CLK_DIVW::IOCONCLKDIV1 => 1,
                    CLK_DIVW::IOCONCLKDIV2 => 2,
                    CLK_DIVW::IOCONCLKDIV3 => 3,
                    CLK_DIVW::IOCONCLKDIV4 => 4,
                    CLK_DIVW::IOCONCLKDIV5 => 5,
                    CLK_DIVW::IOCONCLKDIV6 => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONCLKDIV0."]
            #[inline]
            pub fn ioconclkdiv0(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV0)
            }
            #[doc = "IOCONCLKDIV1."]
            #[inline]
            pub fn ioconclkdiv1(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV1)
            }
            #[doc = "IOCONCLKDIV2."]
            #[inline]
            pub fn ioconclkdiv2(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV2)
            }
            #[doc = "IOCONCLKDIV3."]
            #[inline]
            pub fn ioconclkdiv3(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV3)
            }
            #[doc = "IOCONCLKDIV4."]
            #[inline]
            pub fn ioconclkdiv4(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV4)
            }
            #[doc = "IOCONCLKDIV5."]
            #[inline]
            pub fn ioconclkdiv5(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV5)
            }
            #[doc = "IOCONCLKDIV6."]
            #[inline]
            pub fn ioconclkdiv6(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONCLKDIV6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x90 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
}
#[doc = "System configuration (SYSCON)"]
pub struct SYSCON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSCON {}
impl SYSCON {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const syscon::RegisterBlock {
        0x4004_8000 as *const _
    }
}
impl Deref for SYSCON {
    type Target = syscon::RegisterBlock;
    fn deref(&self) -> &syscon::RegisterBlock {
        unsafe { &*SYSCON::ptr() }
    }
}
#[doc = "System configuration (SYSCON)"]
pub mod syscon {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - System memory remap"]
        pub sysmemremap: SYSMEMREMAP,
        #[doc = "0x04 - Peripheral reset control"]
        pub presetctrl: PRESETCTRL,
        #[doc = "0x08 - System PLL control"]
        pub syspllctrl: SYSPLLCTRL,
        #[doc = "0x0c - System PLL status"]
        pub syspllstat: SYSPLLSTAT,
        _reserved0: [u8; 16usize],
        #[doc = "0x20 - System oscillator control"]
        pub sysoscctrl: SYSOSCCTRL,
        #[doc = "0x24 - Watchdog oscillator control"]
        pub wdtoscctrl: WDTOSCCTRL,
        #[doc = "0x28 - IRC control"]
        pub ircctrl: IRCCTRL,
        _reserved1: [u8; 4usize],
        #[doc = "0x30 - System reset status register"]
        pub sysrststat: SYSRSTSTAT,
        _reserved2: [u8; 12usize],
        #[doc = "0x40 - System PLL clock source select"]
        pub syspllclksel: SYSPLLCLKSEL,
        #[doc = "0x44 - System PLL clock source update enable"]
        pub syspllclkuen: SYSPLLCLKUEN,
        _reserved3: [u8; 40usize],
        #[doc = "0x70 - Main clock source select"]
        pub mainclksel: MAINCLKSEL,
        #[doc = "0x74 - Main clock source update enable"]
        pub mainclkuen: MAINCLKUEN,
        #[doc = "0x78 - System clock divider"]
        pub sysahbclkdiv: SYSAHBCLKDIV,
        _reserved4: [u8; 4usize],
        #[doc = "0x80 - System clock control"]
        pub sysahbclkctrl: SYSAHBCLKCTRL,
        _reserved5: [u8; 16usize],
        #[doc = "0x94 - USART clock divider"]
        pub uartclkdiv: UARTCLKDIV,
        _reserved6: [u8; 72usize],
        #[doc = "0xe0 - CLKOUT clock source select"]
        pub clkoutsel: CLKOUTSEL,
        #[doc = "0xe4 - CLKOUT clock source update enable"]
        pub clkoutuen: CLKOUTUEN,
        #[doc = "0xe8 - CLKOUT clock divider"]
        pub clkoutdiv: CLKOUTDIV,
        _reserved7: [u8; 4usize],
        #[doc = "0xf0 - USART1 to USART4 common fractional generator divider value"]
        pub uartfrgdiv: UARTFRGDIV,
        #[doc = "0xf4 - USART1 to USART4 common fractional generator multiplier value"]
        pub uartfrgmult: UARTFRGMULT,
        _reserved8: [u8; 4usize],
        #[doc = "0xfc - External trace buffer command register"]
        pub exttracecmd: EXTTRACECMD,
        #[doc = "0x100 - POR captured PIO status 0"]
        pub pioporcap0: PIOPORCAP0,
        _reserved9: [u8; 48usize],
        #[doc = "0x134 - Peripheral clock 6 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv6: IOCONCLKDIV6,
        #[doc = "0x138 - Peripheral clock 5 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv5: IOCONCLKDIV5,
        #[doc = "0x13c - Peripheral clock 4 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv4: IOCONCLKDIV4,
        #[doc = "0x140 - Peripheral clock 3 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv3: IOCONCLKDIV3,
        #[doc = "0x144 - Peripheral clock 2 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv2: IOCONCLKDIV2,
        #[doc = "0x148 - Peripheral clock 1 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv1: IOCONCLKDIV1,
        #[doc = "0x14c - Peripheral clock 0 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv0: IOCONCLKDIV0,
        #[doc = "0x150 - Brown-Out Detect"]
        pub bodctrl: BODCTRL,
        #[doc = "0x154 - System tick counter calibration"]
        pub systckcal: SYSTCKCAL,
        _reserved10: [u8; 24usize],
        #[doc = "0x170 - IQR delay. Allows trade-off between interrupt latency and determinism."]
        pub irqlatency: IRQLATENCY,
        #[doc = "0x174 - NMI Source Control"]
        pub nmisrc: NMISRC,
        #[doc = "0x178 - GPIO Pin Interrupt Select register 0"]
        pub pintsel: [PINTSEL; 8],
        _reserved11: [u8; 108usize],
        #[doc = "0x204 - Start logic 0 pin wake-up enable register"]
        pub starterp0: STARTERP0,
        _reserved12: [u8; 12usize],
        #[doc = "0x214 - Start logic 1 interrupt wake-up enable register"]
        pub starterp1: STARTERP1,
        _reserved13: [u8; 24usize],
        #[doc = "0x230 - Power-down states in deep-sleep mode"]
        pub pdsleepcfg: PDSLEEPCFG,
        #[doc = "0x234 - Power-down states for wake-up from deep-sleep"]
        pub pdawakecfg: PDAWAKECFG,
        #[doc = "0x238 - Power configuration register"]
        pub pdruncfg: PDRUNCFG,
        _reserved14: [u8; 444usize],
        #[doc = "0x3f8 - Device ID"]
        pub device_id: DEVICE_ID,
    }
    #[doc = "System memory remap"]
    pub struct SYSMEMREMAP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System memory remap"]
    pub mod sysmemremap {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSMEMREMAP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MAPR {
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            BOOT_LOADER_MODE,
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            USER_RAM_MODE,
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            USER_FLASH_MODE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MAPR::BOOT_LOADER_MODE => 0,
                    MAPR::USER_RAM_MODE => 0x01,
                    MAPR::USER_FLASH_MODE => 0x02,
                    MAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MAPR {
                match value {
                    0 => MAPR::BOOT_LOADER_MODE,
                    1 => MAPR::USER_RAM_MODE,
                    2 => MAPR::USER_FLASH_MODE,
                    i => MAPR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BOOT_LOADER_MODE`"]
            #[inline]
            pub fn is_boot_loader_mode(&self) -> bool {
                *self == MAPR::BOOT_LOADER_MODE
            }
            #[doc = "Checks if the value of the field is `USER_RAM_MODE`"]
            #[inline]
            pub fn is_user_ram_mode(&self) -> bool {
                *self == MAPR::USER_RAM_MODE
            }
            #[doc = "Checks if the value of the field is `USER_FLASH_MODE`"]
            #[inline]
            pub fn is_user_flash_mode(&self) -> bool {
                *self == MAPR::USER_FLASH_MODE
            }
        }
        #[doc = "Values that can be written to the field `MAP`"]
        pub enum MAPW {
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            BOOT_LOADER_MODE,
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            USER_RAM_MODE,
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            USER_FLASH_MODE,
        }
        impl MAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MAPW::BOOT_LOADER_MODE => 0,
                    MAPW::USER_RAM_MODE => 1,
                    MAPW::USER_FLASH_MODE => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MAPW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            #[inline]
            pub fn boot_loader_mode(self) -> &'a mut W {
                self.variant(MAPW::BOOT_LOADER_MODE)
            }
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            #[inline]
            pub fn user_ram_mode(self) -> &'a mut W {
                self.variant(MAPW::USER_RAM_MODE)
            }
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            #[inline]
            pub fn user_flash_mode(self) -> &'a mut W {
                self.variant(MAPW::USER_FLASH_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System memory remap. Value 0x3 is reserved."]
            #[inline]
            pub fn map(&self) -> MAPR {
                MAPR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x02 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System memory remap. Value 0x3 is reserved."]
            #[inline]
            pub fn map(&mut self) -> _MAPW {
                _MAPW { w: self }
            }
        }
    }
    #[doc = "Peripheral reset control"]
    pub struct PRESETCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral reset control"]
    pub mod presetctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRESETCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SPI0_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI0_RST_NR {
            #[doc = "Assert the SPI0 reset."]
            ASSERT_THE_SPI0_RESE,
            #[doc = "Clear the SPI0 reset."]
            CLEAR_THE_SPI0_RESET,
        }
        impl SPI0_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI0_RST_NR::ASSERT_THE_SPI0_RESE => false,
                    SPI0_RST_NR::CLEAR_THE_SPI0_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPI0_RST_NR {
                match value {
                    false => SPI0_RST_NR::ASSERT_THE_SPI0_RESE,
                    true => SPI0_RST_NR::CLEAR_THE_SPI0_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_SPI0_RESE`"]
            #[inline]
            pub fn is_assert_the_spi0_rese(&self) -> bool {
                *self == SPI0_RST_NR::ASSERT_THE_SPI0_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_SPI0_RESET`"]
            #[inline]
            pub fn is_clear_the_spi0_reset(&self) -> bool {
                *self == SPI0_RST_NR::CLEAR_THE_SPI0_RESET
            }
        }
        #[doc = "Possible values of the field `SPI1_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI1_RST_NR {
            #[doc = "Assert the SPI1 reset."]
            ASSERT_THE_SPI1_RESE,
            #[doc = "Clear the SPI1 reset."]
            CLEAR_THE_SPI1_RESET,
        }
        impl SPI1_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI1_RST_NR::ASSERT_THE_SPI1_RESE => false,
                    SPI1_RST_NR::CLEAR_THE_SPI1_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPI1_RST_NR {
                match value {
                    false => SPI1_RST_NR::ASSERT_THE_SPI1_RESE,
                    true => SPI1_RST_NR::CLEAR_THE_SPI1_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_SPI1_RESE`"]
            #[inline]
            pub fn is_assert_the_spi1_rese(&self) -> bool {
                *self == SPI1_RST_NR::ASSERT_THE_SPI1_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_SPI1_RESET`"]
            #[inline]
            pub fn is_clear_the_spi1_reset(&self) -> bool {
                *self == SPI1_RST_NR::CLEAR_THE_SPI1_RESET
            }
        }
        #[doc = "Possible values of the field `UARTFRG_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UARTFRG_RST_NR {
            #[doc = "Assert the UARTFRG reset."]
            ASSERT_THE_UARTFRG_R,
            #[doc = "Clear the UARTFRG reset."]
            CLEAR_THE_UARTFRG_RE,
        }
        impl UARTFRG_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UARTFRG_RST_NR::ASSERT_THE_UARTFRG_R => false,
                    UARTFRG_RST_NR::CLEAR_THE_UARTFRG_RE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UARTFRG_RST_NR {
                match value {
                    false => UARTFRG_RST_NR::ASSERT_THE_UARTFRG_R,
                    true => UARTFRG_RST_NR::CLEAR_THE_UARTFRG_RE,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_UARTFRG_R`"]
            #[inline]
            pub fn is_assert_the_uartfrg_r(&self) -> bool {
                *self == UARTFRG_RST_NR::ASSERT_THE_UARTFRG_R
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_UARTFRG_RE`"]
            #[inline]
            pub fn is_clear_the_uartfrg_re(&self) -> bool {
                *self == UARTFRG_RST_NR::CLEAR_THE_UARTFRG_RE
            }
        }
        #[doc = "Possible values of the field `UART0_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART0_RST_NR {
            #[doc = "Assert the USART0 reset."]
            ASSERT_THE_USART0_RE,
            #[doc = "Clear the USART0 reset."]
            CLEAR_THE_USART0_RES,
        }
        impl UART0_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UART0_RST_NR::ASSERT_THE_USART0_RE => false,
                    UART0_RST_NR::CLEAR_THE_USART0_RES => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UART0_RST_NR {
                match value {
                    false => UART0_RST_NR::ASSERT_THE_USART0_RE,
                    true => UART0_RST_NR::CLEAR_THE_USART0_RES,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_USART0_RE`"]
            #[inline]
            pub fn is_assert_the_usart0_re(&self) -> bool {
                *self == UART0_RST_NR::ASSERT_THE_USART0_RE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_USART0_RES`"]
            #[inline]
            pub fn is_clear_the_usart0_res(&self) -> bool {
                *self == UART0_RST_NR::CLEAR_THE_USART0_RES
            }
        }
        #[doc = "Possible values of the field `UART1_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART1_RST_NR {
            #[doc = "Assert the USART reset."]
            ASSERT_THE_USART_RES,
            #[doc = "Clear the USART1 reset."]
            CLEAR_THE_USART1_RES,
        }
        impl UART1_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UART1_RST_NR::ASSERT_THE_USART_RES => false,
                    UART1_RST_NR::CLEAR_THE_USART1_RES => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UART1_RST_NR {
                match value {
                    false => UART1_RST_NR::ASSERT_THE_USART_RES,
                    true => UART1_RST_NR::CLEAR_THE_USART1_RES,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_USART_RES`"]
            #[inline]
            pub fn is_assert_the_usart_res(&self) -> bool {
                *self == UART1_RST_NR::ASSERT_THE_USART_RES
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_USART1_RES`"]
            #[inline]
            pub fn is_clear_the_usart1_res(&self) -> bool {
                *self == UART1_RST_NR::CLEAR_THE_USART1_RES
            }
        }
        #[doc = "Possible values of the field `UART2_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART2_RST_NR {
            #[doc = "Assert the USART2 reset."]
            ASSERT_THE_USART2_RE,
            #[doc = "Clear the USART2 reset."]
            CLEAR_THE_USART2_RES,
        }
        impl UART2_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UART2_RST_NR::ASSERT_THE_USART2_RE => false,
                    UART2_RST_NR::CLEAR_THE_USART2_RES => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UART2_RST_NR {
                match value {
                    false => UART2_RST_NR::ASSERT_THE_USART2_RE,
                    true => UART2_RST_NR::CLEAR_THE_USART2_RES,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_USART2_RE`"]
            #[inline]
            pub fn is_assert_the_usart2_re(&self) -> bool {
                *self == UART2_RST_NR::ASSERT_THE_USART2_RE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_USART2_RES`"]
            #[inline]
            pub fn is_clear_the_usart2_res(&self) -> bool {
                *self == UART2_RST_NR::CLEAR_THE_USART2_RES
            }
        }
        #[doc = "Possible values of the field `I2C0_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C0_RST_NR {
            #[doc = "Assert the I2C0 reset."]
            ASSERT_THE_I2C0_RESE,
            #[doc = "Clear the I2C0 reset."]
            CLEAR_THE_I2C0_RESET,
        }
        impl I2C0_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C0_RST_NR::ASSERT_THE_I2C0_RESE => false,
                    I2C0_RST_NR::CLEAR_THE_I2C0_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C0_RST_NR {
                match value {
                    false => I2C0_RST_NR::ASSERT_THE_I2C0_RESE,
                    true => I2C0_RST_NR::CLEAR_THE_I2C0_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_I2C0_RESE`"]
            #[inline]
            pub fn is_assert_the_i2c0_rese(&self) -> bool {
                *self == I2C0_RST_NR::ASSERT_THE_I2C0_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_I2C0_RESET`"]
            #[inline]
            pub fn is_clear_the_i2c0_reset(&self) -> bool {
                *self == I2C0_RST_NR::CLEAR_THE_I2C0_RESET
            }
        }
        #[doc = "Possible values of the field `MRT_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MRT_RST_NR {
            #[doc = "Assert the MRT reset."]
            ASSERT_THE_MRT_RESET,
            #[doc = "Clear the MRT reset."]
            CLEAR_THE_MRT_RESET,
        }
        impl MRT_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MRT_RST_NR::ASSERT_THE_MRT_RESET => false,
                    MRT_RST_NR::CLEAR_THE_MRT_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MRT_RST_NR {
                match value {
                    false => MRT_RST_NR::ASSERT_THE_MRT_RESET,
                    true => MRT_RST_NR::CLEAR_THE_MRT_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_MRT_RESET`"]
            #[inline]
            pub fn is_assert_the_mrt_reset(&self) -> bool {
                *self == MRT_RST_NR::ASSERT_THE_MRT_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_MRT_RESET`"]
            #[inline]
            pub fn is_clear_the_mrt_reset(&self) -> bool {
                *self == MRT_RST_NR::CLEAR_THE_MRT_RESET
            }
        }
        #[doc = "Possible values of the field `SCT_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCT_RST_NR {
            #[doc = "Assert the SCT reset."]
            ASSERT_THE_SCT_RESET,
            #[doc = "Clear the SCT reset."]
            CLEAR_THE_SCT_RESET,
        }
        impl SCT_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SCT_RST_NR::ASSERT_THE_SCT_RESET => false,
                    SCT_RST_NR::CLEAR_THE_SCT_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SCT_RST_NR {
                match value {
                    false => SCT_RST_NR::ASSERT_THE_SCT_RESET,
                    true => SCT_RST_NR::CLEAR_THE_SCT_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_SCT_RESET`"]
            #[inline]
            pub fn is_assert_the_sct_reset(&self) -> bool {
                *self == SCT_RST_NR::ASSERT_THE_SCT_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_SCT_RESET`"]
            #[inline]
            pub fn is_clear_the_sct_reset(&self) -> bool {
                *self == SCT_RST_NR::CLEAR_THE_SCT_RESET
            }
        }
        #[doc = "Possible values of the field `WKT_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WKT_RST_NR {
            #[doc = "Assert the WKT reset."]
            ASSERT_THE_WKT_RESET,
            #[doc = "Clear the WKT reset."]
            CLEAR_THE_WKT_RESET,
        }
        impl WKT_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WKT_RST_NR::ASSERT_THE_WKT_RESET => false,
                    WKT_RST_NR::CLEAR_THE_WKT_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WKT_RST_NR {
                match value {
                    false => WKT_RST_NR::ASSERT_THE_WKT_RESET,
                    true => WKT_RST_NR::CLEAR_THE_WKT_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_WKT_RESET`"]
            #[inline]
            pub fn is_assert_the_wkt_reset(&self) -> bool {
                *self == WKT_RST_NR::ASSERT_THE_WKT_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_WKT_RESET`"]
            #[inline]
            pub fn is_clear_the_wkt_reset(&self) -> bool {
                *self == WKT_RST_NR::CLEAR_THE_WKT_RESET
            }
        }
        #[doc = "Possible values of the field `GPIO_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GPIO_RST_NR {
            #[doc = "Assert the GPIO reset."]
            ASSERT_THE_GPIO_RESE,
            #[doc = "Clear the GPIO reset."]
            CLEAR_THE_GPIO_RESET,
        }
        impl GPIO_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GPIO_RST_NR::ASSERT_THE_GPIO_RESE => false,
                    GPIO_RST_NR::CLEAR_THE_GPIO_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GPIO_RST_NR {
                match value {
                    false => GPIO_RST_NR::ASSERT_THE_GPIO_RESE,
                    true => GPIO_RST_NR::CLEAR_THE_GPIO_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_GPIO_RESE`"]
            #[inline]
            pub fn is_assert_the_gpio_rese(&self) -> bool {
                *self == GPIO_RST_NR::ASSERT_THE_GPIO_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_GPIO_RESET`"]
            #[inline]
            pub fn is_clear_the_gpio_reset(&self) -> bool {
                *self == GPIO_RST_NR::CLEAR_THE_GPIO_RESET
            }
        }
        #[doc = "Possible values of the field `FLASH_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_RST_NR {
            #[doc = "Assert the flash controller reset."]
            ASSERT_THE_FLASH_CON,
            #[doc = "Clear the flash controller reset."]
            CLEAR_THE_FLASH_CONT,
        }
        impl FLASH_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_RST_NR::ASSERT_THE_FLASH_CON => false,
                    FLASH_RST_NR::CLEAR_THE_FLASH_CONT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASH_RST_NR {
                match value {
                    false => FLASH_RST_NR::ASSERT_THE_FLASH_CON,
                    true => FLASH_RST_NR::CLEAR_THE_FLASH_CONT,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_FLASH_CON`"]
            #[inline]
            pub fn is_assert_the_flash_con(&self) -> bool {
                *self == FLASH_RST_NR::ASSERT_THE_FLASH_CON
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_FLASH_CONT`"]
            #[inline]
            pub fn is_clear_the_flash_cont(&self) -> bool {
                *self == FLASH_RST_NR::CLEAR_THE_FLASH_CONT
            }
        }
        #[doc = "Possible values of the field `ACMP_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_RST_NR {
            #[doc = "Assert the analog comparator reset."]
            ASSERT_THE_ANALOG_CO,
            #[doc = "Clear the analog comparator controller reset."]
            CLEAR_THE_ANALOG_COM,
        }
        impl ACMP_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_RST_NR::ASSERT_THE_ANALOG_CO => false,
                    ACMP_RST_NR::CLEAR_THE_ANALOG_COM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMP_RST_NR {
                match value {
                    false => ACMP_RST_NR::ASSERT_THE_ANALOG_CO,
                    true => ACMP_RST_NR::CLEAR_THE_ANALOG_COM,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_ANALOG_CO`"]
            #[inline]
            pub fn is_assert_the_analog_co(&self) -> bool {
                *self == ACMP_RST_NR::ASSERT_THE_ANALOG_CO
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_ANALOG_COM`"]
            #[inline]
            pub fn is_clear_the_analog_com(&self) -> bool {
                *self == ACMP_RST_NR::CLEAR_THE_ANALOG_COM
            }
        }
        #[doc = "Possible values of the field `I2C1_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C1_RST_NR {
            #[doc = "Assert the I2C1 reset."]
            ASSERT_THE_I2C1_RESE,
            #[doc = "Clear the I2C1 reset."]
            CLEAR_THE_I2C1_RESET,
        }
        impl I2C1_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C1_RST_NR::ASSERT_THE_I2C1_RESE => false,
                    I2C1_RST_NR::CLEAR_THE_I2C1_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C1_RST_NR {
                match value {
                    false => I2C1_RST_NR::ASSERT_THE_I2C1_RESE,
                    true => I2C1_RST_NR::CLEAR_THE_I2C1_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_I2C1_RESE`"]
            #[inline]
            pub fn is_assert_the_i2c1_rese(&self) -> bool {
                *self == I2C1_RST_NR::ASSERT_THE_I2C1_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_I2C1_RESET`"]
            #[inline]
            pub fn is_clear_the_i2c1_reset(&self) -> bool {
                *self == I2C1_RST_NR::CLEAR_THE_I2C1_RESET
            }
        }
        #[doc = "Possible values of the field `I2C2_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C2_RST_NR {
            #[doc = "Assert the I2C2 reset."]
            ASSERT_THE_I2C2_RESE,
            #[doc = "Clear the I2C2 reset."]
            CLEAR_THE_I2C2_RESET,
        }
        impl I2C2_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C2_RST_NR::ASSERT_THE_I2C2_RESE => false,
                    I2C2_RST_NR::CLEAR_THE_I2C2_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C2_RST_NR {
                match value {
                    false => I2C2_RST_NR::ASSERT_THE_I2C2_RESE,
                    true => I2C2_RST_NR::CLEAR_THE_I2C2_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_I2C2_RESE`"]
            #[inline]
            pub fn is_assert_the_i2c2_rese(&self) -> bool {
                *self == I2C2_RST_NR::ASSERT_THE_I2C2_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_I2C2_RESET`"]
            #[inline]
            pub fn is_clear_the_i2c2_reset(&self) -> bool {
                *self == I2C2_RST_NR::CLEAR_THE_I2C2_RESET
            }
        }
        #[doc = "Possible values of the field `I2C3_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C3_RST_NR {
            #[doc = "Assert the I2C3 reset."]
            ASSERT_THE_I2C3_RESE,
            #[doc = "Clear the I2C3 reset."]
            CLEAR_THE_I2C3_RESET,
        }
        impl I2C3_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C3_RST_NR::ASSERT_THE_I2C3_RESE => false,
                    I2C3_RST_NR::CLEAR_THE_I2C3_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C3_RST_NR {
                match value {
                    false => I2C3_RST_NR::ASSERT_THE_I2C3_RESE,
                    true => I2C3_RST_NR::CLEAR_THE_I2C3_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_I2C3_RESE`"]
            #[inline]
            pub fn is_assert_the_i2c3_rese(&self) -> bool {
                *self == I2C3_RST_NR::ASSERT_THE_I2C3_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_I2C3_RESET`"]
            #[inline]
            pub fn is_clear_the_i2c3_reset(&self) -> bool {
                *self == I2C3_RST_NR::CLEAR_THE_I2C3_RESET
            }
        }
        #[doc = "Possible values of the field `ADC_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_RST_NR {
            #[doc = "Assert the ADC reset."]
            ASSERT_THE_ADC_RESET,
            #[doc = "Clear the ADC reset."]
            CLEAR_THE_ADC_RESET,
        }
        impl ADC_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_RST_NR::ASSERT_THE_ADC_RESET => false,
                    ADC_RST_NR::CLEAR_THE_ADC_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_RST_NR {
                match value {
                    false => ADC_RST_NR::ASSERT_THE_ADC_RESET,
                    true => ADC_RST_NR::CLEAR_THE_ADC_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_ADC_RESET`"]
            #[inline]
            pub fn is_assert_the_adc_reset(&self) -> bool {
                *self == ADC_RST_NR::ASSERT_THE_ADC_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_ADC_RESET`"]
            #[inline]
            pub fn is_clear_the_adc_reset(&self) -> bool {
                *self == ADC_RST_NR::CLEAR_THE_ADC_RESET
            }
        }
        #[doc = "Possible values of the field `DMA_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA_RST_NR {
            #[doc = "Assert the DMA reset."]
            ASSERT_THE_DMA_RESET,
            #[doc = "Clear the DMA reset."]
            CLEAR_THE_DMA_RESET,
        }
        impl DMA_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMA_RST_NR::ASSERT_THE_DMA_RESET => false,
                    DMA_RST_NR::CLEAR_THE_DMA_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMA_RST_NR {
                match value {
                    false => DMA_RST_NR::ASSERT_THE_DMA_RESET,
                    true => DMA_RST_NR::CLEAR_THE_DMA_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_DMA_RESET`"]
            #[inline]
            pub fn is_assert_the_dma_reset(&self) -> bool {
                *self == DMA_RST_NR::ASSERT_THE_DMA_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_DMA_RESET`"]
            #[inline]
            pub fn is_clear_the_dma_reset(&self) -> bool {
                *self == DMA_RST_NR::CLEAR_THE_DMA_RESET
            }
        }
        #[doc = "Values that can be written to the field `SPI0_RST_N`"]
        pub enum SPI0_RST_NW {
            #[doc = "Assert the SPI0 reset."]
            ASSERT_THE_SPI0_RESE,
            #[doc = "Clear the SPI0 reset."]
            CLEAR_THE_SPI0_RESET,
        }
        impl SPI0_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI0_RST_NW::ASSERT_THE_SPI0_RESE => false,
                    SPI0_RST_NW::CLEAR_THE_SPI0_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI0_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the SPI0 reset."]
            #[inline]
            pub fn assert_the_spi0_rese(self) -> &'a mut W {
                self.variant(SPI0_RST_NW::ASSERT_THE_SPI0_RESE)
            }
            #[doc = "Clear the SPI0 reset."]
            #[inline]
            pub fn clear_the_spi0_reset(self) -> &'a mut W {
                self.variant(SPI0_RST_NW::CLEAR_THE_SPI0_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1_RST_N`"]
        pub enum SPI1_RST_NW {
            #[doc = "Assert the SPI1 reset."]
            ASSERT_THE_SPI1_RESE,
            #[doc = "Clear the SPI1 reset."]
            CLEAR_THE_SPI1_RESET,
        }
        impl SPI1_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI1_RST_NW::ASSERT_THE_SPI1_RESE => false,
                    SPI1_RST_NW::CLEAR_THE_SPI1_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI1_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the SPI1 reset."]
            #[inline]
            pub fn assert_the_spi1_rese(self) -> &'a mut W {
                self.variant(SPI1_RST_NW::ASSERT_THE_SPI1_RESE)
            }
            #[doc = "Clear the SPI1 reset."]
            #[inline]
            pub fn clear_the_spi1_reset(self) -> &'a mut W {
                self.variant(SPI1_RST_NW::CLEAR_THE_SPI1_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UARTFRG_RST_N`"]
        pub enum UARTFRG_RST_NW {
            #[doc = "Assert the UARTFRG reset."]
            ASSERT_THE_UARTFRG_R,
            #[doc = "Clear the UARTFRG reset."]
            CLEAR_THE_UARTFRG_RE,
        }
        impl UARTFRG_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UARTFRG_RST_NW::ASSERT_THE_UARTFRG_R => false,
                    UARTFRG_RST_NW::CLEAR_THE_UARTFRG_RE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UARTFRG_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UARTFRG_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UARTFRG_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the UARTFRG reset."]
            #[inline]
            pub fn assert_the_uartfrg_r(self) -> &'a mut W {
                self.variant(UARTFRG_RST_NW::ASSERT_THE_UARTFRG_R)
            }
            #[doc = "Clear the UARTFRG reset."]
            #[inline]
            pub fn clear_the_uartfrg_re(self) -> &'a mut W {
                self.variant(UARTFRG_RST_NW::CLEAR_THE_UARTFRG_RE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART0_RST_N`"]
        pub enum UART0_RST_NW {
            #[doc = "Assert the USART0 reset."]
            ASSERT_THE_USART0_RE,
            #[doc = "Clear the USART0 reset."]
            CLEAR_THE_USART0_RES,
        }
        impl UART0_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART0_RST_NW::ASSERT_THE_USART0_RE => false,
                    UART0_RST_NW::CLEAR_THE_USART0_RES => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART0_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART0_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART0_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the USART0 reset."]
            #[inline]
            pub fn assert_the_usart0_re(self) -> &'a mut W {
                self.variant(UART0_RST_NW::ASSERT_THE_USART0_RE)
            }
            #[doc = "Clear the USART0 reset."]
            #[inline]
            pub fn clear_the_usart0_res(self) -> &'a mut W {
                self.variant(UART0_RST_NW::CLEAR_THE_USART0_RES)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART1_RST_N`"]
        pub enum UART1_RST_NW {
            #[doc = "Assert the USART reset."]
            ASSERT_THE_USART_RES,
            #[doc = "Clear the USART1 reset."]
            CLEAR_THE_USART1_RES,
        }
        impl UART1_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART1_RST_NW::ASSERT_THE_USART_RES => false,
                    UART1_RST_NW::CLEAR_THE_USART1_RES => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART1_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART1_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART1_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the USART reset."]
            #[inline]
            pub fn assert_the_usart_res(self) -> &'a mut W {
                self.variant(UART1_RST_NW::ASSERT_THE_USART_RES)
            }
            #[doc = "Clear the USART1 reset."]
            #[inline]
            pub fn clear_the_usart1_res(self) -> &'a mut W {
                self.variant(UART1_RST_NW::CLEAR_THE_USART1_RES)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART2_RST_N`"]
        pub enum UART2_RST_NW {
            #[doc = "Assert the USART2 reset."]
            ASSERT_THE_USART2_RE,
            #[doc = "Clear the USART2 reset."]
            CLEAR_THE_USART2_RES,
        }
        impl UART2_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART2_RST_NW::ASSERT_THE_USART2_RE => false,
                    UART2_RST_NW::CLEAR_THE_USART2_RES => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART2_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART2_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART2_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the USART2 reset."]
            #[inline]
            pub fn assert_the_usart2_re(self) -> &'a mut W {
                self.variant(UART2_RST_NW::ASSERT_THE_USART2_RE)
            }
            #[doc = "Clear the USART2 reset."]
            #[inline]
            pub fn clear_the_usart2_res(self) -> &'a mut W {
                self.variant(UART2_RST_NW::CLEAR_THE_USART2_RES)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C0_RST_N`"]
        pub enum I2C0_RST_NW {
            #[doc = "Assert the I2C0 reset."]
            ASSERT_THE_I2C0_RESE,
            #[doc = "Clear the I2C0 reset."]
            CLEAR_THE_I2C0_RESET,
        }
        impl I2C0_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C0_RST_NW::ASSERT_THE_I2C0_RESE => false,
                    I2C0_RST_NW::CLEAR_THE_I2C0_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C0_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the I2C0 reset."]
            #[inline]
            pub fn assert_the_i2c0_rese(self) -> &'a mut W {
                self.variant(I2C0_RST_NW::ASSERT_THE_I2C0_RESE)
            }
            #[doc = "Clear the I2C0 reset."]
            #[inline]
            pub fn clear_the_i2c0_reset(self) -> &'a mut W {
                self.variant(I2C0_RST_NW::CLEAR_THE_I2C0_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MRT_RST_N`"]
        pub enum MRT_RST_NW {
            #[doc = "Assert the MRT reset."]
            ASSERT_THE_MRT_RESET,
            #[doc = "Clear the MRT reset."]
            CLEAR_THE_MRT_RESET,
        }
        impl MRT_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MRT_RST_NW::ASSERT_THE_MRT_RESET => false,
                    MRT_RST_NW::CLEAR_THE_MRT_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MRT_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MRT_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MRT_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the MRT reset."]
            #[inline]
            pub fn assert_the_mrt_reset(self) -> &'a mut W {
                self.variant(MRT_RST_NW::ASSERT_THE_MRT_RESET)
            }
            #[doc = "Clear the MRT reset."]
            #[inline]
            pub fn clear_the_mrt_reset(self) -> &'a mut W {
                self.variant(MRT_RST_NW::CLEAR_THE_MRT_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCT_RST_N`"]
        pub enum SCT_RST_NW {
            #[doc = "Assert the SCT reset."]
            ASSERT_THE_SCT_RESET,
            #[doc = "Clear the SCT reset."]
            CLEAR_THE_SCT_RESET,
        }
        impl SCT_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCT_RST_NW::ASSERT_THE_SCT_RESET => false,
                    SCT_RST_NW::CLEAR_THE_SCT_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SCT_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the SCT reset."]
            #[inline]
            pub fn assert_the_sct_reset(self) -> &'a mut W {
                self.variant(SCT_RST_NW::ASSERT_THE_SCT_RESET)
            }
            #[doc = "Clear the SCT reset."]
            #[inline]
            pub fn clear_the_sct_reset(self) -> &'a mut W {
                self.variant(SCT_RST_NW::CLEAR_THE_SCT_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WKT_RST_N`"]
        pub enum WKT_RST_NW {
            #[doc = "Assert the WKT reset."]
            ASSERT_THE_WKT_RESET,
            #[doc = "Clear the WKT reset."]
            CLEAR_THE_WKT_RESET,
        }
        impl WKT_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WKT_RST_NW::ASSERT_THE_WKT_RESET => false,
                    WKT_RST_NW::CLEAR_THE_WKT_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WKT_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WKT_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WKT_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the WKT reset."]
            #[inline]
            pub fn assert_the_wkt_reset(self) -> &'a mut W {
                self.variant(WKT_RST_NW::ASSERT_THE_WKT_RESET)
            }
            #[doc = "Clear the WKT reset."]
            #[inline]
            pub fn clear_the_wkt_reset(self) -> &'a mut W {
                self.variant(WKT_RST_NW::CLEAR_THE_WKT_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GPIO_RST_N`"]
        pub enum GPIO_RST_NW {
            #[doc = "Assert the GPIO reset."]
            ASSERT_THE_GPIO_RESE,
            #[doc = "Clear the GPIO reset."]
            CLEAR_THE_GPIO_RESET,
        }
        impl GPIO_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    GPIO_RST_NW::ASSERT_THE_GPIO_RESE => false,
                    GPIO_RST_NW::CLEAR_THE_GPIO_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIO_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIO_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GPIO_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the GPIO reset."]
            #[inline]
            pub fn assert_the_gpio_rese(self) -> &'a mut W {
                self.variant(GPIO_RST_NW::ASSERT_THE_GPIO_RESE)
            }
            #[doc = "Clear the GPIO reset."]
            #[inline]
            pub fn clear_the_gpio_reset(self) -> &'a mut W {
                self.variant(GPIO_RST_NW::CLEAR_THE_GPIO_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_RST_N`"]
        pub enum FLASH_RST_NW {
            #[doc = "Assert the flash controller reset."]
            ASSERT_THE_FLASH_CON,
            #[doc = "Clear the flash controller reset."]
            CLEAR_THE_FLASH_CONT,
        }
        impl FLASH_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_RST_NW::ASSERT_THE_FLASH_CON => false,
                    FLASH_RST_NW::CLEAR_THE_FLASH_CONT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASH_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the flash controller reset."]
            #[inline]
            pub fn assert_the_flash_con(self) -> &'a mut W {
                self.variant(FLASH_RST_NW::ASSERT_THE_FLASH_CON)
            }
            #[doc = "Clear the flash controller reset."]
            #[inline]
            pub fn clear_the_flash_cont(self) -> &'a mut W {
                self.variant(FLASH_RST_NW::CLEAR_THE_FLASH_CONT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP_RST_N`"]
        pub enum ACMP_RST_NW {
            #[doc = "Assert the analog comparator reset."]
            ASSERT_THE_ANALOG_CO,
            #[doc = "Clear the analog comparator controller reset."]
            CLEAR_THE_ANALOG_COM,
        }
        impl ACMP_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_RST_NW::ASSERT_THE_ANALOG_CO => false,
                    ACMP_RST_NW::CLEAR_THE_ANALOG_COM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMP_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the analog comparator reset."]
            #[inline]
            pub fn assert_the_analog_co(self) -> &'a mut W {
                self.variant(ACMP_RST_NW::ASSERT_THE_ANALOG_CO)
            }
            #[doc = "Clear the analog comparator controller reset."]
            #[inline]
            pub fn clear_the_analog_com(self) -> &'a mut W {
                self.variant(ACMP_RST_NW::CLEAR_THE_ANALOG_COM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C1_RST_N`"]
        pub enum I2C1_RST_NW {
            #[doc = "Assert the I2C1 reset."]
            ASSERT_THE_I2C1_RESE,
            #[doc = "Clear the I2C1 reset."]
            CLEAR_THE_I2C1_RESET,
        }
        impl I2C1_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C1_RST_NW::ASSERT_THE_I2C1_RESE => false,
                    I2C1_RST_NW::CLEAR_THE_I2C1_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C1_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the I2C1 reset."]
            #[inline]
            pub fn assert_the_i2c1_rese(self) -> &'a mut W {
                self.variant(I2C1_RST_NW::ASSERT_THE_I2C1_RESE)
            }
            #[doc = "Clear the I2C1 reset."]
            #[inline]
            pub fn clear_the_i2c1_reset(self) -> &'a mut W {
                self.variant(I2C1_RST_NW::CLEAR_THE_I2C1_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C2_RST_N`"]
        pub enum I2C2_RST_NW {
            #[doc = "Assert the I2C2 reset."]
            ASSERT_THE_I2C2_RESE,
            #[doc = "Clear the I2C2 reset."]
            CLEAR_THE_I2C2_RESET,
        }
        impl I2C2_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C2_RST_NW::ASSERT_THE_I2C2_RESE => false,
                    I2C2_RST_NW::CLEAR_THE_I2C2_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C2_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the I2C2 reset."]
            #[inline]
            pub fn assert_the_i2c2_rese(self) -> &'a mut W {
                self.variant(I2C2_RST_NW::ASSERT_THE_I2C2_RESE)
            }
            #[doc = "Clear the I2C2 reset."]
            #[inline]
            pub fn clear_the_i2c2_reset(self) -> &'a mut W {
                self.variant(I2C2_RST_NW::CLEAR_THE_I2C2_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C3_RST_N`"]
        pub enum I2C3_RST_NW {
            #[doc = "Assert the I2C3 reset."]
            ASSERT_THE_I2C3_RESE,
            #[doc = "Clear the I2C3 reset."]
            CLEAR_THE_I2C3_RESET,
        }
        impl I2C3_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C3_RST_NW::ASSERT_THE_I2C3_RESE => false,
                    I2C3_RST_NW::CLEAR_THE_I2C3_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C3_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C3_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C3_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the I2C3 reset."]
            #[inline]
            pub fn assert_the_i2c3_rese(self) -> &'a mut W {
                self.variant(I2C3_RST_NW::ASSERT_THE_I2C3_RESE)
            }
            #[doc = "Clear the I2C3 reset."]
            #[inline]
            pub fn clear_the_i2c3_reset(self) -> &'a mut W {
                self.variant(I2C3_RST_NW::CLEAR_THE_I2C3_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_RST_N`"]
        pub enum ADC_RST_NW {
            #[doc = "Assert the ADC reset."]
            ASSERT_THE_ADC_RESET,
            #[doc = "Clear the ADC reset."]
            CLEAR_THE_ADC_RESET,
        }
        impl ADC_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_RST_NW::ASSERT_THE_ADC_RESET => false,
                    ADC_RST_NW::CLEAR_THE_ADC_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the ADC reset."]
            #[inline]
            pub fn assert_the_adc_reset(self) -> &'a mut W {
                self.variant(ADC_RST_NW::ASSERT_THE_ADC_RESET)
            }
            #[doc = "Clear the ADC reset."]
            #[inline]
            pub fn clear_the_adc_reset(self) -> &'a mut W {
                self.variant(ADC_RST_NW::CLEAR_THE_ADC_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMA_RST_N`"]
        pub enum DMA_RST_NW {
            #[doc = "Assert the DMA reset."]
            ASSERT_THE_DMA_RESET,
            #[doc = "Clear the DMA reset."]
            CLEAR_THE_DMA_RESET,
        }
        impl DMA_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMA_RST_NW::ASSERT_THE_DMA_RESET => false,
                    DMA_RST_NW::CLEAR_THE_DMA_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the DMA reset."]
            #[inline]
            pub fn assert_the_dma_reset(self) -> &'a mut W {
                self.variant(DMA_RST_NW::ASSERT_THE_DMA_RESET)
            }
            #[doc = "Clear the DMA reset."]
            #[inline]
            pub fn clear_the_dma_reset(self) -> &'a mut W {
                self.variant(DMA_RST_NW::CLEAR_THE_DMA_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SPI0 reset control"]
            #[inline]
            pub fn spi0_rst_n(&self) -> SPI0_RST_NR {
                SPI0_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - SPI1 reset control"]
            #[inline]
            pub fn spi1_rst_n(&self) -> SPI1_RST_NR {
                SPI1_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - USART fractional baud rate generator (UARTFRG) reset control"]
            #[inline]
            pub fn uartfrg_rst_n(&self) -> UARTFRG_RST_NR {
                UARTFRG_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - USART0 reset control"]
            #[inline]
            pub fn uart0_rst_n(&self) -> UART0_RST_NR {
                UART0_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - USART1 reset control"]
            #[inline]
            pub fn uart1_rst_n(&self) -> UART1_RST_NR {
                UART1_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - USART2 reset control"]
            #[inline]
            pub fn uart2_rst_n(&self) -> UART2_RST_NR {
                UART2_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - I2C0 reset control"]
            #[inline]
            pub fn i2c0_rst_n(&self) -> I2C0_RST_NR {
                I2C0_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Multi-rate timer (MRT) reset control"]
            #[inline]
            pub fn mrt_rst_n(&self) -> MRT_RST_NR {
                MRT_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - SCT reset control"]
            #[inline]
            pub fn sct_rst_n(&self) -> SCT_RST_NR {
                SCT_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Self wake-up timer (WKT) reset control"]
            #[inline]
            pub fn wkt_rst_n(&self) -> WKT_RST_NR {
                WKT_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - GPIO and GPIO pin interrupt reset control"]
            #[inline]
            pub fn gpio_rst_n(&self) -> GPIO_RST_NR {
                GPIO_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Flash controller reset control"]
            #[inline]
            pub fn flash_rst_n(&self) -> FLASH_RST_NR {
                FLASH_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Analog comparator reset control"]
            #[inline]
            pub fn acmp_rst_n(&self) -> ACMP_RST_NR {
                ACMP_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - I2C1 reset control"]
            #[inline]
            pub fn i2c1_rst_n(&self) -> I2C1_RST_NR {
                I2C1_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - I2C2 reset control"]
            #[inline]
            pub fn i2c2_rst_n(&self) -> I2C2_RST_NR {
                I2C2_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - I2C3 reset control"]
            #[inline]
            pub fn i2c3_rst_n(&self) -> I2C3_RST_NR {
                I2C3_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - ADC reset control"]
            #[inline]
            pub fn adc_rst_n(&self) -> ADC_RST_NR {
                ADC_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - DMA reset control"]
            #[inline]
            pub fn dma_rst_n(&self) -> DMA_RST_NR {
                DMA_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0001_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SPI0 reset control"]
            #[inline]
            pub fn spi0_rst_n(&mut self) -> _SPI0_RST_NW {
                _SPI0_RST_NW { w: self }
            }
            #[doc = "Bit 1 - SPI1 reset control"]
            #[inline]
            pub fn spi1_rst_n(&mut self) -> _SPI1_RST_NW {
                _SPI1_RST_NW { w: self }
            }
            #[doc = "Bit 2 - USART fractional baud rate generator (UARTFRG) reset control"]
            #[inline]
            pub fn uartfrg_rst_n(&mut self) -> _UARTFRG_RST_NW {
                _UARTFRG_RST_NW { w: self }
            }
            #[doc = "Bit 3 - USART0 reset control"]
            #[inline]
            pub fn uart0_rst_n(&mut self) -> _UART0_RST_NW {
                _UART0_RST_NW { w: self }
            }
            #[doc = "Bit 4 - USART1 reset control"]
            #[inline]
            pub fn uart1_rst_n(&mut self) -> _UART1_RST_NW {
                _UART1_RST_NW { w: self }
            }
            #[doc = "Bit 5 - USART2 reset control"]
            #[inline]
            pub fn uart2_rst_n(&mut self) -> _UART2_RST_NW {
                _UART2_RST_NW { w: self }
            }
            #[doc = "Bit 6 - I2C0 reset control"]
            #[inline]
            pub fn i2c0_rst_n(&mut self) -> _I2C0_RST_NW {
                _I2C0_RST_NW { w: self }
            }
            #[doc = "Bit 7 - Multi-rate timer (MRT) reset control"]
            #[inline]
            pub fn mrt_rst_n(&mut self) -> _MRT_RST_NW {
                _MRT_RST_NW { w: self }
            }
            #[doc = "Bit 8 - SCT reset control"]
            #[inline]
            pub fn sct_rst_n(&mut self) -> _SCT_RST_NW {
                _SCT_RST_NW { w: self }
            }
            #[doc = "Bit 9 - Self wake-up timer (WKT) reset control"]
            #[inline]
            pub fn wkt_rst_n(&mut self) -> _WKT_RST_NW {
                _WKT_RST_NW { w: self }
            }
            #[doc = "Bit 10 - GPIO and GPIO pin interrupt reset control"]
            #[inline]
            pub fn gpio_rst_n(&mut self) -> _GPIO_RST_NW {
                _GPIO_RST_NW { w: self }
            }
            #[doc = "Bit 11 - Flash controller reset control"]
            #[inline]
            pub fn flash_rst_n(&mut self) -> _FLASH_RST_NW {
                _FLASH_RST_NW { w: self }
            }
            #[doc = "Bit 12 - Analog comparator reset control"]
            #[inline]
            pub fn acmp_rst_n(&mut self) -> _ACMP_RST_NW {
                _ACMP_RST_NW { w: self }
            }
            #[doc = "Bit 14 - I2C1 reset control"]
            #[inline]
            pub fn i2c1_rst_n(&mut self) -> _I2C1_RST_NW {
                _I2C1_RST_NW { w: self }
            }
            #[doc = "Bit 15 - I2C2 reset control"]
            #[inline]
            pub fn i2c2_rst_n(&mut self) -> _I2C2_RST_NW {
                _I2C2_RST_NW { w: self }
            }
            #[doc = "Bit 16 - I2C3 reset control"]
            #[inline]
            pub fn i2c3_rst_n(&mut self) -> _I2C3_RST_NW {
                _I2C3_RST_NW { w: self }
            }
            #[doc = "Bit 24 - ADC reset control"]
            #[inline]
            pub fn adc_rst_n(&mut self) -> _ADC_RST_NW {
                _ADC_RST_NW { w: self }
            }
            #[doc = "Bit 29 - DMA reset control"]
            #[inline]
            pub fn dma_rst_n(&mut self) -> _DMA_RST_NW {
                _DMA_RST_NW { w: self }
            }
        }
    }
    #[doc = "System PLL control"]
    pub struct SYSPLLCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL control"]
    pub mod syspllctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSELR {
            bits: u8,
        }
        impl MSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSELR {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSELR::P_EQ_1 => 0,
                    PSELR::P_EQ_2 => 0x01,
                    PSELR::P_EQ_4 => 0x02,
                    PSELR::P_EQ_8 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PSELR {
                match value {
                    0 => PSELR::P_EQ_1,
                    1 => PSELR::P_EQ_2,
                    2 => PSELR::P_EQ_4,
                    3 => PSELR::P_EQ_8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `P_EQ_1`"]
            #[inline]
            pub fn is_p_eq_1(&self) -> bool {
                *self == PSELR::P_EQ_1
            }
            #[doc = "Checks if the value of the field is `P_EQ_2`"]
            #[inline]
            pub fn is_p_eq_2(&self) -> bool {
                *self == PSELR::P_EQ_2
            }
            #[doc = "Checks if the value of the field is `P_EQ_4`"]
            #[inline]
            pub fn is_p_eq_4(&self) -> bool {
                *self == PSELR::P_EQ_4
            }
            #[doc = "Checks if the value of the field is `P_EQ_8`"]
            #[inline]
            pub fn is_p_eq_8(&self) -> bool {
                *self == PSELR::P_EQ_8
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PSEL`"]
        pub enum PSELW {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSELW::P_EQ_1 => 0,
                    PSELW::P_EQ_2 => 1,
                    PSELW::P_EQ_4 => 2,
                    PSELW::P_EQ_8 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "P = 1"]
            #[inline]
            pub fn p_eq_1(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_1)
            }
            #[doc = "P = 2"]
            #[inline]
            pub fn p_eq_2(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_2)
            }
            #[doc = "P = 4"]
            #[inline]
            pub fn p_eq_4(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_4)
            }
            #[doc = "P = 8"]
            #[inline]
            pub fn p_eq_8(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32"]
            #[inline]
            pub fn msel(&self) -> MSELR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MSELR { bits }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline]
            pub fn psel(&self) -> PSELR {
                PSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32"]
            #[inline]
            pub fn msel(&mut self) -> _MSELW {
                _MSELW { w: self }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
        }
    }
    #[doc = "System PLL status"]
    pub struct SYSPLLSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL status"]
    pub mod syspllstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SYSPLLSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `LOCK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOCKR {
            #[doc = "PLL not locked"]
            PLL_NOT_LOCKED,
            #[doc = "PLL locked"]
            PLL_LOCKED,
        }
        impl LOCKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOCKR::PLL_NOT_LOCKED => false,
                    LOCKR::PLL_LOCKED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOCKR {
                match value {
                    false => LOCKR::PLL_NOT_LOCKED,
                    true => LOCKR::PLL_LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `PLL_NOT_LOCKED`"]
            #[inline]
            pub fn is_pll_not_locked(&self) -> bool {
                *self == LOCKR::PLL_NOT_LOCKED
            }
            #[doc = "Checks if the value of the field is `PLL_LOCKED`"]
            #[inline]
            pub fn is_pll_locked(&self) -> bool {
                *self == LOCKR::PLL_LOCKED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PLL lock status"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                LOCKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "System oscillator control"]
    pub struct SYSOSCCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System oscillator control"]
    pub mod sysoscctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSOSCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BYPASS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BYPASSR {
            #[doc = "Disabled. Oscillator is not bypassed."]
            DISABLED,
            #[doc = "Enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator."]
            ENABLED,
        }
        impl BYPASSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BYPASSR::DISABLED => false,
                    BYPASSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BYPASSR {
                match value {
                    false => BYPASSR::DISABLED,
                    true => BYPASSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BYPASSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BYPASSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `FREQRANGE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQRANGER {
            #[doc = "1 - 20 MHz frequency range."]
            _1_TO_20_MHZ_FREQUENCY,
            #[doc = "15 - 25 MHz frequency range"]
            _15_TO_25_MHZ_FREQUENC,
        }
        impl FREQRANGER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FREQRANGER::_1_TO_20_MHZ_FREQUENCY => false,
                    FREQRANGER::_15_TO_25_MHZ_FREQUENC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FREQRANGER {
                match value {
                    false => FREQRANGER::_1_TO_20_MHZ_FREQUENCY,
                    true => FREQRANGER::_15_TO_25_MHZ_FREQUENC,
                }
            }
            #[doc = "Checks if the value of the field is `_1_TO_20_MHZ_FREQUENCY`"]
            #[inline]
            pub fn is_1_to_20_mhz_frequency(&self) -> bool {
                *self == FREQRANGER::_1_TO_20_MHZ_FREQUENCY
            }
            #[doc = "Checks if the value of the field is `_15_TO_25_MHZ_FREQUENC`"]
            #[inline]
            pub fn is_15_to_25_mhz_frequenc(&self) -> bool {
                *self == FREQRANGER::_15_TO_25_MHZ_FREQUENC
            }
        }
        #[doc = "Values that can be written to the field `BYPASS`"]
        pub enum BYPASSW {
            #[doc = "Disabled. Oscillator is not bypassed."]
            DISABLED,
            #[doc = "Enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator."]
            ENABLED,
        }
        impl BYPASSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BYPASSW::DISABLED => false,
                    BYPASSW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BYPASSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BYPASSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Oscillator is not bypassed."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BYPASSW::DISABLED)
            }
            #[doc = "Enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BYPASSW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FREQRANGE`"]
        pub enum FREQRANGEW {
            #[doc = "1 - 20 MHz frequency range."]
            _1_TO_20_MHZ_FREQUENCY,
            #[doc = "15 - 25 MHz frequency range"]
            _15_TO_25_MHZ_FREQUENC,
        }
        impl FREQRANGEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FREQRANGEW::_1_TO_20_MHZ_FREQUENCY => false,
                    FREQRANGEW::_15_TO_25_MHZ_FREQUENC => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQRANGEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FREQRANGEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "1 - 20 MHz frequency range."]
            #[inline]
            pub fn _1_to_20_mhz_frequency(self) -> &'a mut W {
                self.variant(FREQRANGEW::_1_TO_20_MHZ_FREQUENCY)
            }
            #[doc = "15 - 25 MHz frequency range"]
            #[inline]
            pub fn _15_to_25_mhz_frequenc(self) -> &'a mut W {
                self.variant(FREQRANGEW::_15_TO_25_MHZ_FREQUENC)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Bypass system oscillator"]
            #[inline]
            pub fn bypass(&self) -> BYPASSR {
                BYPASSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Determines oscillator frequency range."]
            #[inline]
            pub fn freqrange(&self) -> FREQRANGER {
                FREQRANGER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Bypass system oscillator"]
            #[inline]
            pub fn bypass(&mut self) -> _BYPASSW {
                _BYPASSW { w: self }
            }
            #[doc = "Bit 1 - Determines oscillator frequency range."]
            #[inline]
            pub fn freqrange(&mut self) -> _FREQRANGEW {
                _FREQRANGEW { w: self }
            }
        }
    }
    #[doc = "Watchdog oscillator control"]
    pub struct WDTOSCCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog oscillator control"]
    pub mod wdtoscctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WDTOSCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVSELR {
            bits: u8,
        }
        impl DIVSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `FREQSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQSELR {
            #[doc = "0.6 MHz"]
            _0_6,
            #[doc = "1.05 MHz"]
            _1_05,
            #[doc = "1.4 MHz"]
            _1_4,
            #[doc = "1.75 MHz"]
            _1_75,
            #[doc = "2.1 MHz"]
            _2_1,
            #[doc = "2.4 MHz"]
            _2_4,
            #[doc = "2.7 MHz"]
            _2_7,
            #[doc = "3.0 MHz"]
            _3_0,
            #[doc = "3.25 MHz"]
            _3_25,
            #[doc = "3.5 MHz"]
            _3_5,
            #[doc = "3.75 MHz"]
            _3_75,
            #[doc = "4.0 MHz"]
            _4_0,
            #[doc = "4.2 MHz"]
            _4_2,
            #[doc = "4.4 MHz"]
            _4_4,
            #[doc = "4.6 MHz"]
            _4_6,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FREQSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FREQSELR::_0_6 => 0x01,
                    FREQSELR::_1_05 => 0x02,
                    FREQSELR::_1_4 => 0x03,
                    FREQSELR::_1_75 => 0x04,
                    FREQSELR::_2_1 => 0x05,
                    FREQSELR::_2_4 => 0x06,
                    FREQSELR::_2_7 => 0x07,
                    FREQSELR::_3_0 => 0x08,
                    FREQSELR::_3_25 => 0x09,
                    FREQSELR::_3_5 => 0x0a,
                    FREQSELR::_3_75 => 0x0b,
                    FREQSELR::_4_0 => 0x0c,
                    FREQSELR::_4_2 => 0x0d,
                    FREQSELR::_4_4 => 0x0e,
                    FREQSELR::_4_6 => 0x0f,
                    FREQSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FREQSELR {
                match value {
                    1 => FREQSELR::_0_6,
                    2 => FREQSELR::_1_05,
                    3 => FREQSELR::_1_4,
                    4 => FREQSELR::_1_75,
                    5 => FREQSELR::_2_1,
                    6 => FREQSELR::_2_4,
                    7 => FREQSELR::_2_7,
                    8 => FREQSELR::_3_0,
                    9 => FREQSELR::_3_25,
                    10 => FREQSELR::_3_5,
                    11 => FREQSELR::_3_75,
                    12 => FREQSELR::_4_0,
                    13 => FREQSELR::_4_2,
                    14 => FREQSELR::_4_4,
                    15 => FREQSELR::_4_6,
                    i => FREQSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0_6`"]
            #[inline]
            pub fn is_0_6(&self) -> bool {
                *self == FREQSELR::_0_6
            }
            #[doc = "Checks if the value of the field is `_1_05`"]
            #[inline]
            pub fn is_1_05(&self) -> bool {
                *self == FREQSELR::_1_05
            }
            #[doc = "Checks if the value of the field is `_1_4`"]
            #[inline]
            pub fn is_1_4(&self) -> bool {
                *self == FREQSELR::_1_4
            }
            #[doc = "Checks if the value of the field is `_1_75`"]
            #[inline]
            pub fn is_1_75(&self) -> bool {
                *self == FREQSELR::_1_75
            }
            #[doc = "Checks if the value of the field is `_2_1`"]
            #[inline]
            pub fn is_2_1(&self) -> bool {
                *self == FREQSELR::_2_1
            }
            #[doc = "Checks if the value of the field is `_2_4`"]
            #[inline]
            pub fn is_2_4(&self) -> bool {
                *self == FREQSELR::_2_4
            }
            #[doc = "Checks if the value of the field is `_2_7`"]
            #[inline]
            pub fn is_2_7(&self) -> bool {
                *self == FREQSELR::_2_7
            }
            #[doc = "Checks if the value of the field is `_3_0`"]
            #[inline]
            pub fn is_3_0(&self) -> bool {
                *self == FREQSELR::_3_0
            }
            #[doc = "Checks if the value of the field is `_3_25`"]
            #[inline]
            pub fn is_3_25(&self) -> bool {
                *self == FREQSELR::_3_25
            }
            #[doc = "Checks if the value of the field is `_3_5`"]
            #[inline]
            pub fn is_3_5(&self) -> bool {
                *self == FREQSELR::_3_5
            }
            #[doc = "Checks if the value of the field is `_3_75`"]
            #[inline]
            pub fn is_3_75(&self) -> bool {
                *self == FREQSELR::_3_75
            }
            #[doc = "Checks if the value of the field is `_4_0`"]
            #[inline]
            pub fn is_4_0(&self) -> bool {
                *self == FREQSELR::_4_0
            }
            #[doc = "Checks if the value of the field is `_4_2`"]
            #[inline]
            pub fn is_4_2(&self) -> bool {
                *self == FREQSELR::_4_2
            }
            #[doc = "Checks if the value of the field is `_4_4`"]
            #[inline]
            pub fn is_4_4(&self) -> bool {
                *self == FREQSELR::_4_4
            }
            #[doc = "Checks if the value of the field is `_4_6`"]
            #[inline]
            pub fn is_4_6(&self) -> bool {
                *self == FREQSELR::_4_6
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FREQSEL`"]
        pub enum FREQSELW {
            #[doc = "0.6 MHz"]
            _0_6,
            #[doc = "1.05 MHz"]
            _1_05,
            #[doc = "1.4 MHz"]
            _1_4,
            #[doc = "1.75 MHz"]
            _1_75,
            #[doc = "2.1 MHz"]
            _2_1,
            #[doc = "2.4 MHz"]
            _2_4,
            #[doc = "2.7 MHz"]
            _2_7,
            #[doc = "3.0 MHz"]
            _3_0,
            #[doc = "3.25 MHz"]
            _3_25,
            #[doc = "3.5 MHz"]
            _3_5,
            #[doc = "3.75 MHz"]
            _3_75,
            #[doc = "4.0 MHz"]
            _4_0,
            #[doc = "4.2 MHz"]
            _4_2,
            #[doc = "4.4 MHz"]
            _4_4,
            #[doc = "4.6 MHz"]
            _4_6,
        }
        impl FREQSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FREQSELW::_0_6 => 1,
                    FREQSELW::_1_05 => 2,
                    FREQSELW::_1_4 => 3,
                    FREQSELW::_1_75 => 4,
                    FREQSELW::_2_1 => 5,
                    FREQSELW::_2_4 => 6,
                    FREQSELW::_2_7 => 7,
                    FREQSELW::_3_0 => 8,
                    FREQSELW::_3_25 => 9,
                    FREQSELW::_3_5 => 10,
                    FREQSELW::_3_75 => 11,
                    FREQSELW::_4_0 => 12,
                    FREQSELW::_4_2 => 13,
                    FREQSELW::_4_4 => 14,
                    FREQSELW::_4_6 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FREQSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "0.6 MHz"]
            #[inline]
            pub fn _0_6(self) -> &'a mut W {
                self.variant(FREQSELW::_0_6)
            }
            #[doc = "1.05 MHz"]
            #[inline]
            pub fn _1_05(self) -> &'a mut W {
                self.variant(FREQSELW::_1_05)
            }
            #[doc = "1.4 MHz"]
            #[inline]
            pub fn _1_4(self) -> &'a mut W {
                self.variant(FREQSELW::_1_4)
            }
            #[doc = "1.75 MHz"]
            #[inline]
            pub fn _1_75(self) -> &'a mut W {
                self.variant(FREQSELW::_1_75)
            }
            #[doc = "2.1 MHz"]
            #[inline]
            pub fn _2_1(self) -> &'a mut W {
                self.variant(FREQSELW::_2_1)
            }
            #[doc = "2.4 MHz"]
            #[inline]
            pub fn _2_4(self) -> &'a mut W {
                self.variant(FREQSELW::_2_4)
            }
            #[doc = "2.7 MHz"]
            #[inline]
            pub fn _2_7(self) -> &'a mut W {
                self.variant(FREQSELW::_2_7)
            }
            #[doc = "3.0 MHz"]
            #[inline]
            pub fn _3_0(self) -> &'a mut W {
                self.variant(FREQSELW::_3_0)
            }
            #[doc = "3.25 MHz"]
            #[inline]
            pub fn _3_25(self) -> &'a mut W {
                self.variant(FREQSELW::_3_25)
            }
            #[doc = "3.5 MHz"]
            #[inline]
            pub fn _3_5(self) -> &'a mut W {
                self.variant(FREQSELW::_3_5)
            }
            #[doc = "3.75 MHz"]
            #[inline]
            pub fn _3_75(self) -> &'a mut W {
                self.variant(FREQSELW::_3_75)
            }
            #[doc = "4.0 MHz"]
            #[inline]
            pub fn _4_0(self) -> &'a mut W {
                self.variant(FREQSELW::_4_0)
            }
            #[doc = "4.2 MHz"]
            #[inline]
            pub fn _4_2(self) -> &'a mut W {
                self.variant(FREQSELW::_4_2)
            }
            #[doc = "4.4 MHz"]
            #[inline]
            pub fn _4_4(self) -> &'a mut W {
                self.variant(FREQSELW::_4_4)
            }
            #[doc = "4.6 MHz"]
            #[inline]
            pub fn _4_6(self) -> &'a mut W {
                self.variant(FREQSELW::_4_6)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64"]
            #[inline]
            pub fn divsel(&self) -> DIVSELR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVSELR { bits }
            }
            #[doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)."]
            #[inline]
            pub fn freqsel(&self) -> FREQSELR {
                FREQSELR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xa0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64"]
            #[inline]
            pub fn divsel(&mut self) -> _DIVSELW {
                _DIVSELW { w: self }
            }
            #[doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)."]
            #[inline]
            pub fn freqsel(&mut self) -> _FREQSELW {
                _FREQSELW { w: self }
            }
        }
    }
    #[doc = "IRC control"]
    pub struct IRCCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "IRC control"]
    pub mod ircctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRIMR {
            bits: u8,
        }
        impl TRIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Trim value"]
            #[inline]
            pub fn trim(&self) -> TRIMR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRIMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Trim value"]
            #[inline]
            pub fn trim(&mut self) -> _TRIMW {
                _TRIMW { w: self }
            }
        }
    }
    #[doc = "System reset status register"]
    pub struct SYSRSTSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System reset status register"]
    pub mod sysrststat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSRSTSTAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PORR {
            #[doc = "No POR detected"]
            NO_POR_DETECTED,
            #[doc = "POR detected. Writing a one clears this reset."]
            POR_DETECTED,
        }
        impl PORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PORR::NO_POR_DETECTED => false,
                    PORR::POR_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PORR {
                match value {
                    false => PORR::NO_POR_DETECTED,
                    true => PORR::POR_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_POR_DETECTED`"]
            #[inline]
            pub fn is_no_por_detected(&self) -> bool {
                *self == PORR::NO_POR_DETECTED
            }
            #[doc = "Checks if the value of the field is `POR_DETECTED`"]
            #[inline]
            pub fn is_por_detected(&self) -> bool {
                *self == PORR::POR_DETECTED
            }
        }
        #[doc = "Possible values of the field `EXTRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTRSTR {
            #[doc = "No reset event detected."]
            NO_RESET_EVENT_DETEC,
            #[doc = "Reset detected. Writing a one clears this reset."]
            RESET_DETECTED,
        }
        impl EXTRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EXTRSTR::NO_RESET_EVENT_DETEC => false,
                    EXTRSTR::RESET_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EXTRSTR {
                match value {
                    false => EXTRSTR::NO_RESET_EVENT_DETEC,
                    true => EXTRSTR::RESET_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_RESET_EVENT_DETEC`"]
            #[inline]
            pub fn is_no_reset_event_detec(&self) -> bool {
                *self == EXTRSTR::NO_RESET_EVENT_DETEC
            }
            #[doc = "Checks if the value of the field is `RESET_DETECTED`"]
            #[inline]
            pub fn is_reset_detected(&self) -> bool {
                *self == EXTRSTR::RESET_DETECTED
            }
        }
        #[doc = "Possible values of the field `WDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTR {
            #[doc = "No WDT reset detected"]
            NO_WDT_RESET_DETECTE,
            #[doc = "WDT reset detected. Writing a one clears this reset."]
            WDT_RESET_DETECTED,
        }
        impl WDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTR::NO_WDT_RESET_DETECTE => false,
                    WDTR::WDT_RESET_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTR {
                match value {
                    false => WDTR::NO_WDT_RESET_DETECTE,
                    true => WDTR::WDT_RESET_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_WDT_RESET_DETECTE`"]
            #[inline]
            pub fn is_no_wdt_reset_detecte(&self) -> bool {
                *self == WDTR::NO_WDT_RESET_DETECTE
            }
            #[doc = "Checks if the value of the field is `WDT_RESET_DETECTED`"]
            #[inline]
            pub fn is_wdt_reset_detected(&self) -> bool {
                *self == WDTR::WDT_RESET_DETECTED
            }
        }
        #[doc = "Possible values of the field `BOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODR {
            #[doc = "No BOD reset detected"]
            NO_BOD_RESET_DETECTE,
            #[doc = "BOD reset detected. Writing a one clears this reset."]
            BOD_RESET_DETECTED,
        }
        impl BODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BODR::NO_BOD_RESET_DETECTE => false,
                    BODR::BOD_RESET_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BODR {
                match value {
                    false => BODR::NO_BOD_RESET_DETECTE,
                    true => BODR::BOD_RESET_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_BOD_RESET_DETECTE`"]
            #[inline]
            pub fn is_no_bod_reset_detecte(&self) -> bool {
                *self == BODR::NO_BOD_RESET_DETECTE
            }
            #[doc = "Checks if the value of the field is `BOD_RESET_DETECTED`"]
            #[inline]
            pub fn is_bod_reset_detected(&self) -> bool {
                *self == BODR::BOD_RESET_DETECTED
            }
        }
        #[doc = "Possible values of the field `SYSRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSRSTR {
            #[doc = "No System reset detected"]
            NO_SYSTEM_RESET_DETE,
            #[doc = "System reset detected. Writing a one clears this reset."]
            SYSTEM_RESET_DETECTE,
        }
        impl SYSRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSRSTR::NO_SYSTEM_RESET_DETE => false,
                    SYSRSTR::SYSTEM_RESET_DETECTE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSRSTR {
                match value {
                    false => SYSRSTR::NO_SYSTEM_RESET_DETE,
                    true => SYSRSTR::SYSTEM_RESET_DETECTE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_SYSTEM_RESET_DETE`"]
            #[inline]
            pub fn is_no_system_reset_dete(&self) -> bool {
                *self == SYSRSTR::NO_SYSTEM_RESET_DETE
            }
            #[doc = "Checks if the value of the field is `SYSTEM_RESET_DETECTE`"]
            #[inline]
            pub fn is_system_reset_detecte(&self) -> bool {
                *self == SYSRSTR::SYSTEM_RESET_DETECTE
            }
        }
        #[doc = "Values that can be written to the field `POR`"]
        pub enum PORW {
            #[doc = "No POR detected"]
            NO_POR_DETECTED,
            #[doc = "POR detected. Writing a one clears this reset."]
            POR_DETECTED,
        }
        impl PORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PORW::NO_POR_DETECTED => false,
                    PORW::POR_DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No POR detected"]
            #[inline]
            pub fn no_por_detected(self) -> &'a mut W {
                self.variant(PORW::NO_POR_DETECTED)
            }
            #[doc = "POR detected. Writing a one clears this reset."]
            #[inline]
            pub fn por_detected(self) -> &'a mut W {
                self.variant(PORW::POR_DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EXTRST`"]
        pub enum EXTRSTW {
            #[doc = "No reset event detected."]
            NO_RESET_EVENT_DETEC,
            #[doc = "Reset detected. Writing a one clears this reset."]
            RESET_DETECTED,
        }
        impl EXTRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EXTRSTW::NO_RESET_EVENT_DETEC => false,
                    EXTRSTW::RESET_DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EXTRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset event detected."]
            #[inline]
            pub fn no_reset_event_detec(self) -> &'a mut W {
                self.variant(EXTRSTW::NO_RESET_EVENT_DETEC)
            }
            #[doc = "Reset detected. Writing a one clears this reset."]
            #[inline]
            pub fn reset_detected(self) -> &'a mut W {
                self.variant(EXTRSTW::RESET_DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDT`"]
        pub enum WDTW {
            #[doc = "No WDT reset detected"]
            NO_WDT_RESET_DETECTE,
            #[doc = "WDT reset detected. Writing a one clears this reset."]
            WDT_RESET_DETECTED,
        }
        impl WDTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTW::NO_WDT_RESET_DETECTE => false,
                    WDTW::WDT_RESET_DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No WDT reset detected"]
            #[inline]
            pub fn no_wdt_reset_detecte(self) -> &'a mut W {
                self.variant(WDTW::NO_WDT_RESET_DETECTE)
            }
            #[doc = "WDT reset detected. Writing a one clears this reset."]
            #[inline]
            pub fn wdt_reset_detected(self) -> &'a mut W {
                self.variant(WDTW::WDT_RESET_DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD`"]
        pub enum BODW {
            #[doc = "No BOD reset detected"]
            NO_BOD_RESET_DETECTE,
            #[doc = "BOD reset detected. Writing a one clears this reset."]
            BOD_RESET_DETECTED,
        }
        impl BODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BODW::NO_BOD_RESET_DETECTE => false,
                    BODW::BOD_RESET_DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No BOD reset detected"]
            #[inline]
            pub fn no_bod_reset_detecte(self) -> &'a mut W {
                self.variant(BODW::NO_BOD_RESET_DETECTE)
            }
            #[doc = "BOD reset detected. Writing a one clears this reset."]
            #[inline]
            pub fn bod_reset_detected(self) -> &'a mut W {
                self.variant(BODW::BOD_RESET_DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSRST`"]
        pub enum SYSRSTW {
            #[doc = "No System reset detected"]
            NO_SYSTEM_RESET_DETE,
            #[doc = "System reset detected. Writing a one clears this reset."]
            SYSTEM_RESET_DETECTE,
        }
        impl SYSRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSRSTW::NO_SYSTEM_RESET_DETE => false,
                    SYSRSTW::SYSTEM_RESET_DETECTE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No System reset detected"]
            #[inline]
            pub fn no_system_reset_dete(self) -> &'a mut W {
                self.variant(SYSRSTW::NO_SYSTEM_RESET_DETE)
            }
            #[doc = "System reset detected. Writing a one clears this reset."]
            #[inline]
            pub fn system_reset_detecte(self) -> &'a mut W {
                self.variant(SYSRSTW::SYSTEM_RESET_DETECTE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - POR reset status"]
            #[inline]
            pub fn por(&self) -> PORR {
                PORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Status of the external RESET pin. External reset status."]
            #[inline]
            pub fn extrst(&self) -> EXTRSTR {
                EXTRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Status of the Watchdog reset"]
            #[inline]
            pub fn wdt(&self) -> WDTR {
                WDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Status of the Brown-out detect reset"]
            #[inline]
            pub fn bod(&self) -> BODR {
                BODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Status of the software system reset"]
            #[inline]
            pub fn sysrst(&self) -> SYSRSTR {
                SYSRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - POR reset status"]
            #[inline]
            pub fn por(&mut self) -> _PORW {
                _PORW { w: self }
            }
            #[doc = "Bit 1 - Status of the external RESET pin. External reset status."]
            #[inline]
            pub fn extrst(&mut self) -> _EXTRSTW {
                _EXTRSTW { w: self }
            }
            #[doc = "Bit 2 - Status of the Watchdog reset"]
            #[inline]
            pub fn wdt(&mut self) -> _WDTW {
                _WDTW { w: self }
            }
            #[doc = "Bit 3 - Status of the Brown-out detect reset"]
            #[inline]
            pub fn bod(&mut self) -> _BODW {
                _BODW { w: self }
            }
            #[doc = "Bit 4 - Status of the software system reset"]
            #[inline]
            pub fn sysrst(&mut self) -> _SYSRSTW {
                _SYSRSTW { w: self }
            }
        }
    }
    #[doc = "System PLL clock source select"]
    pub struct SYSPLLCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL clock source select"]
    pub mod syspllclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC"]
            IRC,
            #[doc = "Crystal Oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR,
            #[doc = "CLKIN. External clock input."]
            CLKIN,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC => 0,
                    SELR::CRYSTAL_OSCILLATOR => 0x01,
                    SELR::CLKIN => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC,
                    1 => SELR::CRYSTAL_OSCILLATOR,
                    3 => SELR::CLKIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC`"]
            #[inline]
            pub fn is_irc(&self) -> bool {
                *self == SELR::IRC
            }
            #[doc = "Checks if the value of the field is `CRYSTAL_OSCILLATOR`"]
            #[inline]
            pub fn is_crystal_oscillator(&self) -> bool {
                *self == SELR::CRYSTAL_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `CLKIN`"]
            #[inline]
            pub fn is_clkin(&self) -> bool {
                *self == SELR::CLKIN
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC"]
            IRC,
            #[doc = "Crystal Oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR,
            #[doc = "CLKIN. External clock input."]
            CLKIN,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC => 0,
                    SELW::CRYSTAL_OSCILLATOR => 1,
                    SELW::CLKIN => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IRC"]
            #[inline]
            pub fn irc(self) -> &'a mut W {
                self.variant(SELW::IRC)
            }
            #[doc = "Crystal Oscillator (SYSOSC)"]
            #[inline]
            pub fn crystal_oscillator(self) -> &'a mut W {
                self.variant(SELW::CRYSTAL_OSCILLATOR)
            }
            #[doc = "CLKIN. External clock input."]
            #[inline]
            pub fn clkin(self) -> &'a mut W {
                self.variant(SELW::CLKIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System PLL clock source"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System PLL clock source"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "System PLL clock source update enable"]
    pub struct SYSPLLCLKUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL clock source update enable"]
    pub mod syspllclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable system PLL clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable system PLL clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "Main clock source select"]
    pub struct MAINCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Main clock source select"]
    pub mod mainclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAINCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC Oscillator"]
            IRC_OSCILLATOR,
            #[doc = "PLL input"]
            PLL_INPUT,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "PLL output"]
            PLL_OUTPUT,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::PLL_INPUT => 0x01,
                    SELR::WATCHDOG_OSCILLATOR => 0x02,
                    SELR::PLL_OUTPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::PLL_INPUT,
                    2 => SELR::WATCHDOG_OSCILLATOR,
                    3 => SELR::PLL_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `PLL_INPUT`"]
            #[inline]
            pub fn is_pll_input(&self) -> bool {
                *self == SELR::PLL_INPUT
            }
            #[doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR`"]
            #[inline]
            pub fn is_watchdog_oscillator(&self) -> bool {
                *self == SELR::WATCHDOG_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `PLL_OUTPUT`"]
            #[inline]
            pub fn is_pll_output(&self) -> bool {
                *self == SELR::PLL_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC Oscillator"]
            IRC_OSCILLATOR,
            #[doc = "PLL input"]
            PLL_INPUT,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "PLL output"]
            PLL_OUTPUT,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::PLL_INPUT => 1,
                    SELW::WATCHDOG_OSCILLATOR => 2,
                    SELW::PLL_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "IRC Oscillator"]
            #[inline]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "PLL input"]
            #[inline]
            pub fn pll_input(self) -> &'a mut W {
                self.variant(SELW::PLL_INPUT)
            }
            #[doc = "Watchdog oscillator"]
            #[inline]
            pub fn watchdog_oscillator(self) -> &'a mut W {
                self.variant(SELW::WATCHDOG_OSCILLATOR)
            }
            #[doc = "PLL output"]
            #[inline]
            pub fn pll_output(self) -> &'a mut W {
                self.variant(SELW::PLL_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Clock source for main clock"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Clock source for main clock"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "Main clock source update enable"]
    pub struct MAINCLKUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Main clock source update enable"]
    pub mod mainclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAINCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable main clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable main clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "System clock divider"]
    pub struct SYSAHBCLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System clock divider"]
    pub mod sysahbclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSAHBCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "System clock control"]
    pub struct SYSAHBCLKCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System clock control"]
    pub mod sysahbclkctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSAHBCLKCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYSR {
            bits: bool,
        }
        impl SYSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `ROM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ROMR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ROMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ROMR::DISABLE => false,
                    ROMR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ROMR {
                match value {
                    false => ROMR::DISABLE,
                    true => ROMR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ROMR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == ROMR::ENABLE
            }
        }
        #[doc = "Possible values of the field `RAM0_1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAM0_1R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl RAM0_1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RAM0_1R::DISABLE => false,
                    RAM0_1R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RAM0_1R {
                match value {
                    false => RAM0_1R::DISABLE,
                    true => RAM0_1R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == RAM0_1R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == RAM0_1R::ENABLE
            }
        }
        #[doc = "Possible values of the field `FLASHREG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHREGR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHREGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASHREGR::DISABLE => false,
                    FLASHREGR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASHREGR {
                match value {
                    false => FLASHREGR::DISABLE,
                    true => FLASHREGR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == FLASHREGR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == FLASHREGR::ENABLE
            }
        }
        #[doc = "Possible values of the field `FLASH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASHR::DISABLE => false,
                    FLASHR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASHR {
                match value {
                    false => FLASHR::DISABLE,
                    true => FLASHR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == FLASHR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == FLASHR::ENABLE
            }
        }
        #[doc = "Possible values of the field `I2C0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C0R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C0R::DISABLE => false,
                    I2C0R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C0R {
                match value {
                    false => I2C0R::DISABLE,
                    true => I2C0R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == I2C0R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == I2C0R::ENABLE
            }
        }
        #[doc = "Possible values of the field `GPIO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GPIOR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl GPIOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GPIOR::DISABLE => false,
                    GPIOR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GPIOR {
                match value {
                    false => GPIOR::DISABLE,
                    true => GPIOR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == GPIOR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == GPIOR::ENABLE
            }
        }
        #[doc = "Possible values of the field `SWM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWMR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SWMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SWMR::DISABLE => false,
                    SWMR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SWMR {
                match value {
                    false => SWMR::DISABLE,
                    true => SWMR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == SWMR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == SWMR::ENABLE
            }
        }
        #[doc = "Possible values of the field `SCT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SCTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SCTR::DISABLE => false,
                    SCTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SCTR {
                match value {
                    false => SCTR::DISABLE,
                    true => SCTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == SCTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == SCTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `WKT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WKTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WKTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WKTR::DISABLE => false,
                    WKTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WKTR {
                match value {
                    false => WKTR::DISABLE,
                    true => WKTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == WKTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == WKTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `MRT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MRTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl MRTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MRTR::DISABLE => false,
                    MRTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MRTR {
                match value {
                    false => MRTR::DISABLE,
                    true => MRTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == MRTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == MRTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `SPI0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI0R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI0R::DISABLE => false,
                    SPI0R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPI0R {
                match value {
                    false => SPI0R::DISABLE,
                    true => SPI0R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == SPI0R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == SPI0R::ENABLE
            }
        }
        #[doc = "Possible values of the field `SPI1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI1R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI1R::DISABLE => false,
                    SPI1R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPI1R {
                match value {
                    false => SPI1R::DISABLE,
                    true => SPI1R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == SPI1R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == SPI1R::ENABLE
            }
        }
        #[doc = "Possible values of the field `CRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl CRCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CRCR::DISABLE => false,
                    CRCR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CRCR {
                match value {
                    false => CRCR::DISABLE,
                    true => CRCR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == CRCR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == CRCR::ENABLE
            }
        }
        #[doc = "Possible values of the field `UART0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART0R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UART0R::DISABLE => false,
                    UART0R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UART0R {
                match value {
                    false => UART0R::DISABLE,
                    true => UART0R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == UART0R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == UART0R::ENABLE
            }
        }
        #[doc = "Possible values of the field `UART1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART1R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UART1R::DISABLE => false,
                    UART1R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UART1R {
                match value {
                    false => UART1R::DISABLE,
                    true => UART1R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == UART1R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == UART1R::ENABLE
            }
        }
        #[doc = "Possible values of the field `UART2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART2R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UART2R::DISABLE => false,
                    UART2R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UART2R {
                match value {
                    false => UART2R::DISABLE,
                    true => UART2R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == UART2R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == UART2R::ENABLE
            }
        }
        #[doc = "Possible values of the field `WWDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WWDTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WWDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WWDTR::DISABLE => false,
                    WWDTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WWDTR {
                match value {
                    false => WWDTR::DISABLE,
                    true => WWDTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == WWDTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == WWDTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `IOCON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl IOCONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IOCONR::DISABLE => false,
                    IOCONR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IOCONR {
                match value {
                    false => IOCONR::DISABLE,
                    true => IOCONR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == IOCONR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == IOCONR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ACMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMPR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ACMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMPR::DISABLE => false,
                    ACMPR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMPR {
                match value {
                    false => ACMPR::DISABLE,
                    true => ACMPR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ACMPR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == ACMPR::ENABLE
            }
        }
        #[doc = "Possible values of the field `I2C1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C1R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C1R::DISABLE => false,
                    I2C1R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C1R {
                match value {
                    false => I2C1R::DISABLE,
                    true => I2C1R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == I2C1R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == I2C1R::ENABLE
            }
        }
        #[doc = "Possible values of the field `I2C2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C2R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C2R::DISABLE => false,
                    I2C2R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C2R {
                match value {
                    false => I2C2R::DISABLE,
                    true => I2C2R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == I2C2R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == I2C2R::ENABLE
            }
        }
        #[doc = "Possible values of the field `I2C3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C3R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C3R::DISABLE => false,
                    I2C3R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C3R {
                match value {
                    false => I2C3R::DISABLE,
                    true => I2C3R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == I2C3R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == I2C3R::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ADCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADCR::DISABLE => false,
                    ADCR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADCR {
                match value {
                    false => ADCR::DISABLE,
                    true => ADCR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ADCR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == ADCR::ENABLE
            }
        }
        #[doc = "Possible values of the field `MTB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MTBR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl MTBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MTBR::DISABLE => false,
                    MTBR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MTBR {
                match value {
                    false => MTBR::DISABLE,
                    true => MTBR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == MTBR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == MTBR::ENABLE
            }
        }
        #[doc = "Possible values of the field `DMA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl DMAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAR::DISABLE => false,
                    DMAR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAR {
                match value {
                    false => DMAR::DISABLE,
                    true => DMAR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == DMAR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == DMAR::ENABLE
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ROM`"]
        pub enum ROMW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ROMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ROMW::DISABLE => false,
                    ROMW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ROMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ROMW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(ROMW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RAM0_1`"]
        pub enum RAM0_1W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl RAM0_1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RAM0_1W::DISABLE => false,
                    RAM0_1W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RAM0_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RAM0_1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RAM0_1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(RAM0_1W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(RAM0_1W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASHREG`"]
        pub enum FLASHREGW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHREGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASHREGW::DISABLE => false,
                    FLASHREGW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHREGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHREGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASHREGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(FLASHREGW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(FLASHREGW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH`"]
        pub enum FLASHW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASHW::DISABLE => false,
                    FLASHW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(FLASHW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(FLASHW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C0`"]
        pub enum I2C0W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C0W::DISABLE => false,
                    I2C0W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(I2C0W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(I2C0W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GPIO`"]
        pub enum GPIOW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl GPIOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    GPIOW::DISABLE => false,
                    GPIOW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GPIOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(GPIOW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(GPIOW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWM`"]
        pub enum SWMW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SWMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWMW::DISABLE => false,
                    SWMW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(SWMW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(SWMW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCT`"]
        pub enum SCTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SCTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCTW::DISABLE => false,
                    SCTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SCTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(SCTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(SCTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WKT`"]
        pub enum WKTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WKTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WKTW::DISABLE => false,
                    WKTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WKTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WKTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WKTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(WKTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(WKTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MRT`"]
        pub enum MRTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl MRTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MRTW::DISABLE => false,
                    MRTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MRTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MRTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(MRTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(MRTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI0`"]
        pub enum SPI0W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI0W::DISABLE => false,
                    SPI0W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(SPI0W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(SPI0W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1`"]
        pub enum SPI1W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI1W::DISABLE => false,
                    SPI1W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(SPI1W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(SPI1W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CRC`"]
        pub enum CRCW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl CRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CRCW::DISABLE => false,
                    CRCW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CRCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(CRCW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(CRCW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART0`"]
        pub enum UART0W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART0W::DISABLE => false,
                    UART0W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(UART0W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(UART0W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART1`"]
        pub enum UART1W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART1W::DISABLE => false,
                    UART1W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(UART1W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(UART1W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART2`"]
        pub enum UART2W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART2W::DISABLE => false,
                    UART2W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(UART2W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(UART2W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDT`"]
        pub enum WWDTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WWDTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WWDTW::DISABLE => false,
                    WWDTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WWDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WWDTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WWDTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(WWDTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(WWDTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCON`"]
        pub enum IOCONW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl IOCONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IOCONW::DISABLE => false,
                    IOCONW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOCONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(IOCONW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(IOCONW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP`"]
        pub enum ACMPW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ACMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMPW::DISABLE => false,
                    ACMPW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ACMPW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(ACMPW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C1`"]
        pub enum I2C1W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C1W::DISABLE => false,
                    I2C1W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(I2C1W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(I2C1W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C2`"]
        pub enum I2C2W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C2W::DISABLE => false,
                    I2C2W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(I2C2W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(I2C2W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C3`"]
        pub enum I2C3W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2C3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C3W::DISABLE => false,
                    I2C3W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(I2C3W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(I2C3W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC`"]
        pub enum ADCW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ADCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADCW::DISABLE => false,
                    ADCW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ADCW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(ADCW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MTB`"]
        pub enum MTBW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl MTBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MTBW::DISABLE => false,
                    MTBW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MTBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MTBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MTBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(MTBW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(MTBW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMA`"]
        pub enum DMAW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl DMAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAW::DISABLE => false,
                    DMAW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(DMAW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(DMAW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enables the clock for the AHB, the APB bridge, the Cortex-M0+ core clocks, SYSCON, and the PMU. This bit is read only and always reads as 1."]
            #[inline]
            pub fn sys(&self) -> SYSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SYSR { bits }
            }
            #[doc = "Bit 1 - Enables clock for ROM."]
            #[inline]
            pub fn rom(&self) -> ROMR {
                ROMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enables clock for SRAM0 and SRAM1."]
            #[inline]
            pub fn ram0_1(&self) -> RAM0_1R {
                RAM0_1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enables clock for flash register interface."]
            #[inline]
            pub fn flashreg(&self) -> FLASHREGR {
                FLASHREGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enables clock for flash."]
            #[inline]
            pub fn flash(&self) -> FLASHR {
                FLASHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enables clock for I2C0."]
            #[inline]
            pub fn i2c0(&self) -> I2C0R {
                I2C0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enables clock for GPIO port registers and GPIO pin interrupt registers."]
            #[inline]
            pub fn gpio(&self) -> GPIOR {
                GPIOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enables clock for switch matrix."]
            #[inline]
            pub fn swm(&self) -> SWMR {
                SWMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enables clock for state configurable timer SCTimer/PWM."]
            #[inline]
            pub fn sct(&self) -> SCTR {
                SCTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enables clock for self wake-up timer."]
            #[inline]
            pub fn wkt(&self) -> WKTR {
                WKTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Enables clock for multi-rate timer."]
            #[inline]
            pub fn mrt(&self) -> MRTR {
                MRTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Enables clock for SPI0."]
            #[inline]
            pub fn spi0(&self) -> SPI0R {
                SPI0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Enables clock for SPI1."]
            #[inline]
            pub fn spi1(&self) -> SPI1R {
                SPI1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Enables clock for CRC."]
            #[inline]
            pub fn crc(&self) -> CRCR {
                CRCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Enables clock for USART0."]
            #[inline]
            pub fn uart0(&self) -> UART0R {
                UART0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Enables clock for USART1."]
            #[inline]
            pub fn uart1(&self) -> UART1R {
                UART1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Enables clock for USART2."]
            #[inline]
            pub fn uart2(&self) -> UART2R {
                UART2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Enables clock for WWDT."]
            #[inline]
            pub fn wwdt(&self) -> WWDTR {
                WWDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Enables clock for IOCON block."]
            #[inline]
            pub fn iocon(&self) -> IOCONR {
                IOCONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Enables clock to analog comparator."]
            #[inline]
            pub fn acmp(&self) -> ACMPR {
                ACMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Enables clock to I2C1."]
            #[inline]
            pub fn i2c1(&self) -> I2C1R {
                I2C1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Enables clock to I2C2."]
            #[inline]
            pub fn i2c2(&self) -> I2C2R {
                I2C2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Enables clock to I2C3."]
            #[inline]
            pub fn i2c3(&self) -> I2C3R {
                I2C3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Enables clock to ADC."]
            #[inline]
            pub fn adc(&self) -> ADCR {
                ADCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Enables clock to micro- trace buffer control registers. Turn on this clock when using the micro-trace buffer for debug purposes."]
            #[inline]
            pub fn mtb(&self) -> MTBR {
                MTBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Enables clock to DMA."]
            #[inline]
            pub fn dma(&self) -> DMAR {
                DMAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xdf }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enables the clock for the AHB, the APB bridge, the Cortex-M0+ core clocks, SYSCON, and the PMU. This bit is read only and always reads as 1."]
            #[inline]
            pub fn sys(&mut self) -> _SYSW {
                _SYSW { w: self }
            }
            #[doc = "Bit 1 - Enables clock for ROM."]
            #[inline]
            pub fn rom(&mut self) -> _ROMW {
                _ROMW { w: self }
            }
            #[doc = "Bit 2 - Enables clock for SRAM0 and SRAM1."]
            #[inline]
            pub fn ram0_1(&mut self) -> _RAM0_1W {
                _RAM0_1W { w: self }
            }
            #[doc = "Bit 3 - Enables clock for flash register interface."]
            #[inline]
            pub fn flashreg(&mut self) -> _FLASHREGW {
                _FLASHREGW { w: self }
            }
            #[doc = "Bit 4 - Enables clock for flash."]
            #[inline]
            pub fn flash(&mut self) -> _FLASHW {
                _FLASHW { w: self }
            }
            #[doc = "Bit 5 - Enables clock for I2C0."]
            #[inline]
            pub fn i2c0(&mut self) -> _I2C0W {
                _I2C0W { w: self }
            }
            #[doc = "Bit 6 - Enables clock for GPIO port registers and GPIO pin interrupt registers."]
            #[inline]
            pub fn gpio(&mut self) -> _GPIOW {
                _GPIOW { w: self }
            }
            #[doc = "Bit 7 - Enables clock for switch matrix."]
            #[inline]
            pub fn swm(&mut self) -> _SWMW {
                _SWMW { w: self }
            }
            #[doc = "Bit 8 - Enables clock for state configurable timer SCTimer/PWM."]
            #[inline]
            pub fn sct(&mut self) -> _SCTW {
                _SCTW { w: self }
            }
            #[doc = "Bit 9 - Enables clock for self wake-up timer."]
            #[inline]
            pub fn wkt(&mut self) -> _WKTW {
                _WKTW { w: self }
            }
            #[doc = "Bit 10 - Enables clock for multi-rate timer."]
            #[inline]
            pub fn mrt(&mut self) -> _MRTW {
                _MRTW { w: self }
            }
            #[doc = "Bit 11 - Enables clock for SPI0."]
            #[inline]
            pub fn spi0(&mut self) -> _SPI0W {
                _SPI0W { w: self }
            }
            #[doc = "Bit 12 - Enables clock for SPI1."]
            #[inline]
            pub fn spi1(&mut self) -> _SPI1W {
                _SPI1W { w: self }
            }
            #[doc = "Bit 13 - Enables clock for CRC."]
            #[inline]
            pub fn crc(&mut self) -> _CRCW {
                _CRCW { w: self }
            }
            #[doc = "Bit 14 - Enables clock for USART0."]
            #[inline]
            pub fn uart0(&mut self) -> _UART0W {
                _UART0W { w: self }
            }
            #[doc = "Bit 15 - Enables clock for USART1."]
            #[inline]
            pub fn uart1(&mut self) -> _UART1W {
                _UART1W { w: self }
            }
            #[doc = "Bit 16 - Enables clock for USART2."]
            #[inline]
            pub fn uart2(&mut self) -> _UART2W {
                _UART2W { w: self }
            }
            #[doc = "Bit 17 - Enables clock for WWDT."]
            #[inline]
            pub fn wwdt(&mut self) -> _WWDTW {
                _WWDTW { w: self }
            }
            #[doc = "Bit 18 - Enables clock for IOCON block."]
            #[inline]
            pub fn iocon(&mut self) -> _IOCONW {
                _IOCONW { w: self }
            }
            #[doc = "Bit 19 - Enables clock to analog comparator."]
            #[inline]
            pub fn acmp(&mut self) -> _ACMPW {
                _ACMPW { w: self }
            }
            #[doc = "Bit 21 - Enables clock to I2C1."]
            #[inline]
            pub fn i2c1(&mut self) -> _I2C1W {
                _I2C1W { w: self }
            }
            #[doc = "Bit 22 - Enables clock to I2C2."]
            #[inline]
            pub fn i2c2(&mut self) -> _I2C2W {
                _I2C2W { w: self }
            }
            #[doc = "Bit 23 - Enables clock to I2C3."]
            #[inline]
            pub fn i2c3(&mut self) -> _I2C3W {
                _I2C3W { w: self }
            }
            #[doc = "Bit 24 - Enables clock to ADC."]
            #[inline]
            pub fn adc(&mut self) -> _ADCW {
                _ADCW { w: self }
            }
            #[doc = "Bit 26 - Enables clock to micro- trace buffer control registers. Turn on this clock when using the micro-trace buffer for debug purposes."]
            #[inline]
            pub fn mtb(&mut self) -> _MTBW {
                _MTBW { w: self }
            }
            #[doc = "Bit 29 - Enables clock to DMA."]
            #[inline]
            pub fn dma(&mut self) -> _DMAW {
                _DMAW { w: self }
            }
        }
    }
    #[doc = "USART clock divider"]
    pub struct UARTCLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USART clock divider"]
    pub mod uartclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UARTCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - USART fractional baud rate generator clock divider values. 0: Clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - USART fractional baud rate generator clock divider values. 0: Clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock source select"]
    pub struct CLKOUTSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock source select"]
    pub mod clkoutsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Crystal oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::CRYSTAL_OSCILLATOR => 0x01,
                    SELR::WATCHDOG_OSCILLATOR => 0x02,
                    SELR::MAIN_CLOCK => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::CRYSTAL_OSCILLATOR,
                    2 => SELR::WATCHDOG_OSCILLATOR,
                    3 => SELR::MAIN_CLOCK,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `CRYSTAL_OSCILLATOR`"]
            #[inline]
            pub fn is_crystal_oscillator(&self) -> bool {
                *self == SELR::CRYSTAL_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR`"]
            #[inline]
            pub fn is_watchdog_oscillator(&self) -> bool {
                *self == SELR::WATCHDOG_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `MAIN_CLOCK`"]
            #[inline]
            pub fn is_main_clock(&self) -> bool {
                *self == SELR::MAIN_CLOCK
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Crystal oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::CRYSTAL_OSCILLATOR => 1,
                    SELW::WATCHDOG_OSCILLATOR => 2,
                    SELW::MAIN_CLOCK => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "IRC oscillator"]
            #[inline]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "Crystal oscillator (SYSOSC)"]
            #[inline]
            pub fn crystal_oscillator(self) -> &'a mut W {
                self.variant(SELW::CRYSTAL_OSCILLATOR)
            }
            #[doc = "Watchdog oscillator"]
            #[inline]
            pub fn watchdog_oscillator(self) -> &'a mut W {
                self.variant(SELW::WATCHDOG_OSCILLATOR)
            }
            #[doc = "Main clock"]
            #[inline]
            pub fn main_clock(self) -> &'a mut W {
                self.variant(SELW::MAIN_CLOCK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - CLKOUT clock source"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CLKOUT clock source"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock source update enable"]
    pub struct CLKOUTUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock source update enable"]
    pub mod clkoutuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable CLKOUT clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable CLKOUT clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock divider"]
    pub struct CLKOUTDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock divider"]
    pub mod clkoutdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - CLKOUT clock divider values 0: Disable CLKOUT clock divider. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - CLKOUT clock divider values 0: Disable CLKOUT clock divider. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "USART1 to USART4 common fractional generator divider value"]
    pub struct UARTFRGDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USART1 to USART4 common fractional generator divider value"]
    pub mod uartfrgdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UARTFRGDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "USART1 to USART4 common fractional generator multiplier value"]
    pub struct UARTFRGMULT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USART1 to USART4 common fractional generator multiplier value"]
    pub mod uartfrgmult {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UARTFRGMULT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MULTR {
            bits: u8,
        }
        impl MULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MULTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MULTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Numerator of the fractional divider. MULT is equal to the programmed value."]
            #[inline]
            pub fn mult(&self) -> MULTR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MULTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Numerator of the fractional divider. MULT is equal to the programmed value."]
            #[inline]
            pub fn mult(&mut self) -> _MULTW {
                _MULTW { w: self }
            }
        }
    }
    #[doc = "External trace buffer command register"]
    pub struct EXTTRACECMD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External trace buffer command register"]
    pub mod exttracecmd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTTRACECMD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: bool,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Trace start command. Writing a one to this bit sets the TSTART signal to the MTB to HIGH and starts tracing if the TSTARTEN bit in the MTB master register is set to one as well."]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 1 - Trace stop command. Writing a one to this bit sets the TSTOP signal in the MTB to HIGH and stops tracing if the TSTOPEN bit in the MTB master register is set to one as well."]
            #[inline]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Trace start command. Writing a one to this bit sets the TSTART signal to the MTB to HIGH and starts tracing if the TSTARTEN bit in the MTB master register is set to one as well."]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 1 - Trace stop command. Writing a one to this bit sets the TSTOP signal in the MTB to HIGH and stops tracing if the TSTOPEN bit in the MTB master register is set to one as well."]
            #[inline]
            pub fn stop(&mut self) -> _STOPW {
                _STOPW { w: self }
            }
        }
    }
    #[doc = "POR captured PIO status 0"]
    pub struct PIOPORCAP0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "POR captured PIO status 0"]
    pub mod pioporcap0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PIOPORCAP0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIOSTATR {
            bits: u32,
        }
        impl PIOSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - State of PIO0_17 through PIO0_0 at power-on reset"]
            #[inline]
            pub fn piostat(&self) -> PIOSTATR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PIOSTATR { bits }
            }
        }
    }
    #[doc = "Peripheral clock 6 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 6 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 5 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 5 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 4 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 4 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 3 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 3 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 2 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 2 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 1 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 1 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 0 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 0 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Brown-Out Detect"]
    pub struct BODCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Brown-Out Detect"]
    pub mod bodctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BODCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BODRSTLEV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODRSTLEVR {
            #[doc = "Level 1."]
            LEVEL_1,
            #[doc = "Level 2."]
            LEVEL_2,
            #[doc = "Level 3."]
            LEVEL_3,
        }
        impl BODRSTLEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    BODRSTLEVR::LEVEL_1 => 0x01,
                    BODRSTLEVR::LEVEL_2 => 0x02,
                    BODRSTLEVR::LEVEL_3 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> BODRSTLEVR {
                match value {
                    1 => BODRSTLEVR::LEVEL_1,
                    2 => BODRSTLEVR::LEVEL_2,
                    3 => BODRSTLEVR::LEVEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LEVEL_1`"]
            #[inline]
            pub fn is_level_1(&self) -> bool {
                *self == BODRSTLEVR::LEVEL_1
            }
            #[doc = "Checks if the value of the field is `LEVEL_2`"]
            #[inline]
            pub fn is_level_2(&self) -> bool {
                *self == BODRSTLEVR::LEVEL_2
            }
            #[doc = "Checks if the value of the field is `LEVEL_3`"]
            #[inline]
            pub fn is_level_3(&self) -> bool {
                *self == BODRSTLEVR::LEVEL_3
            }
        }
        #[doc = "Possible values of the field `BODINTVAL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODINTVALR {
            #[doc = "Level 1."]
            LEVEL_1,
            #[doc = "Level 2."]
            LEVEL_2,
            #[doc = "Level 3."]
            LEVEL_3,
        }
        impl BODINTVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    BODINTVALR::LEVEL_1 => 0x01,
                    BODINTVALR::LEVEL_2 => 0x02,
                    BODINTVALR::LEVEL_3 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> BODINTVALR {
                match value {
                    1 => BODINTVALR::LEVEL_1,
                    2 => BODINTVALR::LEVEL_2,
                    3 => BODINTVALR::LEVEL_3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LEVEL_1`"]
            #[inline]
            pub fn is_level_1(&self) -> bool {
                *self == BODINTVALR::LEVEL_1
            }
            #[doc = "Checks if the value of the field is `LEVEL_2`"]
            #[inline]
            pub fn is_level_2(&self) -> bool {
                *self == BODINTVALR::LEVEL_2
            }
            #[doc = "Checks if the value of the field is `LEVEL_3`"]
            #[inline]
            pub fn is_level_3(&self) -> bool {
                *self == BODINTVALR::LEVEL_3
            }
        }
        #[doc = "Possible values of the field `BODRSTENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODRSTENAR {
            #[doc = "Disable reset function."]
            DISABLE_RESET_FUNCTI,
            #[doc = "Enable reset function."]
            ENABLE_RESET_FUNCTIO,
        }
        impl BODRSTENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BODRSTENAR::DISABLE_RESET_FUNCTI => false,
                    BODRSTENAR::ENABLE_RESET_FUNCTIO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BODRSTENAR {
                match value {
                    false => BODRSTENAR::DISABLE_RESET_FUNCTI,
                    true => BODRSTENAR::ENABLE_RESET_FUNCTIO,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_RESET_FUNCTI`"]
            #[inline]
            pub fn is_disable_reset_functi(&self) -> bool {
                *self == BODRSTENAR::DISABLE_RESET_FUNCTI
            }
            #[doc = "Checks if the value of the field is `ENABLE_RESET_FUNCTIO`"]
            #[inline]
            pub fn is_enable_reset_functio(&self) -> bool {
                *self == BODRSTENAR::ENABLE_RESET_FUNCTIO
            }
        }
        #[doc = "Values that can be written to the field `BODRSTLEV`"]
        pub enum BODRSTLEVW {
            #[doc = "Level 1."]
            LEVEL_1,
            #[doc = "Level 2."]
            LEVEL_2,
            #[doc = "Level 3."]
            LEVEL_3,
        }
        impl BODRSTLEVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BODRSTLEVW::LEVEL_1 => 1,
                    BODRSTLEVW::LEVEL_2 => 2,
                    BODRSTLEVW::LEVEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODRSTLEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODRSTLEVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODRSTLEVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Level 1."]
            #[inline]
            pub fn level_1(self) -> &'a mut W {
                self.variant(BODRSTLEVW::LEVEL_1)
            }
            #[doc = "Level 2."]
            #[inline]
            pub fn level_2(self) -> &'a mut W {
                self.variant(BODRSTLEVW::LEVEL_2)
            }
            #[doc = "Level 3."]
            #[inline]
            pub fn level_3(self) -> &'a mut W {
                self.variant(BODRSTLEVW::LEVEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BODINTVAL`"]
        pub enum BODINTVALW {
            #[doc = "Level 1."]
            LEVEL_1,
            #[doc = "Level 2."]
            LEVEL_2,
            #[doc = "Level 3."]
            LEVEL_3,
        }
        impl BODINTVALW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BODINTVALW::LEVEL_1 => 1,
                    BODINTVALW::LEVEL_2 => 2,
                    BODINTVALW::LEVEL_3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODINTVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODINTVALW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODINTVALW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Level 1."]
            #[inline]
            pub fn level_1(self) -> &'a mut W {
                self.variant(BODINTVALW::LEVEL_1)
            }
            #[doc = "Level 2."]
            #[inline]
            pub fn level_2(self) -> &'a mut W {
                self.variant(BODINTVALW::LEVEL_2)
            }
            #[doc = "Level 3."]
            #[inline]
            pub fn level_3(self) -> &'a mut W {
                self.variant(BODINTVALW::LEVEL_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BODRSTENA`"]
        pub enum BODRSTENAW {
            #[doc = "Disable reset function."]
            DISABLE_RESET_FUNCTI,
            #[doc = "Enable reset function."]
            ENABLE_RESET_FUNCTIO,
        }
        impl BODRSTENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BODRSTENAW::DISABLE_RESET_FUNCTI => false,
                    BODRSTENAW::ENABLE_RESET_FUNCTIO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODRSTENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODRSTENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODRSTENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable reset function."]
            #[inline]
            pub fn disable_reset_functi(self) -> &'a mut W {
                self.variant(BODRSTENAW::DISABLE_RESET_FUNCTI)
            }
            #[doc = "Enable reset function."]
            #[inline]
            pub fn enable_reset_functio(self) -> &'a mut W {
                self.variant(BODRSTENAW::ENABLE_RESET_FUNCTIO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - BOD reset level"]
            #[inline]
            pub fn bodrstlev(&self) -> BODRSTLEVR {
                BODRSTLEVR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - BOD interrupt level"]
            #[inline]
            pub fn bodintval(&self) -> BODINTVALR {
                BODINTVALR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 4 - BOD reset enable"]
            #[inline]
            pub fn bodrstena(&self) -> BODRSTENAR {
                BODRSTENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - BOD reset level"]
            #[inline]
            pub fn bodrstlev(&mut self) -> _BODRSTLEVW {
                _BODRSTLEVW { w: self }
            }
            #[doc = "Bits 2:3 - BOD interrupt level"]
            #[inline]
            pub fn bodintval(&mut self) -> _BODINTVALW {
                _BODINTVALW { w: self }
            }
            #[doc = "Bit 4 - BOD reset enable"]
            #[inline]
            pub fn bodrstena(&mut self) -> _BODRSTENAW {
                _BODRSTENAW { w: self }
            }
        }
    }
    #[doc = "System tick counter calibration"]
    pub struct SYSTCKCAL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System tick counter calibration"]
    pub mod systckcal {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSTCKCAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALR {
            bits: u32,
        }
        impl CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x03ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:25 - System tick timer calibration value"]
            #[inline]
            pub fn cal(&self) -> CALR {
                let bits = {
                    const MASK: u32 = 0x03ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:25 - System tick timer calibration value"]
            #[inline]
            pub fn cal(&mut self) -> _CALW {
                _CALW { w: self }
            }
        }
    }
    #[doc = "IQR delay. Allows trade-off between interrupt latency and determinism."]
    pub struct IRQLATENCY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "IQR delay. Allows trade-off between interrupt latency and determinism."]
    pub mod irqlatency {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRQLATENCY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LATENCYR {
            bits: u8,
        }
        impl LATENCYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LATENCYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LATENCYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - 8-bit latency value"]
            #[inline]
            pub fn latency(&self) -> LATENCYR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LATENCYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x10 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - 8-bit latency value"]
            #[inline]
            pub fn latency(&mut self) -> _LATENCYW {
                _LATENCYW { w: self }
            }
        }
    }
    #[doc = "NMI Source Control"]
    pub struct NMISRC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "NMI Source Control"]
    pub mod nmisrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NMISRC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRQNR {
            bits: u8,
        }
        impl IRQNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NMIENR {
            bits: bool,
        }
        impl NMIENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRQNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRQNW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 3 for the list of interrupt sources and their IRQ numbers."]
            #[inline]
            pub fn irqn(&self) -> IRQNR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IRQNR { bits }
            }
            #[doc = "Bit 31 - Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0."]
            #[inline]
            pub fn nmien(&self) -> NMIENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NMIENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 3 for the list of interrupt sources and their IRQ numbers."]
            #[inline]
            pub fn irqn(&mut self) -> _IRQNW {
                _IRQNW { w: self }
            }
            #[doc = "Bit 31 - Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0."]
            #[inline]
            pub fn nmien(&mut self) -> _NMIENW {
                _NMIENW { w: self }
            }
        }
    }
    #[doc = "GPIO Pin Interrupt Select register 0"]
    pub struct PINTSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "GPIO Pin Interrupt Select register 0"]
    pub mod pintsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINTSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTPINR {
            bits: u8,
        }
        impl INTPINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTPINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTPINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_28 correspond to numbers 0 to 28)."]
            #[inline]
            pub fn intpin(&self) -> INTPINR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INTPINR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_28 correspond to numbers 0 to 28)."]
            #[inline]
            pub fn intpin(&mut self) -> _INTPINW {
                _INTPINW { w: self }
            }
        }
    }
    #[doc = "Start logic 0 pin wake-up enable register"]
    pub struct STARTERP0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic 0 pin wake-up enable register"]
    pub mod starterp0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTERP0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PINT0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT0R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT0R::DISABLED => false,
                    PINT0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT0R {
                match value {
                    false => PINT0R::DISABLED,
                    true => PINT0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT1R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT1R::DISABLED => false,
                    PINT1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT1R {
                match value {
                    false => PINT1R::DISABLED,
                    true => PINT1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT2R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT2R::DISABLED => false,
                    PINT2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT2R {
                match value {
                    false => PINT2R::DISABLED,
                    true => PINT2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT3R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT3R::DISABLED => false,
                    PINT3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT3R {
                match value {
                    false => PINT3R::DISABLED,
                    true => PINT3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT4R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT4R::DISABLED => false,
                    PINT4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT4R {
                match value {
                    false => PINT4R::DISABLED,
                    true => PINT4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT5R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT5R::DISABLED => false,
                    PINT5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT5R {
                match value {
                    false => PINT5R::DISABLED,
                    true => PINT5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT6R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT6R::DISABLED => false,
                    PINT6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT6R {
                match value {
                    false => PINT6R::DISABLED,
                    true => PINT6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT7R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT7R::DISABLED => false,
                    PINT7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINT7R {
                match value {
                    false => PINT7R::DISABLED,
                    true => PINT7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PINT7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PINT7R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `PINT0`"]
        pub enum PINT0W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT0W::DISABLED => false,
                    PINT0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT0W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT1`"]
        pub enum PINT1W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT1W::DISABLED => false,
                    PINT1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT1W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT2`"]
        pub enum PINT2W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT2W::DISABLED => false,
                    PINT2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT2W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT3`"]
        pub enum PINT3W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT3W::DISABLED => false,
                    PINT3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT3W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT4`"]
        pub enum PINT4W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT4W::DISABLED => false,
                    PINT4W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT4W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT4W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT5`"]
        pub enum PINT5W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT5W::DISABLED => false,
                    PINT5W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT5W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT5W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT6`"]
        pub enum PINT6W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT6W::DISABLED => false,
                    PINT6W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT6W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT6W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT7`"]
        pub enum PINT7W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT7W::DISABLED => false,
                    PINT7W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINT7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT7W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT7W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - GPIO pin interrupt 0 wake-up"]
            #[inline]
            pub fn pint0(&self) -> PINT0R {
                PINT0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - GPIO pin interrupt 1 wake-up"]
            #[inline]
            pub fn pint1(&self) -> PINT1R {
                PINT1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - GPIO pin interrupt 2 wake-up"]
            #[inline]
            pub fn pint2(&self) -> PINT2R {
                PINT2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - GPIO pin interrupt 3 wake-up"]
            #[inline]
            pub fn pint3(&self) -> PINT3R {
                PINT3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - GPIO pin interrupt 4 wake-up"]
            #[inline]
            pub fn pint4(&self) -> PINT4R {
                PINT4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - GPIO pin interrupt 5 wake-up"]
            #[inline]
            pub fn pint5(&self) -> PINT5R {
                PINT5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - GPIO pin interrupt 6 wake-up"]
            #[inline]
            pub fn pint6(&self) -> PINT6R {
                PINT6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - GPIO pin interrupt 7 wake-up"]
            #[inline]
            pub fn pint7(&self) -> PINT7R {
                PINT7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - GPIO pin interrupt 0 wake-up"]
            #[inline]
            pub fn pint0(&mut self) -> _PINT0W {
                _PINT0W { w: self }
            }
            #[doc = "Bit 1 - GPIO pin interrupt 1 wake-up"]
            #[inline]
            pub fn pint1(&mut self) -> _PINT1W {
                _PINT1W { w: self }
            }
            #[doc = "Bit 2 - GPIO pin interrupt 2 wake-up"]
            #[inline]
            pub fn pint2(&mut self) -> _PINT2W {
                _PINT2W { w: self }
            }
            #[doc = "Bit 3 - GPIO pin interrupt 3 wake-up"]
            #[inline]
            pub fn pint3(&mut self) -> _PINT3W {
                _PINT3W { w: self }
            }
            #[doc = "Bit 4 - GPIO pin interrupt 4 wake-up"]
            #[inline]
            pub fn pint4(&mut self) -> _PINT4W {
                _PINT4W { w: self }
            }
            #[doc = "Bit 5 - GPIO pin interrupt 5 wake-up"]
            #[inline]
            pub fn pint5(&mut self) -> _PINT5W {
                _PINT5W { w: self }
            }
            #[doc = "Bit 6 - GPIO pin interrupt 6 wake-up"]
            #[inline]
            pub fn pint6(&mut self) -> _PINT6W {
                _PINT6W { w: self }
            }
            #[doc = "Bit 7 - GPIO pin interrupt 7 wake-up"]
            #[inline]
            pub fn pint7(&mut self) -> _PINT7W {
                _PINT7W { w: self }
            }
        }
    }
    #[doc = "Start logic 1 interrupt wake-up enable register"]
    pub struct STARTERP1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic 1 interrupt wake-up enable register"]
    pub mod starterp1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTERP1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SPI0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI0R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SPI0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI0R::DISABLED => false,
                    SPI0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPI0R {
                match value {
                    false => SPI0R::DISABLED,
                    true => SPI0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SPI0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SPI0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `SPI1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI1R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SPI1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI1R::DISABLED => false,
                    SPI1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPI1R {
                match value {
                    false => SPI1R::DISABLED,
                    true => SPI1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SPI1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SPI1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `USART0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USART0R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USART0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USART0R::DISABLED => false,
                    USART0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USART0R {
                match value {
                    false => USART0R::DISABLED,
                    true => USART0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == USART0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == USART0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `USART1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USART1R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USART1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USART1R::DISABLED => false,
                    USART1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USART1R {
                match value {
                    false => USART1R::DISABLED,
                    true => USART1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == USART1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == USART1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `USART2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USART2R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USART2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USART2R::DISABLED => false,
                    USART2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USART2R {
                match value {
                    false => USART2R::DISABLED,
                    true => USART2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == USART2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == USART2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `I2C1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C1R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C1R::DISABLED => false,
                    I2C1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C1R {
                match value {
                    false => I2C1R::DISABLED,
                    true => I2C1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == I2C1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == I2C1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `I2C0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C0R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C0R::DISABLED => false,
                    I2C0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C0R {
                match value {
                    false => I2C0R::DISABLED,
                    true => I2C0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == I2C0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == I2C0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `WWDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WWDTR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WWDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WWDTR::DISABLED => false,
                    WWDTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WWDTR {
                match value {
                    false => WWDTR::DISABLED,
                    true => WWDTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WWDTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WWDTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl BODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BODR::DISABLED => false,
                    BODR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BODR {
                match value {
                    false => BODR::DISABLED,
                    true => BODR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BODR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BODR::ENABLED
            }
        }
        #[doc = "Possible values of the field `WKT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WKTR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WKTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WKTR::DISABLED => false,
                    WKTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WKTR {
                match value {
                    false => WKTR::DISABLED,
                    true => WKTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WKTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WKTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `I2C2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C2R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C2R::DISABLED => false,
                    I2C2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C2R {
                match value {
                    false => I2C2R::DISABLED,
                    true => I2C2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == I2C2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == I2C2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `I2C3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C3R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C3R::DISABLED => false,
                    I2C3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C3R {
                match value {
                    false => I2C3R::DISABLED,
                    true => I2C3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == I2C3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == I2C3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `SPI0`"]
        pub enum SPI0W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SPI0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI0W::DISABLED => false,
                    SPI0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPI0W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPI0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1`"]
        pub enum SPI1W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SPI1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI1W::DISABLED => false,
                    SPI1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPI1W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPI1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART0`"]
        pub enum USART0W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USART0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USART0W::DISABLED => false,
                    USART0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USART0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USART0W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USART0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART1`"]
        pub enum USART1W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USART1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USART1W::DISABLED => false,
                    USART1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USART1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USART1W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USART1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART2`"]
        pub enum USART2W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USART2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USART2W::DISABLED => false,
                    USART2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USART2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USART2W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USART2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C1`"]
        pub enum I2C1W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C1W::DISABLED => false,
                    I2C1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2C1W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2C1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C0`"]
        pub enum I2C0W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C0W::DISABLED => false,
                    I2C0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2C0W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2C0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDT`"]
        pub enum WWDTW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WWDTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WWDTW::DISABLED => false,
                    WWDTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WWDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WWDTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WWDTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WWDTW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WWDTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD`"]
        pub enum BODW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl BODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BODW::DISABLED => false,
                    BODW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BODW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BODW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WKT`"]
        pub enum WKTW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WKTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WKTW::DISABLED => false,
                    WKTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WKTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WKTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WKTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WKTW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WKTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C2`"]
        pub enum I2C2W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C2W::DISABLED => false,
                    I2C2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2C2W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2C2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C3`"]
        pub enum I2C3W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2C3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C3W::DISABLED => false,
                    I2C3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2C3W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2C3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SPI0 interrupt wake-up"]
            #[inline]
            pub fn spi0(&self) -> SPI0R {
                SPI0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - SPI1 interrupt wake-up"]
            #[inline]
            pub fn spi1(&self) -> SPI1R {
                SPI1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - USART0 interrupt wake-up. Configure USART in synchronous slave mode."]
            #[inline]
            pub fn usart0(&self) -> USART0R {
                USART0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - USART1 interrupt wake-up. Configure USART in synchronous slave mode."]
            #[inline]
            pub fn usart1(&self) -> USART1R {
                USART1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - USART2 interrupt wake-up. Configure USART in synchronous slave mode."]
            #[inline]
            pub fn usart2(&self) -> USART2R {
                USART2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - I2C1 interrupt wake-up."]
            #[inline]
            pub fn i2c1(&self) -> I2C1R {
                I2C1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - I2C0 interrupt wake-up."]
            #[inline]
            pub fn i2c0(&self) -> I2C0R {
                I2C0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - WWDT interrupt wake-up"]
            #[inline]
            pub fn wwdt(&self) -> WWDTR {
                WWDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - BOD interrupt wake-up"]
            #[inline]
            pub fn bod(&self) -> BODR {
                BODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Self wake-up timer interrupt wake-up"]
            #[inline]
            pub fn wkt(&self) -> WKTR {
                WKTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - I2C2 interrupt wake-up."]
            #[inline]
            pub fn i2c2(&self) -> I2C2R {
                I2C2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - I2C3 interrupt wake-up."]
            #[inline]
            pub fn i2c3(&self) -> I2C3R {
                I2C3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SPI0 interrupt wake-up"]
            #[inline]
            pub fn spi0(&mut self) -> _SPI0W {
                _SPI0W { w: self }
            }
            #[doc = "Bit 1 - SPI1 interrupt wake-up"]
            #[inline]
            pub fn spi1(&mut self) -> _SPI1W {
                _SPI1W { w: self }
            }
            #[doc = "Bit 3 - USART0 interrupt wake-up. Configure USART in synchronous slave mode."]
            #[inline]
            pub fn usart0(&mut self) -> _USART0W {
                _USART0W { w: self }
            }
            #[doc = "Bit 4 - USART1 interrupt wake-up. Configure USART in synchronous slave mode."]
            #[inline]
            pub fn usart1(&mut self) -> _USART1W {
                _USART1W { w: self }
            }
            #[doc = "Bit 5 - USART2 interrupt wake-up. Configure USART in synchronous slave mode."]
            #[inline]
            pub fn usart2(&mut self) -> _USART2W {
                _USART2W { w: self }
            }
            #[doc = "Bit 7 - I2C1 interrupt wake-up."]
            #[inline]
            pub fn i2c1(&mut self) -> _I2C1W {
                _I2C1W { w: self }
            }
            #[doc = "Bit 8 - I2C0 interrupt wake-up."]
            #[inline]
            pub fn i2c0(&mut self) -> _I2C0W {
                _I2C0W { w: self }
            }
            #[doc = "Bit 12 - WWDT interrupt wake-up"]
            #[inline]
            pub fn wwdt(&mut self) -> _WWDTW {
                _WWDTW { w: self }
            }
            #[doc = "Bit 13 - BOD interrupt wake-up"]
            #[inline]
            pub fn bod(&mut self) -> _BODW {
                _BODW { w: self }
            }
            #[doc = "Bit 15 - Self wake-up timer interrupt wake-up"]
            #[inline]
            pub fn wkt(&mut self) -> _WKTW {
                _WKTW { w: self }
            }
            #[doc = "Bit 21 - I2C2 interrupt wake-up."]
            #[inline]
            pub fn i2c2(&mut self) -> _I2C2W {
                _I2C2W { w: self }
            }
            #[doc = "Bit 22 - I2C3 interrupt wake-up."]
            #[inline]
            pub fn i2c3(&mut self) -> _I2C3W {
                _I2C3W { w: self }
            }
        }
    }
    #[doc = "Power-down states in deep-sleep mode"]
    pub struct PDSLEEPCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power-down states in deep-sleep mode"]
    pub mod pdsleepcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDSLEEPCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - BOD power-down control for Deep-sleep and Power-down mode"]
            #[inline]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator power-down control for Deep-sleep and Power-down mode. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - BOD power-down control for Deep-sleep and Power-down mode"]
            #[inline]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator power-down control for Deep-sleep and Power-down mode. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
        }
    }
    #[doc = "Power-down states for wake-up from deep-sleep"]
    pub struct PDAWAKECFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power-down states for wake-up from deep-sleep"]
    pub mod pdawakecfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDAWAKECFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IRCOUT_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRCOUT_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRCOUT_PDR::POWERED => false,
                    IRCOUT_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRCOUT_PDR {
                match value {
                    false => IRCOUT_PDR::POWERED,
                    true => IRCOUT_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRCOUT_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRCOUT_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `IRC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRC_PDR::POWERED => false,
                    IRC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRC_PDR {
                match value {
                    false => IRC_PDR::POWERED,
                    true => IRC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `FLASH_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_PDR::POWERED => false,
                    FLASH_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASH_PDR {
                match value {
                    false => FLASH_PDR::POWERED,
                    true => FLASH_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == FLASH_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == FLASH_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ADC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_PDR::POWERED => false,
                    ADC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_PDR {
                match value {
                    false => ADC_PDR::POWERED,
                    true => ADC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == ADC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == ADC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSOSC_PDR::POWERED => false,
                    SYSOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSOSC_PDR {
                match value {
                    false => SYSOSC_PDR::POWERED,
                    true => SYSOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSPLL_PDR::POWERED => false,
                    SYSPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSPLL_PDR {
                match value {
                    false => SYSPLL_PDR::POWERED,
                    true => SYSPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ACMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMPR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMPR::POWERED => false,
                    ACMPR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMPR {
                match value {
                    false => ACMPR::POWERED,
                    true => ACMPR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == ACMPR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == ACMPR::POWERED_DOWN
            }
        }
        #[doc = "Values that can be written to the field `IRCOUT_PD`"]
        pub enum IRCOUT_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRCOUT_PDW::POWERED => false,
                    IRCOUT_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRCOUT_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRCOUT_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRCOUT_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IRC_PD`"]
        pub enum IRC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRC_PDW::POWERED => false,
                    IRC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_PD`"]
        pub enum FLASH_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_PDW::POWERED => false,
                    FLASH_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASH_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_PD`"]
        pub enum ADC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_PDW::POWERED => false,
                    ADC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSOSC_PD`"]
        pub enum SYSOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSOSC_PDW::POWERED => false,
                    SYSOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSPLL_PD`"]
        pub enum SYSPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSPLL_PDW::POWERED => false,
                    SYSPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP`"]
        pub enum ACMPW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMPW::POWERED => false,
                    ACMPW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(ACMPW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ACMPW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - IRC oscillator output wake-up configuration"]
            #[inline]
            pub fn ircout_pd(&self) -> IRCOUT_PDR {
                IRCOUT_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - IRC oscillator power-down wake-up configuration"]
            #[inline]
            pub fn irc_pd(&self) -> IRC_PDR {
                IRC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Flash wake-up configuration"]
            #[inline]
            pub fn flash_pd(&self) -> FLASH_PDR {
                FLASH_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - BOD wake-up configuration"]
            #[inline]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - ADC wake-up configuration"]
            #[inline]
            pub fn adc_pd(&self) -> ADC_PDR {
                ADC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Crystal oscillator wake-up configuration"]
            #[inline]
            pub fn sysosc_pd(&self) -> SYSOSC_PDR {
                SYSOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator wake-up configuration. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - System PLL wake-up configuration"]
            #[inline]
            pub fn syspll_pd(&self) -> SYSPLL_PDR {
                SYSPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Analog comparator wake-up configuration"]
            #[inline]
            pub fn acmp(&self) -> ACMPR {
                ACMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xedf0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRC oscillator output wake-up configuration"]
            #[inline]
            pub fn ircout_pd(&mut self) -> _IRCOUT_PDW {
                _IRCOUT_PDW { w: self }
            }
            #[doc = "Bit 1 - IRC oscillator power-down wake-up configuration"]
            #[inline]
            pub fn irc_pd(&mut self) -> _IRC_PDW {
                _IRC_PDW { w: self }
            }
            #[doc = "Bit 2 - Flash wake-up configuration"]
            #[inline]
            pub fn flash_pd(&mut self) -> _FLASH_PDW {
                _FLASH_PDW { w: self }
            }
            #[doc = "Bit 3 - BOD wake-up configuration"]
            #[inline]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 4 - ADC wake-up configuration"]
            #[inline]
            pub fn adc_pd(&mut self) -> _ADC_PDW {
                _ADC_PDW { w: self }
            }
            #[doc = "Bit 5 - Crystal oscillator wake-up configuration"]
            #[inline]
            pub fn sysosc_pd(&mut self) -> _SYSOSC_PDW {
                _SYSOSC_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator wake-up configuration. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
            #[doc = "Bit 7 - System PLL wake-up configuration"]
            #[inline]
            pub fn syspll_pd(&mut self) -> _SYSPLL_PDW {
                _SYSPLL_PDW { w: self }
            }
            #[doc = "Bit 15 - Analog comparator wake-up configuration"]
            #[inline]
            pub fn acmp(&mut self) -> _ACMPW {
                _ACMPW { w: self }
            }
        }
    }
    #[doc = "Power configuration register"]
    pub struct PDRUNCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power configuration register"]
    pub mod pdruncfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDRUNCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IRCOUT_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRCOUT_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRCOUT_PDR::POWERED => false,
                    IRCOUT_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRCOUT_PDR {
                match value {
                    false => IRCOUT_PDR::POWERED,
                    true => IRCOUT_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRCOUT_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRCOUT_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `IRC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRC_PDR::POWERED => false,
                    IRC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRC_PDR {
                match value {
                    false => IRC_PDR::POWERED,
                    true => IRC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `FLASH_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_PDR::POWERED => false,
                    FLASH_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASH_PDR {
                match value {
                    false => FLASH_PDR::POWERED,
                    true => FLASH_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == FLASH_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == FLASH_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ADC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_PDR::POWERED => false,
                    ADC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_PDR {
                match value {
                    false => ADC_PDR::POWERED,
                    true => ADC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == ADC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == ADC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSOSC_PDR::POWERED => false,
                    SYSOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSOSC_PDR {
                match value {
                    false => SYSOSC_PDR::POWERED,
                    true => SYSOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSPLL_PDR::POWERED => false,
                    SYSPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSPLL_PDR {
                match value {
                    false => SYSPLL_PDR::POWERED,
                    true => SYSPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ACMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMPR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMPR::POWERED => false,
                    ACMPR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACMPR {
                match value {
                    false => ACMPR::POWERED,
                    true => ACMPR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == ACMPR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == ACMPR::POWERED_DOWN
            }
        }
        #[doc = "Values that can be written to the field `IRCOUT_PD`"]
        pub enum IRCOUT_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRCOUT_PDW::POWERED => false,
                    IRCOUT_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRCOUT_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRCOUT_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRCOUT_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IRC_PD`"]
        pub enum IRC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRC_PDW::POWERED => false,
                    IRC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_PD`"]
        pub enum FLASH_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_PDW::POWERED => false,
                    FLASH_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASH_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_PD`"]
        pub enum ADC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_PDW::POWERED => false,
                    ADC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSOSC_PD`"]
        pub enum SYSOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSOSC_PDW::POWERED => false,
                    SYSOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSPLL_PD`"]
        pub enum SYSPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSPLL_PDW::POWERED => false,
                    SYSPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP`"]
        pub enum ACMPW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMPW::POWERED => false,
                    ACMPW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(ACMPW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ACMPW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - IRC oscillator output power"]
            #[inline]
            pub fn ircout_pd(&self) -> IRCOUT_PDR {
                IRCOUT_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - IRC oscillator power down"]
            #[inline]
            pub fn irc_pd(&self) -> IRC_PDR {
                IRC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Flash power down"]
            #[inline]
            pub fn flash_pd(&self) -> FLASH_PDR {
                FLASH_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - BOD power down"]
            #[inline]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - ADC wake-up configuration"]
            #[inline]
            pub fn adc_pd(&self) -> ADC_PDR {
                ADC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Crystal oscillator power down. After power-up, add a software delay of approximately 500 us before using."]
            #[inline]
            pub fn sysosc_pd(&self) -> SYSOSC_PDR {
                SYSOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator power down. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - System PLL power down"]
            #[inline]
            pub fn syspll_pd(&self) -> SYSPLL_PDR {
                SYSPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Analog comparator power down"]
            #[inline]
            pub fn acmp(&self) -> ACMPR {
                ACMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xedf0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRC oscillator output power"]
            #[inline]
            pub fn ircout_pd(&mut self) -> _IRCOUT_PDW {
                _IRCOUT_PDW { w: self }
            }
            #[doc = "Bit 1 - IRC oscillator power down"]
            #[inline]
            pub fn irc_pd(&mut self) -> _IRC_PDW {
                _IRC_PDW { w: self }
            }
            #[doc = "Bit 2 - Flash power down"]
            #[inline]
            pub fn flash_pd(&mut self) -> _FLASH_PDW {
                _FLASH_PDW { w: self }
            }
            #[doc = "Bit 3 - BOD power down"]
            #[inline]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 4 - ADC wake-up configuration"]
            #[inline]
            pub fn adc_pd(&mut self) -> _ADC_PDW {
                _ADC_PDW { w: self }
            }
            #[doc = "Bit 5 - Crystal oscillator power down. After power-up, add a software delay of approximately 500 us before using."]
            #[inline]
            pub fn sysosc_pd(&mut self) -> _SYSOSC_PDW {
                _SYSOSC_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator power down. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
            #[doc = "Bit 7 - System PLL power down"]
            #[inline]
            pub fn syspll_pd(&mut self) -> _SYSPLL_PDW {
                _SYSPLL_PDW { w: self }
            }
            #[doc = "Bit 15 - Analog comparator power down"]
            #[inline]
            pub fn acmp(&mut self) -> _ACMPW {
                _ACMPW { w: self }
            }
        }
    }
    #[doc = "Device ID"]
    pub struct DEVICE_ID {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Device ID"]
    pub mod device_id {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DEVICE_ID {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEVICEIDR {
            bits: u32,
        }
        impl DEVICEIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - tbd"]
            #[inline]
            pub fn deviceid(&self) -> DEVICEIDR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DEVICEIDR { bits }
            }
        }
    }
}
#[doc = "I2C0-bus interface"]
pub struct I2C0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C0 {}
impl I2C0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c0::RegisterBlock {
        0x4005_0000 as *const _
    }
}
impl Deref for I2C0 {
    type Target = i2c0::RegisterBlock;
    fn deref(&self) -> &i2c0::RegisterBlock {
        unsafe { &*I2C0::ptr() }
    }
}
#[doc = "I2C0-bus interface"]
pub mod i2c0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Configuration for shared functions."]
        pub cfg: CFG,
        #[doc = "0x04 - Status register for Master, Slave, and Monitor functions."]
        pub stat: STAT,
        #[doc = "0x08 - Interrupt Enable Set and read register."]
        pub intenset: INTENSET,
        #[doc = "0x0c - Interrupt Enable Clear register."]
        pub intenclr: INTENCLR,
        #[doc = "0x10 - Time-out value register."]
        pub timeout: TIMEOUT,
        #[doc = "0x14 - Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME registers."]
        pub clkdiv: CLKDIV,
        #[doc = "0x18 - Interrupt Status register for Master, Slave, and Monitor functions."]
        pub intstat: INTSTAT,
        _reserved0: [u8; 4usize],
        #[doc = "0x20 - Master control register."]
        pub mstctl: MSTCTL,
        #[doc = "0x24 - Master timing configuration."]
        pub msttime: MSTTIME,
        #[doc = "0x28 - Combined Master receiver and transmitter data register."]
        pub mstdat: MSTDAT,
        _reserved1: [u8; 20usize],
        #[doc = "0x40 - Slave control register."]
        pub slvctl: SLVCTL,
        #[doc = "0x44 - Combined Slave receiver and transmitter data register."]
        pub slvdat: SLVDAT,
        #[doc = "0x48 - Slave address 0."]
        pub slvadr: [SLVADR; 4],
        #[doc = "0x58 - Slave Qualification for address 0."]
        pub slvqual0: SLVQUAL0,
        _reserved2: [u8; 36usize],
        #[doc = "0x80 - Monitor receiver data register."]
        pub monrxdat: MONRXDAT,
    }
    #[doc = "Configuration for shared functions."]
    pub struct CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Configuration for shared functions."]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTENR {
            #[doc = "Disabled. The I2C Master function is disabled."]
            DISABLED,
            #[doc = "Enabled. The I2C Master function is enabled."]
            ENABLED,
        }
        impl MSTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTENR::DISABLED => false,
                    MSTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTENR {
                match value {
                    false => MSTENR::DISABLED,
                    true => MSTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MSTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MSTENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SLVEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVENR {
            #[doc = "Disabled. The I2C slave function is disabled."]
            DISABLED,
            #[doc = "Enabled. The I2C slave function is enabled."]
            ENABLED,
        }
        impl SLVENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVENR::DISABLED => false,
                    SLVENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVENR {
                match value {
                    false => SLVENR::DISABLED,
                    true => SLVENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SLVENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SLVENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `MONEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONENR {
            #[doc = "Disabled. The I2C monitor function is disabled."]
            DISABLED,
            #[doc = "Enabled. The I2C monitor function is enabled."]
            ENABLED,
        }
        impl MONENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONENR::DISABLED => false,
                    MONENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONENR {
                match value {
                    false => MONENR::DISABLED,
                    true => MONENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MONENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MONENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TIMEOUTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUTENR {
            #[doc = "Disabled. Time-out function is disabled."]
            DISABLED,
            #[doc = "Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one time-out will be used in a system."]
            ENABLED,
        }
        impl TIMEOUTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIMEOUTENR::DISABLED => false,
                    TIMEOUTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIMEOUTENR {
                match value {
                    false => TIMEOUTENR::DISABLED,
                    true => TIMEOUTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TIMEOUTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TIMEOUTENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `MONCLKSTR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONCLKSTRR {
            #[doc = "Disabled. The monitor function will not perform clock stretching. Software or DMA may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical."]
            DISABLED,
            #[doc = "Enabled. The monitor function will perform clock stretching in order to ensure that software or DMA can read all incoming data supplied by the monitor function."]
            ENABLED,
        }
        impl MONCLKSTRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONCLKSTRR::DISABLED => false,
                    MONCLKSTRR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONCLKSTRR {
                match value {
                    false => MONCLKSTRR::DISABLED,
                    true => MONCLKSTRR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MONCLKSTRR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MONCLKSTRR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `MSTEN`"]
        pub enum MSTENW {
            #[doc = "Disabled. The I2C Master function is disabled."]
            DISABLED,
            #[doc = "Enabled. The I2C Master function is enabled."]
            ENABLED,
        }
        impl MSTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTENW::DISABLED => false,
                    MSTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The I2C Master function is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MSTENW::DISABLED)
            }
            #[doc = "Enabled. The I2C Master function is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MSTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVEN`"]
        pub enum SLVENW {
            #[doc = "Disabled. The I2C slave function is disabled."]
            DISABLED,
            #[doc = "Enabled. The I2C slave function is enabled."]
            ENABLED,
        }
        impl SLVENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVENW::DISABLED => false,
                    SLVENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The I2C slave function is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SLVENW::DISABLED)
            }
            #[doc = "Enabled. The I2C slave function is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SLVENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONEN`"]
        pub enum MONENW {
            #[doc = "Disabled. The I2C monitor function is disabled."]
            DISABLED,
            #[doc = "Enabled. The I2C monitor function is enabled."]
            ENABLED,
        }
        impl MONENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONENW::DISABLED => false,
                    MONENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The I2C monitor function is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MONENW::DISABLED)
            }
            #[doc = "Enabled. The I2C monitor function is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MONENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIMEOUTEN`"]
        pub enum TIMEOUTENW {
            #[doc = "Disabled. Time-out function is disabled."]
            DISABLED,
            #[doc = "Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one time-out will be used in a system."]
            ENABLED,
        }
        impl TIMEOUTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIMEOUTENW::DISABLED => false,
                    TIMEOUTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMEOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMEOUTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIMEOUTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Time-out function is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIMEOUTENW::DISABLED)
            }
            #[doc = "Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one time-out will be used in a system."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIMEOUTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONCLKSTR`"]
        pub enum MONCLKSTRW {
            #[doc = "Disabled. The monitor function will not perform clock stretching. Software or DMA may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical."]
            DISABLED,
            #[doc = "Enabled. The monitor function will perform clock stretching in order to ensure that software or DMA can read all incoming data supplied by the monitor function."]
            ENABLED,
        }
        impl MONCLKSTRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONCLKSTRW::DISABLED => false,
                    MONCLKSTRW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONCLKSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONCLKSTRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONCLKSTRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The monitor function will not perform clock stretching. Software or DMA may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MONCLKSTRW::DISABLED)
            }
            #[doc = "Enabled. The monitor function will perform clock stretching in order to ensure that software or DMA can read all incoming data supplied by the monitor function."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MONCLKSTRW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset."]
            #[inline]
            pub fn msten(&self) -> MSTENR {
                MSTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset."]
            #[inline]
            pub fn slven(&self) -> SLVENR {
                SLVENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset."]
            #[inline]
            pub fn monen(&self) -> MONENR {
                MONENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - I2C bus Time-out Enable. When disabled, the time-out function is internally reset."]
            #[inline]
            pub fn timeouten(&self) -> TIMEOUTENR {
                TIMEOUTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Monitor function Clock Stretching."]
            #[inline]
            pub fn monclkstr(&self) -> MONCLKSTRR {
                MONCLKSTRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset."]
            #[inline]
            pub fn msten(&mut self) -> _MSTENW {
                _MSTENW { w: self }
            }
            #[doc = "Bit 1 - Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset."]
            #[inline]
            pub fn slven(&mut self) -> _SLVENW {
                _SLVENW { w: self }
            }
            #[doc = "Bit 2 - Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset."]
            #[inline]
            pub fn monen(&mut self) -> _MONENW {
                _MONENW { w: self }
            }
            #[doc = "Bit 3 - I2C bus Time-out Enable. When disabled, the time-out function is internally reset."]
            #[inline]
            pub fn timeouten(&mut self) -> _TIMEOUTENW {
                _TIMEOUTENW { w: self }
            }
            #[doc = "Bit 4 - Monitor function Clock Stretching."]
            #[inline]
            pub fn monclkstr(&mut self) -> _MONCLKSTRW {
                _MONCLKSTRW { w: self }
            }
        }
    }
    #[doc = "Status register for Master, Slave, and Monitor functions."]
    pub struct STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register for Master, Slave, and Monitor functions."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTPENDING`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTPENDINGR {
            #[doc = "In progress. Communication is in progress and the Master function is busy and cannot currently accept a command."]
            IN_PROGRESS,
            #[doc = "Pending. The Master function needs software service or is in the idle state. If the master is not in the idle state, it is waiting to receive or transmit data or the NACK bit."]
            PENDING,
        }
        impl MSTPENDINGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTPENDINGR::IN_PROGRESS => false,
                    MSTPENDINGR::PENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTPENDINGR {
                match value {
                    false => MSTPENDINGR::IN_PROGRESS,
                    true => MSTPENDINGR::PENDING,
                }
            }
            #[doc = "Checks if the value of the field is `IN_PROGRESS`"]
            #[inline]
            pub fn is_in_progress(&self) -> bool {
                *self == MSTPENDINGR::IN_PROGRESS
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline]
            pub fn is_pending(&self) -> bool {
                *self == MSTPENDINGR::PENDING
            }
        }
        #[doc = "Possible values of the field `MSTSTATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTATER {
            #[doc = "Idle. The Master function is available to be used for a new transaction."]
            IDLE,
            #[doc = "Receive ready. Received data  available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave."]
            RECEIVE_READY,
            #[doc = "Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave."]
            TRANSMIT_READY,
            #[doc = "NACK Address. Slave NACKed address."]
            NACK_ADDRESS,
            #[doc = "NACK Data. Slave NACKed transmitted data."]
            NACK_DATA,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MSTSTATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MSTSTATER::IDLE => 0,
                    MSTSTATER::RECEIVE_READY => 0x01,
                    MSTSTATER::TRANSMIT_READY => 0x02,
                    MSTSTATER::NACK_ADDRESS => 0x03,
                    MSTSTATER::NACK_DATA => 0x04,
                    MSTSTATER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MSTSTATER {
                match value {
                    0 => MSTSTATER::IDLE,
                    1 => MSTSTATER::RECEIVE_READY,
                    2 => MSTSTATER::TRANSMIT_READY,
                    3 => MSTSTATER::NACK_ADDRESS,
                    4 => MSTSTATER::NACK_DATA,
                    i => MSTSTATER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IDLE`"]
            #[inline]
            pub fn is_idle(&self) -> bool {
                *self == MSTSTATER::IDLE
            }
            #[doc = "Checks if the value of the field is `RECEIVE_READY`"]
            #[inline]
            pub fn is_receive_ready(&self) -> bool {
                *self == MSTSTATER::RECEIVE_READY
            }
            #[doc = "Checks if the value of the field is `TRANSMIT_READY`"]
            #[inline]
            pub fn is_transmit_ready(&self) -> bool {
                *self == MSTSTATER::TRANSMIT_READY
            }
            #[doc = "Checks if the value of the field is `NACK_ADDRESS`"]
            #[inline]
            pub fn is_nack_address(&self) -> bool {
                *self == MSTSTATER::NACK_ADDRESS
            }
            #[doc = "Checks if the value of the field is `NACK_DATA`"]
            #[inline]
            pub fn is_nack_data(&self) -> bool {
                *self == MSTSTATER::NACK_DATA
            }
        }
        #[doc = "Possible values of the field `MSTARBLOSS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTARBLOSSR {
            #[doc = "No loss. No Arbitration Loss has occurred."]
            NO_LOSS,
            #[doc = "Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle."]
            ARBITRATION_LOSS,
        }
        impl MSTARBLOSSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTARBLOSSR::NO_LOSS => false,
                    MSTARBLOSSR::ARBITRATION_LOSS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTARBLOSSR {
                match value {
                    false => MSTARBLOSSR::NO_LOSS,
                    true => MSTARBLOSSR::ARBITRATION_LOSS,
                }
            }
            #[doc = "Checks if the value of the field is `NO_LOSS`"]
            #[inline]
            pub fn is_no_loss(&self) -> bool {
                *self == MSTARBLOSSR::NO_LOSS
            }
            #[doc = "Checks if the value of the field is `ARBITRATION_LOSS`"]
            #[inline]
            pub fn is_arbitration_loss(&self) -> bool {
                *self == MSTARBLOSSR::ARBITRATION_LOSS
            }
        }
        #[doc = "Possible values of the field `MSTSTSTPERR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTSTPERRR {
            #[doc = "No Start/Stop Error has occurred."]
            NO_ERROR,
            #[doc = "Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled."]
            STARTSTOP_ERROR,
        }
        impl MSTSTSTPERRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTSTPERRR::NO_ERROR => false,
                    MSTSTSTPERRR::STARTSTOP_ERROR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTSTSTPERRR {
                match value {
                    false => MSTSTSTPERRR::NO_ERROR,
                    true => MSTSTSTPERRR::STARTSTOP_ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERROR`"]
            #[inline]
            pub fn is_no_error(&self) -> bool {
                *self == MSTSTSTPERRR::NO_ERROR
            }
            #[doc = "Checks if the value of the field is `STARTSTOP_ERROR`"]
            #[inline]
            pub fn is_startstop_error(&self) -> bool {
                *self == MSTSTSTPERRR::STARTSTOP_ERROR
            }
        }
        #[doc = "Possible values of the field `SLVPENDING`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVPENDINGR {
            #[doc = "In progress. The Slave function does not currently need service."]
            IN_PROGRESS,
            #[doc = "Pending. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field."]
            PENDING,
        }
        impl SLVPENDINGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVPENDINGR::IN_PROGRESS => false,
                    SLVPENDINGR::PENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVPENDINGR {
                match value {
                    false => SLVPENDINGR::IN_PROGRESS,
                    true => SLVPENDINGR::PENDING,
                }
            }
            #[doc = "Checks if the value of the field is `IN_PROGRESS`"]
            #[inline]
            pub fn is_in_progress(&self) -> bool {
                *self == SLVPENDINGR::IN_PROGRESS
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline]
            pub fn is_pending(&self) -> bool {
                *self == SLVPENDINGR::PENDING
            }
        }
        #[doc = "Possible values of the field `SLVSTATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVSTATER {
            #[doc = "Slave address. Address plus R/W received. At least one of the four slave addresses has been matched by hardware."]
            SLAVE_ADDRESS,
            #[doc = "Slave receive. Received data is available (Slave Receiver mode)."]
            SLAVE_RECEIVE,
            #[doc = "Slave transmit. Data can be transmitted (Slave Transmitter mode)."]
            SLAVE_TRANSMIT,
        }
        impl SLVSTATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SLVSTATER::SLAVE_ADDRESS => 0,
                    SLVSTATER::SLAVE_RECEIVE => 0x01,
                    SLVSTATER::SLAVE_TRANSMIT => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SLVSTATER {
                match value {
                    0 => SLVSTATER::SLAVE_ADDRESS,
                    1 => SLVSTATER::SLAVE_RECEIVE,
                    2 => SLVSTATER::SLAVE_TRANSMIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS`"]
            #[inline]
            pub fn is_slave_address(&self) -> bool {
                *self == SLVSTATER::SLAVE_ADDRESS
            }
            #[doc = "Checks if the value of the field is `SLAVE_RECEIVE`"]
            #[inline]
            pub fn is_slave_receive(&self) -> bool {
                *self == SLVSTATER::SLAVE_RECEIVE
            }
            #[doc = "Checks if the value of the field is `SLAVE_TRANSMIT`"]
            #[inline]
            pub fn is_slave_transmit(&self) -> bool {
                *self == SLVSTATER::SLAVE_TRANSMIT
            }
        }
        #[doc = "Possible values of the field `SLVNOTSTR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVNOTSTRR {
            #[doc = "Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time."]
            STRETCHING,
            #[doc = "Not stretching. The slave function is not currently stretching the I2C bus clock. Deep-sleep or Power-down mode could be entered at this time."]
            NOT_STRETCHING,
        }
        impl SLVNOTSTRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVNOTSTRR::STRETCHING => false,
                    SLVNOTSTRR::NOT_STRETCHING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVNOTSTRR {
                match value {
                    false => SLVNOTSTRR::STRETCHING,
                    true => SLVNOTSTRR::NOT_STRETCHING,
                }
            }
            #[doc = "Checks if the value of the field is `STRETCHING`"]
            #[inline]
            pub fn is_stretching(&self) -> bool {
                *self == SLVNOTSTRR::STRETCHING
            }
            #[doc = "Checks if the value of the field is `NOT_STRETCHING`"]
            #[inline]
            pub fn is_not_stretching(&self) -> bool {
                *self == SLVNOTSTRR::NOT_STRETCHING
            }
        }
        #[doc = "Possible values of the field `SLVIDX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVIDXR {
            #[doc = "Slave address 0 was matched."]
            SLAVE_ADDRESS_0_WAS,
            #[doc = "Slave address 1 was matched."]
            SLAVE_ADDRESS_1_WAS,
            #[doc = "Slave address 2 was matched."]
            SLAVE_ADDRESS_2_WAS,
            #[doc = "Slave address 3 was matched."]
            SLAVE_ADDRESS_3_WAS,
        }
        impl SLVIDXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SLVIDXR::SLAVE_ADDRESS_0_WAS => 0,
                    SLVIDXR::SLAVE_ADDRESS_1_WAS => 0x01,
                    SLVIDXR::SLAVE_ADDRESS_2_WAS => 0x02,
                    SLVIDXR::SLAVE_ADDRESS_3_WAS => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SLVIDXR {
                match value {
                    0 => SLVIDXR::SLAVE_ADDRESS_0_WAS,
                    1 => SLVIDXR::SLAVE_ADDRESS_1_WAS,
                    2 => SLVIDXR::SLAVE_ADDRESS_2_WAS,
                    3 => SLVIDXR::SLAVE_ADDRESS_3_WAS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_0_WAS`"]
            #[inline]
            pub fn is_slave_address_0_was(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_0_WAS
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_1_WAS`"]
            #[inline]
            pub fn is_slave_address_1_was(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_1_WAS
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_2_WAS`"]
            #[inline]
            pub fn is_slave_address_2_was(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_2_WAS
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_3_WAS`"]
            #[inline]
            pub fn is_slave_address_3_was(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_3_WAS
            }
        }
        #[doc = "Possible values of the field `SLVSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVSELR {
            #[doc = "Not selected. The Slave function is not currently selected."]
            NOT_SELECTED,
            #[doc = "Selected. The Slave function is currently selected."]
            SELECTED,
        }
        impl SLVSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVSELR::NOT_SELECTED => false,
                    SLVSELR::SELECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVSELR {
                match value {
                    false => SLVSELR::NOT_SELECTED,
                    true => SLVSELR::SELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_SELECTED`"]
            #[inline]
            pub fn is_not_selected(&self) -> bool {
                *self == SLVSELR::NOT_SELECTED
            }
            #[doc = "Checks if the value of the field is `SELECTED`"]
            #[inline]
            pub fn is_selected(&self) -> bool {
                *self == SLVSELR::SELECTED
            }
        }
        #[doc = "Possible values of the field `SLVDESEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVDESELR {
            #[doc = "Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag."]
            NOT_DESELECTED,
            #[doc = "Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs."]
            DESELECTED,
        }
        impl SLVDESELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVDESELR::NOT_DESELECTED => false,
                    SLVDESELR::DESELECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVDESELR {
                match value {
                    false => SLVDESELR::NOT_DESELECTED,
                    true => SLVDESELR::DESELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_DESELECTED`"]
            #[inline]
            pub fn is_not_deselected(&self) -> bool {
                *self == SLVDESELR::NOT_DESELECTED
            }
            #[doc = "Checks if the value of the field is `DESELECTED`"]
            #[inline]
            pub fn is_deselected(&self) -> bool {
                *self == SLVDESELR::DESELECTED
            }
        }
        #[doc = "Possible values of the field `MONRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONRDYR {
            #[doc = "No data. The Monitor function does not currently have data available."]
            NO_DATA,
            #[doc = "Data waiting. The Monitor function has data waiting to be read."]
            DATA_WAITING,
        }
        impl MONRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONRDYR::NO_DATA => false,
                    MONRDYR::DATA_WAITING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONRDYR {
                match value {
                    false => MONRDYR::NO_DATA,
                    true => MONRDYR::DATA_WAITING,
                }
            }
            #[doc = "Checks if the value of the field is `NO_DATA`"]
            #[inline]
            pub fn is_no_data(&self) -> bool {
                *self == MONRDYR::NO_DATA
            }
            #[doc = "Checks if the value of the field is `DATA_WAITING`"]
            #[inline]
            pub fn is_data_waiting(&self) -> bool {
                *self == MONRDYR::DATA_WAITING
            }
        }
        #[doc = "Possible values of the field `MONOV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONOVR {
            #[doc = "No overrun. Monitor data has not overrun."]
            NO_OVERRUN,
            #[doc = "Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag."]
            OVERRUN,
        }
        impl MONOVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONOVR::NO_OVERRUN => false,
                    MONOVR::OVERRUN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONOVR {
                match value {
                    false => MONOVR::NO_OVERRUN,
                    true => MONOVR::OVERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NO_OVERRUN`"]
            #[inline]
            pub fn is_no_overrun(&self) -> bool {
                *self == MONOVR::NO_OVERRUN
            }
            #[doc = "Checks if the value of the field is `OVERRUN`"]
            #[inline]
            pub fn is_overrun(&self) -> bool {
                *self == MONOVR::OVERRUN
            }
        }
        #[doc = "Possible values of the field `MONACTIVE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONACTIVER {
            #[doc = "Inactive. The Monitor function considers the I2C bus to be inactive."]
            INACTIVE,
            #[doc = "Active. The Monitor function considers the I2C bus to be active."]
            ACTIVE,
        }
        impl MONACTIVER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONACTIVER::INACTIVE => false,
                    MONACTIVER::ACTIVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONACTIVER {
                match value {
                    false => MONACTIVER::INACTIVE,
                    true => MONACTIVER::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline]
            pub fn is_inactive(&self) -> bool {
                *self == MONACTIVER::INACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline]
            pub fn is_active(&self) -> bool {
                *self == MONACTIVER::ACTIVE
            }
        }
        #[doc = "Possible values of the field `MONIDLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONIDLER {
            #[doc = "Not idle. The I2C bus is not idle, or this flag has been cleared by software."]
            NOT_IDLE,
            #[doc = "Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software."]
            IDLE,
        }
        impl MONIDLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONIDLER::NOT_IDLE => false,
                    MONIDLER::IDLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONIDLER {
                match value {
                    false => MONIDLER::NOT_IDLE,
                    true => MONIDLER::IDLE,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_IDLE`"]
            #[inline]
            pub fn is_not_idle(&self) -> bool {
                *self == MONIDLER::NOT_IDLE
            }
            #[doc = "Checks if the value of the field is `IDLE`"]
            #[inline]
            pub fn is_idle(&self) -> bool {
                *self == MONIDLER::IDLE
            }
        }
        #[doc = "Possible values of the field `EVENTTIMEOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVENTTIMEOUTR {
            #[doc = "No time-out. I2C bus events have not caused a time-out."]
            NO_TIME_OUT,
            #[doc = "Event time-out. The time between I2C bus events has been longer than the time specified by the I2C TIMEOUT register."]
            EVENT_TIME_OUT,
        }
        impl EVENTTIMEOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EVENTTIMEOUTR::NO_TIME_OUT => false,
                    EVENTTIMEOUTR::EVENT_TIME_OUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EVENTTIMEOUTR {
                match value {
                    false => EVENTTIMEOUTR::NO_TIME_OUT,
                    true => EVENTTIMEOUTR::EVENT_TIME_OUT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_TIME_OUT`"]
            #[inline]
            pub fn is_no_time_out(&self) -> bool {
                *self == EVENTTIMEOUTR::NO_TIME_OUT
            }
            #[doc = "Checks if the value of the field is `EVENT_TIME_OUT`"]
            #[inline]
            pub fn is_event_time_out(&self) -> bool {
                *self == EVENTTIMEOUTR::EVENT_TIME_OUT
            }
        }
        #[doc = "Possible values of the field `SCLTIMEOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCLTIMEOUTR {
            #[doc = "No time-out. SCL low time has not caused a time-out."]
            NO_TIME_OUT,
            #[doc = "Time-out. SCL low time has caused a time-out."]
            TIME_OUT,
        }
        impl SCLTIMEOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SCLTIMEOUTR::NO_TIME_OUT => false,
                    SCLTIMEOUTR::TIME_OUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SCLTIMEOUTR {
                match value {
                    false => SCLTIMEOUTR::NO_TIME_OUT,
                    true => SCLTIMEOUTR::TIME_OUT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_TIME_OUT`"]
            #[inline]
            pub fn is_no_time_out(&self) -> bool {
                *self == SCLTIMEOUTR::NO_TIME_OUT
            }
            #[doc = "Checks if the value of the field is `TIME_OUT`"]
            #[inline]
            pub fn is_time_out(&self) -> bool {
                *self == SCLTIMEOUTR::TIME_OUT
            }
        }
        #[doc = "Values that can be written to the field `MSTPENDING`"]
        pub enum MSTPENDINGW {
            #[doc = "In progress. Communication is in progress and the Master function is busy and cannot currently accept a command."]
            IN_PROGRESS,
            #[doc = "Pending. The Master function needs software service or is in the idle state. If the master is not in the idle state, it is waiting to receive or transmit data or the NACK bit."]
            PENDING,
        }
        impl MSTPENDINGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTPENDINGW::IN_PROGRESS => false,
                    MSTPENDINGW::PENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTPENDINGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTPENDINGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTPENDINGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "In progress. Communication is in progress and the Master function is busy and cannot currently accept a command."]
            #[inline]
            pub fn in_progress(self) -> &'a mut W {
                self.variant(MSTPENDINGW::IN_PROGRESS)
            }
            #[doc = "Pending. The Master function needs software service or is in the idle state. If the master is not in the idle state, it is waiting to receive or transmit data or the NACK bit."]
            #[inline]
            pub fn pending(self) -> &'a mut W {
                self.variant(MSTPENDINGW::PENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTATE`"]
        pub enum MSTSTATEW {
            #[doc = "Idle. The Master function is available to be used for a new transaction."]
            IDLE,
            #[doc = "Receive ready. Received data  available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave."]
            RECEIVE_READY,
            #[doc = "Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave."]
            TRANSMIT_READY,
            #[doc = "NACK Address. Slave NACKed address."]
            NACK_ADDRESS,
            #[doc = "NACK Data. Slave NACKed transmitted data."]
            NACK_DATA,
        }
        impl MSTSTATEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MSTSTATEW::IDLE => 0,
                    MSTSTATEW::RECEIVE_READY => 1,
                    MSTSTATEW::TRANSMIT_READY => 2,
                    MSTSTATEW::NACK_ADDRESS => 3,
                    MSTSTATEW::NACK_DATA => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTATEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTSTATEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Idle. The Master function is available to be used for a new transaction."]
            #[inline]
            pub fn idle(self) -> &'a mut W {
                self.variant(MSTSTATEW::IDLE)
            }
            #[doc = "Receive ready. Received data available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave."]
            #[inline]
            pub fn receive_ready(self) -> &'a mut W {
                self.variant(MSTSTATEW::RECEIVE_READY)
            }
            #[doc = "Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave."]
            #[inline]
            pub fn transmit_ready(self) -> &'a mut W {
                self.variant(MSTSTATEW::TRANSMIT_READY)
            }
            #[doc = "NACK Address. Slave NACKed address."]
            #[inline]
            pub fn nack_address(self) -> &'a mut W {
                self.variant(MSTSTATEW::NACK_ADDRESS)
            }
            #[doc = "NACK Data. Slave NACKed transmitted data."]
            #[inline]
            pub fn nack_data(self) -> &'a mut W {
                self.variant(MSTSTATEW::NACK_DATA)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTARBLOSS`"]
        pub enum MSTARBLOSSW {
            #[doc = "No loss. No Arbitration Loss has occurred."]
            NO_LOSS,
            #[doc = "Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle."]
            ARBITRATION_LOSS,
        }
        impl MSTARBLOSSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTARBLOSSW::NO_LOSS => false,
                    MSTARBLOSSW::ARBITRATION_LOSS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTARBLOSSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTARBLOSSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTARBLOSSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No loss. No Arbitration Loss has occurred."]
            #[inline]
            pub fn no_loss(self) -> &'a mut W {
                self.variant(MSTARBLOSSW::NO_LOSS)
            }
            #[doc = "Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle."]
            #[inline]
            pub fn arbitration_loss(self) -> &'a mut W {
                self.variant(MSTARBLOSSW::ARBITRATION_LOSS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTSTPERR`"]
        pub enum MSTSTSTPERRW {
            #[doc = "No Start/Stop Error has occurred."]
            NO_ERROR,
            #[doc = "Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled."]
            STARTSTOP_ERROR,
        }
        impl MSTSTSTPERRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTSTPERRW::NO_ERROR => false,
                    MSTSTSTPERRW::STARTSTOP_ERROR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTSTPERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTSTPERRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTSTSTPERRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No Start/Stop Error has occurred."]
            #[inline]
            pub fn no_error(self) -> &'a mut W {
                self.variant(MSTSTSTPERRW::NO_ERROR)
            }
            #[doc = "Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled."]
            #[inline]
            pub fn startstop_error(self) -> &'a mut W {
                self.variant(MSTSTSTPERRW::STARTSTOP_ERROR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVPENDING`"]
        pub enum SLVPENDINGW {
            #[doc = "In progress. The Slave function does not currently need service."]
            IN_PROGRESS,
            #[doc = "Pending. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field."]
            PENDING,
        }
        impl SLVPENDINGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVPENDINGW::IN_PROGRESS => false,
                    SLVPENDINGW::PENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVPENDINGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVPENDINGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVPENDINGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "In progress. The Slave function does not currently need service."]
            #[inline]
            pub fn in_progress(self) -> &'a mut W {
                self.variant(SLVPENDINGW::IN_PROGRESS)
            }
            #[doc = "Pending. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field."]
            #[inline]
            pub fn pending(self) -> &'a mut W {
                self.variant(SLVPENDINGW::PENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVSTATE`"]
        pub enum SLVSTATEW {
            #[doc = "Slave address. Address plus R/W received. At least one of the four slave addresses has been matched by hardware."]
            SLAVE_ADDRESS,
            #[doc = "Slave receive. Received data is available (Slave Receiver mode)."]
            SLAVE_RECEIVE,
            #[doc = "Slave transmit. Data can be transmitted (Slave Transmitter mode)."]
            SLAVE_TRANSMIT,
        }
        impl SLVSTATEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SLVSTATEW::SLAVE_ADDRESS => 0,
                    SLVSTATEW::SLAVE_RECEIVE => 1,
                    SLVSTATEW::SLAVE_TRANSMIT => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVSTATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVSTATEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVSTATEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Slave address. Address plus R/W received. At least one of the four slave addresses has been matched by hardware."]
            #[inline]
            pub fn slave_address(self) -> &'a mut W {
                self.variant(SLVSTATEW::SLAVE_ADDRESS)
            }
            #[doc = "Slave receive. Received data is available (Slave Receiver mode)."]
            #[inline]
            pub fn slave_receive(self) -> &'a mut W {
                self.variant(SLVSTATEW::SLAVE_RECEIVE)
            }
            #[doc = "Slave transmit. Data can be transmitted (Slave Transmitter mode)."]
            #[inline]
            pub fn slave_transmit(self) -> &'a mut W {
                self.variant(SLVSTATEW::SLAVE_TRANSMIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVNOTSTR`"]
        pub enum SLVNOTSTRW {
            #[doc = "Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time."]
            STRETCHING,
            #[doc = "Not stretching. The slave function is not currently stretching the I2C bus clock. Deep-sleep or Power-down mode could be entered at this time."]
            NOT_STRETCHING,
        }
        impl SLVNOTSTRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVNOTSTRW::STRETCHING => false,
                    SLVNOTSTRW::NOT_STRETCHING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNOTSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNOTSTRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVNOTSTRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time."]
            #[inline]
            pub fn stretching(self) -> &'a mut W {
                self.variant(SLVNOTSTRW::STRETCHING)
            }
            #[doc = "Not stretching. The slave function is not currently stretching the I2C bus clock. Deep-sleep or Power-down mode could be entered at this time."]
            #[inline]
            pub fn not_stretching(self) -> &'a mut W {
                self.variant(SLVNOTSTRW::NOT_STRETCHING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVIDX`"]
        pub enum SLVIDXW {
            #[doc = "Slave address 0 was matched."]
            SLAVE_ADDRESS_0_WAS,
            #[doc = "Slave address 1 was matched."]
            SLAVE_ADDRESS_1_WAS,
            #[doc = "Slave address 2 was matched."]
            SLAVE_ADDRESS_2_WAS,
            #[doc = "Slave address 3 was matched."]
            SLAVE_ADDRESS_3_WAS,
        }
        impl SLVIDXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SLVIDXW::SLAVE_ADDRESS_0_WAS => 0,
                    SLVIDXW::SLAVE_ADDRESS_1_WAS => 1,
                    SLVIDXW::SLAVE_ADDRESS_2_WAS => 2,
                    SLVIDXW::SLAVE_ADDRESS_3_WAS => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIDXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIDXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVIDXW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Slave address 0 was matched."]
            #[inline]
            pub fn slave_address_0_was(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_0_WAS)
            }
            #[doc = "Slave address 1 was matched."]
            #[inline]
            pub fn slave_address_1_was(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_1_WAS)
            }
            #[doc = "Slave address 2 was matched."]
            #[inline]
            pub fn slave_address_2_was(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_2_WAS)
            }
            #[doc = "Slave address 3 was matched."]
            #[inline]
            pub fn slave_address_3_was(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_3_WAS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVSEL`"]
        pub enum SLVSELW {
            #[doc = "Not selected. The Slave function is not currently selected."]
            NOT_SELECTED,
            #[doc = "Selected. The Slave function is currently selected."]
            SELECTED,
        }
        impl SLVSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVSELW::NOT_SELECTED => false,
                    SLVSELW::SELECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not selected. The Slave function is not currently selected."]
            #[inline]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(SLVSELW::NOT_SELECTED)
            }
            #[doc = "Selected. The Slave function is currently selected."]
            #[inline]
            pub fn selected(self) -> &'a mut W {
                self.variant(SLVSELW::SELECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVDESEL`"]
        pub enum SLVDESELW {
            #[doc = "Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag."]
            NOT_DESELECTED,
            #[doc = "Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs."]
            DESELECTED,
        }
        impl SLVDESELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVDESELW::NOT_DESELECTED => false,
                    SLVDESELW::DESELECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVDESELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVDESELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVDESELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag."]
            #[inline]
            pub fn not_deselected(self) -> &'a mut W {
                self.variant(SLVDESELW::NOT_DESELECTED)
            }
            #[doc = "Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs."]
            #[inline]
            pub fn deselected(self) -> &'a mut W {
                self.variant(SLVDESELW::DESELECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONRDY`"]
        pub enum MONRDYW {
            #[doc = "No data. The Monitor function does not currently have data available."]
            NO_DATA,
            #[doc = "Data waiting. The Monitor function has data waiting to be read."]
            DATA_WAITING,
        }
        impl MONRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONRDYW::NO_DATA => false,
                    MONRDYW::DATA_WAITING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No data. The Monitor function does not currently have data available."]
            #[inline]
            pub fn no_data(self) -> &'a mut W {
                self.variant(MONRDYW::NO_DATA)
            }
            #[doc = "Data waiting. The Monitor function has data waiting to be read."]
            #[inline]
            pub fn data_waiting(self) -> &'a mut W {
                self.variant(MONRDYW::DATA_WAITING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONOV`"]
        pub enum MONOVW {
            #[doc = "No overrun. Monitor data has not overrun."]
            NO_OVERRUN,
            #[doc = "Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag."]
            OVERRUN,
        }
        impl MONOVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONOVW::NO_OVERRUN => false,
                    MONOVW::OVERRUN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONOVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONOVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONOVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No overrun. Monitor data has not overrun."]
            #[inline]
            pub fn no_overrun(self) -> &'a mut W {
                self.variant(MONOVW::NO_OVERRUN)
            }
            #[doc = "Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag."]
            #[inline]
            pub fn overrun(self) -> &'a mut W {
                self.variant(MONOVW::OVERRUN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONACTIVE`"]
        pub enum MONACTIVEW {
            #[doc = "Inactive. The Monitor function considers the I2C bus to be inactive."]
            INACTIVE,
            #[doc = "Active. The Monitor function considers the I2C bus to be active."]
            ACTIVE,
        }
        impl MONACTIVEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONACTIVEW::INACTIVE => false,
                    MONACTIVEW::ACTIVE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONACTIVEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONACTIVEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONACTIVEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Inactive. The Monitor function considers the I2C bus to be inactive."]
            #[inline]
            pub fn inactive(self) -> &'a mut W {
                self.variant(MONACTIVEW::INACTIVE)
            }
            #[doc = "Active. The Monitor function considers the I2C bus to be active."]
            #[inline]
            pub fn active(self) -> &'a mut W {
                self.variant(MONACTIVEW::ACTIVE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONIDLE`"]
        pub enum MONIDLEW {
            #[doc = "Not idle. The I2C bus is not idle, or this flag has been cleared by software."]
            NOT_IDLE,
            #[doc = "Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software."]
            IDLE,
        }
        impl MONIDLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONIDLEW::NOT_IDLE => false,
                    MONIDLEW::IDLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONIDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONIDLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONIDLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not idle. The I2C bus is not idle, or this flag has been cleared by software."]
            #[inline]
            pub fn not_idle(self) -> &'a mut W {
                self.variant(MONIDLEW::NOT_IDLE)
            }
            #[doc = "Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software."]
            #[inline]
            pub fn idle(self) -> &'a mut W {
                self.variant(MONIDLEW::IDLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EVENTTIMEOUT`"]
        pub enum EVENTTIMEOUTW {
            #[doc = "No time-out. I2C bus events have not caused a time-out."]
            NO_TIME_OUT,
            #[doc = "Event time-out. The time between I2C bus events has been longer than the time specified by the I2C TIMEOUT register."]
            EVENT_TIME_OUT,
        }
        impl EVENTTIMEOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EVENTTIMEOUTW::NO_TIME_OUT => false,
                    EVENTTIMEOUTW::EVENT_TIME_OUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVENTTIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVENTTIMEOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EVENTTIMEOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No time-out. I2C bus events have not caused a time-out."]
            #[inline]
            pub fn no_time_out(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTW::NO_TIME_OUT)
            }
            #[doc = "Event time-out. The time between I2C bus events has been longer than the time specified by the I2C TIMEOUT register."]
            #[inline]
            pub fn event_time_out(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTW::EVENT_TIME_OUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCLTIMEOUT`"]
        pub enum SCLTIMEOUTW {
            #[doc = "No time-out. SCL low time has not caused a time-out."]
            NO_TIME_OUT,
            #[doc = "Time-out. SCL low time has caused a time-out."]
            TIME_OUT,
        }
        impl SCLTIMEOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCLTIMEOUTW::NO_TIME_OUT => false,
                    SCLTIMEOUTW::TIME_OUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLTIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLTIMEOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SCLTIMEOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No time-out. SCL low time has not caused a time-out."]
            #[inline]
            pub fn no_time_out(self) -> &'a mut W {
                self.variant(SCLTIMEOUTW::NO_TIME_OUT)
            }
            #[doc = "Time-out. SCL low time has caused a time-out."]
            #[inline]
            pub fn time_out(self) -> &'a mut W {
                self.variant(SCLTIMEOUTW::TIME_OUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Pending. Indicates that the Master is waiting to continue communication on the I2C-bus (pending) or is idle. When the master is pending, the MSTSTATE bits indicate what type of software service if any the master expects. This flag will cause an interrupt when set if, enabled via the INTENSET register. The MSTPENDING flag is not set when the DMA is handling an event (if the MSTDMA bit in the MSTCTL register is set). If the master is in the idle state, and no communication is needed, mask this interrupt."]
            #[inline]
            pub fn mstpending(&self) -> MSTPENDINGR {
                MSTPENDINGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:3 - Master State code. The master state code reflects the master state when the MSTPENDING bit is set, that is the master is pending or in the idle state. Each value of this field indicates a specific required service for the Master function. All other values are reserved."]
            #[inline]
            pub fn mststate(&self) -> MSTSTATER {
                MSTSTATER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 4 - Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE."]
            #[inline]
            pub fn mstarbloss(&self) -> MSTARBLOSSR {
                MSTARBLOSSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE."]
            #[inline]
            pub fn mstststperr(&self) -> MSTSTSTPERRR {
                MSTSTSTPERRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Slave Pending. Indicates that the Slave function is waiting to continue communication on the I2C-bus and needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is not set when the DMA is handling an event (if the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the MSTCTL register."]
            #[inline]
            pub fn slvpending(&self) -> SLVPENDINGR {
                SLVPENDINGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 9:10 - Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved."]
            #[inline]
            pub fn slvstate(&self) -> SLVSTATER {
                SLVSTATER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 11 - Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time."]
            #[inline]
            pub fn slvnotstr(&self) -> SLVNOTSTRR {
                SLVNOTSTRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 12:13 - Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here."]
            #[inline]
            pub fn slvidx(&self) -> SLVIDXR {
                SLVIDXR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to NACK a matched address, or when there is a Stop detected on the bus. SLVSEL is not cleared if software Nacks data."]
            #[inline]
            pub fn slvsel(&self) -> SLVSELR {
                SLVSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit."]
            #[inline]
            pub fn slvdesel(&self) -> SLVDESELR {
                SLVDESELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Monitor Ready. This flag is cleared when the MONRXDAT register is read."]
            #[inline]
            pub fn monrdy(&self) -> MONRDYR {
                MONRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Monitor Overflow flag."]
            #[inline]
            pub fn monov(&self) -> MONOVR {
                MONOVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Monitor Active flag. This flag indicates when the Monitor function considers the I2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop."]
            #[inline]
            pub fn monactive(&self) -> MONACTIVER {
                MONACTIVER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register . The flag can be cleared by writing a 1 to this bit."]
            #[inline]
            pub fn monidle(&self) -> MONIDLER {
                MONIDLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The flag is cleared by writing a 1 to this bit. No time-out is created when the I2C-bus is idle."]
            #[inline]
            pub fn eventtimeout(&self) -> EVENTTIMEOUTR {
                EVENTTIMEOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit."]
            #[inline]
            pub fn scltimeout(&self) -> SCLTIMEOUTR {
                SCLTIMEOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0801 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Pending. Indicates that the Master is waiting to continue communication on the I2C-bus (pending) or is idle. When the master is pending, the MSTSTATE bits indicate what type of software service if any the master expects. This flag will cause an interrupt when set if, enabled via the INTENSET register. The MSTPENDING flag is not set when the DMA is handling an event (if the MSTDMA bit in the MSTCTL register is set). If the master is in the idle state, and no communication is needed, mask this interrupt."]
            #[inline]
            pub fn mstpending(&mut self) -> _MSTPENDINGW {
                _MSTPENDINGW { w: self }
            }
            #[doc = "Bits 1:3 - Master State code. The master state code reflects the master state when the MSTPENDING bit is set, that is the master is pending or in the idle state. Each value of this field indicates a specific required service for the Master function. All other values are reserved."]
            #[inline]
            pub fn mststate(&mut self) -> _MSTSTATEW {
                _MSTSTATEW { w: self }
            }
            #[doc = "Bit 4 - Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE."]
            #[inline]
            pub fn mstarbloss(&mut self) -> _MSTARBLOSSW {
                _MSTARBLOSSW { w: self }
            }
            #[doc = "Bit 6 - Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE."]
            #[inline]
            pub fn mstststperr(&mut self) -> _MSTSTSTPERRW {
                _MSTSTSTPERRW { w: self }
            }
            #[doc = "Bit 8 - Slave Pending. Indicates that the Slave function is waiting to continue communication on the I2C-bus and needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is not set when the DMA is handling an event (if the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the MSTCTL register."]
            #[inline]
            pub fn slvpending(&mut self) -> _SLVPENDINGW {
                _SLVPENDINGW { w: self }
            }
            #[doc = "Bits 9:10 - Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved."]
            #[inline]
            pub fn slvstate(&mut self) -> _SLVSTATEW {
                _SLVSTATEW { w: self }
            }
            #[doc = "Bit 11 - Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time."]
            #[inline]
            pub fn slvnotstr(&mut self) -> _SLVNOTSTRW {
                _SLVNOTSTRW { w: self }
            }
            #[doc = "Bits 12:13 - Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here."]
            #[inline]
            pub fn slvidx(&mut self) -> _SLVIDXW {
                _SLVIDXW { w: self }
            }
            #[doc = "Bit 14 - Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to NACK a matched address, or when there is a Stop detected on the bus. SLVSEL is not cleared if software Nacks data."]
            #[inline]
            pub fn slvsel(&mut self) -> _SLVSELW {
                _SLVSELW { w: self }
            }
            #[doc = "Bit 15 - Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit."]
            #[inline]
            pub fn slvdesel(&mut self) -> _SLVDESELW {
                _SLVDESELW { w: self }
            }
            #[doc = "Bit 16 - Monitor Ready. This flag is cleared when the MONRXDAT register is read."]
            #[inline]
            pub fn monrdy(&mut self) -> _MONRDYW {
                _MONRDYW { w: self }
            }
            #[doc = "Bit 17 - Monitor Overflow flag."]
            #[inline]
            pub fn monov(&mut self) -> _MONOVW {
                _MONOVW { w: self }
            }
            #[doc = "Bit 18 - Monitor Active flag. This flag indicates when the Monitor function considers the I2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop."]
            #[inline]
            pub fn monactive(&mut self) -> _MONACTIVEW {
                _MONACTIVEW { w: self }
            }
            #[doc = "Bit 19 - Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register . The flag can be cleared by writing a 1 to this bit."]
            #[inline]
            pub fn monidle(&mut self) -> _MONIDLEW {
                _MONIDLEW { w: self }
            }
            #[doc = "Bit 24 - Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The flag is cleared by writing a 1 to this bit. No time-out is created when the I2C-bus is idle."]
            #[inline]
            pub fn eventtimeout(&mut self) -> _EVENTTIMEOUTW {
                _EVENTTIMEOUTW { w: self }
            }
            #[doc = "Bit 25 - SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit."]
            #[inline]
            pub fn scltimeout(&mut self) -> _SCLTIMEOUTW {
                _SCLTIMEOUTW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set and read register."]
    pub struct INTENSET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set and read register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTPENDINGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTPENDINGENR {
            #[doc = "The MstPending interrupt is disabled."]
            DISABLED,
            #[doc = "The MstPending interrupt is enabled."]
            ENABLED,
        }
        impl MSTPENDINGENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTPENDINGENR::DISABLED => false,
                    MSTPENDINGENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTPENDINGENR {
                match value {
                    false => MSTPENDINGENR::DISABLED,
                    true => MSTPENDINGENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MSTPENDINGENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MSTPENDINGENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `MSTARBLOSSEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTARBLOSSENR {
            #[doc = "The MstArbLoss interrupt is disabled."]
            DISABLED,
            #[doc = "The MstArbLoss interrupt is enabled."]
            ENABLED,
        }
        impl MSTARBLOSSENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTARBLOSSENR::DISABLED => false,
                    MSTARBLOSSENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTARBLOSSENR {
                match value {
                    false => MSTARBLOSSENR::DISABLED,
                    true => MSTARBLOSSENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MSTARBLOSSENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MSTARBLOSSENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `MSTSTSTPERREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTSTPERRENR {
            #[doc = "The MstStStpErr interrupt is disabled."]
            DISABLED,
            #[doc = "The MstStStpErr interrupt is enabled."]
            ENABLED,
        }
        impl MSTSTSTPERRENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTSTPERRENR::DISABLED => false,
                    MSTSTSTPERRENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTSTSTPERRENR {
                match value {
                    false => MSTSTSTPERRENR::DISABLED,
                    true => MSTSTSTPERRENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MSTSTSTPERRENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MSTSTSTPERRENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SLVPENDINGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVPENDINGENR {
            #[doc = "The SlvPending interrupt is disabled."]
            DISABLED,
            #[doc = "The SlvPending interrupt is enabled."]
            ENABLED,
        }
        impl SLVPENDINGENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVPENDINGENR::DISABLED => false,
                    SLVPENDINGENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVPENDINGENR {
                match value {
                    false => SLVPENDINGENR::DISABLED,
                    true => SLVPENDINGENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SLVPENDINGENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SLVPENDINGENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SLVNOTSTREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVNOTSTRENR {
            #[doc = "The SlvNotStr interrupt is disabled."]
            DISABLED,
            #[doc = "The SlvNotStr interrupt is enabled."]
            ENABLED,
        }
        impl SLVNOTSTRENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVNOTSTRENR::DISABLED => false,
                    SLVNOTSTRENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVNOTSTRENR {
                match value {
                    false => SLVNOTSTRENR::DISABLED,
                    true => SLVNOTSTRENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SLVNOTSTRENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SLVNOTSTRENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SLVDESELEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVDESELENR {
            #[doc = "The SlvDeSel interrupt is disabled."]
            DISABLED,
            #[doc = "The SlvDeSel interrupt is enabled."]
            ENABLED,
        }
        impl SLVDESELENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVDESELENR::DISABLED => false,
                    SLVDESELENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVDESELENR {
                match value {
                    false => SLVDESELENR::DISABLED,
                    true => SLVDESELENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SLVDESELENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SLVDESELENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `MONRDYEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONRDYENR {
            #[doc = "The MonRdy interrupt is disabled."]
            DISABLED,
            #[doc = "The MonRdy interrupt is enabled."]
            ENABLED,
        }
        impl MONRDYENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONRDYENR::DISABLED => false,
                    MONRDYENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONRDYENR {
                match value {
                    false => MONRDYENR::DISABLED,
                    true => MONRDYENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MONRDYENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MONRDYENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `MONOVEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONOVENR {
            #[doc = "The MonOv interrupt is disabled."]
            DISABLED,
            #[doc = "The MonOv interrupt is enabled."]
            ENABLED,
        }
        impl MONOVENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONOVENR::DISABLED => false,
                    MONOVENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONOVENR {
                match value {
                    false => MONOVENR::DISABLED,
                    true => MONOVENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MONOVENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MONOVENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `MONIDLEEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONIDLEENR {
            #[doc = "The MonIdle interrupt is disabled."]
            DISABLED,
            #[doc = "The MonIdle interrupt is enabled."]
            ENABLED,
        }
        impl MONIDLEENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONIDLEENR::DISABLED => false,
                    MONIDLEENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONIDLEENR {
                match value {
                    false => MONIDLEENR::DISABLED,
                    true => MONIDLEENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MONIDLEENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MONIDLEENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `EVENTTIMEOUTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVENTTIMEOUTENR {
            #[doc = "The Event time-out interrupt is disabled."]
            DISABLED,
            #[doc = "The Event time-out interrupt is enabled."]
            ENABLED,
        }
        impl EVENTTIMEOUTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EVENTTIMEOUTENR::DISABLED => false,
                    EVENTTIMEOUTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EVENTTIMEOUTENR {
                match value {
                    false => EVENTTIMEOUTENR::DISABLED,
                    true => EVENTTIMEOUTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == EVENTTIMEOUTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == EVENTTIMEOUTENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SCLTIMEOUTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCLTIMEOUTENR {
            #[doc = "The SCL time-out interrupt is disabled."]
            DISABLED,
            #[doc = "The SCL time-out interrupt is enabled."]
            ENABLED,
        }
        impl SCLTIMEOUTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SCLTIMEOUTENR::DISABLED => false,
                    SCLTIMEOUTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SCLTIMEOUTENR {
                match value {
                    false => SCLTIMEOUTENR::DISABLED,
                    true => SCLTIMEOUTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SCLTIMEOUTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SCLTIMEOUTENR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `MSTPENDINGEN`"]
        pub enum MSTPENDINGENW {
            #[doc = "The MstPending interrupt is disabled."]
            DISABLED,
            #[doc = "The MstPending interrupt is enabled."]
            ENABLED,
        }
        impl MSTPENDINGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTPENDINGENW::DISABLED => false,
                    MSTPENDINGENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTPENDINGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTPENDINGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTPENDINGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MstPending interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MSTPENDINGENW::DISABLED)
            }
            #[doc = "The MstPending interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MSTPENDINGENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTARBLOSSEN`"]
        pub enum MSTARBLOSSENW {
            #[doc = "The MstArbLoss interrupt is disabled."]
            DISABLED,
            #[doc = "The MstArbLoss interrupt is enabled."]
            ENABLED,
        }
        impl MSTARBLOSSENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTARBLOSSENW::DISABLED => false,
                    MSTARBLOSSENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTARBLOSSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTARBLOSSENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTARBLOSSENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MstArbLoss interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MSTARBLOSSENW::DISABLED)
            }
            #[doc = "The MstArbLoss interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MSTARBLOSSENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTSTPERREN`"]
        pub enum MSTSTSTPERRENW {
            #[doc = "The MstStStpErr interrupt is disabled."]
            DISABLED,
            #[doc = "The MstStStpErr interrupt is enabled."]
            ENABLED,
        }
        impl MSTSTSTPERRENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTSTPERRENW::DISABLED => false,
                    MSTSTSTPERRENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTSTPERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTSTPERRENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTSTSTPERRENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MstStStpErr interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MSTSTSTPERRENW::DISABLED)
            }
            #[doc = "The MstStStpErr interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MSTSTSTPERRENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVPENDINGEN`"]
        pub enum SLVPENDINGENW {
            #[doc = "The SlvPending interrupt is disabled."]
            DISABLED,
            #[doc = "The SlvPending interrupt is enabled."]
            ENABLED,
        }
        impl SLVPENDINGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVPENDINGENW::DISABLED => false,
                    SLVPENDINGENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVPENDINGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVPENDINGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVPENDINGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SlvPending interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SLVPENDINGENW::DISABLED)
            }
            #[doc = "The SlvPending interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SLVPENDINGENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVNOTSTREN`"]
        pub enum SLVNOTSTRENW {
            #[doc = "The SlvNotStr interrupt is disabled."]
            DISABLED,
            #[doc = "The SlvNotStr interrupt is enabled."]
            ENABLED,
        }
        impl SLVNOTSTRENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVNOTSTRENW::DISABLED => false,
                    SLVNOTSTRENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNOTSTRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNOTSTRENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVNOTSTRENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SlvNotStr interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SLVNOTSTRENW::DISABLED)
            }
            #[doc = "The SlvNotStr interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SLVNOTSTRENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVDESELEN`"]
        pub enum SLVDESELENW {
            #[doc = "The SlvDeSel interrupt is disabled."]
            DISABLED,
            #[doc = "The SlvDeSel interrupt is enabled."]
            ENABLED,
        }
        impl SLVDESELENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVDESELENW::DISABLED => false,
                    SLVDESELENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVDESELENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVDESELENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVDESELENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SlvDeSel interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SLVDESELENW::DISABLED)
            }
            #[doc = "The SlvDeSel interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SLVDESELENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONRDYEN`"]
        pub enum MONRDYENW {
            #[doc = "The MonRdy interrupt is disabled."]
            DISABLED,
            #[doc = "The MonRdy interrupt is enabled."]
            ENABLED,
        }
        impl MONRDYENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONRDYENW::DISABLED => false,
                    MONRDYENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONRDYENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONRDYENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MonRdy interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MONRDYENW::DISABLED)
            }
            #[doc = "The MonRdy interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MONRDYENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONOVEN`"]
        pub enum MONOVENW {
            #[doc = "The MonOv interrupt is disabled."]
            DISABLED,
            #[doc = "The MonOv interrupt is enabled."]
            ENABLED,
        }
        impl MONOVENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONOVENW::DISABLED => false,
                    MONOVENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONOVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONOVENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONOVENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MonOv interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MONOVENW::DISABLED)
            }
            #[doc = "The MonOv interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MONOVENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONIDLEEN`"]
        pub enum MONIDLEENW {
            #[doc = "The MonIdle interrupt is disabled."]
            DISABLED,
            #[doc = "The MonIdle interrupt is enabled."]
            ENABLED,
        }
        impl MONIDLEENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONIDLEENW::DISABLED => false,
                    MONIDLEENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONIDLEENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONIDLEENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MONIDLEENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MonIdle interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MONIDLEENW::DISABLED)
            }
            #[doc = "The MonIdle interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MONIDLEENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EVENTTIMEOUTEN`"]
        pub enum EVENTTIMEOUTENW {
            #[doc = "The Event time-out interrupt is disabled."]
            DISABLED,
            #[doc = "The Event time-out interrupt is enabled."]
            ENABLED,
        }
        impl EVENTTIMEOUTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EVENTTIMEOUTENW::DISABLED => false,
                    EVENTTIMEOUTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVENTTIMEOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVENTTIMEOUTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EVENTTIMEOUTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The Event time-out interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTENW::DISABLED)
            }
            #[doc = "The Event time-out interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCLTIMEOUTEN`"]
        pub enum SCLTIMEOUTENW {
            #[doc = "The SCL time-out interrupt is disabled."]
            DISABLED,
            #[doc = "The SCL time-out interrupt is enabled."]
            ENABLED,
        }
        impl SCLTIMEOUTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCLTIMEOUTENW::DISABLED => false,
                    SCLTIMEOUTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLTIMEOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLTIMEOUTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SCLTIMEOUTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SCL time-out interrupt is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCLTIMEOUTENW::DISABLED)
            }
            #[doc = "The SCL time-out interrupt is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCLTIMEOUTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Pending interrupt Enable."]
            #[inline]
            pub fn mstpendingen(&self) -> MSTPENDINGENR {
                MSTPENDINGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Master Arbitration Loss interrupt Enable."]
            #[inline]
            pub fn mstarblossen(&self) -> MSTARBLOSSENR {
                MSTARBLOSSENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Master Start/Stop Error interrupt Enable."]
            #[inline]
            pub fn mstststperren(&self) -> MSTSTSTPERRENR {
                MSTSTSTPERRENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Slave Pending interrupt Enable."]
            #[inline]
            pub fn slvpendingen(&self) -> SLVPENDINGENR {
                SLVPENDINGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Slave Not Stretching interrupt Enable."]
            #[inline]
            pub fn slvnotstren(&self) -> SLVNOTSTRENR {
                SLVNOTSTRENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Slave Deselect interrupt Enable."]
            #[inline]
            pub fn slvdeselen(&self) -> SLVDESELENR {
                SLVDESELENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Monitor data Ready interrupt Enable."]
            #[inline]
            pub fn monrdyen(&self) -> MONRDYENR {
                MONRDYENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Monitor Overrun interrupt Enable."]
            #[inline]
            pub fn monoven(&self) -> MONOVENR {
                MONOVENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Monitor Idle interrupt Enable."]
            #[inline]
            pub fn monidleen(&self) -> MONIDLEENR {
                MONIDLEENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Event time-out interrupt Enable."]
            #[inline]
            pub fn eventtimeouten(&self) -> EVENTTIMEOUTENR {
                EVENTTIMEOUTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - SCL time-out interrupt Enable."]
            #[inline]
            pub fn scltimeouten(&self) -> SCLTIMEOUTENR {
                SCLTIMEOUTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Pending interrupt Enable."]
            #[inline]
            pub fn mstpendingen(&mut self) -> _MSTPENDINGENW {
                _MSTPENDINGENW { w: self }
            }
            #[doc = "Bit 4 - Master Arbitration Loss interrupt Enable."]
            #[inline]
            pub fn mstarblossen(&mut self) -> _MSTARBLOSSENW {
                _MSTARBLOSSENW { w: self }
            }
            #[doc = "Bit 6 - Master Start/Stop Error interrupt Enable."]
            #[inline]
            pub fn mstststperren(&mut self) -> _MSTSTSTPERRENW {
                _MSTSTSTPERRENW { w: self }
            }
            #[doc = "Bit 8 - Slave Pending interrupt Enable."]
            #[inline]
            pub fn slvpendingen(&mut self) -> _SLVPENDINGENW {
                _SLVPENDINGENW { w: self }
            }
            #[doc = "Bit 11 - Slave Not Stretching interrupt Enable."]
            #[inline]
            pub fn slvnotstren(&mut self) -> _SLVNOTSTRENW {
                _SLVNOTSTRENW { w: self }
            }
            #[doc = "Bit 15 - Slave Deselect interrupt Enable."]
            #[inline]
            pub fn slvdeselen(&mut self) -> _SLVDESELENW {
                _SLVDESELENW { w: self }
            }
            #[doc = "Bit 16 - Monitor data Ready interrupt Enable."]
            #[inline]
            pub fn monrdyen(&mut self) -> _MONRDYENW {
                _MONRDYENW { w: self }
            }
            #[doc = "Bit 17 - Monitor Overrun interrupt Enable."]
            #[inline]
            pub fn monoven(&mut self) -> _MONOVENW {
                _MONOVENW { w: self }
            }
            #[doc = "Bit 19 - Monitor Idle interrupt Enable."]
            #[inline]
            pub fn monidleen(&mut self) -> _MONIDLEENW {
                _MONIDLEENW { w: self }
            }
            #[doc = "Bit 24 - Event time-out interrupt Enable."]
            #[inline]
            pub fn eventtimeouten(&mut self) -> _EVENTTIMEOUTENW {
                _EVENTTIMEOUTENW { w: self }
            }
            #[doc = "Bit 25 - SCL time-out interrupt Enable."]
            #[inline]
            pub fn scltimeouten(&mut self) -> _SCLTIMEOUTENW {
                _SCLTIMEOUTENW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear register."]
    pub struct INTENCLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear register."]
    pub mod intenclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTPENDINGCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTPENDINGCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTARBLOSSCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTARBLOSSCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTSTPERRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTSTPERRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVPENDINGCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVPENDINGCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNOTSTRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNOTSTRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVDESELCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVDESELCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONRDYCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONRDYCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONOVCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONOVCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONIDLECLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONIDLECLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVENTTIMEOUTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVENTTIMEOUTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLTIMEOUTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLTIMEOUTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Pending interrupt clear. Writing 1 to this bit clears the corresponding bit in the INTENSET register if implemented."]
            #[inline]
            pub fn mstpendingclr(&mut self) -> _MSTPENDINGCLRW {
                _MSTPENDINGCLRW { w: self }
            }
            #[doc = "Bit 4 - Master Arbitration Loss interrupt clear."]
            #[inline]
            pub fn mstarblossclr(&mut self) -> _MSTARBLOSSCLRW {
                _MSTARBLOSSCLRW { w: self }
            }
            #[doc = "Bit 6 - Master Start/Stop Error interrupt clear."]
            #[inline]
            pub fn mstststperrclr(&mut self) -> _MSTSTSTPERRCLRW {
                _MSTSTSTPERRCLRW { w: self }
            }
            #[doc = "Bit 8 - Slave Pending interrupt clear."]
            #[inline]
            pub fn slvpendingclr(&mut self) -> _SLVPENDINGCLRW {
                _SLVPENDINGCLRW { w: self }
            }
            #[doc = "Bit 11 - Slave Not Stretching interrupt clear."]
            #[inline]
            pub fn slvnotstrclr(&mut self) -> _SLVNOTSTRCLRW {
                _SLVNOTSTRCLRW { w: self }
            }
            #[doc = "Bit 15 - Slave Deselect interrupt clear."]
            #[inline]
            pub fn slvdeselclr(&mut self) -> _SLVDESELCLRW {
                _SLVDESELCLRW { w: self }
            }
            #[doc = "Bit 16 - Monitor data Ready interrupt clear."]
            #[inline]
            pub fn monrdyclr(&mut self) -> _MONRDYCLRW {
                _MONRDYCLRW { w: self }
            }
            #[doc = "Bit 17 - Monitor Overrun interrupt clear."]
            #[inline]
            pub fn monovclr(&mut self) -> _MONOVCLRW {
                _MONOVCLRW { w: self }
            }
            #[doc = "Bit 19 - Monitor Idle interrupt clear."]
            #[inline]
            pub fn monidleclr(&mut self) -> _MONIDLECLRW {
                _MONIDLECLRW { w: self }
            }
            #[doc = "Bit 24 - Event time-out interrupt clear."]
            #[inline]
            pub fn eventtimeoutclr(&mut self) -> _EVENTTIMEOUTCLRW {
                _EVENTTIMEOUTCLRW { w: self }
            }
            #[doc = "Bit 25 - SCL time-out interrupt clear."]
            #[inline]
            pub fn scltimeoutclr(&mut self) -> _SCLTIMEOUTCLRW {
                _SCLTIMEOUTCLRW { w: self }
            }
        }
    }
    #[doc = "Time-out value register."]
    pub struct TIMEOUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Time-out value register."]
    pub mod timeout {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TIMEOUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOMINR {
            bits: u8,
        }
        impl TOMINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOR {
            bits: u16,
        }
        impl TOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOMINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOMINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Time-out time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum time-out of 16 I2C function clocks and also a time-out resolution of 16 I2C function clocks."]
            #[inline]
            pub fn tomin(&self) -> TOMINR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TOMINR { bits }
            }
            #[doc = "Bits 4:15 - Time-out time value. Specifies the time-out interval value in increments of 16 I 2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. ... 0xFFF = A time-out will occur after 65,536 counts of the I2C function clock."]
            #[inline]
            pub fn to(&self) -> TOR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Time-out time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum time-out of 16 I2C function clocks and also a time-out resolution of 16 I2C function clocks."]
            #[inline]
            pub fn tomin(&mut self) -> _TOMINW {
                _TOMINW { w: self }
            }
            #[doc = "Bits 4:15 - Time-out time value. Specifies the time-out interval value in increments of 16 I 2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. ... 0xFFF = A time-out will occur after 65,536 counts of the I2C function clock."]
            #[inline]
            pub fn to(&mut self) -> _TOW {
                _TOW { w: self }
            }
        }
    }
    #[doc = "Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME registers."]
    pub struct CLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME registers."]
    pub mod clkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVVALR {
            bits: u16,
        }
        impl DIVVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - This field controls how the clock (PCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = PCLK is used directly by the I2C function. 0x0001 = PCLK is divided by 2 before use by the I 2C function. 0x0002 = PCLK is divided by 3 before use by the I 2C function. ... 0xFFFF = PCLK is divided by 65,536 before use by the I2C function."]
            #[inline]
            pub fn divval(&self) -> DIVVALR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - This field controls how the clock (PCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = PCLK is used directly by the I2C function. 0x0001 = PCLK is divided by 2 before use by the I 2C function. 0x0002 = PCLK is divided by 3 before use by the I 2C function. ... 0xFFFF = PCLK is divided by 65,536 before use by the I2C function."]
            #[inline]
            pub fn divval(&mut self) -> _DIVVALW {
                _DIVVALW { w: self }
            }
        }
    }
    #[doc = "Interrupt Status register for Master, Slave, and Monitor functions."]
    pub struct INTSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Status register for Master, Slave, and Monitor functions."]
    pub mod intstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTPENDINGR {
            bits: bool,
        }
        impl MSTPENDINGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTARBLOSSR {
            bits: bool,
        }
        impl MSTARBLOSSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTSTSTPERRR {
            bits: bool,
        }
        impl MSTSTSTPERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVPENDINGR {
            bits: bool,
        }
        impl SLVPENDINGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVNOTSTRR {
            bits: bool,
        }
        impl SLVNOTSTRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVDESELR {
            bits: bool,
        }
        impl SLVDESELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONRDYR {
            bits: bool,
        }
        impl MONRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONOVR {
            bits: bool,
        }
        impl MONOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONIDLER {
            bits: bool,
        }
        impl MONIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVENTTIMEOUTR {
            bits: bool,
        }
        impl EVENTTIMEOUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCLTIMEOUTR {
            bits: bool,
        }
        impl SCLTIMEOUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Pending."]
            #[inline]
            pub fn mstpending(&self) -> MSTPENDINGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTPENDINGR { bits }
            }
            #[doc = "Bit 4 - Master Arbitration Loss flag."]
            #[inline]
            pub fn mstarbloss(&self) -> MSTARBLOSSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTARBLOSSR { bits }
            }
            #[doc = "Bit 6 - Master Start/Stop Error flag."]
            #[inline]
            pub fn mstststperr(&self) -> MSTSTSTPERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTSTSTPERRR { bits }
            }
            #[doc = "Bit 8 - Slave Pending."]
            #[inline]
            pub fn slvpending(&self) -> SLVPENDINGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVPENDINGR { bits }
            }
            #[doc = "Bit 11 - Slave Not Stretching status."]
            #[inline]
            pub fn slvnotstr(&self) -> SLVNOTSTRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVNOTSTRR { bits }
            }
            #[doc = "Bit 15 - Slave Deselected flag."]
            #[inline]
            pub fn slvdesel(&self) -> SLVDESELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVDESELR { bits }
            }
            #[doc = "Bit 16 - Monitor Ready."]
            #[inline]
            pub fn monrdy(&self) -> MONRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MONRDYR { bits }
            }
            #[doc = "Bit 17 - Monitor Overflow flag."]
            #[inline]
            pub fn monov(&self) -> MONOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MONOVR { bits }
            }
            #[doc = "Bit 19 - Monitor Idle flag."]
            #[inline]
            pub fn monidle(&self) -> MONIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MONIDLER { bits }
            }
            #[doc = "Bit 24 - Event time-out Interrupt flag."]
            #[inline]
            pub fn eventtimeout(&self) -> EVENTTIMEOUTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVENTTIMEOUTR { bits }
            }
            #[doc = "Bit 25 - SCL time-out Interrupt flag."]
            #[inline]
            pub fn scltimeout(&self) -> SCLTIMEOUTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SCLTIMEOUTR { bits }
            }
        }
    }
    #[doc = "Master control register."]
    pub struct MSTCTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Master control register."]
    pub mod mstctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTCONTINUE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTCONTINUER {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE,
        }
        impl MSTCONTINUER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTCONTINUER::NO_EFFECT => false,
                    MSTCONTINUER::CONTINUE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTCONTINUER {
                match value {
                    false => MSTCONTINUER::NO_EFFECT,
                    true => MSTCONTINUER::CONTINUE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT`"]
            #[inline]
            pub fn is_no_effect(&self) -> bool {
                *self == MSTCONTINUER::NO_EFFECT
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline]
            pub fn is_continue_(&self) -> bool {
                *self == MSTCONTINUER::CONTINUE
            }
        }
        #[doc = "Possible values of the field `MSTSTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTARTR {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Start. A Start will be generated on the I2C bus at the next allowed time."]
            START,
        }
        impl MSTSTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTARTR::NO_EFFECT => false,
                    MSTSTARTR::START => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTSTARTR {
                match value {
                    false => MSTSTARTR::NO_EFFECT,
                    true => MSTSTARTR::START,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT`"]
            #[inline]
            pub fn is_no_effect(&self) -> bool {
                *self == MSTSTARTR::NO_EFFECT
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline]
            pub fn is_start(&self) -> bool {
                *self == MSTSTARTR::START
            }
        }
        #[doc = "Possible values of the field `MSTSTOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTOPR {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a NACK to the slave if the master is receiving data from the slave (Master Receiver mode)."]
            STOP,
        }
        impl MSTSTOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTOPR::NO_EFFECT => false,
                    MSTSTOPR::STOP => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTSTOPR {
                match value {
                    false => MSTSTOPR::NO_EFFECT,
                    true => MSTSTOPR::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT`"]
            #[inline]
            pub fn is_no_effect(&self) -> bool {
                *self == MSTSTOPR::NO_EFFECT
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline]
            pub fn is_stop(&self) -> bool {
                *self == MSTSTOPR::STOP
            }
        }
        #[doc = "Possible values of the field `MSTDMA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTDMAR {
            #[doc = "Disable. No DMA requests are generated for master operation."]
            DISABLE,
            #[doc = "Enable. A DMA request is generated for I2C master data operations. When this I2C master is generating Acknowledge bits in Master Receiver mode, the acknowledge is generated automatically."]
            ENABLE,
        }
        impl MSTDMAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTDMAR::DISABLE => false,
                    MSTDMAR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSTDMAR {
                match value {
                    false => MSTDMAR::DISABLE,
                    true => MSTDMAR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == MSTDMAR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == MSTDMAR::ENABLE
            }
        }
        #[doc = "Values that can be written to the field `MSTCONTINUE`"]
        pub enum MSTCONTINUEW {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE,
        }
        impl MSTCONTINUEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTCONTINUEW::NO_EFFECT => false,
                    MSTCONTINUEW::CONTINUE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTCONTINUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTCONTINUEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTCONTINUEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(MSTCONTINUEW::NO_EFFECT)
            }
            #[doc = "Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            #[inline]
            pub fn continue_(self) -> &'a mut W {
                self.variant(MSTCONTINUEW::CONTINUE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTART`"]
        pub enum MSTSTARTW {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Start. A Start will be generated on the I2C bus at the next allowed time."]
            START,
        }
        impl MSTSTARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTARTW::NO_EFFECT => false,
                    MSTSTARTW::START => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTSTARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(MSTSTARTW::NO_EFFECT)
            }
            #[doc = "Start. A Start will be generated on the I2C bus at the next allowed time."]
            #[inline]
            pub fn start(self) -> &'a mut W {
                self.variant(MSTSTARTW::START)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTOP`"]
        pub enum MSTSTOPW {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a NACK to the slave if the master is receiving data from the slave (Master Receiver mode)."]
            STOP,
        }
        impl MSTSTOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTOPW::NO_EFFECT => false,
                    MSTSTOPW::STOP => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTSTOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(MSTSTOPW::NO_EFFECT)
            }
            #[doc = "Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a NACK to the slave if the master is receiving data from the slave (Master Receiver mode)."]
            #[inline]
            pub fn stop(self) -> &'a mut W {
                self.variant(MSTSTOPW::STOP)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTDMA`"]
        pub enum MSTDMAW {
            #[doc = "Disable. No DMA requests are generated for master operation."]
            DISABLE,
            #[doc = "Enable. A DMA request is generated for I2C master data operations. When this I2C master is generating Acknowledge bits in Master Receiver mode, the acknowledge is generated automatically."]
            ENABLE,
        }
        impl MSTDMAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTDMAW::DISABLE => false,
                    MSTDMAW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTDMAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTDMAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTDMAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable. No DMA requests are generated for master operation."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(MSTDMAW::DISABLE)
            }
            #[doc = "Enable. A DMA request is generated for I2C master data operations. When this I2C master is generating Acknowledge bits in Master Receiver mode, the acknowledge is generated automatically."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(MSTDMAW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Continue. This bit is write-only."]
            #[inline]
            pub fn mstcontinue(&self) -> MSTCONTINUER {
                MSTCONTINUER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Master Start control. This bit is write-only."]
            #[inline]
            pub fn mststart(&self) -> MSTSTARTR {
                MSTSTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Master Stop control. This bit is write-only."]
            #[inline]
            pub fn mststop(&self) -> MSTSTOPR {
                MSTSTOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Master DMA enable. Data operations of the I2C can be performed with DMA. Protocol type operations such as Start, address, Stop, and address match must always be done with software, typically via an interrupt. When a DMA data transfer is complete, MSTDMA must be cleared prior to beginning the next operation, typically a Start or Stop.This bit is read/write."]
            #[inline]
            pub fn mstdma(&self) -> MSTDMAR {
                MSTDMAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Continue. This bit is write-only."]
            #[inline]
            pub fn mstcontinue(&mut self) -> _MSTCONTINUEW {
                _MSTCONTINUEW { w: self }
            }
            #[doc = "Bit 1 - Master Start control. This bit is write-only."]
            #[inline]
            pub fn mststart(&mut self) -> _MSTSTARTW {
                _MSTSTARTW { w: self }
            }
            #[doc = "Bit 2 - Master Stop control. This bit is write-only."]
            #[inline]
            pub fn mststop(&mut self) -> _MSTSTOPW {
                _MSTSTOPW { w: self }
            }
            #[doc = "Bit 3 - Master DMA enable. Data operations of the I2C can be performed with DMA. Protocol type operations such as Start, address, Stop, and address match must always be done with software, typically via an interrupt. When a DMA data transfer is complete, MSTDMA must be cleared prior to beginning the next operation, typically a Start or Stop.This bit is read/write."]
            #[inline]
            pub fn mstdma(&mut self) -> _MSTDMAW {
                _MSTDMAW { w: self }
            }
        }
    }
    #[doc = "Master timing configuration."]
    pub struct MSTTIME {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Master timing configuration."]
    pub mod msttime {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTTIME {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTSCLLOW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSCLLOWR {
            #[doc = "2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider."]
            _2_CLOCKS,
            #[doc = "3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider."]
            _3_CLOCKS,
            #[doc = "4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider."]
            _4_CLOCKS,
            #[doc = "5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider."]
            _5_CLOCKS,
            #[doc = "6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider."]
            _6_CLOCKS,
            #[doc = "7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider."]
            _7_CLOCKS,
            #[doc = "8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider."]
            _8_CLOCKS,
            #[doc = "9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS,
        }
        impl MSTSCLLOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MSTSCLLOWR::_2_CLOCKS => 0,
                    MSTSCLLOWR::_3_CLOCKS => 0x01,
                    MSTSCLLOWR::_4_CLOCKS => 0x02,
                    MSTSCLLOWR::_5_CLOCKS => 0x03,
                    MSTSCLLOWR::_6_CLOCKS => 0x04,
                    MSTSCLLOWR::_7_CLOCKS => 0x05,
                    MSTSCLLOWR::_8_CLOCKS => 0x06,
                    MSTSCLLOWR::_9_CLOCKS => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MSTSCLLOWR {
                match value {
                    0 => MSTSCLLOWR::_2_CLOCKS,
                    1 => MSTSCLLOWR::_3_CLOCKS,
                    2 => MSTSCLLOWR::_4_CLOCKS,
                    3 => MSTSCLLOWR::_5_CLOCKS,
                    4 => MSTSCLLOWR::_6_CLOCKS,
                    5 => MSTSCLLOWR::_7_CLOCKS,
                    6 => MSTSCLLOWR::_8_CLOCKS,
                    7 => MSTSCLLOWR::_9_CLOCKS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_2_CLOCKS`"]
            #[inline]
            pub fn is_2_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_2_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_3_CLOCKS`"]
            #[inline]
            pub fn is_3_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_3_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_4_CLOCKS`"]
            #[inline]
            pub fn is_4_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_4_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_5_CLOCKS`"]
            #[inline]
            pub fn is_5_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_5_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_6_CLOCKS`"]
            #[inline]
            pub fn is_6_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_6_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_7_CLOCKS`"]
            #[inline]
            pub fn is_7_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_7_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_8_CLOCKS`"]
            #[inline]
            pub fn is_8_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_8_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_9_CLOCKS`"]
            #[inline]
            pub fn is_9_clocks(&self) -> bool {
                *self == MSTSCLLOWR::_9_CLOCKS
            }
        }
        #[doc = "Possible values of the field `MSTSCLHIGH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSCLHIGHR {
            #[doc = "2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider."]
            _2_CLOCKS,
            #[doc = "3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider ."]
            _3_CLOCKS,
            #[doc = "4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider."]
            _4_CLOCKS,
            #[doc = "5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider."]
            _5_CLOCKS,
            #[doc = "6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider."]
            _6_CLOCKS,
            #[doc = "7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider."]
            _7_CLOCKS,
            #[doc = "8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider."]
            _8_CLOCKS,
            #[doc = "9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS,
        }
        impl MSTSCLHIGHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MSTSCLHIGHR::_2_CLOCKS => 0,
                    MSTSCLHIGHR::_3_CLOCKS => 0x01,
                    MSTSCLHIGHR::_4_CLOCKS => 0x02,
                    MSTSCLHIGHR::_5_CLOCKS => 0x03,
                    MSTSCLHIGHR::_6_CLOCKS => 0x04,
                    MSTSCLHIGHR::_7_CLOCKS => 0x05,
                    MSTSCLHIGHR::_8_CLOCKS => 0x06,
                    MSTSCLHIGHR::_9_CLOCKS => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MSTSCLHIGHR {
                match value {
                    0 => MSTSCLHIGHR::_2_CLOCKS,
                    1 => MSTSCLHIGHR::_3_CLOCKS,
                    2 => MSTSCLHIGHR::_4_CLOCKS,
                    3 => MSTSCLHIGHR::_5_CLOCKS,
                    4 => MSTSCLHIGHR::_6_CLOCKS,
                    5 => MSTSCLHIGHR::_7_CLOCKS,
                    6 => MSTSCLHIGHR::_8_CLOCKS,
                    7 => MSTSCLHIGHR::_9_CLOCKS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_2_CLOCKS`"]
            #[inline]
            pub fn is_2_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_2_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_3_CLOCKS`"]
            #[inline]
            pub fn is_3_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_3_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_4_CLOCKS`"]
            #[inline]
            pub fn is_4_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_4_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_5_CLOCKS`"]
            #[inline]
            pub fn is_5_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_5_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_6_CLOCKS`"]
            #[inline]
            pub fn is_6_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_6_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_7_CLOCKS`"]
            #[inline]
            pub fn is_7_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_7_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_8_CLOCKS`"]
            #[inline]
            pub fn is_8_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_8_CLOCKS
            }
            #[doc = "Checks if the value of the field is `_9_CLOCKS`"]
            #[inline]
            pub fn is_9_clocks(&self) -> bool {
                *self == MSTSCLHIGHR::_9_CLOCKS
            }
        }
        #[doc = "Values that can be written to the field `MSTSCLLOW`"]
        pub enum MSTSCLLOWW {
            #[doc = "2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider."]
            _2_CLOCKS,
            #[doc = "3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider."]
            _3_CLOCKS,
            #[doc = "4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider."]
            _4_CLOCKS,
            #[doc = "5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider."]
            _5_CLOCKS,
            #[doc = "6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider."]
            _6_CLOCKS,
            #[doc = "7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider."]
            _7_CLOCKS,
            #[doc = "8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider."]
            _8_CLOCKS,
            #[doc = "9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS,
        }
        impl MSTSCLLOWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MSTSCLLOWW::_2_CLOCKS => 0,
                    MSTSCLLOWW::_3_CLOCKS => 1,
                    MSTSCLLOWW::_4_CLOCKS => 2,
                    MSTSCLLOWW::_5_CLOCKS => 3,
                    MSTSCLLOWW::_6_CLOCKS => 4,
                    MSTSCLLOWW::_7_CLOCKS => 5,
                    MSTSCLLOWW::_8_CLOCKS => 6,
                    MSTSCLLOWW::_9_CLOCKS => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSCLLOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSCLLOWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTSCLLOWW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _2_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_2_CLOCKS)
            }
            #[doc = "3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _3_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_3_CLOCKS)
            }
            #[doc = "4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _4_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_4_CLOCKS)
            }
            #[doc = "5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _5_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_5_CLOCKS)
            }
            #[doc = "6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _6_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_6_CLOCKS)
            }
            #[doc = "7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _7_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_7_CLOCKS)
            }
            #[doc = "8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _8_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_8_CLOCKS)
            }
            #[doc = "9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _9_clocks(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_9_CLOCKS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSCLHIGH`"]
        pub enum MSTSCLHIGHW {
            #[doc = "2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider."]
            _2_CLOCKS,
            #[doc = "3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider ."]
            _3_CLOCKS,
            #[doc = "4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider."]
            _4_CLOCKS,
            #[doc = "5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider."]
            _5_CLOCKS,
            #[doc = "6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider."]
            _6_CLOCKS,
            #[doc = "7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider."]
            _7_CLOCKS,
            #[doc = "8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider."]
            _8_CLOCKS,
            #[doc = "9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS,
        }
        impl MSTSCLHIGHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MSTSCLHIGHW::_2_CLOCKS => 0,
                    MSTSCLHIGHW::_3_CLOCKS => 1,
                    MSTSCLHIGHW::_4_CLOCKS => 2,
                    MSTSCLHIGHW::_5_CLOCKS => 3,
                    MSTSCLHIGHW::_6_CLOCKS => 4,
                    MSTSCLHIGHW::_7_CLOCKS => 5,
                    MSTSCLHIGHW::_8_CLOCKS => 6,
                    MSTSCLHIGHW::_9_CLOCKS => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSCLHIGHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSCLHIGHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSTSCLHIGHW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider."]
            #[inline]
            pub fn _2_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_2_CLOCKS)
            }
            #[doc = "3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider ."]
            #[inline]
            pub fn _3_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_3_CLOCKS)
            }
            #[doc = "4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider."]
            #[inline]
            pub fn _4_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_4_CLOCKS)
            }
            #[doc = "5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider."]
            #[inline]
            pub fn _5_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_5_CLOCKS)
            }
            #[doc = "6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider."]
            #[inline]
            pub fn _6_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_6_CLOCKS)
            }
            #[doc = "7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider."]
            #[inline]
            pub fn _7_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_7_CLOCKS)
            }
            #[doc = "8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider."]
            #[inline]
            pub fn _8_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_8_CLOCKS)
            }
            #[doc = "9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider."]
            #[inline]
            pub fn _9_clocks(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_9_CLOCKS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter tLOW in the I2C bus specification. I2C bus specification parameters tBUF and t SU;STA have the same values and are also controlled by MSTSCLLOW."]
            #[inline]
            pub fn mstscllow(&self) -> MSTSCLLOWR {
                MSTSCLLOWR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:6 - Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH."]
            #[inline]
            pub fn mstsclhigh(&self) -> MSTSCLHIGHR {
                MSTSCLHIGHR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x77 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter tLOW in the I2C bus specification. I2C bus specification parameters tBUF and t SU;STA have the same values and are also controlled by MSTSCLLOW."]
            #[inline]
            pub fn mstscllow(&mut self) -> _MSTSCLLOWW {
                _MSTSCLLOWW { w: self }
            }
            #[doc = "Bits 4:6 - Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH."]
            #[inline]
            pub fn mstsclhigh(&mut self) -> _MSTSCLHIGHW {
                _MSTSCLHIGHW { w: self }
            }
        }
    }
    #[doc = "Combined Master receiver and transmitter data register."]
    pub struct MSTDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Combined Master receiver and transmitter data register."]
    pub mod mstdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function."]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function."]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Slave control register."]
    pub struct SLVCTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Slave control register."]
    pub mod slvctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SLVCONTINUE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVCONTINUER {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE,
        }
        impl SLVCONTINUER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVCONTINUER::NO_EFFECT => false,
                    SLVCONTINUER::CONTINUE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVCONTINUER {
                match value {
                    false => SLVCONTINUER::NO_EFFECT,
                    true => SLVCONTINUER::CONTINUE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT`"]
            #[inline]
            pub fn is_no_effect(&self) -> bool {
                *self == SLVCONTINUER::NO_EFFECT
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline]
            pub fn is_continue_(&self) -> bool {
                *self == SLVCONTINUER::CONTINUE
            }
        }
        #[doc = "Possible values of the field `SLVNACK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVNACKR {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "NACK. Causes the Slave function to NACK the master when the slave is receiving data from the master (Slave Receiver mode)."]
            NACK,
        }
        impl SLVNACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVNACKR::NO_EFFECT => false,
                    SLVNACKR::NACK => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVNACKR {
                match value {
                    false => SLVNACKR::NO_EFFECT,
                    true => SLVNACKR::NACK,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT`"]
            #[inline]
            pub fn is_no_effect(&self) -> bool {
                *self == SLVNACKR::NO_EFFECT
            }
            #[doc = "Checks if the value of the field is `NACK`"]
            #[inline]
            pub fn is_nack(&self) -> bool {
                *self == SLVNACKR::NACK
            }
        }
        #[doc = "Possible values of the field `SLVDMA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVDMAR {
            #[doc = "Disabled. No DMA requests are issued for Slave mode operation."]
            DISABLED,
            #[doc = "Enabled. DMA requests are issued for I2C slave data transmission and reception."]
            ENABLED,
        }
        impl SLVDMAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVDMAR::DISABLED => false,
                    SLVDMAR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLVDMAR {
                match value {
                    false => SLVDMAR::DISABLED,
                    true => SLVDMAR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SLVDMAR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SLVDMAR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `SLVCONTINUE`"]
        pub enum SLVCONTINUEW {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE,
        }
        impl SLVCONTINUEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVCONTINUEW::NO_EFFECT => false,
                    SLVCONTINUEW::CONTINUE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVCONTINUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVCONTINUEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVCONTINUEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(SLVCONTINUEW::NO_EFFECT)
            }
            #[doc = "Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            #[inline]
            pub fn continue_(self) -> &'a mut W {
                self.variant(SLVCONTINUEW::CONTINUE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVNACK`"]
        pub enum SLVNACKW {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "NACK. Causes the Slave function to NACK the master when the slave is receiving data from the master (Slave Receiver mode)."]
            NACK,
        }
        impl SLVNACKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVNACKW::NO_EFFECT => false,
                    SLVNACKW::NACK => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNACKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVNACKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(SLVNACKW::NO_EFFECT)
            }
            #[doc = "NACK. Causes the Slave function to NACK the master when the slave is receiving data from the master (Slave Receiver mode)."]
            #[inline]
            pub fn nack(self) -> &'a mut W {
                self.variant(SLVNACKW::NACK)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVDMA`"]
        pub enum SLVDMAW {
            #[doc = "Disabled. No DMA requests are issued for Slave mode operation."]
            DISABLED,
            #[doc = "Enabled. DMA requests are issued for I2C slave data transmission and reception."]
            ENABLED,
        }
        impl SLVDMAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVDMAW::DISABLED => false,
                    SLVDMAW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVDMAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVDMAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLVDMAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. No DMA requests are issued for Slave mode operation."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SLVDMAW::DISABLED)
            }
            #[doc = "Enabled. DMA requests are issued for I2C slave data transmission and reception."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SLVDMAW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Slave Continue."]
            #[inline]
            pub fn slvcontinue(&self) -> SLVCONTINUER {
                SLVCONTINUER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Slave NACK."]
            #[inline]
            pub fn slvnack(&self) -> SLVNACKR {
                SLVNACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Slave DMA enable."]
            #[inline]
            pub fn slvdma(&self) -> SLVDMAR {
                SLVDMAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Slave Continue."]
            #[inline]
            pub fn slvcontinue(&mut self) -> _SLVCONTINUEW {
                _SLVCONTINUEW { w: self }
            }
            #[doc = "Bit 1 - Slave NACK."]
            #[inline]
            pub fn slvnack(&mut self) -> _SLVNACKW {
                _SLVNACKW { w: self }
            }
            #[doc = "Bit 3 - Slave DMA enable."]
            #[inline]
            pub fn slvdma(&mut self) -> _SLVDMAW {
                _SLVDMAW { w: self }
            }
        }
    }
    #[doc = "Combined Slave receiver and transmitter data register."]
    pub struct SLVDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Combined Slave receiver and transmitter data register."]
    pub mod slvdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function."]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function."]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Slave address 0."]
    pub struct SLVADR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Slave address 0."]
    pub mod slvadr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVADR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SADISABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SADISABLER {
            #[doc = "Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register."]
            ENABLED,
            #[doc = "Ignored Slave Address n is ignored."]
            IGNORED_SLAVE_ADDRES,
        }
        impl SADISABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SADISABLER::ENABLED => false,
                    SADISABLER::IGNORED_SLAVE_ADDRES => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SADISABLER {
                match value {
                    false => SADISABLER::ENABLED,
                    true => SADISABLER::IGNORED_SLAVE_ADDRES,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SADISABLER::ENABLED
            }
            #[doc = "Checks if the value of the field is `IGNORED_SLAVE_ADDRES`"]
            #[inline]
            pub fn is_ignored_slave_addres(&self) -> bool {
                *self == SADISABLER::IGNORED_SLAVE_ADDRES
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVADRR {
            bits: u8,
        }
        impl SLVADRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SADISABLE`"]
        pub enum SADISABLEW {
            #[doc = "Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register."]
            ENABLED,
            #[doc = "Ignored Slave Address n is ignored."]
            IGNORED_SLAVE_ADDRES,
        }
        impl SADISABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SADISABLEW::ENABLED => false,
                    SADISABLEW::IGNORED_SLAVE_ADDRES => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SADISABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SADISABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SADISABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SADISABLEW::ENABLED)
            }
            #[doc = "Ignored Slave Address n is ignored."]
            #[inline]
            pub fn ignored_slave_addres(self) -> &'a mut W {
                self.variant(SADISABLEW::IGNORED_SLAVE_ADDRES)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVADRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVADRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Slave Address n Disable."]
            #[inline]
            pub fn sadisable(&self) -> SADISABLER {
                SADISABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:7 - Seven bit slave address that is compared to received addresses if enabled."]
            #[inline]
            pub fn slvadr(&self) -> SLVADRR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SLVADRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Slave Address n Disable."]
            #[inline]
            pub fn sadisable(&mut self) -> _SADISABLEW {
                _SADISABLEW { w: self }
            }
            #[doc = "Bits 1:7 - Seven bit slave address that is compared to received addresses if enabled."]
            #[inline]
            pub fn slvadr(&mut self) -> _SLVADRW {
                _SLVADRW { w: self }
            }
        }
    }
    #[doc = "Slave Qualification for address 0."]
    pub struct SLVQUAL0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Slave Qualification for address 0."]
    pub mod slvqual0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVQUAL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `QUALMODE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum QUALMODE0R {
            #[doc = "The SLVQUAL0 field is used as a logical mask for matching address 0."]
            MASK,
            #[doc = "The SLVQUAL0 field is used to extend address 0 matching in a range of addresses."]
            EXTENDMASK,
        }
        impl QUALMODE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    QUALMODE0R::MASK => false,
                    QUALMODE0R::EXTENDMASK => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> QUALMODE0R {
                match value {
                    false => QUALMODE0R::MASK,
                    true => QUALMODE0R::EXTENDMASK,
                }
            }
            #[doc = "Checks if the value of the field is `MASK`"]
            #[inline]
            pub fn is_mask(&self) -> bool {
                *self == QUALMODE0R::MASK
            }
            #[doc = "Checks if the value of the field is `EXTENDMASK`"]
            #[inline]
            pub fn is_extendmask(&self) -> bool {
                *self == QUALMODE0R::EXTENDMASK
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVQUAL0R {
            bits: u8,
        }
        impl SLVQUAL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `QUALMODE0`"]
        pub enum QUALMODE0W {
            #[doc = "The SLVQUAL0 field is used as a logical mask for matching address 0."]
            MASK,
            #[doc = "The SLVQUAL0 field is used to extend address 0 matching in a range of addresses."]
            EXTENDMASK,
        }
        impl QUALMODE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    QUALMODE0W::MASK => false,
                    QUALMODE0W::EXTENDMASK => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _QUALMODE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _QUALMODE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: QUALMODE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SLVQUAL0 field is used as a logical mask for matching address 0."]
            #[inline]
            pub fn mask(self) -> &'a mut W {
                self.variant(QUALMODE0W::MASK)
            }
            #[doc = "The SLVQUAL0 field is used to extend address 0 matching in a range of addresses."]
            #[inline]
            pub fn extendmask(self) -> &'a mut W {
                self.variant(QUALMODE0W::EXTENDMASK)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVQUAL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVQUAL0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Reserved. Read value is undefined, only zero should be written."]
            #[inline]
            pub fn qualmode0(&self) -> QUALMODE0R {
                QUALMODE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:7 - Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] <= received address < = SLVQUAL0[7:1])."]
            #[inline]
            pub fn slvqual0(&self) -> SLVQUAL0R {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SLVQUAL0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Reserved. Read value is undefined, only zero should be written."]
            #[inline]
            pub fn qualmode0(&mut self) -> _QUALMODE0W {
                _QUALMODE0W { w: self }
            }
            #[doc = "Bits 1:7 - Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] <= received address < = SLVQUAL0[7:1])."]
            #[inline]
            pub fn slvqual0(&mut self) -> _SLVQUAL0W {
                _SLVQUAL0W { w: self }
            }
        }
    }
    #[doc = "Monitor receiver data register."]
    pub struct MONRXDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Monitor receiver data register."]
    pub mod monrxdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MONRXDAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONRXDATR {
            bits: u8,
        }
        impl MONRXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `MONSTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONSTARTR {
            #[doc = "No detect. The monitor function has not detected a Start event on the I2C bus."]
            NO_DETECT,
            #[doc = "Start detect. The monitor function has detected a Start event on the I2C bus."]
            START_DETECT,
        }
        impl MONSTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONSTARTR::NO_DETECT => false,
                    MONSTARTR::START_DETECT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONSTARTR {
                match value {
                    false => MONSTARTR::NO_DETECT,
                    true => MONSTARTR::START_DETECT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_DETECT`"]
            #[inline]
            pub fn is_no_detect(&self) -> bool {
                *self == MONSTARTR::NO_DETECT
            }
            #[doc = "Checks if the value of the field is `START_DETECT`"]
            #[inline]
            pub fn is_start_detect(&self) -> bool {
                *self == MONSTARTR::START_DETECT
            }
        }
        #[doc = "Possible values of the field `MONRESTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONRESTARTR {
            #[doc = "No start detect. The monitor function has not detected a Repeated Start event on the I2C bus."]
            NO_START_DETECT,
            #[doc = "Repeated start detect. The monitor function has detected a Repeated Start event on the I 2C bus."]
            REPEATED_START_DETEC,
        }
        impl MONRESTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONRESTARTR::NO_START_DETECT => false,
                    MONRESTARTR::REPEATED_START_DETEC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONRESTARTR {
                match value {
                    false => MONRESTARTR::NO_START_DETECT,
                    true => MONRESTARTR::REPEATED_START_DETEC,
                }
            }
            #[doc = "Checks if the value of the field is `NO_START_DETECT`"]
            #[inline]
            pub fn is_no_start_detect(&self) -> bool {
                *self == MONRESTARTR::NO_START_DETECT
            }
            #[doc = "Checks if the value of the field is `REPEATED_START_DETEC`"]
            #[inline]
            pub fn is_repeated_start_detec(&self) -> bool {
                *self == MONRESTARTR::REPEATED_START_DETEC
            }
        }
        #[doc = "Possible values of the field `MONNACK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONNACKR {
            #[doc = "Acknowledged. The data currently being provided by the monitor function was acknowledged by at least one master or slave receiver."]
            ACKNOWLEDGED,
            #[doc = "Not acknowledged. The data currently being provided by the monitor function was not acknowledged by any receiver."]
            NOT_ACKNOWLEDGED,
        }
        impl MONNACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MONNACKR::ACKNOWLEDGED => false,
                    MONNACKR::NOT_ACKNOWLEDGED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MONNACKR {
                match value {
                    false => MONNACKR::ACKNOWLEDGED,
                    true => MONNACKR::NOT_ACKNOWLEDGED,
                }
            }
            #[doc = "Checks if the value of the field is `ACKNOWLEDGED`"]
            #[inline]
            pub fn is_acknowledged(&self) -> bool {
                *self == MONNACKR::ACKNOWLEDGED
            }
            #[doc = "Checks if the value of the field is `NOT_ACKNOWLEDGED`"]
            #[inline]
            pub fn is_not_acknowledged(&self) -> bool {
                *self == MONNACKR::NOT_ACKNOWLEDGED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Monitor function Receiver Data. This reflects every data byte that passes on the I2C pins, and adds indication of Start, Repeated Start, and data NACK."]
            #[inline]
            pub fn monrxdat(&self) -> MONRXDATR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MONRXDATR { bits }
            }
            #[doc = "Bit 8 - Monitor Received Start."]
            #[inline]
            pub fn monstart(&self) -> MONSTARTR {
                MONSTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Monitor Received Repeated Start."]
            #[inline]
            pub fn monrestart(&self) -> MONRESTARTR {
                MONRESTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Monitor Received NACK."]
            #[inline]
            pub fn monnack(&self) -> MONNACKR {
                MONNACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
}
#[doc = "I2C1"]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c0::RegisterBlock {
        0x4005_4000 as *const _
    }
}
impl Deref for I2C1 {
    type Target = i2c0::RegisterBlock;
    fn deref(&self) -> &i2c0::RegisterBlock {
        unsafe { &*I2C1::ptr() }
    }
}
#[doc = "SPI0"]
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi0::RegisterBlock {
        0x4005_8000 as *const _
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        unsafe { &*SPI0::ptr() }
    }
}
#[doc = "SPI0"]
pub mod spi0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SPI Configuration register"]
        pub cfg: CFG,
        #[doc = "0x04 - SPI Delay register"]
        pub dly: DLY,
        #[doc = "0x08 - SPI Status. Some status flags can be cleared by writing a 1 to that bit position"]
        pub stat: STAT,
        #[doc = "0x0c - SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
        pub intenset: INTENSET,
        #[doc = "0x10 - SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared."]
        pub intenclr: INTENCLR,
        #[doc = "0x14 - SPI Receive Data"]
        pub rxdat: RXDAT,
        #[doc = "0x18 - SPI Transmit Data with Control"]
        pub txdatctl: TXDATCTL,
        #[doc = "0x1c - SPI Transmit Data"]
        pub txdat: TXDAT,
        #[doc = "0x20 - SPI Transmit Control"]
        pub txctl: TXCTL,
        #[doc = "0x24 - SPI clock Divider"]
        pub div: DIV,
        #[doc = "0x28 - SPI Interrupt Status"]
        pub intstat: INTSTAT,
    }
    #[doc = "SPI Configuration register"]
    pub struct CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Configuration register"]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled. The SPI is disabled and the internal state machine and counters are reset."]
            DISABLED,
            #[doc = "Enabled. The SPI is enabled for operation."]
            ENABLED,
        }
        impl ENABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENABLER::DISABLED => false,
                    ENABLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENABLER {
                match value {
                    false => ENABLER::DISABLED,
                    true => ENABLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Possible values of the field `MASTER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MASTERR {
            #[doc = "Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output."]
            SLAVE_MODE,
            #[doc = "Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input."]
            MASTER_MODE,
        }
        impl MASTERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MASTERR::SLAVE_MODE => false,
                    MASTERR::MASTER_MODE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MASTERR {
                match value {
                    false => MASTERR::SLAVE_MODE,
                    true => MASTERR::MASTER_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE_MODE`"]
            #[inline]
            pub fn is_slave_mode(&self) -> bool {
                *self == MASTERR::SLAVE_MODE
            }
            #[doc = "Checks if the value of the field is `MASTER_MODE`"]
            #[inline]
            pub fn is_master_mode(&self) -> bool {
                *self == MASTERR::MASTER_MODE
            }
        }
        #[doc = "Possible values of the field `LSBF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSBFR {
            #[doc = "Standard. Data is transmitted and received in standard MSB first order."]
            STANDARD,
            #[doc = "Reverse. Data is transmitted and received in reverse order (LSB first)."]
            REVERSE,
        }
        impl LSBFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSBFR::STANDARD => false,
                    LSBFR::REVERSE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSBFR {
                match value {
                    false => LSBFR::STANDARD,
                    true => LSBFR::REVERSE,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == LSBFR::STANDARD
            }
            #[doc = "Checks if the value of the field is `REVERSE`"]
            #[inline]
            pub fn is_reverse(&self) -> bool {
                *self == LSBFR::REVERSE
            }
        }
        #[doc = "Possible values of the field `CPHA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHAR {
            #[doc = "Change. The SPI captures serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is changed on the following edge."]
            CHANGE,
            #[doc = "Capture. The SPI changes serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is captured on the following edge."]
            CAPTURE,
        }
        impl CPHAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPHAR::CHANGE => false,
                    CPHAR::CAPTURE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPHAR {
                match value {
                    false => CPHAR::CHANGE,
                    true => CPHAR::CAPTURE,
                }
            }
            #[doc = "Checks if the value of the field is `CHANGE`"]
            #[inline]
            pub fn is_change(&self) -> bool {
                *self == CPHAR::CHANGE
            }
            #[doc = "Checks if the value of the field is `CAPTURE`"]
            #[inline]
            pub fn is_capture(&self) -> bool {
                *self == CPHAR::CAPTURE
            }
        }
        #[doc = "Possible values of the field `CPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOLR {
            #[doc = "Low. The rest state of the clock (between transfers) is low."]
            LOW,
            #[doc = "High. The rest state of the clock (between transfers) is high."]
            HIGH,
        }
        impl CPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPOLR::LOW => false,
                    CPOLR::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPOLR {
                match value {
                    false => CPOLR::LOW,
                    true => CPOLR::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == CPOLR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == CPOLR::HIGH
            }
        }
        #[doc = "Possible values of the field `LOOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOOPR {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl LOOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOOPR::DISABLED => false,
                    LOOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOOPR {
                match value {
                    false => LOOPR::DISABLED,
                    true => LOOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LOOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == LOOPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SPOL0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPOL0R {
            #[doc = "Low. The SSEL0 pin is active low. The value in the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL0 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL0 pin is active high. The value in the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL0 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPOL0R::LOW => false,
                    SPOL0R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPOL0R {
                match value {
                    false => SPOL0R::LOW,
                    true => SPOL0R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SPOL0R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SPOL0R::HIGH
            }
        }
        #[doc = "Possible values of the field `SPOL1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPOL1R {
            #[doc = "Low. The SSEL1 pin is active low. The value in the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL1 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL1 pin is active high. The value in the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL1 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPOL1R::LOW => false,
                    SPOL1R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPOL1R {
                match value {
                    false => SPOL1R::LOW,
                    true => SPOL1R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SPOL1R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SPOL1R::HIGH
            }
        }
        #[doc = "Possible values of the field `SPOL2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPOL2R {
            #[doc = "Low. The SSEL2 pin is active low. The value in the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL2 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL2 pin is active high. The value in the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL2 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPOL2R::LOW => false,
                    SPOL2R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPOL2R {
                match value {
                    false => SPOL2R::LOW,
                    true => SPOL2R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SPOL2R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SPOL2R::HIGH
            }
        }
        #[doc = "Possible values of the field `SPOL3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPOL3R {
            #[doc = "Low. The SSEL3 pin is active low. The value in the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL3 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL3 pin is active high. The value in the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL3 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SPOL3R::LOW => false,
                    SPOL3R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SPOL3R {
                match value {
                    false => SPOL3R::LOW,
                    true => SPOL3R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SPOL3R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SPOL3R::HIGH
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled. The SPI is disabled and the internal state machine and counters are reset."]
            DISABLED,
            #[doc = "Enabled. The SPI is enabled for operation."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENABLEW::DISABLED => false,
                    ENABLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The SPI is disabled and the internal state machine and counters are reset."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enabled. The SPI is enabled for operation."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MASTER`"]
        pub enum MASTERW {
            #[doc = "Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output."]
            SLAVE_MODE,
            #[doc = "Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input."]
            MASTER_MODE,
        }
        impl MASTERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MASTERW::SLAVE_MODE => false,
                    MASTERW::MASTER_MODE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASTERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASTERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MASTERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output."]
            #[inline]
            pub fn slave_mode(self) -> &'a mut W {
                self.variant(MASTERW::SLAVE_MODE)
            }
            #[doc = "Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input."]
            #[inline]
            pub fn master_mode(self) -> &'a mut W {
                self.variant(MASTERW::MASTER_MODE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LSBF`"]
        pub enum LSBFW {
            #[doc = "Standard. Data is transmitted and received in standard MSB first order."]
            STANDARD,
            #[doc = "Reverse. Data is transmitted and received in reverse order (LSB first)."]
            REVERSE,
        }
        impl LSBFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LSBFW::STANDARD => false,
                    LSBFW::REVERSE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSBFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSBFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSBFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard. Data is transmitted and received in standard MSB first order."]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(LSBFW::STANDARD)
            }
            #[doc = "Reverse. Data is transmitted and received in reverse order (LSB first)."]
            #[inline]
            pub fn reverse(self) -> &'a mut W {
                self.variant(LSBFW::REVERSE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPHA`"]
        pub enum CPHAW {
            #[doc = "Change. The SPI captures serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is changed on the following edge."]
            CHANGE,
            #[doc = "Capture. The SPI changes serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is captured on the following edge."]
            CAPTURE,
        }
        impl CPHAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPHAW::CHANGE => false,
                    CPHAW::CAPTURE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPHAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Change. The SPI captures serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is changed on the following edge."]
            #[inline]
            pub fn change(self) -> &'a mut W {
                self.variant(CPHAW::CHANGE)
            }
            #[doc = "Capture. The SPI changes serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is captured on the following edge."]
            #[inline]
            pub fn capture(self) -> &'a mut W {
                self.variant(CPHAW::CAPTURE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPOL`"]
        pub enum CPOLW {
            #[doc = "Low. The rest state of the clock (between transfers) is low."]
            LOW,
            #[doc = "High. The rest state of the clock (between transfers) is high."]
            HIGH,
        }
        impl CPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPOLW::LOW => false,
                    CPOLW::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. The rest state of the clock (between transfers) is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(CPOLW::LOW)
            }
            #[doc = "High. The rest state of the clock (between transfers) is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(CPOLW::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOOP`"]
        pub enum LOOPW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl LOOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOOPW::DISABLED => false,
                    LOOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LOOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LOOPW::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LOOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPOL0`"]
        pub enum SPOL0W {
            #[doc = "Low. The SSEL0 pin is active low. The value in the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL0 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL0 pin is active high. The value in the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL0 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPOL0W::LOW => false,
                    SPOL0W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPOL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPOL0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPOL0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. The SSEL0 pin is active low. The value in the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL0 is not inverted relative to the pins."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SPOL0W::LOW)
            }
            #[doc = "High. The SSEL0 pin is active high. The value in the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL0 is inverted relative to the pins."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SPOL0W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPOL1`"]
        pub enum SPOL1W {
            #[doc = "Low. The SSEL1 pin is active low. The value in the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL1 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL1 pin is active high. The value in the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL1 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPOL1W::LOW => false,
                    SPOL1W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPOL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPOL1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPOL1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. The SSEL1 pin is active low. The value in the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL1 is not inverted relative to the pins."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SPOL1W::LOW)
            }
            #[doc = "High. The SSEL1 pin is active high. The value in the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL1 is inverted relative to the pins."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SPOL1W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPOL2`"]
        pub enum SPOL2W {
            #[doc = "Low. The SSEL2 pin is active low. The value in the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL2 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL2 pin is active high. The value in the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL2 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPOL2W::LOW => false,
                    SPOL2W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPOL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPOL2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPOL2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. The SSEL2 pin is active low. The value in the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL2 is not inverted relative to the pins."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SPOL2W::LOW)
            }
            #[doc = "High. The SSEL2 pin is active high. The value in the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL2 is inverted relative to the pins."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SPOL2W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPOL3`"]
        pub enum SPOL3W {
            #[doc = "Low. The SSEL3 pin is active low. The value in the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL3 is not inverted relative to the pins."]
            LOW,
            #[doc = "High. The SSEL3 pin is active high. The value in the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL3 is inverted relative to the pins."]
            HIGH,
        }
        impl SPOL3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPOL3W::LOW => false,
                    SPOL3W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPOL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPOL3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPOL3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. The SSEL3 pin is active low. The value in the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL3 is not inverted relative to the pins."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SPOL3W::LOW)
            }
            #[doc = "High. The SSEL3 pin is active high. The value in the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL3 is inverted relative to the pins."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SPOL3W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SPI enable."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Master mode select."]
            #[inline]
            pub fn master(&self) -> MASTERR {
                MASTERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - LSB First mode enable."]
            #[inline]
            pub fn lsbf(&self) -> LSBFR {
                LSBFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Clock Phase select."]
            #[inline]
            pub fn cpha(&self) -> CPHAR {
                CPHAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Clock Polarity select."]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                CPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing."]
            #[inline]
            pub fn loop_(&self) -> LOOPR {
                LOOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - SSEL0 Polarity select."]
            #[inline]
            pub fn spol0(&self) -> SPOL0R {
                SPOL0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - SSEL1 Polarity select."]
            #[inline]
            pub fn spol1(&self) -> SPOL1R {
                SPOL1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - SSEL2 Polarity select."]
            #[inline]
            pub fn spol2(&self) -> SPOL2R {
                SPOL2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - SSEL3 Polarity select."]
            #[inline]
            pub fn spol3(&self) -> SPOL3R {
                SPOL3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SPI enable."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Master mode select."]
            #[inline]
            pub fn master(&mut self) -> _MASTERW {
                _MASTERW { w: self }
            }
            #[doc = "Bit 3 - LSB First mode enable."]
            #[inline]
            pub fn lsbf(&mut self) -> _LSBFW {
                _LSBFW { w: self }
            }
            #[doc = "Bit 4 - Clock Phase select."]
            #[inline]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
            #[doc = "Bit 5 - Clock Polarity select."]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
            #[doc = "Bit 7 - Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing."]
            #[inline]
            pub fn loop_(&mut self) -> _LOOPW {
                _LOOPW { w: self }
            }
            #[doc = "Bit 8 - SSEL0 Polarity select."]
            #[inline]
            pub fn spol0(&mut self) -> _SPOL0W {
                _SPOL0W { w: self }
            }
            #[doc = "Bit 9 - SSEL1 Polarity select."]
            #[inline]
            pub fn spol1(&mut self) -> _SPOL1W {
                _SPOL1W { w: self }
            }
            #[doc = "Bit 10 - SSEL2 Polarity select."]
            #[inline]
            pub fn spol2(&mut self) -> _SPOL2W {
                _SPOL2W { w: self }
            }
            #[doc = "Bit 11 - SSEL3 Polarity select."]
            #[inline]
            pub fn spol3(&mut self) -> _SPOL3W {
                _SPOL3W { w: self }
            }
        }
    }
    #[doc = "SPI Delay register"]
    pub struct DLY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Delay register"]
    pub mod dly {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DLY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRE_DELAYR {
            bits: u8,
        }
        impl PRE_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct POST_DELAYR {
            bits: u8,
        }
        impl POST_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAME_DELAYR {
            bits: u8,
        }
        impl FRAME_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRANSFER_DELAYR {
            bits: u8,
        }
        impl TRANSFER_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRE_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRE_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POST_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POST_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRANSFER_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRANSFER_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Controls the amount of time between SSEL assertion and the beginning of a data transfer. There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline]
            pub fn pre_delay(&self) -> PRE_DELAYR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRE_DELAYR { bits }
            }
            #[doc = "Bits 4:7 - Controls the amount of time between the end of a data transfer and SSEL deassertion. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline]
            pub fn post_delay(&self) -> POST_DELAYR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                POST_DELAYR { bits }
            }
            #[doc = "Bits 8:11 - If the EOF flag is set, controls the minimum amount of time between the current frame and the next frame (or SSEL deassertion if EOT). 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline]
            pub fn frame_delay(&self) -> FRAME_DELAYR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FRAME_DELAYR { bits }
            }
            #[doc = "Bits 12:15 - Controls the minimum amount of time that the SSEL is deasserted between transfers. 0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times."]
            #[inline]
            pub fn transfer_delay(&self) -> TRANSFER_DELAYR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRANSFER_DELAYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Controls the amount of time between SSEL assertion and the beginning of a data transfer. There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline]
            pub fn pre_delay(&mut self) -> _PRE_DELAYW {
                _PRE_DELAYW { w: self }
            }
            #[doc = "Bits 4:7 - Controls the amount of time between the end of a data transfer and SSEL deassertion. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline]
            pub fn post_delay(&mut self) -> _POST_DELAYW {
                _POST_DELAYW { w: self }
            }
            #[doc = "Bits 8:11 - If the EOF flag is set, controls the minimum amount of time between the current frame and the next frame (or SSEL deassertion if EOT). 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline]
            pub fn frame_delay(&mut self) -> _FRAME_DELAYW {
                _FRAME_DELAYW { w: self }
            }
            #[doc = "Bits 12:15 - Controls the minimum amount of time that the SSEL is deasserted between transfers. 0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times."]
            #[inline]
            pub fn transfer_delay(&mut self) -> _TRANSFER_DELAYW {
                _TRANSFER_DELAYW { w: self }
            }
        }
    }
    #[doc = "SPI Status. Some status flags can be cleared by writing a 1 to that bit position"]
    pub struct STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Status. Some status flags can be cleared by writing a 1 to that bit position"]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOVR {
            bits: bool,
        }
        impl RXOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXURR {
            bits: bool,
        }
        impl TXURR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSAR {
            bits: bool,
        }
        impl SSAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSDR {
            bits: bool,
        }
        impl SSDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STALLEDR {
            bits: bool,
        }
        impl STALLEDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENDTRANSFERR {
            bits: bool,
        }
        impl ENDTRANSFERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTIDLER {
            bits: bool,
        }
        impl MSTIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXURW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXURW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STALLEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STALLEDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDTRANSFERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDTRANSFERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTIDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTIDLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT register."]
            #[inline]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 1 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT or TXDATCTL until the data is moved to the transmit shift register."]
            #[inline]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 2 - Receiver Overrun interrupt flag. This flag applies only to slave mode (Master = 0). This flag is set when the beginning of a received character is detected while the receiver buffer is still in use. If this occurs, the receiver buffer contents are preserved, and the incoming data is lost. Data received by the SPI should be considered undefined if RxOv is set."]
            #[inline]
            pub fn rxov(&self) -> RXOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXOVR { bits }
            }
            #[doc = "Bit 3 - Transmitter Underrun interrupt flag. This flag applies only to slave mode (Master = 0). In this case, the transmitter must begin sending new data on the next input clock if the transmitter is idle. If that data is not available in the transmitter holding register at that point, there is no data to transmit and the TXUR flag is set. Data transmitted by the SPI should be considered undefined if TXUR is set."]
            #[inline]
            pub fn txur(&self) -> TXURR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXURR { bits }
            }
            #[doc = "Bit 4 - Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software."]
            #[inline]
            pub fn ssa(&self) -> SSAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSAR { bits }
            }
            #[doc = "Bit 5 - Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software."]
            #[inline]
            pub fn ssd(&self) -> SSDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSDR { bits }
            }
            #[doc = "Bit 6 - Stalled status flag. This indicates whether the SPI is currently in a stall condition."]
            #[inline]
            pub fn stalled(&self) -> STALLEDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STALLEDR { bits }
            }
            #[doc = "Bit 7 - End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOT flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FRAME_DELAY and TRANSFER_DELAY to be inserted."]
            #[inline]
            pub fn endtransfer(&self) -> ENDTRANSFERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENDTRANSFERR { bits }
            }
            #[doc = "Bit 8 - Master idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data."]
            #[inline]
            pub fn mstidle(&self) -> MSTIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTIDLER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0102 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT register."]
            #[inline]
            pub fn rxrdy(&mut self) -> _RXRDYW {
                _RXRDYW { w: self }
            }
            #[doc = "Bit 1 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT or TXDATCTL until the data is moved to the transmit shift register."]
            #[inline]
            pub fn txrdy(&mut self) -> _TXRDYW {
                _TXRDYW { w: self }
            }
            #[doc = "Bit 2 - Receiver Overrun interrupt flag. This flag applies only to slave mode (Master = 0). This flag is set when the beginning of a received character is detected while the receiver buffer is still in use. If this occurs, the receiver buffer contents are preserved, and the incoming data is lost. Data received by the SPI should be considered undefined if RxOv is set."]
            #[inline]
            pub fn rxov(&mut self) -> _RXOVW {
                _RXOVW { w: self }
            }
            #[doc = "Bit 3 - Transmitter Underrun interrupt flag. This flag applies only to slave mode (Master = 0). In this case, the transmitter must begin sending new data on the next input clock if the transmitter is idle. If that data is not available in the transmitter holding register at that point, there is no data to transmit and the TXUR flag is set. Data transmitted by the SPI should be considered undefined if TXUR is set."]
            #[inline]
            pub fn txur(&mut self) -> _TXURW {
                _TXURW { w: self }
            }
            #[doc = "Bit 4 - Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software."]
            #[inline]
            pub fn ssa(&mut self) -> _SSAW {
                _SSAW { w: self }
            }
            #[doc = "Bit 5 - Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software."]
            #[inline]
            pub fn ssd(&mut self) -> _SSDW {
                _SSDW { w: self }
            }
            #[doc = "Bit 6 - Stalled status flag. This indicates whether the SPI is currently in a stall condition."]
            #[inline]
            pub fn stalled(&mut self) -> _STALLEDW {
                _STALLEDW { w: self }
            }
            #[doc = "Bit 7 - End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOT flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FRAME_DELAY and TRANSFER_DELAY to be inserted."]
            #[inline]
            pub fn endtransfer(&mut self) -> _ENDTRANSFERW {
                _ENDTRANSFERW { w: self }
            }
            #[doc = "Bit 8 - Master idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data."]
            #[inline]
            pub fn mstidle(&mut self) -> _MSTIDLEW {
                _MSTIDLEW { w: self }
            }
        }
    }
    #[doc = "SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub struct INTENSET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RXRDYEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXRDYENR {
            #[doc = "No interrupt will be generated when receiver data is available."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when receiver data is available in the RXDAT register."]
            INTERRUPT,
        }
        impl RXRDYENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXRDYENR::NO_INTERRUPT => false,
                    RXRDYENR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXRDYENR {
                match value {
                    false => RXRDYENR::NO_INTERRUPT,
                    true => RXRDYENR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT`"]
            #[inline]
            pub fn is_no_interrupt(&self) -> bool {
                *self == RXRDYENR::NO_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == RXRDYENR::INTERRUPT
            }
        }
        #[doc = "Possible values of the field `TXRDYEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXRDYENR {
            #[doc = "No interrupt will be generated when the transmitter holding register is available."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when data may be written to TXDAT."]
            INTERRUPT,
        }
        impl TXRDYENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXRDYENR::NO_INTERRUPT => false,
                    TXRDYENR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXRDYENR {
                match value {
                    false => TXRDYENR::NO_INTERRUPT,
                    true => TXRDYENR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT`"]
            #[inline]
            pub fn is_no_interrupt(&self) -> bool {
                *self == TXRDYENR::NO_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == TXRDYENR::INTERRUPT
            }
        }
        #[doc = "Possible values of the field `RXOVEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXOVENR {
            #[doc = "No interrupt will be generated when a receiver overrun occurs."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated if a receiver overrun occurs."]
            INTERRUPT,
        }
        impl RXOVENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXOVENR::NO_INTERRUPT => false,
                    RXOVENR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXOVENR {
                match value {
                    false => RXOVENR::NO_INTERRUPT,
                    true => RXOVENR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT`"]
            #[inline]
            pub fn is_no_interrupt(&self) -> bool {
                *self == RXOVENR::NO_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == RXOVENR::INTERRUPT
            }
        }
        #[doc = "Possible values of the field `TXUREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXURENR {
            #[doc = "No interrupt will be generated when the transmitter underruns."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated if the transmitter underruns."]
            INTERRUPT,
        }
        impl TXURENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXURENR::NO_INTERRUPT => false,
                    TXURENR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXURENR {
                match value {
                    false => TXURENR::NO_INTERRUPT,
                    true => TXURENR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT`"]
            #[inline]
            pub fn is_no_interrupt(&self) -> bool {
                *self == TXURENR::NO_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == TXURENR::INTERRUPT
            }
        }
        #[doc = "Possible values of the field `SSAEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSAENR {
            #[doc = "No interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            INTERRUPT,
        }
        impl SSAENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SSAENR::NO_INTERRUPT => false,
                    SSAENR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SSAENR {
                match value {
                    false => SSAENR::NO_INTERRUPT,
                    true => SSAENR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT`"]
            #[inline]
            pub fn is_no_interrupt(&self) -> bool {
                *self == SSAENR::NO_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == SSAENR::INTERRUPT
            }
        }
        #[doc = "Possible values of the field `SSDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSDENR {
            #[doc = "No interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            INTERRUPT,
        }
        impl SSDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SSDENR::NO_INTERRUPT => false,
                    SSDENR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SSDENR {
                match value {
                    false => SSDENR::NO_INTERRUPT,
                    true => SSDENR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT`"]
            #[inline]
            pub fn is_no_interrupt(&self) -> bool {
                *self == SSDENR::NO_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == SSDENR::INTERRUPT
            }
        }
        #[doc = "Values that can be written to the field `RXRDYEN`"]
        pub enum RXRDYENW {
            #[doc = "No interrupt will be generated when receiver data is available."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when receiver data is available in the RXDAT register."]
            INTERRUPT,
        }
        impl RXRDYENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXRDYENW::NO_INTERRUPT => false,
                    RXRDYENW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXRDYENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when receiver data is available."]
            #[inline]
            pub fn no_interrupt(self) -> &'a mut W {
                self.variant(RXRDYENW::NO_INTERRUPT)
            }
            #[doc = "An interrupt will be generated when receiver data is available in the RXDAT register."]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(RXRDYENW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXRDYEN`"]
        pub enum TXRDYENW {
            #[doc = "No interrupt will be generated when the transmitter holding register is available."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when data may be written to TXDAT."]
            INTERRUPT,
        }
        impl TXRDYENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXRDYENW::NO_INTERRUPT => false,
                    TXRDYENW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXRDYENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when the transmitter holding register is available."]
            #[inline]
            pub fn no_interrupt(self) -> &'a mut W {
                self.variant(TXRDYENW::NO_INTERRUPT)
            }
            #[doc = "An interrupt will be generated when data may be written to TXDAT."]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(TXRDYENW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXOVEN`"]
        pub enum RXOVENW {
            #[doc = "No interrupt will be generated when a receiver overrun occurs."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated if a receiver overrun occurs."]
            INTERRUPT,
        }
        impl RXOVENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXOVENW::NO_INTERRUPT => false,
                    RXOVENW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOVENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXOVENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when a receiver overrun occurs."]
            #[inline]
            pub fn no_interrupt(self) -> &'a mut W {
                self.variant(RXOVENW::NO_INTERRUPT)
            }
            #[doc = "An interrupt will be generated if a receiver overrun occurs."]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(RXOVENW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXUREN`"]
        pub enum TXURENW {
            #[doc = "No interrupt will be generated when the transmitter underruns."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated if the transmitter underruns."]
            INTERRUPT,
        }
        impl TXURENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXURENW::NO_INTERRUPT => false,
                    TXURENW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXURENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXURENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXURENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when the transmitter underruns."]
            #[inline]
            pub fn no_interrupt(self) -> &'a mut W {
                self.variant(TXURENW::NO_INTERRUPT)
            }
            #[doc = "An interrupt will be generated if the transmitter underruns."]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(TXURENW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSAEN`"]
        pub enum SSAENW {
            #[doc = "No interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            INTERRUPT,
        }
        impl SSAENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSAENW::NO_INTERRUPT => false,
                    SSAENW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSAENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SSAENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            #[inline]
            pub fn no_interrupt(self) -> &'a mut W {
                self.variant(SSAENW::NO_INTERRUPT)
            }
            #[doc = "An interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(SSAENW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSDEN`"]
        pub enum SSDENW {
            #[doc = "No interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            NO_INTERRUPT,
            #[doc = "An interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            INTERRUPT,
        }
        impl SSDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSDENW::NO_INTERRUPT => false,
                    SSDENW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SSDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            #[inline]
            pub fn no_interrupt(self) -> &'a mut W {
                self.variant(SSDENW::NO_INTERRUPT)
            }
            #[doc = "An interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(SSDENW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Determines whether an interrupt occurs when receiver data is available."]
            #[inline]
            pub fn rxrdyen(&self) -> RXRDYENR {
                RXRDYENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Determines whether an interrupt occurs when the transmitter holding register is available."]
            #[inline]
            pub fn txrdyen(&self) -> TXRDYENR {
                TXRDYENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Determines whether an interrupt occurs when a receiver overrun occurs. This happens in slave mode when there is a need for the receiver to move newly received data to the RXDAT register when it is already in use. The interface prevents receiver overrun in Master mode by not allowing a new transmission to begin when a receiver overrun would otherwise occur."]
            #[inline]
            pub fn rxoven(&self) -> RXOVENR {
                RXOVENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Determines whether an interrupt occurs when a transmitter underrun occurs. This happens in slave mode when there is a need to transmit data when none is available."]
            #[inline]
            pub fn txuren(&self) -> TXURENR {
                TXURENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Determines whether an interrupt occurs when the Slave Select is asserted."]
            #[inline]
            pub fn ssaen(&self) -> SSAENR {
                SSAENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Determines whether an interrupt occurs when the Slave Select is deasserted."]
            #[inline]
            pub fn ssden(&self) -> SSDENR {
                SSDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Determines whether an interrupt occurs when receiver data is available."]
            #[inline]
            pub fn rxrdyen(&mut self) -> _RXRDYENW {
                _RXRDYENW { w: self }
            }
            #[doc = "Bit 1 - Determines whether an interrupt occurs when the transmitter holding register is available."]
            #[inline]
            pub fn txrdyen(&mut self) -> _TXRDYENW {
                _TXRDYENW { w: self }
            }
            #[doc = "Bit 2 - Determines whether an interrupt occurs when a receiver overrun occurs. This happens in slave mode when there is a need for the receiver to move newly received data to the RXDAT register when it is already in use. The interface prevents receiver overrun in Master mode by not allowing a new transmission to begin when a receiver overrun would otherwise occur."]
            #[inline]
            pub fn rxoven(&mut self) -> _RXOVENW {
                _RXOVENW { w: self }
            }
            #[doc = "Bit 3 - Determines whether an interrupt occurs when a transmitter underrun occurs. This happens in slave mode when there is a need to transmit data when none is available."]
            #[inline]
            pub fn txuren(&mut self) -> _TXURENW {
                _TXURENW { w: self }
            }
            #[doc = "Bit 4 - Determines whether an interrupt occurs when the Slave Select is asserted."]
            #[inline]
            pub fn ssaen(&mut self) -> _SSAENW {
                _SSAENW { w: self }
            }
            #[doc = "Bit 5 - Determines whether an interrupt occurs when the Slave Select is deasserted."]
            #[inline]
            pub fn ssden(&mut self) -> _SSDENW {
                _SSDENW { w: self }
            }
        }
    }
    #[doc = "SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared."]
    pub struct INTENCLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared."]
    pub mod intenclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOVENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXURENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXURENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSAENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSDENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline]
            pub fn rxrdyen(&mut self) -> _RXRDYENW {
                _RXRDYENW { w: self }
            }
            #[doc = "Bit 1 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline]
            pub fn txrdyen(&mut self) -> _TXRDYENW {
                _TXRDYENW { w: self }
            }
            #[doc = "Bit 2 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline]
            pub fn rxoven(&mut self) -> _RXOVENW {
                _RXOVENW { w: self }
            }
            #[doc = "Bit 3 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline]
            pub fn txuren(&mut self) -> _TXURENW {
                _TXURENW { w: self }
            }
            #[doc = "Bit 4 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline]
            pub fn ssaen(&mut self) -> _SSAENW {
                _SSAENW { w: self }
            }
            #[doc = "Bit 5 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline]
            pub fn ssden(&mut self) -> _SSDENW {
                _SSDENW { w: self }
            }
        }
    }
    #[doc = "SPI Receive Data"]
    pub struct RXDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Receive Data"]
    pub mod rxdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXDAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDATR {
            bits: u16,
        }
        impl RXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXSSEL0_NR {
            bits: bool,
        }
        impl RXSSEL0_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXSSEL1_NR {
            bits: bool,
        }
        impl RXSSEL1_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXSSEL2_NR {
            bits: bool,
        }
        impl RXSSEL2_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXSSEL3_NR {
            bits: bool,
        }
        impl RXSSEL3_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SOTR {
            bits: bool,
        }
        impl SOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Receiver Data. This contains the next piece of received data. The number of bits that are used depends on the LEN setting in TXCTL / TXDATCTL."]
            #[inline]
            pub fn rxdat(&self) -> RXDATR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RXDATR { bits }
            }
            #[doc = "Bit 16 - Slave Select for receive. This field allows the state of the SSEL0 pin to be saved along with received data. The value will reflect the SSEL0 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG."]
            #[inline]
            pub fn rxssel0_n(&self) -> RXSSEL0_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXSSEL0_NR { bits }
            }
            #[doc = "Bit 17 - Slave Select for receive. This field allows the state of the SSEL1 pin to be saved along with received data. The value will reflect the SSEL1 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG."]
            #[inline]
            pub fn rxssel1_n(&self) -> RXSSEL1_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXSSEL1_NR { bits }
            }
            #[doc = "Bit 18 - Slave Select for receive. This field allows the state of the SSEL2 pin to be saved along with received data. The value will reflect the SSEL2 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG."]
            #[inline]
            pub fn rxssel2_n(&self) -> RXSSEL2_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXSSEL2_NR { bits }
            }
            #[doc = "Bit 19 - Slave Select for receive. This field allows the state of the SSEL3 pin to be saved along with received data. The value will reflect the SSEL3 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG."]
            #[inline]
            pub fn rxssel3_n(&self) -> RXSSEL3_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXSSEL3_NR { bits }
            }
            #[doc = "Bit 20 - Start of Transfer flag. This flag will be 1 if this is the first data after the SSELs went from deasserted to asserted (i.e., any previous transfer has ended). This information can be used to identify the first piece of data in cases where the transfer length is greater than 16 bit."]
            #[inline]
            pub fn sot(&self) -> SOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SOTR { bits }
            }
        }
    }
    #[doc = "SPI Transmit Data with Control"]
    pub struct TXDATCTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Transmit Data with Control"]
    pub mod txdatctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDATCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDATR {
            bits: u16,
        }
        impl TXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TXSSEL0_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXSSEL0_NR {
            #[doc = "SSEL0 asserted."]
            SSEL0_ASSERTED,
            #[doc = "SSEL0 not asserted."]
            SSEL0_NOT_ASSERTED,
        }
        impl TXSSEL0_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXSSEL0_NR::SSEL0_ASSERTED => false,
                    TXSSEL0_NR::SSEL0_NOT_ASSERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXSSEL0_NR {
                match value {
                    false => TXSSEL0_NR::SSEL0_ASSERTED,
                    true => TXSSEL0_NR::SSEL0_NOT_ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `SSEL0_ASSERTED`"]
            #[inline]
            pub fn is_ssel0_asserted(&self) -> bool {
                *self == TXSSEL0_NR::SSEL0_ASSERTED
            }
            #[doc = "Checks if the value of the field is `SSEL0_NOT_ASSERTED`"]
            #[inline]
            pub fn is_ssel0_not_asserted(&self) -> bool {
                *self == TXSSEL0_NR::SSEL0_NOT_ASSERTED
            }
        }
        #[doc = "Possible values of the field `TXSSEL1_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXSSEL1_NR {
            #[doc = "SSEL1 asserted."]
            SSEL1_ASSERTED,
            #[doc = "SSEL1 not asserted."]
            SSEL1_NOT_ASSERTED,
        }
        impl TXSSEL1_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXSSEL1_NR::SSEL1_ASSERTED => false,
                    TXSSEL1_NR::SSEL1_NOT_ASSERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXSSEL1_NR {
                match value {
                    false => TXSSEL1_NR::SSEL1_ASSERTED,
                    true => TXSSEL1_NR::SSEL1_NOT_ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `SSEL1_ASSERTED`"]
            #[inline]
            pub fn is_ssel1_asserted(&self) -> bool {
                *self == TXSSEL1_NR::SSEL1_ASSERTED
            }
            #[doc = "Checks if the value of the field is `SSEL1_NOT_ASSERTED`"]
            #[inline]
            pub fn is_ssel1_not_asserted(&self) -> bool {
                *self == TXSSEL1_NR::SSEL1_NOT_ASSERTED
            }
        }
        #[doc = "Possible values of the field `TXSSEL2_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXSSEL2_NR {
            #[doc = "SSEL2 asserted."]
            SSEL2_ASSERTED,
            #[doc = "SSEL2 not asserted."]
            SSEL2_NOT_ASSERTED,
        }
        impl TXSSEL2_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXSSEL2_NR::SSEL2_ASSERTED => false,
                    TXSSEL2_NR::SSEL2_NOT_ASSERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXSSEL2_NR {
                match value {
                    false => TXSSEL2_NR::SSEL2_ASSERTED,
                    true => TXSSEL2_NR::SSEL2_NOT_ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `SSEL2_ASSERTED`"]
            #[inline]
            pub fn is_ssel2_asserted(&self) -> bool {
                *self == TXSSEL2_NR::SSEL2_ASSERTED
            }
            #[doc = "Checks if the value of the field is `SSEL2_NOT_ASSERTED`"]
            #[inline]
            pub fn is_ssel2_not_asserted(&self) -> bool {
                *self == TXSSEL2_NR::SSEL2_NOT_ASSERTED
            }
        }
        #[doc = "Possible values of the field `TXSSEL3_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXSSEL3_NR {
            #[doc = "SSEL3 asserted."]
            SSEL3_ASSERTED,
            #[doc = "SSEL3 not asserted."]
            SSEL3_NOT_ASSERTED,
        }
        impl TXSSEL3_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXSSEL3_NR::SSEL3_ASSERTED => false,
                    TXSSEL3_NR::SSEL3_NOT_ASSERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXSSEL3_NR {
                match value {
                    false => TXSSEL3_NR::SSEL3_ASSERTED,
                    true => TXSSEL3_NR::SSEL3_NOT_ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `SSEL3_ASSERTED`"]
            #[inline]
            pub fn is_ssel3_asserted(&self) -> bool {
                *self == TXSSEL3_NR::SSEL3_ASSERTED
            }
            #[doc = "Checks if the value of the field is `SSEL3_NOT_ASSERTED`"]
            #[inline]
            pub fn is_ssel3_not_asserted(&self) -> bool {
                *self == TXSSEL3_NR::SSEL3_NOT_ASSERTED
            }
        }
        #[doc = "Possible values of the field `EOT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOTR {
            #[doc = "SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data."]
            SSEL_NOT_DEASSERTED,
            #[doc = "SSEL deasserted. This piece of data is treated as the end of a transfer. SSEL will be deasserted at the end of this piece of data."]
            SSEL_DEASSERTED,
        }
        impl EOTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EOTR::SSEL_NOT_DEASSERTED => false,
                    EOTR::SSEL_DEASSERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EOTR {
                match value {
                    false => EOTR::SSEL_NOT_DEASSERTED,
                    true => EOTR::SSEL_DEASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `SSEL_NOT_DEASSERTED`"]
            #[inline]
            pub fn is_ssel_not_deasserted(&self) -> bool {
                *self == EOTR::SSEL_NOT_DEASSERTED
            }
            #[doc = "Checks if the value of the field is `SSEL_DEASSERTED`"]
            #[inline]
            pub fn is_ssel_deasserted(&self) -> bool {
                *self == EOTR::SSEL_DEASSERTED
            }
        }
        #[doc = "Possible values of the field `EOF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOFR {
            #[doc = "Data not EOF. This piece of data transmitted is not treated as the end of a frame."]
            DATA_NOT_EOF,
            #[doc = "Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted."]
            DATA_EOF,
        }
        impl EOFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EOFR::DATA_NOT_EOF => false,
                    EOFR::DATA_EOF => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EOFR {
                match value {
                    false => EOFR::DATA_NOT_EOF,
                    true => EOFR::DATA_EOF,
                }
            }
            #[doc = "Checks if the value of the field is `DATA_NOT_EOF`"]
            #[inline]
            pub fn is_data_not_eof(&self) -> bool {
                *self == EOFR::DATA_NOT_EOF
            }
            #[doc = "Checks if the value of the field is `DATA_EOF`"]
            #[inline]
            pub fn is_data_eof(&self) -> bool {
                *self == EOFR::DATA_EOF
            }
        }
        #[doc = "Possible values of the field `RXIGNORE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXIGNORER {
            #[doc = "Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received."]
            READ_RECEIVED_DATA,
            #[doc = "Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated."]
            IGNORE_RECEIVED_DATA,
        }
        impl RXIGNORER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXIGNORER::READ_RECEIVED_DATA => false,
                    RXIGNORER::IGNORE_RECEIVED_DATA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXIGNORER {
                match value {
                    false => RXIGNORER::READ_RECEIVED_DATA,
                    true => RXIGNORER::IGNORE_RECEIVED_DATA,
                }
            }
            #[doc = "Checks if the value of the field is `READ_RECEIVED_DATA`"]
            #[inline]
            pub fn is_read_received_data(&self) -> bool {
                *self == RXIGNORER::READ_RECEIVED_DATA
            }
            #[doc = "Checks if the value of the field is `IGNORE_RECEIVED_DATA`"]
            #[inline]
            pub fn is_ignore_received_data(&self) -> bool {
                *self == RXIGNORER::IGNORE_RECEIVED_DATA
            }
        }
        #[doc = r" Value of the field"]
        pub struct LENR {
            bits: u8,
        }
        impl LENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXSSEL0_N`"]
        pub enum TXSSEL0_NW {
            #[doc = "SSEL0 asserted."]
            SSEL0_ASSERTED,
            #[doc = "SSEL0 not asserted."]
            SSEL0_NOT_ASSERTED,
        }
        impl TXSSEL0_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXSSEL0_NW::SSEL0_ASSERTED => false,
                    TXSSEL0_NW::SSEL0_NOT_ASSERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL0_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL0_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXSSEL0_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSEL0 asserted."]
            #[inline]
            pub fn ssel0_asserted(self) -> &'a mut W {
                self.variant(TXSSEL0_NW::SSEL0_ASSERTED)
            }
            #[doc = "SSEL0 not asserted."]
            #[inline]
            pub fn ssel0_not_asserted(self) -> &'a mut W {
                self.variant(TXSSEL0_NW::SSEL0_NOT_ASSERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXSSEL1_N`"]
        pub enum TXSSEL1_NW {
            #[doc = "SSEL1 asserted."]
            SSEL1_ASSERTED,
            #[doc = "SSEL1 not asserted."]
            SSEL1_NOT_ASSERTED,
        }
        impl TXSSEL1_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXSSEL1_NW::SSEL1_ASSERTED => false,
                    TXSSEL1_NW::SSEL1_NOT_ASSERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL1_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL1_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXSSEL1_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSEL1 asserted."]
            #[inline]
            pub fn ssel1_asserted(self) -> &'a mut W {
                self.variant(TXSSEL1_NW::SSEL1_ASSERTED)
            }
            #[doc = "SSEL1 not asserted."]
            #[inline]
            pub fn ssel1_not_asserted(self) -> &'a mut W {
                self.variant(TXSSEL1_NW::SSEL1_NOT_ASSERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXSSEL2_N`"]
        pub enum TXSSEL2_NW {
            #[doc = "SSEL2 asserted."]
            SSEL2_ASSERTED,
            #[doc = "SSEL2 not asserted."]
            SSEL2_NOT_ASSERTED,
        }
        impl TXSSEL2_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXSSEL2_NW::SSEL2_ASSERTED => false,
                    TXSSEL2_NW::SSEL2_NOT_ASSERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL2_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL2_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXSSEL2_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSEL2 asserted."]
            #[inline]
            pub fn ssel2_asserted(self) -> &'a mut W {
                self.variant(TXSSEL2_NW::SSEL2_ASSERTED)
            }
            #[doc = "SSEL2 not asserted."]
            #[inline]
            pub fn ssel2_not_asserted(self) -> &'a mut W {
                self.variant(TXSSEL2_NW::SSEL2_NOT_ASSERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXSSEL3_N`"]
        pub enum TXSSEL3_NW {
            #[doc = "SSEL3 asserted."]
            SSEL3_ASSERTED,
            #[doc = "SSEL3 not asserted."]
            SSEL3_NOT_ASSERTED,
        }
        impl TXSSEL3_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXSSEL3_NW::SSEL3_ASSERTED => false,
                    TXSSEL3_NW::SSEL3_NOT_ASSERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL3_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL3_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXSSEL3_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSEL3 asserted."]
            #[inline]
            pub fn ssel3_asserted(self) -> &'a mut W {
                self.variant(TXSSEL3_NW::SSEL3_ASSERTED)
            }
            #[doc = "SSEL3 not asserted."]
            #[inline]
            pub fn ssel3_not_asserted(self) -> &'a mut W {
                self.variant(TXSSEL3_NW::SSEL3_NOT_ASSERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EOT`"]
        pub enum EOTW {
            #[doc = "SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data."]
            SSEL_NOT_DEASSERTED,
            #[doc = "SSEL deasserted. This piece of data is treated as the end of a transfer. SSEL will be deasserted at the end of this piece of data."]
            SSEL_DEASSERTED,
        }
        impl EOTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EOTW::SSEL_NOT_DEASSERTED => false,
                    EOTW::SSEL_DEASSERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EOTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data."]
            #[inline]
            pub fn ssel_not_deasserted(self) -> &'a mut W {
                self.variant(EOTW::SSEL_NOT_DEASSERTED)
            }
            #[doc = "SSEL deasserted. This piece of data is treated as the end of a transfer. SSEL will be deasserted at the end of this piece of data."]
            #[inline]
            pub fn ssel_deasserted(self) -> &'a mut W {
                self.variant(EOTW::SSEL_DEASSERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EOF`"]
        pub enum EOFW {
            #[doc = "Data not EOF. This piece of data transmitted is not treated as the end of a frame."]
            DATA_NOT_EOF,
            #[doc = "Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted."]
            DATA_EOF,
        }
        impl EOFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EOFW::DATA_NOT_EOF => false,
                    EOFW::DATA_EOF => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EOFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Data not EOF. This piece of data transmitted is not treated as the end of a frame."]
            #[inline]
            pub fn data_not_eof(self) -> &'a mut W {
                self.variant(EOFW::DATA_NOT_EOF)
            }
            #[doc = "Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted."]
            #[inline]
            pub fn data_eof(self) -> &'a mut W {
                self.variant(EOFW::DATA_EOF)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXIGNORE`"]
        pub enum RXIGNOREW {
            #[doc = "Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received."]
            READ_RECEIVED_DATA,
            #[doc = "Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated."]
            IGNORE_RECEIVED_DATA,
        }
        impl RXIGNOREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXIGNOREW::READ_RECEIVED_DATA => false,
                    RXIGNOREW::IGNORE_RECEIVED_DATA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXIGNOREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXIGNOREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXIGNOREW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received."]
            #[inline]
            pub fn read_received_data(self) -> &'a mut W {
                self.variant(RXIGNOREW::READ_RECEIVED_DATA)
            }
            #[doc = "Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated."]
            #[inline]
            pub fn ignore_received_data(self) -> &'a mut W {
                self.variant(RXIGNOREW::IGNORE_RECEIVED_DATA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 1 to 16 bits of data to be transmitted."]
            #[inline]
            pub fn txdat(&self) -> TXDATR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TXDATR { bits }
            }
            #[doc = "Bit 16 - Transmit Slave Select. This field asserts SSEL0 in master mode. The output on the pin is active LOW by default. The active state of the SSEL0 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel0_n(&self) -> TXSSEL0_NR {
                TXSSEL0_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Transmit Slave Select. This field asserts SSEL1 in master mode. The output on the pin is active LOW by default. The active state of the SSEL1 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel1_n(&self) -> TXSSEL1_NR {
                TXSSEL1_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Transmit Slave Select. This field asserts SSEL2 in master mode. The output on the pin is active LOW by default. The active state of the SSEL2 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel2_n(&self) -> TXSSEL2_NR {
                TXSSEL2_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Transmit Slave Select. This field asserts SSEL3 in master mode. The output on the pin is active LOW by default. The active state of the SSEL3 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel3_n(&self) -> TXSSEL3_NR {
                TXSSEL3_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - End of Transfer. The asserted SSEL will be deasserted at the end of a transfer, and remain so for at least the time specified by the Transfer_delay value in the DLY register."]
            #[inline]
            pub fn eot(&self) -> EOTR {
                EOTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - End of Frame. Between frames, a delay may be inserted, as defined by the FRAME_DELAY value in the DLY register. The end of a frame may not be particularly meaningful if the FRAME_DELAY value = 0. This control can be used as part of the support for frame lengths greater than 16 bits."]
            #[inline]
            pub fn eof(&self) -> EOFR {
                EOFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver.Setting this bit simplifies the transmit process and can be used with the DMA."]
            #[inline]
            pub fn rxignore(&self) -> RXIGNORER {
                RXIGNORER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 24:27 - Data Length. Specifies the data length from 1 to 16 bits. Note that transfer lengths greater than 16 bits are supported by implementing multiple sequential transmits. 0x0 = Data transfer is 1 bit in length. 0x1 = Data transfer is 2 bits in length. 0x2 = Data transfer is 3 bits in length. ... 0xF = Data transfer is 16 bits in length."]
            #[inline]
            pub fn len(&self) -> LENR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 1 to 16 bits of data to be transmitted."]
            #[inline]
            pub fn txdat(&mut self) -> _TXDATW {
                _TXDATW { w: self }
            }
            #[doc = "Bit 16 - Transmit Slave Select. This field asserts SSEL0 in master mode. The output on the pin is active LOW by default. The active state of the SSEL0 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel0_n(&mut self) -> _TXSSEL0_NW {
                _TXSSEL0_NW { w: self }
            }
            #[doc = "Bit 17 - Transmit Slave Select. This field asserts SSEL1 in master mode. The output on the pin is active LOW by default. The active state of the SSEL1 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel1_n(&mut self) -> _TXSSEL1_NW {
                _TXSSEL1_NW { w: self }
            }
            #[doc = "Bit 18 - Transmit Slave Select. This field asserts SSEL2 in master mode. The output on the pin is active LOW by default. The active state of the SSEL2 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel2_n(&mut self) -> _TXSSEL2_NW {
                _TXSSEL2_NW { w: self }
            }
            #[doc = "Bit 19 - Transmit Slave Select. This field asserts SSEL3 in master mode. The output on the pin is active LOW by default. The active state of the SSEL3 pin is configured by bits in the CFG register."]
            #[inline]
            pub fn txssel3_n(&mut self) -> _TXSSEL3_NW {
                _TXSSEL3_NW { w: self }
            }
            #[doc = "Bit 20 - End of Transfer. The asserted SSEL will be deasserted at the end of a transfer, and remain so for at least the time specified by the Transfer_delay value in the DLY register."]
            #[inline]
            pub fn eot(&mut self) -> _EOTW {
                _EOTW { w: self }
            }
            #[doc = "Bit 21 - End of Frame. Between frames, a delay may be inserted, as defined by the FRAME_DELAY value in the DLY register. The end of a frame may not be particularly meaningful if the FRAME_DELAY value = 0. This control can be used as part of the support for frame lengths greater than 16 bits."]
            #[inline]
            pub fn eof(&mut self) -> _EOFW {
                _EOFW { w: self }
            }
            #[doc = "Bit 22 - Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver.Setting this bit simplifies the transmit process and can be used with the DMA."]
            #[inline]
            pub fn rxignore(&mut self) -> _RXIGNOREW {
                _RXIGNOREW { w: self }
            }
            #[doc = "Bits 24:27 - Data Length. Specifies the data length from 1 to 16 bits. Note that transfer lengths greater than 16 bits are supported by implementing multiple sequential transmits. 0x0 = Data transfer is 1 bit in length. 0x1 = Data transfer is 2 bits in length. 0x2 = Data transfer is 3 bits in length. ... 0xF = Data transfer is 16 bits in length."]
            #[inline]
            pub fn len(&mut self) -> _LENW {
                _LENW { w: self }
            }
        }
    }
    #[doc = "SPI Transmit Data"]
    pub struct TXDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Transmit Data"]
    pub mod txdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u16,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 4 to 16 bits of data to be transmitted."]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 4 to 16 bits of data to be transmitted."]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "SPI Transmit Control"]
    pub struct TXCTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Transmit Control"]
    pub mod txctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXSSEL0_NR {
            bits: bool,
        }
        impl TXSSEL0_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXSSEL1_NR {
            bits: bool,
        }
        impl TXSSEL1_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXSSEL2_NR {
            bits: bool,
        }
        impl TXSSEL2_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXSSEL3_NR {
            bits: bool,
        }
        impl TXSSEL3_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOTR {
            bits: bool,
        }
        impl EOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOFR {
            bits: bool,
        }
        impl EOFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXIGNORER {
            bits: bool,
        }
        impl RXIGNORER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LENR {
            bits: u8,
        }
        impl LENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL0_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL0_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL1_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL1_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL2_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL2_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSEL3_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSEL3_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXIGNOREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXIGNOREW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 16 - Transmit Slave Select 0."]
            #[inline]
            pub fn txssel0_n(&self) -> TXSSEL0_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXSSEL0_NR { bits }
            }
            #[doc = "Bit 17 - Transmit Slave Select 1."]
            #[inline]
            pub fn txssel1_n(&self) -> TXSSEL1_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXSSEL1_NR { bits }
            }
            #[doc = "Bit 18 - Transmit Slave Select 2."]
            #[inline]
            pub fn txssel2_n(&self) -> TXSSEL2_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXSSEL2_NR { bits }
            }
            #[doc = "Bit 19 - Transmit Slave Select 3."]
            #[inline]
            pub fn txssel3_n(&self) -> TXSSEL3_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXSSEL3_NR { bits }
            }
            #[doc = "Bit 20 - End of Transfer."]
            #[inline]
            pub fn eot(&self) -> EOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOTR { bits }
            }
            #[doc = "Bit 21 - End of Frame."]
            #[inline]
            pub fn eof(&self) -> EOFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOFR { bits }
            }
            #[doc = "Bit 22 - Receive Ignore."]
            #[inline]
            pub fn rxignore(&self) -> RXIGNORER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXIGNORER { bits }
            }
            #[doc = "Bits 24:27 - Data transfer Length."]
            #[inline]
            pub fn len(&self) -> LENR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 16 - Transmit Slave Select 0."]
            #[inline]
            pub fn txssel0_n(&mut self) -> _TXSSEL0_NW {
                _TXSSEL0_NW { w: self }
            }
            #[doc = "Bit 17 - Transmit Slave Select 1."]
            #[inline]
            pub fn txssel1_n(&mut self) -> _TXSSEL1_NW {
                _TXSSEL1_NW { w: self }
            }
            #[doc = "Bit 18 - Transmit Slave Select 2."]
            #[inline]
            pub fn txssel2_n(&mut self) -> _TXSSEL2_NW {
                _TXSSEL2_NW { w: self }
            }
            #[doc = "Bit 19 - Transmit Slave Select 3."]
            #[inline]
            pub fn txssel3_n(&mut self) -> _TXSSEL3_NW {
                _TXSSEL3_NW { w: self }
            }
            #[doc = "Bit 20 - End of Transfer."]
            #[inline]
            pub fn eot(&mut self) -> _EOTW {
                _EOTW { w: self }
            }
            #[doc = "Bit 21 - End of Frame."]
            #[inline]
            pub fn eof(&mut self) -> _EOFW {
                _EOFW { w: self }
            }
            #[doc = "Bit 22 - Receive Ignore."]
            #[inline]
            pub fn rxignore(&mut self) -> _RXIGNOREW {
                _RXIGNOREW { w: self }
            }
            #[doc = "Bits 24:27 - Data transfer Length."]
            #[inline]
            pub fn len(&mut self) -> _LENW {
                _LENW { w: self }
            }
        }
    }
    #[doc = "SPI clock Divider"]
    pub struct DIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI clock Divider"]
    pub mod div {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVVALR {
            bits: u16,
        }
        impl DIVVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Rate divider value. Specifies how the PCLK for the SPI is divided to produce the SPI clock rate in master mode. DIVVAL is -1 encoded such that the value 0 results in PCLK/1, the value 1 results in PCLK/2, up to the maximum possible divide value of 0xFFFF, which results in PCLK/65536."]
            #[inline]
            pub fn divval(&self) -> DIVVALR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Rate divider value. Specifies how the PCLK for the SPI is divided to produce the SPI clock rate in master mode. DIVVAL is -1 encoded such that the value 0 results in PCLK/1, the value 1 results in PCLK/2, up to the maximum possible divide value of 0xFFFF, which results in PCLK/65536."]
            #[inline]
            pub fn divval(&mut self) -> _DIVVALW {
                _DIVVALW { w: self }
            }
        }
    }
    #[doc = "SPI Interrupt Status"]
    pub struct INTSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Interrupt Status"]
    pub mod intstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOVR {
            bits: bool,
        }
        impl RXOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXURR {
            bits: bool,
        }
        impl TXURR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSAR {
            bits: bool,
        }
        impl SSAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSDR {
            bits: bool,
        }
        impl SSDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag."]
            #[inline]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 1 - Transmitter Ready flag."]
            #[inline]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 2 - Receiver Overrun interrupt flag."]
            #[inline]
            pub fn rxov(&self) -> RXOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXOVR { bits }
            }
            #[doc = "Bit 3 - Transmitter Underrun interrupt flag."]
            #[inline]
            pub fn txur(&self) -> TXURR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXURR { bits }
            }
            #[doc = "Bit 4 - Slave Select Assert."]
            #[inline]
            pub fn ssa(&self) -> SSAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSAR { bits }
            }
            #[doc = "Bit 5 - Slave Select Deassert."]
            #[inline]
            pub fn ssd(&self) -> SSDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSDR { bits }
            }
        }
    }
}
#[doc = "SPI1"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi0::RegisterBlock {
        0x4005_c000 as *const _
    }
}
impl Deref for SPI1 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        unsafe { &*SPI1::ptr() }
    }
}
#[doc = "USART0"]
pub struct USART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART0 {}
impl USART0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const usart0::RegisterBlock {
        0x4006_4000 as *const _
    }
}
impl Deref for USART0 {
    type Target = usart0::RegisterBlock;
    fn deref(&self) -> &usart0::RegisterBlock {
        unsafe { &*USART0::ptr() }
    }
}
#[doc = "USART0"]
pub mod usart0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - USART Configuration register. Basic USART configuration settings that typically are not changed during operation."]
        pub cfg: CFG,
        #[doc = "0x04 - USART Control register. USART control settings that are more likely to change during operation."]
        pub ctl: CTL,
        #[doc = "0x08 - USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them."]
        pub stat: STAT,
        #[doc = "0x0c - Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
        pub intenset: INTENSET,
        #[doc = "0x10 - Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared."]
        pub intenclr: INTENCLR,
        #[doc = "0x14 - Receiver Data register. Contains the last character received."]
        pub rxdat: RXDAT,
        #[doc = "0x18 - Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together."]
        pub rxdatstat: RXDATSTAT,
        #[doc = "0x1c - Transmit Data register. Data to be transmitted is written here."]
        pub txdat: TXDAT,
        #[doc = "0x20 - Baud Rate Generator register. 16-bit integer baud rate divisor value."]
        pub brg: BRG,
        #[doc = "0x24 - Interrupt status register. Reflects interrupts that are currently enabled."]
        pub intstat: INTSTAT,
        #[doc = "0x28 - Oversample selection register for asynchronous communication."]
        pub osr: OSR,
        #[doc = "0x2c - Address register for automatic address matching."]
        pub addr: ADDR,
    }
    #[doc = "USART Configuration register. Basic USART configuration settings that typically are not changed during operation."]
    pub struct CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USART Configuration register. Basic USART configuration settings that typically are not changed during operation."]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt (if  enabled in the INTENSET register) or a DMA transfer request because the transmitter has been reset and is therefore available."]
            DISABLED,
            #[doc = "Enabled. The USART is enabled for operation."]
            ENABLED,
        }
        impl ENABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENABLER::DISABLED => false,
                    ENABLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENABLER {
                match value {
                    false => ENABLER::DISABLED,
                    true => ENABLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Possible values of the field `DATALEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATALENR {
            #[doc = "7 bit Data length."]
            _7_BIT_DATA_LENGTH,
            #[doc = "8 bit Data length."]
            _8_BIT_DATA_LENGTH,
            #[doc = "9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register."]
            _9_BIT_DATA_LENGTH,
        }
        impl DATALENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DATALENR::_7_BIT_DATA_LENGTH => 0,
                    DATALENR::_8_BIT_DATA_LENGTH => 0x01,
                    DATALENR::_9_BIT_DATA_LENGTH => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DATALENR {
                match value {
                    0 => DATALENR::_7_BIT_DATA_LENGTH,
                    1 => DATALENR::_8_BIT_DATA_LENGTH,
                    2 => DATALENR::_9_BIT_DATA_LENGTH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_7_BIT_DATA_LENGTH`"]
            #[inline]
            pub fn is_7_bit_data_length(&self) -> bool {
                *self == DATALENR::_7_BIT_DATA_LENGTH
            }
            #[doc = "Checks if the value of the field is `_8_BIT_DATA_LENGTH`"]
            #[inline]
            pub fn is_8_bit_data_length(&self) -> bool {
                *self == DATALENR::_8_BIT_DATA_LENGTH
            }
            #[doc = "Checks if the value of the field is `_9_BIT_DATA_LENGTH`"]
            #[inline]
            pub fn is_9_bit_data_length(&self) -> bool {
                *self == DATALENR::_9_BIT_DATA_LENGTH
            }
        }
        #[doc = "Possible values of the field `PARITYSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PARITYSELR {
            #[doc = "No parity."]
            NO_PARITY,
            #[doc = "Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even."]
            EVEN_PARITY,
            #[doc = "Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd."]
            ODD_PARITY,
        }
        impl PARITYSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PARITYSELR::NO_PARITY => 0,
                    PARITYSELR::EVEN_PARITY => 0x02,
                    PARITYSELR::ODD_PARITY => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PARITYSELR {
                match value {
                    0 => PARITYSELR::NO_PARITY,
                    2 => PARITYSELR::EVEN_PARITY,
                    3 => PARITYSELR::ODD_PARITY,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_PARITY`"]
            #[inline]
            pub fn is_no_parity(&self) -> bool {
                *self == PARITYSELR::NO_PARITY
            }
            #[doc = "Checks if the value of the field is `EVEN_PARITY`"]
            #[inline]
            pub fn is_even_parity(&self) -> bool {
                *self == PARITYSELR::EVEN_PARITY
            }
            #[doc = "Checks if the value of the field is `ODD_PARITY`"]
            #[inline]
            pub fn is_odd_parity(&self) -> bool {
                *self == PARITYSELR::ODD_PARITY
            }
        }
        #[doc = "Possible values of the field `STOPLEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPLENR {
            #[doc = "1 stop bit."]
            _1_STOP_BIT,
            #[doc = "2 stop bits. This setting should only be used for asynchronous communication."]
            _2_STOP_BITS,
        }
        impl STOPLENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPLENR::_1_STOP_BIT => false,
                    STOPLENR::_2_STOP_BITS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STOPLENR {
                match value {
                    false => STOPLENR::_1_STOP_BIT,
                    true => STOPLENR::_2_STOP_BITS,
                }
            }
            #[doc = "Checks if the value of the field is `_1_STOP_BIT`"]
            #[inline]
            pub fn is_1_stop_bit(&self) -> bool {
                *self == STOPLENR::_1_STOP_BIT
            }
            #[doc = "Checks if the value of the field is `_2_STOP_BITS`"]
            #[inline]
            pub fn is_2_stop_bits(&self) -> bool {
                *self == STOPLENR::_2_STOP_BITS
            }
        }
        #[doc = "Possible values of the field `CTSEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSENR {
            #[doc = "No flow control. The transmitter does not receive any automatic flow control signal."]
            NO_FLOW_CONTROL,
            #[doc = "Flow control enabled. The transmitter uses  the CTS input (or RTS output in loopback mode) for flow control purposes."]
            FLOW_CONTROL_ENABLED,
        }
        impl CTSENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CTSENR::NO_FLOW_CONTROL => false,
                    CTSENR::FLOW_CONTROL_ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CTSENR {
                match value {
                    false => CTSENR::NO_FLOW_CONTROL,
                    true => CTSENR::FLOW_CONTROL_ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_FLOW_CONTROL`"]
            #[inline]
            pub fn is_no_flow_control(&self) -> bool {
                *self == CTSENR::NO_FLOW_CONTROL
            }
            #[doc = "Checks if the value of the field is `FLOW_CONTROL_ENABLED`"]
            #[inline]
            pub fn is_flow_control_enabled(&self) -> bool {
                *self == CTSENR::FLOW_CONTROL_ENABLED
            }
        }
        #[doc = "Possible values of the field `SYNCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYNCENR {
            #[doc = "Asynchronous mode is selected."]
            ASYNCHRONOUS_MODE_IS,
            #[doc = "Synchronous mode is selected."]
            SYNCHRONOUS_MODE_IS,
        }
        impl SYNCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYNCENR::ASYNCHRONOUS_MODE_IS => false,
                    SYNCENR::SYNCHRONOUS_MODE_IS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYNCENR {
                match value {
                    false => SYNCENR::ASYNCHRONOUS_MODE_IS,
                    true => SYNCENR::SYNCHRONOUS_MODE_IS,
                }
            }
            #[doc = "Checks if the value of the field is `ASYNCHRONOUS_MODE_IS`"]
            #[inline]
            pub fn is_asynchronous_mode_is(&self) -> bool {
                *self == SYNCENR::ASYNCHRONOUS_MODE_IS
            }
            #[doc = "Checks if the value of the field is `SYNCHRONOUS_MODE_IS`"]
            #[inline]
            pub fn is_synchronous_mode_is(&self) -> bool {
                *self == SYNCENR::SYNCHRONOUS_MODE_IS
            }
        }
        #[doc = "Possible values of the field `CLKPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKPOLR {
            #[doc = "Falling edge. Un_RXD is sampled on the falling edge of SCLK."]
            FALLING_EDGE,
            #[doc = "Rising edge. Un_RXD is sampled on the rising edge of SCLK."]
            RISING_EDGE,
        }
        impl CLKPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CLKPOLR::FALLING_EDGE => false,
                    CLKPOLR::RISING_EDGE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CLKPOLR {
                match value {
                    false => CLKPOLR::FALLING_EDGE,
                    true => CLKPOLR::RISING_EDGE,
                }
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE`"]
            #[inline]
            pub fn is_falling_edge(&self) -> bool {
                *self == CLKPOLR::FALLING_EDGE
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE`"]
            #[inline]
            pub fn is_rising_edge(&self) -> bool {
                *self == CLKPOLR::RISING_EDGE
            }
        }
        #[doc = "Possible values of the field `SYNCMST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYNCMSTR {
            #[doc = "Slave. When synchronous mode is enabled, the USART is a slave."]
            SLAVE,
            #[doc = "Master. When synchronous mode is enabled, the USART is a master."]
            MASTER,
        }
        impl SYNCMSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYNCMSTR::SLAVE => false,
                    SYNCMSTR::MASTER => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYNCMSTR {
                match value {
                    false => SYNCMSTR::SLAVE,
                    true => SYNCMSTR::MASTER,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE`"]
            #[inline]
            pub fn is_slave(&self) -> bool {
                *self == SYNCMSTR::SLAVE
            }
            #[doc = "Checks if the value of the field is `MASTER`"]
            #[inline]
            pub fn is_master(&self) -> bool {
                *self == SYNCMSTR::MASTER
            }
        }
        #[doc = "Possible values of the field `LOOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOOPR {
            #[doc = "Normal operation."]
            NORMAL_OPERATION,
            #[doc = "Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN."]
            LOOPBACK_MODE,
        }
        impl LOOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOOPR::NORMAL_OPERATION => false,
                    LOOPR::LOOPBACK_MODE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOOPR {
                match value {
                    false => LOOPR::NORMAL_OPERATION,
                    true => LOOPR::LOOPBACK_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
            #[inline]
            pub fn is_normal_operation(&self) -> bool {
                *self == LOOPR::NORMAL_OPERATION
            }
            #[doc = "Checks if the value of the field is `LOOPBACK_MODE`"]
            #[inline]
            pub fn is_loopback_mode(&self) -> bool {
                *self == LOOPR::LOOPBACK_MODE
            }
        }
        #[doc = "Possible values of the field `OETA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OETAR {
            #[doc = "Deasserted. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission."]
            DEASSERTED,
            #[doc = "Asserted. If selected by OESEL, the Output Enable signal remains asserted for 1 character time after then end the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted."]
            ASSERTED,
        }
        impl OETAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OETAR::DEASSERTED => false,
                    OETAR::ASSERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OETAR {
                match value {
                    false => OETAR::DEASSERTED,
                    true => OETAR::ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `DEASSERTED`"]
            #[inline]
            pub fn is_deasserted(&self) -> bool {
                *self == OETAR::DEASSERTED
            }
            #[doc = "Checks if the value of the field is `ASSERTED`"]
            #[inline]
            pub fn is_asserted(&self) -> bool {
                *self == OETAR::ASSERTED
            }
        }
        #[doc = "Possible values of the field `AUTOADDR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AUTOADDRR {
            #[doc = "Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address)."]
            DISABLED,
            #[doc = "Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match."]
            ENABLED,
        }
        impl AUTOADDRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    AUTOADDRR::DISABLED => false,
                    AUTOADDRR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> AUTOADDRR {
                match value {
                    false => AUTOADDRR::DISABLED,
                    true => AUTOADDRR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == AUTOADDRR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == AUTOADDRR::ENABLED
            }
        }
        #[doc = "Possible values of the field `OESEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OESELR {
            #[doc = "Flow control. The RTS signal is used as the standard flow control function."]
            FLOW_CONTROL,
            #[doc = "Output enable. The RTS signal is taken over in order to provide an output enable signal to control an RS-485 transceiver."]
            OUTPUT_ENABLE,
        }
        impl OESELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OESELR::FLOW_CONTROL => false,
                    OESELR::OUTPUT_ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OESELR {
                match value {
                    false => OESELR::FLOW_CONTROL,
                    true => OESELR::OUTPUT_ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `FLOW_CONTROL`"]
            #[inline]
            pub fn is_flow_control(&self) -> bool {
                *self == OESELR::FLOW_CONTROL
            }
            #[doc = "Checks if the value of the field is `OUTPUT_ENABLE`"]
            #[inline]
            pub fn is_output_enable(&self) -> bool {
                *self == OESELR::OUTPUT_ENABLE
            }
        }
        #[doc = "Possible values of the field `OEPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OEPOLR {
            #[doc = "Low. If selected by OESEL, the output enable is active low."]
            LOW,
            #[doc = "High. If selected by OESEL, the output enable is active high."]
            HIGH,
        }
        impl OEPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OEPOLR::LOW => false,
                    OEPOLR::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OEPOLR {
                match value {
                    false => OEPOLR::LOW,
                    true => OEPOLR::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == OEPOLR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == OEPOLR::HIGH
            }
        }
        #[doc = "Possible values of the field `RXPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXPOLR {
            #[doc = "Not changed. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1."]
            NOT_CHANGED,
            #[doc = "Inverted. The RX signal is inverted before being used by the UART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0."]
            INVERTED,
        }
        impl RXPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXPOLR::NOT_CHANGED => false,
                    RXPOLR::INVERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXPOLR {
                match value {
                    false => RXPOLR::NOT_CHANGED,
                    true => RXPOLR::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_CHANGED`"]
            #[inline]
            pub fn is_not_changed(&self) -> bool {
                *self == RXPOLR::NOT_CHANGED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline]
            pub fn is_inverted(&self) -> bool {
                *self == RXPOLR::INVERTED
            }
        }
        #[doc = "Possible values of the field `TXPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXPOLR {
            #[doc = "Not changed. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1."]
            NOT_CHANGED,
            #[doc = "Inverted. The TX signal is inverted by the UART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0."]
            INVERTED,
        }
        impl TXPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXPOLR::NOT_CHANGED => false,
                    TXPOLR::INVERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXPOLR {
                match value {
                    false => TXPOLR::NOT_CHANGED,
                    true => TXPOLR::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_CHANGED`"]
            #[inline]
            pub fn is_not_changed(&self) -> bool {
                *self == TXPOLR::NOT_CHANGED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline]
            pub fn is_inverted(&self) -> bool {
                *self == TXPOLR::INVERTED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt (if  enabled in the INTENSET register) or a DMA transfer request because the transmitter has been reset and is therefore available."]
            DISABLED,
            #[doc = "Enabled. The USART is enabled for operation."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENABLEW::DISABLED => false,
                    ENABLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt (if enabled in the INTENSET register) or a DMA transfer request because the transmitter has been reset and is therefore available."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enabled. The USART is enabled for operation."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DATALEN`"]
        pub enum DATALENW {
            #[doc = "7 bit Data length."]
            _7_BIT_DATA_LENGTH,
            #[doc = "8 bit Data length."]
            _8_BIT_DATA_LENGTH,
            #[doc = "9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register."]
            _9_BIT_DATA_LENGTH,
        }
        impl DATALENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DATALENW::_7_BIT_DATA_LENGTH => 0,
                    DATALENW::_8_BIT_DATA_LENGTH => 1,
                    DATALENW::_9_BIT_DATA_LENGTH => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATALENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATALENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DATALENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "7 bit Data length."]
            #[inline]
            pub fn _7_bit_data_length(self) -> &'a mut W {
                self.variant(DATALENW::_7_BIT_DATA_LENGTH)
            }
            #[doc = "8 bit Data length."]
            #[inline]
            pub fn _8_bit_data_length(self) -> &'a mut W {
                self.variant(DATALENW::_8_BIT_DATA_LENGTH)
            }
            #[doc = "9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register."]
            #[inline]
            pub fn _9_bit_data_length(self) -> &'a mut W {
                self.variant(DATALENW::_9_BIT_DATA_LENGTH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PARITYSEL`"]
        pub enum PARITYSELW {
            #[doc = "No parity."]
            NO_PARITY,
            #[doc = "Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even."]
            EVEN_PARITY,
            #[doc = "Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd."]
            ODD_PARITY,
        }
        impl PARITYSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PARITYSELW::NO_PARITY => 0,
                    PARITYSELW::EVEN_PARITY => 2,
                    PARITYSELW::ODD_PARITY => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PARITYSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No parity."]
            #[inline]
            pub fn no_parity(self) -> &'a mut W {
                self.variant(PARITYSELW::NO_PARITY)
            }
            #[doc = "Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even."]
            #[inline]
            pub fn even_parity(self) -> &'a mut W {
                self.variant(PARITYSELW::EVEN_PARITY)
            }
            #[doc = "Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd."]
            #[inline]
            pub fn odd_parity(self) -> &'a mut W {
                self.variant(PARITYSELW::ODD_PARITY)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STOPLEN`"]
        pub enum STOPLENW {
            #[doc = "1 stop bit."]
            _1_STOP_BIT,
            #[doc = "2 stop bits. This setting should only be used for asynchronous communication."]
            _2_STOP_BITS,
        }
        impl STOPLENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STOPLENW::_1_STOP_BIT => false,
                    STOPLENW::_2_STOP_BITS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPLENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STOPLENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "1 stop bit."]
            #[inline]
            pub fn _1_stop_bit(self) -> &'a mut W {
                self.variant(STOPLENW::_1_STOP_BIT)
            }
            #[doc = "2 stop bits. This setting should only be used for asynchronous communication."]
            #[inline]
            pub fn _2_stop_bits(self) -> &'a mut W {
                self.variant(STOPLENW::_2_STOP_BITS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTSEN`"]
        pub enum CTSENW {
            #[doc = "No flow control. The transmitter does not receive any automatic flow control signal."]
            NO_FLOW_CONTROL,
            #[doc = "Flow control enabled. The transmitter uses  the CTS input (or RTS output in loopback mode) for flow control purposes."]
            FLOW_CONTROL_ENABLED,
        }
        impl CTSENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTSENW::NO_FLOW_CONTROL => false,
                    CTSENW::FLOW_CONTROL_ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTSENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No flow control. The transmitter does not receive any automatic flow control signal."]
            #[inline]
            pub fn no_flow_control(self) -> &'a mut W {
                self.variant(CTSENW::NO_FLOW_CONTROL)
            }
            #[doc = "Flow control enabled. The transmitter uses the CTS input (or RTS output in loopback mode) for flow control purposes."]
            #[inline]
            pub fn flow_control_enabled(self) -> &'a mut W {
                self.variant(CTSENW::FLOW_CONTROL_ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYNCEN`"]
        pub enum SYNCENW {
            #[doc = "Asynchronous mode is selected."]
            ASYNCHRONOUS_MODE_IS,
            #[doc = "Synchronous mode is selected."]
            SYNCHRONOUS_MODE_IS,
        }
        impl SYNCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYNCENW::ASYNCHRONOUS_MODE_IS => false,
                    SYNCENW::SYNCHRONOUS_MODE_IS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYNCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Asynchronous mode is selected."]
            #[inline]
            pub fn asynchronous_mode_is(self) -> &'a mut W {
                self.variant(SYNCENW::ASYNCHRONOUS_MODE_IS)
            }
            #[doc = "Synchronous mode is selected."]
            #[inline]
            pub fn synchronous_mode_is(self) -> &'a mut W {
                self.variant(SYNCENW::SYNCHRONOUS_MODE_IS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKPOL`"]
        pub enum CLKPOLW {
            #[doc = "Falling edge. Un_RXD is sampled on the falling edge of SCLK."]
            FALLING_EDGE,
            #[doc = "Rising edge. Un_RXD is sampled on the rising edge of SCLK."]
            RISING_EDGE,
        }
        impl CLKPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLKPOLW::FALLING_EDGE => false,
                    CLKPOLW::RISING_EDGE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLKPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Falling edge. Un_RXD is sampled on the falling edge of SCLK."]
            #[inline]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CLKPOLW::FALLING_EDGE)
            }
            #[doc = "Rising edge. Un_RXD is sampled on the rising edge of SCLK."]
            #[inline]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CLKPOLW::RISING_EDGE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYNCMST`"]
        pub enum SYNCMSTW {
            #[doc = "Slave. When synchronous mode is enabled, the USART is a slave."]
            SLAVE,
            #[doc = "Master. When synchronous mode is enabled, the USART is a master."]
            MASTER,
        }
        impl SYNCMSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYNCMSTW::SLAVE => false,
                    SYNCMSTW::MASTER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCMSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCMSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYNCMSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Slave. When synchronous mode is enabled, the USART is a slave."]
            #[inline]
            pub fn slave(self) -> &'a mut W {
                self.variant(SYNCMSTW::SLAVE)
            }
            #[doc = "Master. When synchronous mode is enabled, the USART is a master."]
            #[inline]
            pub fn master(self) -> &'a mut W {
                self.variant(SYNCMSTW::MASTER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOOP`"]
        pub enum LOOPW {
            #[doc = "Normal operation."]
            NORMAL_OPERATION,
            #[doc = "Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN."]
            LOOPBACK_MODE,
        }
        impl LOOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOOPW::NORMAL_OPERATION => false,
                    LOOPW::LOOPBACK_MODE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LOOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Normal operation."]
            #[inline]
            pub fn normal_operation(self) -> &'a mut W {
                self.variant(LOOPW::NORMAL_OPERATION)
            }
            #[doc = "Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN."]
            #[inline]
            pub fn loopback_mode(self) -> &'a mut W {
                self.variant(LOOPW::LOOPBACK_MODE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OETA`"]
        pub enum OETAW {
            #[doc = "Deasserted. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission."]
            DEASSERTED,
            #[doc = "Asserted. If selected by OESEL, the Output Enable signal remains asserted for 1 character time after then end the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted."]
            ASSERTED,
        }
        impl OETAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OETAW::DEASSERTED => false,
                    OETAW::ASSERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OETAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OETAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OETAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Deasserted. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission."]
            #[inline]
            pub fn deasserted(self) -> &'a mut W {
                self.variant(OETAW::DEASSERTED)
            }
            #[doc = "Asserted. If selected by OESEL, the Output Enable signal remains asserted for 1 character time after then end the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted."]
            #[inline]
            pub fn asserted(self) -> &'a mut W {
                self.variant(OETAW::ASSERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `AUTOADDR`"]
        pub enum AUTOADDRW {
            #[doc = "Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address)."]
            DISABLED,
            #[doc = "Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match."]
            ENABLED,
        }
        impl AUTOADDRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    AUTOADDRW::DISABLED => false,
                    AUTOADDRW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOADDRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AUTOADDRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address)."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AUTOADDRW::DISABLED)
            }
            #[doc = "Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AUTOADDRW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OESEL`"]
        pub enum OESELW {
            #[doc = "Flow control. The RTS signal is used as the standard flow control function."]
            FLOW_CONTROL,
            #[doc = "Output enable. The RTS signal is taken over in order to provide an output enable signal to control an RS-485 transceiver."]
            OUTPUT_ENABLE,
        }
        impl OESELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OESELW::FLOW_CONTROL => false,
                    OESELW::OUTPUT_ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OESELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OESELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OESELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Flow control. The RTS signal is used as the standard flow control function."]
            #[inline]
            pub fn flow_control(self) -> &'a mut W {
                self.variant(OESELW::FLOW_CONTROL)
            }
            #[doc = "Output enable. The RTS signal is taken over in order to provide an output enable signal to control an RS-485 transceiver."]
            #[inline]
            pub fn output_enable(self) -> &'a mut W {
                self.variant(OESELW::OUTPUT_ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OEPOL`"]
        pub enum OEPOLW {
            #[doc = "Low. If selected by OESEL, the output enable is active low."]
            LOW,
            #[doc = "High. If selected by OESEL, the output enable is active high."]
            HIGH,
        }
        impl OEPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OEPOLW::LOW => false,
                    OEPOLW::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OEPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OEPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OEPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. If selected by OESEL, the output enable is active low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(OEPOLW::LOW)
            }
            #[doc = "High. If selected by OESEL, the output enable is active high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(OEPOLW::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXPOL`"]
        pub enum RXPOLW {
            #[doc = "Not changed. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1."]
            NOT_CHANGED,
            #[doc = "Inverted. The RX signal is inverted before being used by the UART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0."]
            INVERTED,
        }
        impl RXPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXPOLW::NOT_CHANGED => false,
                    RXPOLW::INVERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not changed. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1."]
            #[inline]
            pub fn not_changed(self) -> &'a mut W {
                self.variant(RXPOLW::NOT_CHANGED)
            }
            #[doc = "Inverted. The RX signal is inverted before being used by the UART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0."]
            #[inline]
            pub fn inverted(self) -> &'a mut W {
                self.variant(RXPOLW::INVERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXPOL`"]
        pub enum TXPOLW {
            #[doc = "Not changed. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1."]
            NOT_CHANGED,
            #[doc = "Inverted. The TX signal is inverted by the UART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0."]
            INVERTED,
        }
        impl TXPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXPOLW::NOT_CHANGED => false,
                    TXPOLW::INVERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not changed. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1."]
            #[inline]
            pub fn not_changed(self) -> &'a mut W {
                self.variant(TXPOLW::NOT_CHANGED)
            }
            #[doc = "Inverted. The TX signal is inverted by the UART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0."]
            #[inline]
            pub fn inverted(self) -> &'a mut W {
                self.variant(TXPOLW::INVERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - USART Enable."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 2:3 - Selects the data size for the USART."]
            #[inline]
            pub fn datalen(&self) -> DATALENR {
                DATALENR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Selects what type of parity is used by the USART."]
            #[inline]
            pub fn paritysel(&self) -> PARITYSELR {
                PARITYSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 6 - Number of stop bits appended to transmitted data. Only a single stop bit is required for received data."]
            #[inline]
            pub fn stoplen(&self) -> STOPLENR {
                STOPLENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled."]
            #[inline]
            pub fn ctsen(&self) -> CTSENR {
                CTSENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Selects synchronous or asynchronous operation."]
            #[inline]
            pub fn syncen(&self) -> SYNCENR {
                SYNCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Selects the clock polarity and sampling edge of received data in synchronous mode."]
            #[inline]
            pub fn clkpol(&self) -> CLKPOLR {
                CLKPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Synchronous mode Master select."]
            #[inline]
            pub fn syncmst(&self) -> SYNCMSTR {
                SYNCMSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Selects data loopback mode."]
            #[inline]
            pub fn loop_(&self) -> LOOPR {
                LOOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Output Enable Turnaround time enable for RS-485 operation."]
            #[inline]
            pub fn oeta(&self) -> OETAR {
                OETAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Automatic Address matching enable."]
            #[inline]
            pub fn autoaddr(&self) -> AUTOADDRR {
                AUTOADDRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Output Enable Select."]
            #[inline]
            pub fn oesel(&self) -> OESELR {
                OESELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Output Enable Polarity."]
            #[inline]
            pub fn oepol(&self) -> OEPOLR {
                OEPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Receive data polarity."]
            #[inline]
            pub fn rxpol(&self) -> RXPOLR {
                RXPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Transmit data polarity."]
            #[inline]
            pub fn txpol(&self) -> TXPOLR {
                TXPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USART Enable."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bits 2:3 - Selects the data size for the USART."]
            #[inline]
            pub fn datalen(&mut self) -> _DATALENW {
                _DATALENW { w: self }
            }
            #[doc = "Bits 4:5 - Selects what type of parity is used by the USART."]
            #[inline]
            pub fn paritysel(&mut self) -> _PARITYSELW {
                _PARITYSELW { w: self }
            }
            #[doc = "Bit 6 - Number of stop bits appended to transmitted data. Only a single stop bit is required for received data."]
            #[inline]
            pub fn stoplen(&mut self) -> _STOPLENW {
                _STOPLENW { w: self }
            }
            #[doc = "Bit 9 - CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled."]
            #[inline]
            pub fn ctsen(&mut self) -> _CTSENW {
                _CTSENW { w: self }
            }
            #[doc = "Bit 11 - Selects synchronous or asynchronous operation."]
            #[inline]
            pub fn syncen(&mut self) -> _SYNCENW {
                _SYNCENW { w: self }
            }
            #[doc = "Bit 12 - Selects the clock polarity and sampling edge of received data in synchronous mode."]
            #[inline]
            pub fn clkpol(&mut self) -> _CLKPOLW {
                _CLKPOLW { w: self }
            }
            #[doc = "Bit 14 - Synchronous mode Master select."]
            #[inline]
            pub fn syncmst(&mut self) -> _SYNCMSTW {
                _SYNCMSTW { w: self }
            }
            #[doc = "Bit 15 - Selects data loopback mode."]
            #[inline]
            pub fn loop_(&mut self) -> _LOOPW {
                _LOOPW { w: self }
            }
            #[doc = "Bit 18 - Output Enable Turnaround time enable for RS-485 operation."]
            #[inline]
            pub fn oeta(&mut self) -> _OETAW {
                _OETAW { w: self }
            }
            #[doc = "Bit 19 - Automatic Address matching enable."]
            #[inline]
            pub fn autoaddr(&mut self) -> _AUTOADDRW {
                _AUTOADDRW { w: self }
            }
            #[doc = "Bit 20 - Output Enable Select."]
            #[inline]
            pub fn oesel(&mut self) -> _OESELW {
                _OESELW { w: self }
            }
            #[doc = "Bit 21 - Output Enable Polarity."]
            #[inline]
            pub fn oepol(&mut self) -> _OEPOLW {
                _OEPOLW { w: self }
            }
            #[doc = "Bit 22 - Receive data polarity."]
            #[inline]
            pub fn rxpol(&mut self) -> _RXPOLW {
                _RXPOLW { w: self }
            }
            #[doc = "Bit 23 - Transmit data polarity."]
            #[inline]
            pub fn txpol(&mut self) -> _TXPOLW {
                _TXPOLW { w: self }
            }
        }
    }
    #[doc = "USART Control register. USART control settings that are more likely to change during operation."]
    pub struct CTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USART Control register. USART control settings that are more likely to change during operation."]
    pub mod ctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TXBRKEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXBRKENR {
            #[doc = "Normal operation."]
            NORMAL_OPERATION,
            #[doc = "Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN."]
            CONTINUOUS_BREAK_IS,
        }
        impl TXBRKENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXBRKENR::NORMAL_OPERATION => false,
                    TXBRKENR::CONTINUOUS_BREAK_IS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXBRKENR {
                match value {
                    false => TXBRKENR::NORMAL_OPERATION,
                    true => TXBRKENR::CONTINUOUS_BREAK_IS,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
            #[inline]
            pub fn is_normal_operation(&self) -> bool {
                *self == TXBRKENR::NORMAL_OPERATION
            }
            #[doc = "Checks if the value of the field is `CONTINUOUS_BREAK_IS`"]
            #[inline]
            pub fn is_continuous_break_is(&self) -> bool {
                *self == TXBRKENR::CONTINUOUS_BREAK_IS
            }
        }
        #[doc = "Possible values of the field `ADDRDET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRDETR {
            #[doc = "Disabled. The USART presents all incoming data."]
            DISABLED,
            #[doc = "Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally."]
            ENABLED,
        }
        impl ADDRDETR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDRDETR::DISABLED => false,
                    ADDRDETR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDRDETR {
                match value {
                    false => ADDRDETR::DISABLED,
                    true => ADDRDETR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDRDETR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDRDETR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TXDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDISR {
            #[doc = "Not disabled. USART transmitter is not disabled."]
            NOT_DISABLED,
            #[doc = "Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control."]
            DISABLED,
        }
        impl TXDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXDISR::NOT_DISABLED => false,
                    TXDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXDISR {
                match value {
                    false => TXDISR::NOT_DISABLED,
                    true => TXDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_DISABLED`"]
            #[inline]
            pub fn is_not_disabled(&self) -> bool {
                *self == TXDISR::NOT_DISABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TXDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCR {
            #[doc = "Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received."]
            CLOCK_ON_CHARACTER,
            #[doc = "Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD)."]
            CONTINUOUS_CLOCK,
        }
        impl CCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CCR::CLOCK_ON_CHARACTER => false,
                    CCR::CONTINUOUS_CLOCK => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CCR {
                match value {
                    false => CCR::CLOCK_ON_CHARACTER,
                    true => CCR::CONTINUOUS_CLOCK,
                }
            }
            #[doc = "Checks if the value of the field is `CLOCK_ON_CHARACTER`"]
            #[inline]
            pub fn is_clock_on_character(&self) -> bool {
                *self == CCR::CLOCK_ON_CHARACTER
            }
            #[doc = "Checks if the value of the field is `CONTINUOUS_CLOCK`"]
            #[inline]
            pub fn is_continuous_clock(&self) -> bool {
                *self == CCR::CONTINUOUS_CLOCK
            }
        }
        #[doc = "Possible values of the field `CLRCCONRX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLRCCONRXR {
            #[doc = "No effect on the CC bit."]
            NO_EFFECT_ON_THE_CC,
            #[doc = "Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time."]
            AUTO_CLEAR,
        }
        impl CLRCCONRXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CLRCCONRXR::NO_EFFECT_ON_THE_CC => false,
                    CLRCCONRXR::AUTO_CLEAR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CLRCCONRXR {
                match value {
                    false => CLRCCONRXR::NO_EFFECT_ON_THE_CC,
                    true => CLRCCONRXR::AUTO_CLEAR,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_ON_THE_CC`"]
            #[inline]
            pub fn is_no_effect_on_the_cc(&self) -> bool {
                *self == CLRCCONRXR::NO_EFFECT_ON_THE_CC
            }
            #[doc = "Checks if the value of the field is `AUTO_CLEAR`"]
            #[inline]
            pub fn is_auto_clear(&self) -> bool {
                *self == CLRCCONRXR::AUTO_CLEAR
            }
        }
        #[doc = "Possible values of the field `AUTOBAUD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AUTOBAUDR {
            #[doc = "Disabled. UART is in normal operating mode."]
            DISABLED,
            #[doc = "Enabled. UART is in autobaud mode. This bit should only be set when the UART is enabled in the CFG register and the UART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR. This bit can be cleared by software when set, but only when the UART receiver is idle. Disabling the UART in the CFG register also clears the AUTOBAUD bit."]
            ENABLED,
        }
        impl AUTOBAUDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    AUTOBAUDR::DISABLED => false,
                    AUTOBAUDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> AUTOBAUDR {
                match value {
                    false => AUTOBAUDR::DISABLED,
                    true => AUTOBAUDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == AUTOBAUDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == AUTOBAUDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TXBRKEN`"]
        pub enum TXBRKENW {
            #[doc = "Normal operation."]
            NORMAL_OPERATION,
            #[doc = "Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN."]
            CONTINUOUS_BREAK_IS,
        }
        impl TXBRKENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXBRKENW::NORMAL_OPERATION => false,
                    TXBRKENW::CONTINUOUS_BREAK_IS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXBRKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXBRKENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXBRKENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Normal operation."]
            #[inline]
            pub fn normal_operation(self) -> &'a mut W {
                self.variant(TXBRKENW::NORMAL_OPERATION)
            }
            #[doc = "Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN."]
            #[inline]
            pub fn continuous_break_is(self) -> &'a mut W {
                self.variant(TXBRKENW::CONTINUOUS_BREAK_IS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDRDET`"]
        pub enum ADDRDETW {
            #[doc = "Disabled. The USART presents all incoming data."]
            DISABLED,
            #[doc = "Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally."]
            ENABLED,
        }
        impl ADDRDETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDRDETW::DISABLED => false,
                    ADDRDETW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRDETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDRDETW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The USART presents all incoming data."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDRDETW::DISABLED)
            }
            #[doc = "Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDRDETW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDIS`"]
        pub enum TXDISW {
            #[doc = "Not disabled. USART transmitter is not disabled."]
            NOT_DISABLED,
            #[doc = "Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control."]
            DISABLED,
        }
        impl TXDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXDISW::NOT_DISABLED => false,
                    TXDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not disabled. USART transmitter is not disabled."]
            #[inline]
            pub fn not_disabled(self) -> &'a mut W {
                self.variant(TXDISW::NOT_DISABLED)
            }
            #[doc = "Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC`"]
        pub enum CCW {
            #[doc = "Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received."]
            CLOCK_ON_CHARACTER,
            #[doc = "Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD)."]
            CONTINUOUS_CLOCK,
        }
        impl CCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CCW::CLOCK_ON_CHARACTER => false,
                    CCW::CONTINUOUS_CLOCK => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received."]
            #[inline]
            pub fn clock_on_character(self) -> &'a mut W {
                self.variant(CCW::CLOCK_ON_CHARACTER)
            }
            #[doc = "Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD)."]
            #[inline]
            pub fn continuous_clock(self) -> &'a mut W {
                self.variant(CCW::CONTINUOUS_CLOCK)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLRCCONRX`"]
        pub enum CLRCCONRXW {
            #[doc = "No effect on the CC bit."]
            NO_EFFECT_ON_THE_CC,
            #[doc = "Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time."]
            AUTO_CLEAR,
        }
        impl CLRCCONRXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLRCCONRXW::NO_EFFECT_ON_THE_CC => false,
                    CLRCCONRXW::AUTO_CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRCCONRXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRCCONRXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLRCCONRXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect on the CC bit."]
            #[inline]
            pub fn no_effect_on_the_cc(self) -> &'a mut W {
                self.variant(CLRCCONRXW::NO_EFFECT_ON_THE_CC)
            }
            #[doc = "Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time."]
            #[inline]
            pub fn auto_clear(self) -> &'a mut W {
                self.variant(CLRCCONRXW::AUTO_CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `AUTOBAUD`"]
        pub enum AUTOBAUDW {
            #[doc = "Disabled. UART is in normal operating mode."]
            DISABLED,
            #[doc = "Enabled. UART is in autobaud mode. This bit should only be set when the UART is enabled in the CFG register and the UART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR. This bit can be cleared by software when set, but only when the UART receiver is idle. Disabling the UART in the CFG register also clears the AUTOBAUD bit."]
            ENABLED,
        }
        impl AUTOBAUDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    AUTOBAUDW::DISABLED => false,
                    AUTOBAUDW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOBAUDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOBAUDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AUTOBAUDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. UART is in normal operating mode."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AUTOBAUDW::DISABLED)
            }
            #[doc = "Enabled. UART is in autobaud mode. This bit should only be set when the UART is enabled in the CFG register and the UART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR. This bit can be cleared by software when set, but only when the UART receiver is idle. Disabling the UART in the CFG register also clears the AUTOBAUD bit."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AUTOBAUDW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Break Enable."]
            #[inline]
            pub fn txbrken(&self) -> TXBRKENR {
                TXBRKENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable address detect mode."]
            #[inline]
            pub fn addrdet(&self) -> ADDRDETR {
                ADDRDETR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Transmit Disable."]
            #[inline]
            pub fn txdis(&self) -> TXDISR {
                TXDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode."]
            #[inline]
            pub fn cc(&self) -> CCR {
                CCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Clear Continuous Clock."]
            #[inline]
            pub fn clrcconrx(&self) -> CLRCCONRXR {
                CLRCCONRXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Autobaud enable."]
            #[inline]
            pub fn autobaud(&self) -> AUTOBAUDR {
                AUTOBAUDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Break Enable."]
            #[inline]
            pub fn txbrken(&mut self) -> _TXBRKENW {
                _TXBRKENW { w: self }
            }
            #[doc = "Bit 2 - Enable address detect mode."]
            #[inline]
            pub fn addrdet(&mut self) -> _ADDRDETW {
                _ADDRDETW { w: self }
            }
            #[doc = "Bit 6 - Transmit Disable."]
            #[inline]
            pub fn txdis(&mut self) -> _TXDISW {
                _TXDISW { w: self }
            }
            #[doc = "Bit 8 - Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode."]
            #[inline]
            pub fn cc(&mut self) -> _CCW {
                _CCW { w: self }
            }
            #[doc = "Bit 9 - Clear Continuous Clock."]
            #[inline]
            pub fn clrcconrx(&mut self) -> _CLRCCONRXW {
                _CLRCCONRXW { w: self }
            }
            #[doc = "Bit 16 - Autobaud enable."]
            #[inline]
            pub fn autobaud(&mut self) -> _AUTOBAUDW {
                _AUTOBAUDW { w: self }
            }
        }
    }
    #[doc = "USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them."]
    pub struct STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXIDLER {
            bits: bool,
        }
        impl RXIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXIDLER {
            bits: bool,
        }
        impl TXIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTSR {
            bits: bool,
        }
        impl CTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTACTSR {
            bits: bool,
        }
        impl DELTACTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDISSTATR {
            bits: bool,
        }
        impl TXDISSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNINTR {
            bits: bool,
        }
        impl OVERRUNINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXBRKR {
            bits: bool,
        }
        impl RXBRKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTARXBRKR {
            bits: bool,
        }
        impl DELTARXBRKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRINTR {
            bits: bool,
        }
        impl FRAMERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRINTR {
            bits: bool,
        }
        impl PARITYERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISEINTR {
            bits: bool,
        }
        impl RXNOISEINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ABERRR {
            bits: bool,
        }
        impl ABERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXIDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXIDLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXIDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXIDLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTACTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTACTSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXBRKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXBRKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTARXBRKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTARXBRKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMERRINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMERRINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYERRINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYERRINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNOISEINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNOISEINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT or RXDATSTAT registers."]
            #[inline]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 1 - Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data."]
            #[inline]
            pub fn rxidle(&self) -> RXIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXIDLER { bits }
            }
            #[doc = "Bit 2 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT. Set when the data is moved from the transmit buffer to the transmit shift register."]
            #[inline]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 3 - Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data."]
            #[inline]
            pub fn txidle(&self) -> TXIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXIDLER { bits }
            }
            #[doc = "Bit 4 - This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled."]
            #[inline]
            pub fn cts(&self) -> CTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CTSR { bits }
            }
            #[doc = "Bit 5 - This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software."]
            #[inline]
            pub fn deltacts(&self) -> DELTACTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTACTSR { bits }
            }
            #[doc = "Bit 6 - Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CTL register (TXDIS = 1)."]
            #[inline]
            pub fn txdisstat(&self) -> TXDISSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDISSTATR { bits }
            }
            #[doc = "Bit 8 - Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost."]
            #[inline]
            pub fn overrunint(&self) -> OVERRUNINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNINTR { bits }
            }
            #[doc = "Bit 10 - Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high."]
            #[inline]
            pub fn rxbrk(&self) -> RXBRKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXBRKR { bits }
            }
            #[doc = "Bit 11 - This bit is set when a change in the state of receiver break detection occurs. Cleared by software."]
            #[inline]
            pub fn deltarxbrk(&self) -> DELTARXBRKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTARXBRKR { bits }
            }
            #[doc = "Bit 12 - This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software."]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 13 - Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source."]
            #[inline]
            pub fn framerrint(&self) -> FRAMERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRINTR { bits }
            }
            #[doc = "Bit 14 - Parity Error interrupt flag. This flag is set when a parity error is detected in a received character.."]
            #[inline]
            pub fn parityerrint(&self) -> PARITYERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRINTR { bits }
            }
            #[doc = "Bit 15 - Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception."]
            #[inline]
            pub fn rxnoiseint(&self) -> RXNOISEINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISEINTR { bits }
            }
            #[doc = "Bit 16 - Autobaud Error. An autobaud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an autobaud time-out."]
            #[inline]
            pub fn aberr(&self) -> ABERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ABERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0e }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT or RXDATSTAT registers."]
            #[inline]
            pub fn rxrdy(&mut self) -> _RXRDYW {
                _RXRDYW { w: self }
            }
            #[doc = "Bit 1 - Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data."]
            #[inline]
            pub fn rxidle(&mut self) -> _RXIDLEW {
                _RXIDLEW { w: self }
            }
            #[doc = "Bit 2 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT. Set when the data is moved from the transmit buffer to the transmit shift register."]
            #[inline]
            pub fn txrdy(&mut self) -> _TXRDYW {
                _TXRDYW { w: self }
            }
            #[doc = "Bit 3 - Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data."]
            #[inline]
            pub fn txidle(&mut self) -> _TXIDLEW {
                _TXIDLEW { w: self }
            }
            #[doc = "Bit 4 - This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled."]
            #[inline]
            pub fn cts(&mut self) -> _CTSW {
                _CTSW { w: self }
            }
            #[doc = "Bit 5 - This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software."]
            #[inline]
            pub fn deltacts(&mut self) -> _DELTACTSW {
                _DELTACTSW { w: self }
            }
            #[doc = "Bit 6 - Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CTL register (TXDIS = 1)."]
            #[inline]
            pub fn txdisstat(&mut self) -> _TXDISSTATW {
                _TXDISSTATW { w: self }
            }
            #[doc = "Bit 8 - Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost."]
            #[inline]
            pub fn overrunint(&mut self) -> _OVERRUNINTW {
                _OVERRUNINTW { w: self }
            }
            #[doc = "Bit 10 - Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high."]
            #[inline]
            pub fn rxbrk(&mut self) -> _RXBRKW {
                _RXBRKW { w: self }
            }
            #[doc = "Bit 11 - This bit is set when a change in the state of receiver break detection occurs. Cleared by software."]
            #[inline]
            pub fn deltarxbrk(&mut self) -> _DELTARXBRKW {
                _DELTARXBRKW { w: self }
            }
            #[doc = "Bit 12 - This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software."]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 13 - Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source."]
            #[inline]
            pub fn framerrint(&mut self) -> _FRAMERRINTW {
                _FRAMERRINTW { w: self }
            }
            #[doc = "Bit 14 - Parity Error interrupt flag. This flag is set when a parity error is detected in a received character.."]
            #[inline]
            pub fn parityerrint(&mut self) -> _PARITYERRINTW {
                _PARITYERRINTW { w: self }
            }
            #[doc = "Bit 15 - Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception."]
            #[inline]
            pub fn rxnoiseint(&mut self) -> _RXNOISEINTW {
                _RXNOISEINTW { w: self }
            }
            #[doc = "Bit 16 - Autobaud Error. An autobaud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an autobaud time-out."]
            #[inline]
            pub fn aberr(&mut self) -> _ABERRW {
                _ABERRW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub struct INTENSET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYENR {
            bits: bool,
        }
        impl RXRDYENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYENR {
            bits: bool,
        }
        impl TXRDYENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXIDLEENR {
            bits: bool,
        }
        impl TXIDLEENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTACTSENR {
            bits: bool,
        }
        impl DELTACTSENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDISENR {
            bits: bool,
        }
        impl TXDISENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNENR {
            bits: bool,
        }
        impl OVERRUNENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTARXBRKENR {
            bits: bool,
        }
        impl DELTARXBRKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTENR {
            bits: bool,
        }
        impl STARTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRENR {
            bits: bool,
        }
        impl FRAMERRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRENR {
            bits: bool,
        }
        impl PARITYERRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISEENR {
            bits: bool,
        }
        impl RXNOISEENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ABERRENR {
            bits: bool,
        }
        impl ABERRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXIDLEENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXIDLEENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTACTSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTACTSENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTARXBRKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTARXBRKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMERRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYERRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNOISEENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNOISEENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABERRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - When 1, enables an interrupt when there is a received character available to be read from the RXDAT register."]
            #[inline]
            pub fn rxrdyen(&self) -> RXRDYENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYENR { bits }
            }
            #[doc = "Bit 2 - When 1, enables an interrupt when the TXDAT register is available to take another character to transmit."]
            #[inline]
            pub fn txrdyen(&self) -> TXRDYENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYENR { bits }
            }
            #[doc = "Bit 3 - When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1)."]
            #[inline]
            pub fn txidleen(&self) -> TXIDLEENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXIDLEENR { bits }
            }
            #[doc = "Bit 5 - When 1, enables an interrupt when there is a change in the state of the CTS input."]
            #[inline]
            pub fn deltactsen(&self) -> DELTACTSENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTACTSENR { bits }
            }
            #[doc = "Bit 6 - When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details."]
            #[inline]
            pub fn txdisen(&self) -> TXDISENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDISENR { bits }
            }
            #[doc = "Bit 8 - When 1, enables an interrupt when an overrun error occurred."]
            #[inline]
            pub fn overrunen(&self) -> OVERRUNENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNENR { bits }
            }
            #[doc = "Bit 11 - When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted)."]
            #[inline]
            pub fn deltarxbrken(&self) -> DELTARXBRKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTARXBRKENR { bits }
            }
            #[doc = "Bit 12 - When 1, enables an interrupt when a received start bit has been detected."]
            #[inline]
            pub fn starten(&self) -> STARTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTENR { bits }
            }
            #[doc = "Bit 13 - When 1, enables an interrupt when a framing error has been detected."]
            #[inline]
            pub fn framerren(&self) -> FRAMERRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRENR { bits }
            }
            #[doc = "Bit 14 - When 1, enables an interrupt when a parity error has been detected."]
            #[inline]
            pub fn parityerren(&self) -> PARITYERRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRENR { bits }
            }
            #[doc = "Bit 15 - When 1, enables an interrupt when noise is detected."]
            #[inline]
            pub fn rxnoiseen(&self) -> RXNOISEENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISEENR { bits }
            }
            #[doc = "Bit 16 - When 1, enables an interrupt when an autobaud error occurs."]
            #[inline]
            pub fn aberren(&self) -> ABERRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ABERRENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - When 1, enables an interrupt when there is a received character available to be read from the RXDAT register."]
            #[inline]
            pub fn rxrdyen(&mut self) -> _RXRDYENW {
                _RXRDYENW { w: self }
            }
            #[doc = "Bit 2 - When 1, enables an interrupt when the TXDAT register is available to take another character to transmit."]
            #[inline]
            pub fn txrdyen(&mut self) -> _TXRDYENW {
                _TXRDYENW { w: self }
            }
            #[doc = "Bit 3 - When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1)."]
            #[inline]
            pub fn txidleen(&mut self) -> _TXIDLEENW {
                _TXIDLEENW { w: self }
            }
            #[doc = "Bit 5 - When 1, enables an interrupt when there is a change in the state of the CTS input."]
            #[inline]
            pub fn deltactsen(&mut self) -> _DELTACTSENW {
                _DELTACTSENW { w: self }
            }
            #[doc = "Bit 6 - When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details."]
            #[inline]
            pub fn txdisen(&mut self) -> _TXDISENW {
                _TXDISENW { w: self }
            }
            #[doc = "Bit 8 - When 1, enables an interrupt when an overrun error occurred."]
            #[inline]
            pub fn overrunen(&mut self) -> _OVERRUNENW {
                _OVERRUNENW { w: self }
            }
            #[doc = "Bit 11 - When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted)."]
            #[inline]
            pub fn deltarxbrken(&mut self) -> _DELTARXBRKENW {
                _DELTARXBRKENW { w: self }
            }
            #[doc = "Bit 12 - When 1, enables an interrupt when a received start bit has been detected."]
            #[inline]
            pub fn starten(&mut self) -> _STARTENW {
                _STARTENW { w: self }
            }
            #[doc = "Bit 13 - When 1, enables an interrupt when a framing error has been detected."]
            #[inline]
            pub fn framerren(&mut self) -> _FRAMERRENW {
                _FRAMERRENW { w: self }
            }
            #[doc = "Bit 14 - When 1, enables an interrupt when a parity error has been detected."]
            #[inline]
            pub fn parityerren(&mut self) -> _PARITYERRENW {
                _PARITYERRENW { w: self }
            }
            #[doc = "Bit 15 - When 1, enables an interrupt when noise is detected."]
            #[inline]
            pub fn rxnoiseen(&mut self) -> _RXNOISEENW {
                _RXNOISEENW { w: self }
            }
            #[doc = "Bit 16 - When 1, enables an interrupt when an autobaud error occurs."]
            #[inline]
            pub fn aberren(&mut self) -> _ABERRENW {
                _ABERRENW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared."]
    pub struct INTENCLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared."]
    pub mod intenclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXIDLECLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXIDLECLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTACTSCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTACTSCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISINTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISINTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTARXBRKCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTARXBRKCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMERRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMERRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYERRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYERRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNOISECLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNOISECLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABERRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABERRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn rxrdyclr(&mut self) -> _RXRDYCLRW {
                _RXRDYCLRW { w: self }
            }
            #[doc = "Bit 2 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn txrdyclr(&mut self) -> _TXRDYCLRW {
                _TXRDYCLRW { w: self }
            }
            #[doc = "Bit 3 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn txidleclr(&mut self) -> _TXIDLECLRW {
                _TXIDLECLRW { w: self }
            }
            #[doc = "Bit 5 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn deltactsclr(&mut self) -> _DELTACTSCLRW {
                _DELTACTSCLRW { w: self }
            }
            #[doc = "Bit 6 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn txdisintclr(&mut self) -> _TXDISINTCLRW {
                _TXDISINTCLRW { w: self }
            }
            #[doc = "Bit 8 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn overrunclr(&mut self) -> _OVERRUNCLRW {
                _OVERRUNCLRW { w: self }
            }
            #[doc = "Bit 11 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn deltarxbrkclr(&mut self) -> _DELTARXBRKCLRW {
                _DELTARXBRKCLRW { w: self }
            }
            #[doc = "Bit 12 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn startclr(&mut self) -> _STARTCLRW {
                _STARTCLRW { w: self }
            }
            #[doc = "Bit 13 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn framerrclr(&mut self) -> _FRAMERRCLRW {
                _FRAMERRCLRW { w: self }
            }
            #[doc = "Bit 14 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn parityerrclr(&mut self) -> _PARITYERRCLRW {
                _PARITYERRCLRW { w: self }
            }
            #[doc = "Bit 15 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn rxnoiseclr(&mut self) -> _RXNOISECLRW {
                _RXNOISECLRW { w: self }
            }
            #[doc = "Bit 16 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline]
            pub fn aberrclr(&mut self) -> _ABERRCLRW {
                _ABERRCLRW { w: self }
            }
        }
    }
    #[doc = "Receiver Data register. Contains the last character received."]
    pub struct RXDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receiver Data register. Contains the last character received."]
    pub mod rxdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXDAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDATR {
            bits: u16,
        }
        impl RXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings."]
            #[inline]
            pub fn rxdat(&self) -> RXDATR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RXDATR { bits }
            }
        }
    }
    #[doc = "Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together."]
    pub struct RXDATSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together."]
    pub mod rxdatstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXDATSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDATR {
            bits: u16,
        }
        impl RXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRR {
            bits: bool,
        }
        impl FRAMERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRR {
            bits: bool,
        }
        impl PARITYERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISER {
            bits: bool,
        }
        impl RXNOISER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings."]
            #[inline]
            pub fn rxdat(&self) -> RXDATR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RXDATR { bits }
            }
            #[doc = "Bit 13 - Framing Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source."]
            #[inline]
            pub fn framerr(&self) -> FRAMERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRR { bits }
            }
            #[doc = "Bit 14 - Parity Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will be set when a parity error is detected in a received character."]
            #[inline]
            pub fn parityerr(&self) -> PARITYERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRR { bits }
            }
            #[doc = "Bit 15 - Received Noise flag. See description of the RXNOISEINT bit in Table 177."]
            #[inline]
            pub fn rxnoise(&self) -> RXNOISER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISER { bits }
            }
        }
    }
    #[doc = "Transmit Data register. Data to be transmitted is written here."]
    pub struct TXDAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit Data register. Data to be transmitted is written here."]
    pub mod txdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDATR {
            bits: u16,
        }
        impl TXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available and any conditions for transmitting data are met: CTS low (if CTSEN bit = 1), TXDIS bit = 0."]
            #[inline]
            pub fn txdat(&self) -> TXDATR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TXDATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available and any conditions for transmitting data are met: CTS low (if CTSEN bit = 1), TXDIS bit = 0."]
            #[inline]
            pub fn txdat(&mut self) -> _TXDATW {
                _TXDATW { w: self }
            }
        }
    }
    #[doc = "Baud Rate Generator register. 16-bit integer baud rate divisor value."]
    pub struct BRG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Baud Rate Generator register. 16-bit integer baud rate divisor value."]
    pub mod brg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BRG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct BRGVALR {
            bits: u16,
        }
        impl BRGVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BRGVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BRGVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function."]
            #[inline]
            pub fn brgval(&self) -> BRGVALR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                BRGVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function."]
            #[inline]
            pub fn brgval(&mut self) -> _BRGVALW {
                _BRGVALW { w: self }
            }
        }
    }
    #[doc = "Interrupt status register. Reflects interrupts that are currently enabled."]
    pub struct INTSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt status register. Reflects interrupts that are currently enabled."]
    pub mod intstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXIDLER {
            bits: bool,
        }
        impl TXIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTACTSR {
            bits: bool,
        }
        impl DELTACTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDISINTR {
            bits: bool,
        }
        impl TXDISINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNINTR {
            bits: bool,
        }
        impl OVERRUNINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTARXBRKR {
            bits: bool,
        }
        impl DELTARXBRKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRINTR {
            bits: bool,
        }
        impl FRAMERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRINTR {
            bits: bool,
        }
        impl PARITYERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISEINTR {
            bits: bool,
        }
        impl RXNOISEINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ABERRR {
            bits: bool,
        }
        impl ABERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag."]
            #[inline]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 2 - Transmitter Ready flag."]
            #[inline]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 3 - Transmitter idle status."]
            #[inline]
            pub fn txidle(&self) -> TXIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXIDLER { bits }
            }
            #[doc = "Bit 5 - This bit is set when a change in the state of the CTS input is detected."]
            #[inline]
            pub fn deltacts(&self) -> DELTACTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTACTSR { bits }
            }
            #[doc = "Bit 6 - Transmitter Disabled Interrupt flag."]
            #[inline]
            pub fn txdisint(&self) -> TXDISINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDISINTR { bits }
            }
            #[doc = "Bit 8 - Overrun Error interrupt flag."]
            #[inline]
            pub fn overrunint(&self) -> OVERRUNINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNINTR { bits }
            }
            #[doc = "Bit 11 - This bit is set when a change in the state of receiver break detection occurs."]
            #[inline]
            pub fn deltarxbrk(&self) -> DELTARXBRKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTARXBRKR { bits }
            }
            #[doc = "Bit 12 - This bit is set when a start is detected on the receiver input."]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 13 - Framing Error interrupt flag."]
            #[inline]
            pub fn framerrint(&self) -> FRAMERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRINTR { bits }
            }
            #[doc = "Bit 14 - Parity Error interrupt flag."]
            #[inline]
            pub fn parityerrint(&self) -> PARITYERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRINTR { bits }
            }
            #[doc = "Bit 15 - Received Noise interrupt flag."]
            #[inline]
            pub fn rxnoiseint(&self) -> RXNOISEINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISEINTR { bits }
            }
            #[doc = "Bit 16 - Autobaud Error flag."]
            #[inline]
            pub fn aberr(&self) -> ABERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ABERRR { bits }
            }
        }
    }
    #[doc = "Oversample selection register for asynchronous communication."]
    pub struct OSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Oversample selection register for asynchronous communication."]
    pub mod osr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSRVALR {
            bits: u8,
        }
        impl OSRVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSRVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSRVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 peripheral clocks are used to transmit and receive each data bit. 0x5 = 6 peripheral clocks are used to transmit and receive each data bit. ... 0xF= 16 peripheral clocks are used to transmit and receive each data bit."]
            #[inline]
            pub fn osrval(&self) -> OSRVALR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OSRVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 peripheral clocks are used to transmit and receive each data bit. 0x5 = 6 peripheral clocks are used to transmit and receive each data bit. ... 0xF= 16 peripheral clocks are used to transmit and receive each data bit."]
            #[inline]
            pub fn osrval(&mut self) -> _OSRVALW {
                _OSRVALW { w: self }
            }
        }
    }
    #[doc = "Address register for automatic address matching."]
    pub struct ADDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Address register for automatic address matching."]
    pub mod addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRESSR {
            bits: u8,
        }
        impl ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - 8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1)."]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDRESSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - 8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1)."]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
        }
    }
}
#[doc = "USART1"]
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART1 {}
impl USART1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const usart0::RegisterBlock {
        0x4006_8000 as *const _
    }
}
impl Deref for USART1 {
    type Target = usart0::RegisterBlock;
    fn deref(&self) -> &usart0::RegisterBlock {
        unsafe { &*USART1::ptr() }
    }
}
#[doc = "USART2"]
pub struct USART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART2 {}
impl USART2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const usart0::RegisterBlock {
        0x4006_c000 as *const _
    }
}
impl Deref for USART2 {
    type Target = usart0::RegisterBlock;
    fn deref(&self) -> &usart0::RegisterBlock {
        unsafe { &*USART2::ptr() }
    }
}
#[doc = "I2C2"]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c0::RegisterBlock {
        0x4007_0000 as *const _
    }
}
impl Deref for I2C2 {
    type Target = i2c0::RegisterBlock;
    fn deref(&self) -> &i2c0::RegisterBlock {
        unsafe { &*I2C2::ptr() }
    }
}
#[doc = "I2C3"]
pub struct I2C3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C3 {}
impl I2C3 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c0::RegisterBlock {
        0x4007_4000 as *const _
    }
}
impl Deref for I2C3 {
    type Target = i2c0::RegisterBlock;
    fn deref(&self) -> &i2c0::RegisterBlock {
        unsafe { &*I2C3::ptr() }
    }
}
#[doc = "Cyclic Redundancy Check (CRC) engine"]
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const crc::RegisterBlock {
        0x5000_0000 as *const _
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    fn deref(&self) -> &crc::RegisterBlock {
        unsafe { &*CRC::ptr() }
    }
}
#[doc = "Cyclic Redundancy Check (CRC) engine"]
pub mod crc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - CRC mode register"]
        pub mode: MODE,
        #[doc = "0x04 - CRC seed register"]
        pub seed: SEED,
        #[doc = "0x08 - CRC checksum register"]
        pub sum: SUM,
    }
    #[doc = "CRC mode register"]
    pub struct MODE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CRC mode register"]
    pub mod mode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRC_POLYR {
            bits: u8,
        }
        impl CRC_POLYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIT_RVS_WRR {
            bits: bool,
        }
        impl BIT_RVS_WRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMPL_WRR {
            bits: bool,
        }
        impl CMPL_WRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIT_RVS_SUMR {
            bits: bool,
        }
        impl BIT_RVS_SUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMPL_SUMR {
            bits: bool,
        }
        impl CMPL_SUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRC_POLYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRC_POLYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIT_RVS_WRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIT_RVS_WRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMPL_WRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMPL_WRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIT_RVS_SUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIT_RVS_SUMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMPL_SUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMPL_SUMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - CRC polynom: 1X= CRC-32 polynomial 01= CRC-16 polynomial 00= CRC-CCITT polynomial"]
            #[inline]
            pub fn crc_poly(&self) -> CRC_POLYR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CRC_POLYR { bits }
            }
            #[doc = "Bit 2 - Data bit order: 1= Bit order reverse for CRC_WR_DATA (per byte) 0= No bit order reverse for CRC_WR_DATA (per byte)"]
            #[inline]
            pub fn bit_rvs_wr(&self) -> BIT_RVS_WRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIT_RVS_WRR { bits }
            }
            #[doc = "Bit 3 - Data complement: 1= 1's complement for CRC_WR_DATA 0= No 1's complement for CRC_WR_DATA"]
            #[inline]
            pub fn cmpl_wr(&self) -> CMPL_WRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMPL_WRR { bits }
            }
            #[doc = "Bit 4 - CRC sum bit order: 1= Bit order reverse for CRC_SUM 0= No bit order reverse for CRC_SUM"]
            #[inline]
            pub fn bit_rvs_sum(&self) -> BIT_RVS_SUMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIT_RVS_SUMR { bits }
            }
            #[doc = "Bit 5 - CRC sum complement: 1= 1's complement for CRC_SUM 0=No 1's complement for CRC_SUM"]
            #[inline]
            pub fn cmpl_sum(&self) -> CMPL_SUMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMPL_SUMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CRC polynom: 1X= CRC-32 polynomial 01= CRC-16 polynomial 00= CRC-CCITT polynomial"]
            #[inline]
            pub fn crc_poly(&mut self) -> _CRC_POLYW {
                _CRC_POLYW { w: self }
            }
            #[doc = "Bit 2 - Data bit order: 1= Bit order reverse for CRC_WR_DATA (per byte) 0= No bit order reverse for CRC_WR_DATA (per byte)"]
            #[inline]
            pub fn bit_rvs_wr(&mut self) -> _BIT_RVS_WRW {
                _BIT_RVS_WRW { w: self }
            }
            #[doc = "Bit 3 - Data complement: 1= 1's complement for CRC_WR_DATA 0= No 1's complement for CRC_WR_DATA"]
            #[inline]
            pub fn cmpl_wr(&mut self) -> _CMPL_WRW {
                _CMPL_WRW { w: self }
            }
            #[doc = "Bit 4 - CRC sum bit order: 1= Bit order reverse for CRC_SUM 0= No bit order reverse for CRC_SUM"]
            #[inline]
            pub fn bit_rvs_sum(&mut self) -> _BIT_RVS_SUMW {
                _BIT_RVS_SUMW { w: self }
            }
            #[doc = "Bit 5 - CRC sum complement: 1= 1's complement for CRC_SUM 0=No 1's complement for CRC_SUM"]
            #[inline]
            pub fn cmpl_sum(&mut self) -> _CMPL_SUMW {
                _CMPL_SUMW { w: self }
            }
        }
    }
    #[doc = "CRC seed register"]
    pub struct SEED {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CRC seed register"]
    pub mod seed {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SEED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRC_SEEDR {
            bits: u32,
        }
        impl CRC_SEEDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRC_SEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRC_SEEDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1's complement pre-processes. A write access to this register will overrule the CRC calculation in progresses."]
            #[inline]
            pub fn crc_seed(&self) -> CRC_SEEDR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRC_SEEDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1's complement pre-processes. A write access to this register will overrule the CRC calculation in progresses."]
            #[inline]
            pub fn crc_seed(&mut self) -> _CRC_SEEDW {
                _CRC_SEEDW { w: self }
            }
        }
    }
    #[doc = "CRC checksum register"]
    pub struct SUM {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CRC checksum register"]
    pub mod sum {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SUM {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRC_SUMR {
            bits: u32,
        }
        impl CRC_SUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - The most recent CRC sum can be read through this register with selected bit order and 1's complement post-processes."]
            #[inline]
            pub fn crc_sum(&self) -> CRC_SUMR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRC_SUMR { bits }
            }
        }
    }
    #[doc = "CRC data register"]
    pub struct WR_DATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CRC data register"]
    pub mod wr_data {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WR_DATA {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRC_WR_DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRC_WR_DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data written to this register will be taken to perform CRC calculation with selected bit order and 1's complement pre-process. Any write size 8, 16 or 32-bit are allowed and accept back-to-back transactions."]
            #[inline]
            pub fn crc_wr_data(&mut self) -> _CRC_WR_DATAW {
                _CRC_WR_DATAW { w: self }
            }
        }
    }
}
#[doc = "State Configurable Timer (SCT)"]
pub struct SCT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SCT {}
impl SCT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const sct::RegisterBlock {
        0x5000_4000 as *const _
    }
}
impl Deref for SCT {
    type Target = sct::RegisterBlock;
    fn deref(&self) -> &sct::RegisterBlock {
        unsafe { &*SCT::ptr() }
    }
}
#[doc = "State Configurable Timer (SCT)"]
pub mod sct {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SCT configuration register"]
        pub config: CONFIG,
        #[doc = "0x04 - SCT control register"]
        pub ctrl: CTRL,
        #[doc = "0x08 - SCT limit register"]
        pub limit: LIMIT,
        #[doc = "0x0c - SCT halt condition register"]
        pub halt: HALT,
        #[doc = "0x10 - SCT stop condition register"]
        pub stop: STOP,
        #[doc = "0x14 - SCT start condition register"]
        pub start: START,
        _reserved0: [u8; 40usize],
        #[doc = "0x40 - SCT counter register"]
        pub count: COUNT,
        #[doc = "0x44 - SCT state register"]
        pub state: STATE,
        #[doc = "0x48 - SCT input register"]
        pub input: INPUT,
        #[doc = "0x4c - SCT match/capture registers mode register"]
        pub regmode: REGMODE,
        #[doc = "0x50 - SCT output register"]
        pub output: OUTPUT,
        #[doc = "0x54 - SCT output counter direction control register"]
        pub outputdirctrl: OUTPUTDIRCTRL,
        #[doc = "0x58 - SCT conflict resolution register"]
        pub res: RES,
        #[doc = "0x5c - SCT DMA request 0 register"]
        pub dmareq0: DMAREQ0,
        #[doc = "0x60 - SCT DMA request 1 register"]
        pub dmareq1: DMAREQ1,
        _reserved1: [u8; 140usize],
        #[doc = "0xf0 - SCT event enable register"]
        pub even: EVEN,
        #[doc = "0xf4 - SCT event flag register"]
        pub evflag: EVFLAG,
        #[doc = "0xf8 - SCT conflict enable register"]
        pub conen: CONEN,
        #[doc = "0xfc - SCT conflict flag register"]
        pub conflag: CONFLAG,
        #[doc = "0x100 - SCT match value register of match channels 0 to 7; REGMOD0 to REGMODE7 = 0"]
        pub match_: [MATCH; 8],
        _reserved2: [u8; 224usize],
        #[doc = "0x200 - SCT match reload value register 0 to 7; REGMOD0 = 0 to REGMODE7 = 0"]
        pub matchrel: [MATCHREL; 8],
        _reserved3: [u8; 224usize],
        #[doc = "0x300 - SCT event state register 0"]
        pub ev0_state: EV_STATE,
        #[doc = "0x304 - SCT event control register 0"]
        pub ev0_ctrl: EV_CTRL,
        #[doc = "0x308 - SCT event state register 0"]
        pub ev1_state: EV_STATE,
        #[doc = "0x30c - SCT event control register 0"]
        pub ev1_ctrl: EV_CTRL,
        #[doc = "0x310 - SCT event state register 0"]
        pub ev2_state: EV_STATE,
        #[doc = "0x314 - SCT event control register 0"]
        pub ev2_ctrl: EV_CTRL,
        #[doc = "0x318 - SCT event state register 0"]
        pub ev3_state: EV_STATE,
        #[doc = "0x31c - SCT event control register 0"]
        pub ev3_ctrl: EV_CTRL,
        #[doc = "0x320 - SCT event state register 0"]
        pub ev4_state: EV_STATE,
        #[doc = "0x324 - SCT event control register 0"]
        pub ev4_ctrl: EV_CTRL,
        #[doc = "0x328 - SCT event state register 0"]
        pub ev5_state: EV_STATE,
        #[doc = "0x32c - SCT event control register 0"]
        pub ev5_ctrl: EV_CTRL,
        #[doc = "0x330 - SCT event state register 0"]
        pub ev6_state: EV_STATE,
        #[doc = "0x334 - SCT event control register 0"]
        pub ev6_ctrl: EV_CTRL,
        #[doc = "0x338 - SCT event state register 0"]
        pub ev7_state: EV_STATE,
        #[doc = "0x33c - SCT event control register 0"]
        pub ev7_ctrl: EV_CTRL,
        _reserved4: [u8; 448usize],
        #[doc = "0x500 - SCT output 0 set register"]
        pub out0_set: OUT_SET,
        #[doc = "0x504 - SCT output 0 clear register"]
        pub out0_clr: OUT_CLR,
        #[doc = "0x508 - SCT output 0 set register"]
        pub out1_set: OUT_SET,
        #[doc = "0x50c - SCT output 0 clear register"]
        pub out1_clr: OUT_CLR,
        #[doc = "0x510 - SCT output 0 set register"]
        pub out2_set: OUT_SET,
        #[doc = "0x514 - SCT output 0 clear register"]
        pub out2_clr: OUT_CLR,
        #[doc = "0x518 - SCT output 0 set register"]
        pub out3_set: OUT_SET,
        #[doc = "0x51c - SCT output 0 clear register"]
        pub out3_clr: OUT_CLR,
        #[doc = "0x520 - SCT output 0 set register"]
        pub out4_set: OUT_SET,
        #[doc = "0x524 - SCT output 0 clear register"]
        pub out4_clr: OUT_CLR,
        #[doc = "0x528 - SCT output 0 set register"]
        pub out5_set: OUT_SET,
        #[doc = "0x52c - SCT output 0 clear register"]
        pub out5_clr: OUT_CLR,
    }
    #[doc = "SCT configuration register"]
    pub struct CONFIG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT configuration register"]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UNIFY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UNIFYR {
            #[doc = "The SCT operates as two 16-bit counters named L and H."]
            LHCOUNTER,
            #[doc = "The SCT operates as a unified 32-bit counter."]
            UNIFIEDCOUNTER,
        }
        impl UNIFYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UNIFYR::LHCOUNTER => false,
                    UNIFYR::UNIFIEDCOUNTER => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UNIFYR {
                match value {
                    false => UNIFYR::LHCOUNTER,
                    true => UNIFYR::UNIFIEDCOUNTER,
                }
            }
            #[doc = "Checks if the value of the field is `LHCOUNTER`"]
            #[inline]
            pub fn is_lhcounter(&self) -> bool {
                *self == UNIFYR::LHCOUNTER
            }
            #[doc = "Checks if the value of the field is `UNIFIEDCOUNTER`"]
            #[inline]
            pub fn is_unifiedcounter(&self) -> bool {
                *self == UNIFYR::UNIFIEDCOUNTER
            }
        }
        #[doc = "Possible values of the field `CLKMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKMODER {
            #[doc = "The bus clock clocks the SCT and prescalers."]
            THE_BUS_CLOCK_CLOCKS,
            #[doc = "The SCT clock is the bus clock, but the prescalers are  enabled to count only when sampling of the input selected by  the CKSEL field finds the selected edge. The minimum pulse  width on the clock input is 1 bus clock period. This mode is the high-performance  sampled-clock mode."]
            THE_SCT_CLOCK_IS_THE,
            #[doc = "The input selected by  CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted.  The minimum pulse width on the clock input is 1 bus clock  period. This mode is the low-power sampled-clock mode."]
            THE_INPUT_SELECTED_B,
            #[doc = "Prescaled SCT input. The SCT and prescalers are clocked by the input edge  selected by the CKSEL field. In this mode, most of the SCT is clocked by the (selected polarity of the)  input. The outputs are switched synchronously to the input clock. The input clock rate must be at least half the system clock rate and  can the same or faster than the system clock."]
            PRESCALED_SCT_INPUT,
        }
        impl CLKMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLKMODER::THE_BUS_CLOCK_CLOCKS => 0,
                    CLKMODER::THE_SCT_CLOCK_IS_THE => 0x01,
                    CLKMODER::THE_INPUT_SELECTED_B => 0x02,
                    CLKMODER::PRESCALED_SCT_INPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLKMODER {
                match value {
                    0 => CLKMODER::THE_BUS_CLOCK_CLOCKS,
                    1 => CLKMODER::THE_SCT_CLOCK_IS_THE,
                    2 => CLKMODER::THE_INPUT_SELECTED_B,
                    3 => CLKMODER::PRESCALED_SCT_INPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `THE_BUS_CLOCK_CLOCKS`"]
            #[inline]
            pub fn is_the_bus_clock_clocks(&self) -> bool {
                *self == CLKMODER::THE_BUS_CLOCK_CLOCKS
            }
            #[doc = "Checks if the value of the field is `THE_SCT_CLOCK_IS_THE`"]
            #[inline]
            pub fn is_the_sct_clock_is_the(&self) -> bool {
                *self == CLKMODER::THE_SCT_CLOCK_IS_THE
            }
            #[doc = "Checks if the value of the field is `THE_INPUT_SELECTED_B`"]
            #[inline]
            pub fn is_the_input_selected_b(&self) -> bool {
                *self == CLKMODER::THE_INPUT_SELECTED_B
            }
            #[doc = "Checks if the value of the field is `PRESCALED_SCT_INPUT`"]
            #[inline]
            pub fn is_prescaled_sct_input(&self) -> bool {
                *self == CLKMODER::PRESCALED_SCT_INPUT
            }
        }
        #[doc = "Possible values of the field `CKSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CKSELR {
            #[doc = "Rising edges on input 0."]
            RISING_EDGES_INPUT_0,
            #[doc = "Falling edges on input 0."]
            FALLING_EDGES_INPUT_0,
            #[doc = "Rising edges on input 1."]
            RISING_EDGES_INPUT_1,
            #[doc = "Falling edges on input 1."]
            FALLING_EDGES_INPUT_1,
            #[doc = "Rising edges on input 2."]
            RISING_EDGES_INPUT_2,
            #[doc = "Falling edges on input 2."]
            FALLING_EDGES_INPUT_2,
            #[doc = "Rising edges on input 3."]
            RISING_EDGES_INPUT_3,
            #[doc = "Falling edges on input 3."]
            FALLING_EDGES_INPUT_3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CKSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CKSELR::RISING_EDGES_INPUT_0 => 0,
                    CKSELR::FALLING_EDGES_INPUT_0 => 0x01,
                    CKSELR::RISING_EDGES_INPUT_1 => 0x02,
                    CKSELR::FALLING_EDGES_INPUT_1 => 0x03,
                    CKSELR::RISING_EDGES_INPUT_2 => 0x04,
                    CKSELR::FALLING_EDGES_INPUT_2 => 0x05,
                    CKSELR::RISING_EDGES_INPUT_3 => 0x06,
                    CKSELR::FALLING_EDGES_INPUT_3 => 0x07,
                    CKSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CKSELR {
                match value {
                    0 => CKSELR::RISING_EDGES_INPUT_0,
                    1 => CKSELR::FALLING_EDGES_INPUT_0,
                    2 => CKSELR::RISING_EDGES_INPUT_1,
                    3 => CKSELR::FALLING_EDGES_INPUT_1,
                    4 => CKSELR::RISING_EDGES_INPUT_2,
                    5 => CKSELR::FALLING_EDGES_INPUT_2,
                    6 => CKSELR::RISING_EDGES_INPUT_3,
                    7 => CKSELR::FALLING_EDGES_INPUT_3,
                    i => CKSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_INPUT_0`"]
            #[inline]
            pub fn is_rising_edges_input_0(&self) -> bool {
                *self == CKSELR::RISING_EDGES_INPUT_0
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_INPUT_0`"]
            #[inline]
            pub fn is_falling_edges_input_0(&self) -> bool {
                *self == CKSELR::FALLING_EDGES_INPUT_0
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_INPUT_1`"]
            #[inline]
            pub fn is_rising_edges_input_1(&self) -> bool {
                *self == CKSELR::RISING_EDGES_INPUT_1
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_INPUT_1`"]
            #[inline]
            pub fn is_falling_edges_input_1(&self) -> bool {
                *self == CKSELR::FALLING_EDGES_INPUT_1
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_INPUT_2`"]
            #[inline]
            pub fn is_rising_edges_input_2(&self) -> bool {
                *self == CKSELR::RISING_EDGES_INPUT_2
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_INPUT_2`"]
            #[inline]
            pub fn is_falling_edges_input_2(&self) -> bool {
                *self == CKSELR::FALLING_EDGES_INPUT_2
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_INPUT_3`"]
            #[inline]
            pub fn is_rising_edges_input_3(&self) -> bool {
                *self == CKSELR::RISING_EDGES_INPUT_3
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_INPUT_3`"]
            #[inline]
            pub fn is_falling_edges_input_3(&self) -> bool {
                *self == CKSELR::FALLING_EDGES_INPUT_3
            }
        }
        #[doc = r" Value of the field"]
        pub struct NORELAOD_LR {
            bits: bool,
        }
        impl NORELAOD_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NORELOAD_HR {
            bits: bool,
        }
        impl NORELOAD_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INSYNCR {
            bits: u8,
        }
        impl INSYNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUTOLIMIT_LR {
            bits: bool,
        }
        impl AUTOLIMIT_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUTOLIMIT_HR {
            bits: bool,
        }
        impl AUTOLIMIT_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `UNIFY`"]
        pub enum UNIFYW {
            #[doc = "The SCT operates as two 16-bit counters named L and H."]
            LHCOUNTER,
            #[doc = "The SCT operates as a unified 32-bit counter."]
            UNIFIEDCOUNTER,
        }
        impl UNIFYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UNIFYW::LHCOUNTER => false,
                    UNIFYW::UNIFIEDCOUNTER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNIFYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNIFYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UNIFYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SCT operates as two 16-bit counters named L and H."]
            #[inline]
            pub fn lhcounter(self) -> &'a mut W {
                self.variant(UNIFYW::LHCOUNTER)
            }
            #[doc = "The SCT operates as a unified 32-bit counter."]
            #[inline]
            pub fn unifiedcounter(self) -> &'a mut W {
                self.variant(UNIFYW::UNIFIEDCOUNTER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKMODE`"]
        pub enum CLKMODEW {
            #[doc = "The bus clock clocks the SCT and prescalers."]
            THE_BUS_CLOCK_CLOCKS,
            #[doc = "The SCT clock is the bus clock, but the prescalers are  enabled to count only when sampling of the input selected by  the CKSEL field finds the selected edge. The minimum pulse  width on the clock input is 1 bus clock period. This mode is the high-performance  sampled-clock mode."]
            THE_SCT_CLOCK_IS_THE,
            #[doc = "The input selected by  CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted.  The minimum pulse width on the clock input is 1 bus clock  period. This mode is the low-power sampled-clock mode."]
            THE_INPUT_SELECTED_B,
            #[doc = "Prescaled SCT input. The SCT and prescalers are clocked by the input edge  selected by the CKSEL field. In this mode, most of the SCT is clocked by the (selected polarity of the)  input. The outputs are switched synchronously to the input clock. The input clock rate must be at least half the system clock rate and  can the same or faster than the system clock."]
            PRESCALED_SCT_INPUT,
        }
        impl CLKMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLKMODEW::THE_BUS_CLOCK_CLOCKS => 0,
                    CLKMODEW::THE_SCT_CLOCK_IS_THE => 1,
                    CLKMODEW::THE_INPUT_SELECTED_B => 2,
                    CLKMODEW::PRESCALED_SCT_INPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLKMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "The bus clock clocks the SCT and prescalers."]
            #[inline]
            pub fn the_bus_clock_clocks(self) -> &'a mut W {
                self.variant(CLKMODEW::THE_BUS_CLOCK_CLOCKS)
            }
            #[doc = "The SCT clock is the bus clock, but the prescalers are enabled to count only when sampling of the input selected by the CKSEL field finds the selected edge. The minimum pulse width on the clock input is 1 bus clock period. This mode is the high-performance sampled-clock mode."]
            #[inline]
            pub fn the_sct_clock_is_the(self) -> &'a mut W {
                self.variant(CLKMODEW::THE_SCT_CLOCK_IS_THE)
            }
            #[doc = "The input selected by CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted. The minimum pulse width on the clock input is 1 bus clock period. This mode is the low-power sampled-clock mode."]
            #[inline]
            pub fn the_input_selected_b(self) -> &'a mut W {
                self.variant(CLKMODEW::THE_INPUT_SELECTED_B)
            }
            #[doc = "Prescaled SCT input. The SCT and prescalers are clocked by the input edge selected by the CKSEL field. In this mode, most of the SCT is clocked by the (selected polarity of the) input. The outputs are switched synchronously to the input clock. The input clock rate must be at least half the system clock rate and can the same or faster than the system clock."]
            #[inline]
            pub fn prescaled_sct_input(self) -> &'a mut W {
                self.variant(CLKMODEW::PRESCALED_SCT_INPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CKSEL`"]
        pub enum CKSELW {
            #[doc = "Rising edges on input 0."]
            RISING_EDGES_INPUT_0,
            #[doc = "Falling edges on input 0."]
            FALLING_EDGES_INPUT_0,
            #[doc = "Rising edges on input 1."]
            RISING_EDGES_INPUT_1,
            #[doc = "Falling edges on input 1."]
            FALLING_EDGES_INPUT_1,
            #[doc = "Rising edges on input 2."]
            RISING_EDGES_INPUT_2,
            #[doc = "Falling edges on input 2."]
            FALLING_EDGES_INPUT_2,
            #[doc = "Rising edges on input 3."]
            RISING_EDGES_INPUT_3,
            #[doc = "Falling edges on input 3."]
            FALLING_EDGES_INPUT_3,
        }
        impl CKSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CKSELW::RISING_EDGES_INPUT_0 => 0,
                    CKSELW::FALLING_EDGES_INPUT_0 => 1,
                    CKSELW::RISING_EDGES_INPUT_1 => 2,
                    CKSELW::FALLING_EDGES_INPUT_1 => 3,
                    CKSELW::RISING_EDGES_INPUT_2 => 4,
                    CKSELW::FALLING_EDGES_INPUT_2 => 5,
                    CKSELW::RISING_EDGES_INPUT_3 => 6,
                    CKSELW::FALLING_EDGES_INPUT_3 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CKSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Rising edges on input 0."]
            #[inline]
            pub fn rising_edges_input_0(self) -> &'a mut W {
                self.variant(CKSELW::RISING_EDGES_INPUT_0)
            }
            #[doc = "Falling edges on input 0."]
            #[inline]
            pub fn falling_edges_input_0(self) -> &'a mut W {
                self.variant(CKSELW::FALLING_EDGES_INPUT_0)
            }
            #[doc = "Rising edges on input 1."]
            #[inline]
            pub fn rising_edges_input_1(self) -> &'a mut W {
                self.variant(CKSELW::RISING_EDGES_INPUT_1)
            }
            #[doc = "Falling edges on input 1."]
            #[inline]
            pub fn falling_edges_input_1(self) -> &'a mut W {
                self.variant(CKSELW::FALLING_EDGES_INPUT_1)
            }
            #[doc = "Rising edges on input 2."]
            #[inline]
            pub fn rising_edges_input_2(self) -> &'a mut W {
                self.variant(CKSELW::RISING_EDGES_INPUT_2)
            }
            #[doc = "Falling edges on input 2."]
            #[inline]
            pub fn falling_edges_input_2(self) -> &'a mut W {
                self.variant(CKSELW::FALLING_EDGES_INPUT_2)
            }
            #[doc = "Rising edges on input 3."]
            #[inline]
            pub fn rising_edges_input_3(self) -> &'a mut W {
                self.variant(CKSELW::RISING_EDGES_INPUT_3)
            }
            #[doc = "Falling edges on input 3."]
            #[inline]
            pub fn falling_edges_input_3(self) -> &'a mut W {
                self.variant(CKSELW::FALLING_EDGES_INPUT_3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NORELAOD_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NORELAOD_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NORELOAD_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NORELOAD_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INSYNCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOLIMIT_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOLIMIT_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOLIMIT_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOLIMIT_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SCT operation"]
            #[inline]
            pub fn unify(&self) -> UNIFYR {
                UNIFYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:2 - SCT clock mode"]
            #[inline]
            pub fn clkmode(&self) -> CLKMODER {
                CLKMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:6 - SCT clock select"]
            #[inline]
            pub fn cksel(&self) -> CKSELR {
                CKSELR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - A 1 in this bit prevents the lower match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline]
            pub fn norelaod_l(&self) -> NORELAOD_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NORELAOD_LR { bits }
            }
            #[doc = "Bit 8 - A 1 in this bit prevents the higher match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline]
            pub fn noreload_h(&self) -> NORELOAD_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NORELOAD_HR { bits }
            }
            #[doc = "Bits 9:16 - Synchronization for input N (bit 9 = input 0, bit 10 = input 1,..., bit 12 = input 3); all other bits are reserved. A 1 in one of these bits subjects the corresponding input to synchronization to the SCT clock, before it is used to create an event. If an input is synchronous to the SCT clock, keep its bit 0 for faster response. When the CKMODE field is 1x, the bit in this field, corresponding to the input selected by the CKSEL field, is not used."]
            #[inline]
            pub fn insync(&self) -> INSYNCR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INSYNCR { bits }
            }
            #[doc = "Bit 17 - A one in this bit causes a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline]
            pub fn autolimit_l(&self) -> AUTOLIMIT_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AUTOLIMIT_LR { bits }
            }
            #[doc = "Bit 18 - A one in this bit will cause a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline]
            pub fn autolimit_h(&self) -> AUTOLIMIT_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AUTOLIMIT_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x7e00 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SCT operation"]
            #[inline]
            pub fn unify(&mut self) -> _UNIFYW {
                _UNIFYW { w: self }
            }
            #[doc = "Bits 1:2 - SCT clock mode"]
            #[inline]
            pub fn clkmode(&mut self) -> _CLKMODEW {
                _CLKMODEW { w: self }
            }
            #[doc = "Bits 3:6 - SCT clock select"]
            #[inline]
            pub fn cksel(&mut self) -> _CKSELW {
                _CKSELW { w: self }
            }
            #[doc = "Bit 7 - A 1 in this bit prevents the lower match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline]
            pub fn norelaod_l(&mut self) -> _NORELAOD_LW {
                _NORELAOD_LW { w: self }
            }
            #[doc = "Bit 8 - A 1 in this bit prevents the higher match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline]
            pub fn noreload_h(&mut self) -> _NORELOAD_HW {
                _NORELOAD_HW { w: self }
            }
            #[doc = "Bits 9:16 - Synchronization for input N (bit 9 = input 0, bit 10 = input 1,..., bit 12 = input 3); all other bits are reserved. A 1 in one of these bits subjects the corresponding input to synchronization to the SCT clock, before it is used to create an event. If an input is synchronous to the SCT clock, keep its bit 0 for faster response. When the CKMODE field is 1x, the bit in this field, corresponding to the input selected by the CKSEL field, is not used."]
            #[inline]
            pub fn insync(&mut self) -> _INSYNCW {
                _INSYNCW { w: self }
            }
            #[doc = "Bit 17 - A one in this bit causes a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline]
            pub fn autolimit_l(&mut self) -> _AUTOLIMIT_LW {
                _AUTOLIMIT_LW { w: self }
            }
            #[doc = "Bit 18 - A one in this bit will cause a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline]
            pub fn autolimit_h(&mut self) -> _AUTOLIMIT_HW {
                _AUTOLIMIT_HW { w: self }
            }
        }
    }
    #[doc = "SCT control register"]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT control register"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DOWN_LR {
            bits: bool,
        }
        impl DOWN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_LR {
            bits: bool,
        }
        impl STOP_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALT_LR {
            bits: bool,
        }
        impl HALT_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRCTR_LR {
            bits: bool,
        }
        impl CLRCTR_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BIDIR_L`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIR_LR {
            #[doc = "The counter counts up to its limit condition, then is cleared to zero."]
            UP,
            #[doc = "The counter counts up to its limit, then counts down to a limit condition or to 0."]
            UPDOWN,
        }
        impl BIDIR_LR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BIDIR_LR::UP => false,
                    BIDIR_LR::UPDOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BIDIR_LR {
                match value {
                    false => BIDIR_LR::UP,
                    true => BIDIR_LR::UPDOWN,
                }
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline]
            pub fn is_up(&self) -> bool {
                *self == BIDIR_LR::UP
            }
            #[doc = "Checks if the value of the field is `UPDOWN`"]
            #[inline]
            pub fn is_updown(&self) -> bool {
                *self == BIDIR_LR::UPDOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRE_LR {
            bits: u8,
        }
        impl PRE_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DOWN_HR {
            bits: bool,
        }
        impl DOWN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_HR {
            bits: bool,
        }
        impl STOP_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALT_HR {
            bits: bool,
        }
        impl HALT_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRCTR_HR {
            bits: bool,
        }
        impl CLRCTR_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BIDIR_H`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIR_HR {
            #[doc = "The H counter counts up to its limit condition, then is cleared to zero."]
            UP,
            #[doc = "The H counter counts up to its limit, then counts down to a limit condition or to 0."]
            UPDOWN,
        }
        impl BIDIR_HR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BIDIR_HR::UP => false,
                    BIDIR_HR::UPDOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BIDIR_HR {
                match value {
                    false => BIDIR_HR::UP,
                    true => BIDIR_HR::UPDOWN,
                }
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline]
            pub fn is_up(&self) -> bool {
                *self == BIDIR_HR::UP
            }
            #[doc = "Checks if the value of the field is `UPDOWN`"]
            #[inline]
            pub fn is_updown(&self) -> bool {
                *self == BIDIR_HR::UPDOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRE_HR {
            bits: u8,
        }
        impl PRE_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOWN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOWN_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOP_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOP_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALT_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALT_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRCTR_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRCTR_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BIDIR_L`"]
        pub enum BIDIR_LW {
            #[doc = "The counter counts up to its limit condition, then is cleared to zero."]
            UP,
            #[doc = "The counter counts up to its limit, then counts down to a limit condition or to 0."]
            UPDOWN,
        }
        impl BIDIR_LW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BIDIR_LW::UP => false,
                    BIDIR_LW::UPDOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIDIR_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIDIR_LW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BIDIR_LW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The counter counts up to its limit condition, then is cleared to zero."]
            #[inline]
            pub fn up(self) -> &'a mut W {
                self.variant(BIDIR_LW::UP)
            }
            #[doc = "The counter counts up to its limit, then counts down to a limit condition or to 0."]
            #[inline]
            pub fn updown(self) -> &'a mut W {
                self.variant(BIDIR_LW::UPDOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRE_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRE_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOWN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOWN_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOP_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOP_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALT_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALT_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRCTR_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRCTR_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BIDIR_H`"]
        pub enum BIDIR_HW {
            #[doc = "The H counter counts up to its limit condition, then is cleared to zero."]
            UP,
            #[doc = "The H counter counts up to its limit, then counts down to a limit condition or to 0."]
            UPDOWN,
        }
        impl BIDIR_HW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BIDIR_HW::UP => false,
                    BIDIR_HW::UPDOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIDIR_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIDIR_HW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BIDIR_HW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The H counter counts up to its limit condition, then is cleared to zero."]
            #[inline]
            pub fn up(self) -> &'a mut W {
                self.variant(BIDIR_HW::UP)
            }
            #[doc = "The H counter counts up to its limit, then counts down to a limit condition or to 0."]
            #[inline]
            pub fn updown(self) -> &'a mut W {
                self.variant(BIDIR_HW::UPDOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRE_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRE_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - This bit is 1 when the L or unified counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline]
            pub fn down_l(&self) -> DOWN_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DOWN_LR { bits }
            }
            #[doc = "Bit 1 - When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline]
            pub fn stop_l(&self) -> STOP_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_LR { bits }
            }
            #[doc = "Bit 2 - When this bit is 1, the L or unified counter does not run and no events can occur. A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, only software can clear this bit to restore counter operation."]
            #[inline]
            pub fn halt_l(&self) -> HALT_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HALT_LR { bits }
            }
            #[doc = "Bit 3 - Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0."]
            #[inline]
            pub fn clrctr_l(&self) -> CLRCTR_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRCTR_LR { bits }
            }
            #[doc = "Bit 4 - L or unified counter direction select"]
            #[inline]
            pub fn bidir_l(&self) -> BIDIR_LR {
                BIDIR_LR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 5:12 - Specifies the factor by which the SCT clock is prescaled to produce the L or unified counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRE_L+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline]
            pub fn pre_l(&self) -> PRE_LR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRE_LR { bits }
            }
            #[doc = "Bit 16 - This bit is 1 when the H counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline]
            pub fn down_h(&self) -> DOWN_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DOWN_HR { bits }
            }
            #[doc = "Bit 17 - When this bit is 1 and HALT is 0, the H counter does not, run but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline]
            pub fn stop_h(&self) -> STOP_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_HR { bits }
            }
            #[doc = "Bit 18 - When this bit is 1, the H counter does not run and no events can occur. A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, this bit can only be cleared by software to restore counter operation."]
            #[inline]
            pub fn halt_h(&self) -> HALT_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HALT_HR { bits }
            }
            #[doc = "Bit 19 - Writing a 1 to this bit clears the H counter. This bit always reads as 0."]
            #[inline]
            pub fn clrctr_h(&self) -> CLRCTR_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRCTR_HR { bits }
            }
            #[doc = "Bit 20 - Direction select"]
            #[inline]
            pub fn bidir_h(&self) -> BIDIR_HR {
                BIDIR_HR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 21:28 - Specifies the factor by which the SCT clock is prescaled to produce the H counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRELH+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline]
            pub fn pre_h(&self) -> PRE_HR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRE_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0004_0004 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - This bit is 1 when the L or unified counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline]
            pub fn down_l(&mut self) -> _DOWN_LW {
                _DOWN_LW { w: self }
            }
            #[doc = "Bit 1 - When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline]
            pub fn stop_l(&mut self) -> _STOP_LW {
                _STOP_LW { w: self }
            }
            #[doc = "Bit 2 - When this bit is 1, the L or unified counter does not run and no events can occur. A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, only software can clear this bit to restore counter operation."]
            #[inline]
            pub fn halt_l(&mut self) -> _HALT_LW {
                _HALT_LW { w: self }
            }
            #[doc = "Bit 3 - Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0."]
            #[inline]
            pub fn clrctr_l(&mut self) -> _CLRCTR_LW {
                _CLRCTR_LW { w: self }
            }
            #[doc = "Bit 4 - L or unified counter direction select"]
            #[inline]
            pub fn bidir_l(&mut self) -> _BIDIR_LW {
                _BIDIR_LW { w: self }
            }
            #[doc = "Bits 5:12 - Specifies the factor by which the SCT clock is prescaled to produce the L or unified counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRE_L+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline]
            pub fn pre_l(&mut self) -> _PRE_LW {
                _PRE_LW { w: self }
            }
            #[doc = "Bit 16 - This bit is 1 when the H counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline]
            pub fn down_h(&mut self) -> _DOWN_HW {
                _DOWN_HW { w: self }
            }
            #[doc = "Bit 17 - When this bit is 1 and HALT is 0, the H counter does not, run but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline]
            pub fn stop_h(&mut self) -> _STOP_HW {
                _STOP_HW { w: self }
            }
            #[doc = "Bit 18 - When this bit is 1, the H counter does not run and no events can occur. A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, this bit can only be cleared by software to restore counter operation."]
            #[inline]
            pub fn halt_h(&mut self) -> _HALT_HW {
                _HALT_HW { w: self }
            }
            #[doc = "Bit 19 - Writing a 1 to this bit clears the H counter. This bit always reads as 0."]
            #[inline]
            pub fn clrctr_h(&mut self) -> _CLRCTR_HW {
                _CLRCTR_HW { w: self }
            }
            #[doc = "Bit 20 - Direction select"]
            #[inline]
            pub fn bidir_h(&mut self) -> _BIDIR_HW {
                _BIDIR_HW { w: self }
            }
            #[doc = "Bits 21:28 - Specifies the factor by which the SCT clock is prescaled to produce the H counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRELH+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline]
            pub fn pre_h(&mut self) -> _PRE_HW {
                _PRE_HW { w: self }
            }
        }
    }
    #[doc = "SCT limit register"]
    pub struct LIMIT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT limit register"]
    pub mod limit {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LIMIT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LIMMSK_LR {
            bits: u8,
        }
        impl LIMMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LIMMSK_HR {
            bits: u8,
        }
        impl LIMMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LIMMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LIMMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LIMMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LIMMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn limmsk_l(&self) -> LIMMSK_LR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LIMMSK_LR { bits }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, event 7 = bit 23)."]
            #[inline]
            pub fn limmsk_h(&self) -> LIMMSK_HR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LIMMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn limmsk_l(&mut self) -> _LIMMSK_LW {
                _LIMMSK_LW { w: self }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, event 7 = bit 23)."]
            #[inline]
            pub fn limmsk_h(&mut self) -> _LIMMSK_HW {
                _LIMMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT halt condition register"]
    pub struct HALT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT halt condition register"]
    pub mod halt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::HALT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALTMSK_LR {
            bits: u8,
        }
        impl HALTMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALTMSK_HR {
            bits: u8,
        }
        impl HALTMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn haltmsk_l(&self) -> HALTMSK_LR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HALTMSK_LR { bits }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 7 = bit 23)."]
            #[inline]
            pub fn haltmsk_h(&self) -> HALTMSK_HR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HALTMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn haltmsk_l(&mut self) -> _HALTMSK_LW {
                _HALTMSK_LW { w: self }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 7 = bit 23)."]
            #[inline]
            pub fn haltmsk_h(&mut self) -> _HALTMSK_HW {
                _HALTMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT stop condition register"]
    pub struct STOP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT stop condition register"]
    pub mod stop {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STOP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPMSK_LR {
            bits: u8,
        }
        impl STOPMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPMSK_HR {
            bits: u8,
        }
        impl STOPMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn stopmsk_l(&self) -> STOPMSK_LR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STOPMSK_LR { bits }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 7= bit 23)."]
            #[inline]
            pub fn stopmsk_h(&self) -> STOPMSK_HR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STOPMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn stopmsk_l(&mut self) -> _STOPMSK_LW {
                _STOPMSK_LW { w: self }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 7= bit 23)."]
            #[inline]
            pub fn stopmsk_h(&mut self) -> _STOPMSK_HW {
                _STOPMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT start condition register"]
    pub struct START {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT start condition register"]
    pub mod start {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::START {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTMSK_LR {
            bits: u8,
        }
        impl STARTMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTMSK_HR {
            bits: u8,
        }
        impl STARTMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn startmsk_l(&self) -> STARTMSK_LR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STARTMSK_LR { bits }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 7 = bit 23)."]
            #[inline]
            pub fn startmsk_h(&self) -> STARTMSK_HR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STARTMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 7 = bit 7)."]
            #[inline]
            pub fn startmsk_l(&mut self) -> _STARTMSK_LW {
                _STARTMSK_LW { w: self }
            }
            #[doc = "Bits 16:23 - If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 7 = bit 23)."]
            #[inline]
            pub fn startmsk_h(&mut self) -> _STARTMSK_HW {
                _STARTMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT counter register"]
    pub struct COUNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT counter register"]
    pub mod count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTR_LR {
            bits: u16,
        }
        impl CTR_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTR_HR {
            bits: u16,
        }
        impl CTR_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTR_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTR_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTR_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTR_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter."]
            #[inline]
            pub fn ctr_l(&self) -> CTR_LR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CTR_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter."]
            #[inline]
            pub fn ctr_h(&self) -> CTR_HR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CTR_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter."]
            #[inline]
            pub fn ctr_l(&mut self) -> _CTR_LW {
                _CTR_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter."]
            #[inline]
            pub fn ctr_h(&mut self) -> _CTR_HW {
                _CTR_HW { w: self }
            }
        }
    }
    #[doc = "SCT state register"]
    pub struct STATE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT state register"]
    pub mod state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE_LR {
            bits: u8,
        }
        impl STATE_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE_HR {
            bits: u8,
        }
        impl STATE_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATE_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATE_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATE_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATE_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - State variable."]
            #[inline]
            pub fn state_l(&self) -> STATE_LR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATE_LR { bits }
            }
            #[doc = "Bits 16:20 - State variable."]
            #[inline]
            pub fn state_h(&self) -> STATE_HR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATE_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - State variable."]
            #[inline]
            pub fn state_l(&mut self) -> _STATE_LW {
                _STATE_LW { w: self }
            }
            #[doc = "Bits 16:20 - State variable."]
            #[inline]
            pub fn state_h(&mut self) -> _STATE_HW {
                _STATE_HW { w: self }
            }
        }
    }
    #[doc = "SCT input register"]
    pub struct INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT input register"]
    pub mod input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INPUT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN0R {
            bits: bool,
        }
        impl AIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN1R {
            bits: bool,
        }
        impl AIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN2R {
            bits: bool,
        }
        impl AIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN3R {
            bits: bool,
        }
        impl AIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN0R {
            bits: bool,
        }
        impl SIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN1R {
            bits: bool,
        }
        impl SIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN2R {
            bits: bool,
        }
        impl SIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN3R {
            bits: bool,
        }
        impl SIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - . Input 0 state.Direct read."]
            #[inline]
            pub fn ain0(&self) -> AIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN0R { bits }
            }
            #[doc = "Bit 1 - Input 1 state. Direct read."]
            #[inline]
            pub fn ain1(&self) -> AIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN1R { bits }
            }
            #[doc = "Bit 2 - Input 2 state. Direct read."]
            #[inline]
            pub fn ain2(&self) -> AIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN2R { bits }
            }
            #[doc = "Bit 3 - Input 3 state. Direct read."]
            #[inline]
            pub fn ain3(&self) -> AIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN3R { bits }
            }
            #[doc = "Bit 16 - Input 0 state."]
            #[inline]
            pub fn sin0(&self) -> SIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN0R { bits }
            }
            #[doc = "Bit 17 - Input 1 state."]
            #[inline]
            pub fn sin1(&self) -> SIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN1R { bits }
            }
            #[doc = "Bit 18 - Input 2 state."]
            #[inline]
            pub fn sin2(&self) -> SIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN2R { bits }
            }
            #[doc = "Bit 19 - Input 3 state."]
            #[inline]
            pub fn sin3(&self) -> SIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN3R { bits }
            }
        }
    }
    #[doc = "SCT match/capture registers mode register"]
    pub struct REGMODE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT match/capture registers mode register"]
    pub mod regmode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::REGMODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct REGMOD_LR {
            bits: u8,
        }
        impl REGMOD_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REGMOD_HR {
            bits: u8,
        }
        impl REGMOD_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _REGMOD_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REGMOD_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REGMOD_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REGMOD_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Each bit controls one pair of match/capture registers (register pair 0 = bit 0, register pair 1 = bit 1,..., register pair 7 = bit 7). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline]
            pub fn regmod_l(&self) -> REGMOD_LR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REGMOD_LR { bits }
            }
            #[doc = "Bits 16:23 - Each bit controls one pair of match/capture registers (register 0 = bit 16, register 1 = bit 17,..., register 7 = bit 23). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline]
            pub fn regmod_h(&self) -> REGMOD_HR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REGMOD_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Each bit controls one pair of match/capture registers (register pair 0 = bit 0, register pair 1 = bit 1,..., register pair 7 = bit 7). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline]
            pub fn regmod_l(&mut self) -> _REGMOD_LW {
                _REGMOD_LW { w: self }
            }
            #[doc = "Bits 16:23 - Each bit controls one pair of match/capture registers (register 0 = bit 16, register 1 = bit 17,..., register 7 = bit 23). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline]
            pub fn regmod_h(&mut self) -> _REGMOD_HW {
                _REGMOD_HW { w: self }
            }
        }
    }
    #[doc = "SCT output register"]
    pub struct OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT output register"]
    pub mod output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTR {
            bits: u8,
        }
        impl OUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - Writing a 1 to bit n makes the corresponding output HIGH. 0 makes the corresponding output LOW (output 0 = bit 0, output 1 = bit 1,..., output 5 = bit 5)."]
            #[inline]
            pub fn out(&self) -> OUTR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OUTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Writing a 1 to bit n makes the corresponding output HIGH. 0 makes the corresponding output LOW (output 0 = bit 0, output 1 = bit 1,..., output 5 = bit 5)."]
            #[inline]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
        }
    }
    #[doc = "SCT output counter direction control register"]
    pub struct OUTPUTDIRCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT output counter direction control register"]
    pub mod outputdirctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPUTDIRCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SETCLR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR0R {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR0R::INDEPENDENT => 0,
                    SETCLR0R::REVERSED => 0x01,
                    SETCLR0R::REVERSED_H => 0x02,
                    SETCLR0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SETCLR0R {
                match value {
                    0 => SETCLR0R::INDEPENDENT,
                    1 => SETCLR0R::REVERSED,
                    2 => SETCLR0R::REVERSED_H,
                    i => SETCLR0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INDEPENDENT`"]
            #[inline]
            pub fn is_independent(&self) -> bool {
                *self == SETCLR0R::INDEPENDENT
            }
            #[doc = "Checks if the value of the field is `REVERSED`"]
            #[inline]
            pub fn is_reversed(&self) -> bool {
                *self == SETCLR0R::REVERSED
            }
            #[doc = "Checks if the value of the field is `REVERSED_H`"]
            #[inline]
            pub fn is_reversed_h(&self) -> bool {
                *self == SETCLR0R::REVERSED_H
            }
        }
        #[doc = "Possible values of the field `SETCLR1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR1R {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR1R::INDEPENDENT => 0,
                    SETCLR1R::REVERSED => 0x01,
                    SETCLR1R::REVERSED_H => 0x02,
                    SETCLR1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SETCLR1R {
                match value {
                    0 => SETCLR1R::INDEPENDENT,
                    1 => SETCLR1R::REVERSED,
                    2 => SETCLR1R::REVERSED_H,
                    i => SETCLR1R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INDEPENDENT`"]
            #[inline]
            pub fn is_independent(&self) -> bool {
                *self == SETCLR1R::INDEPENDENT
            }
            #[doc = "Checks if the value of the field is `REVERSED`"]
            #[inline]
            pub fn is_reversed(&self) -> bool {
                *self == SETCLR1R::REVERSED
            }
            #[doc = "Checks if the value of the field is `REVERSED_H`"]
            #[inline]
            pub fn is_reversed_h(&self) -> bool {
                *self == SETCLR1R::REVERSED_H
            }
        }
        #[doc = "Possible values of the field `SETCLR2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR2R {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR2R::INDEPENDENT => 0,
                    SETCLR2R::REVERSED => 0x01,
                    SETCLR2R::REVERSED_H => 0x02,
                    SETCLR2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SETCLR2R {
                match value {
                    0 => SETCLR2R::INDEPENDENT,
                    1 => SETCLR2R::REVERSED,
                    2 => SETCLR2R::REVERSED_H,
                    i => SETCLR2R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INDEPENDENT`"]
            #[inline]
            pub fn is_independent(&self) -> bool {
                *self == SETCLR2R::INDEPENDENT
            }
            #[doc = "Checks if the value of the field is `REVERSED`"]
            #[inline]
            pub fn is_reversed(&self) -> bool {
                *self == SETCLR2R::REVERSED
            }
            #[doc = "Checks if the value of the field is `REVERSED_H`"]
            #[inline]
            pub fn is_reversed_h(&self) -> bool {
                *self == SETCLR2R::REVERSED_H
            }
        }
        #[doc = "Possible values of the field `SETCLR3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR3R {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR3R::INDEPENDENT => 0,
                    SETCLR3R::REVERSED => 0x01,
                    SETCLR3R::REVERSED_H => 0x02,
                    SETCLR3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SETCLR3R {
                match value {
                    0 => SETCLR3R::INDEPENDENT,
                    1 => SETCLR3R::REVERSED,
                    2 => SETCLR3R::REVERSED_H,
                    i => SETCLR3R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INDEPENDENT`"]
            #[inline]
            pub fn is_independent(&self) -> bool {
                *self == SETCLR3R::INDEPENDENT
            }
            #[doc = "Checks if the value of the field is `REVERSED`"]
            #[inline]
            pub fn is_reversed(&self) -> bool {
                *self == SETCLR3R::REVERSED
            }
            #[doc = "Checks if the value of the field is `REVERSED_H`"]
            #[inline]
            pub fn is_reversed_h(&self) -> bool {
                *self == SETCLR3R::REVERSED_H
            }
        }
        #[doc = "Possible values of the field `SETCLR4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR4R {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR4R::INDEPENDENT => 0,
                    SETCLR4R::REVERSED => 0x01,
                    SETCLR4R::REVERSED_H => 0x02,
                    SETCLR4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SETCLR4R {
                match value {
                    0 => SETCLR4R::INDEPENDENT,
                    1 => SETCLR4R::REVERSED,
                    2 => SETCLR4R::REVERSED_H,
                    i => SETCLR4R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INDEPENDENT`"]
            #[inline]
            pub fn is_independent(&self) -> bool {
                *self == SETCLR4R::INDEPENDENT
            }
            #[doc = "Checks if the value of the field is `REVERSED`"]
            #[inline]
            pub fn is_reversed(&self) -> bool {
                *self == SETCLR4R::REVERSED
            }
            #[doc = "Checks if the value of the field is `REVERSED_H`"]
            #[inline]
            pub fn is_reversed_h(&self) -> bool {
                *self == SETCLR4R::REVERSED_H
            }
        }
        #[doc = "Possible values of the field `SETCLR5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR5R {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR5R::INDEPENDENT => 0,
                    SETCLR5R::REVERSED => 0x01,
                    SETCLR5R::REVERSED_H => 0x02,
                    SETCLR5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SETCLR5R {
                match value {
                    0 => SETCLR5R::INDEPENDENT,
                    1 => SETCLR5R::REVERSED,
                    2 => SETCLR5R::REVERSED_H,
                    i => SETCLR5R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INDEPENDENT`"]
            #[inline]
            pub fn is_independent(&self) -> bool {
                *self == SETCLR5R::INDEPENDENT
            }
            #[doc = "Checks if the value of the field is `REVERSED`"]
            #[inline]
            pub fn is_reversed(&self) -> bool {
                *self == SETCLR5R::REVERSED
            }
            #[doc = "Checks if the value of the field is `REVERSED_H`"]
            #[inline]
            pub fn is_reversed_h(&self) -> bool {
                *self == SETCLR5R::REVERSED_H
            }
        }
        #[doc = "Values that can be written to the field `SETCLR0`"]
        pub enum SETCLR0W {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
        }
        impl SETCLR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR0W::INDEPENDENT => 0,
                    SETCLR0W::REVERSED => 1,
                    SETCLR0W::REVERSED_H => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETCLR0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline]
            pub fn independent(self) -> &'a mut W {
                self.variant(SETCLR0W::INDEPENDENT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline]
            pub fn reversed(self) -> &'a mut W {
                self.variant(SETCLR0W::REVERSED)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline]
            pub fn reversed_h(self) -> &'a mut W {
                self.variant(SETCLR0W::REVERSED_H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR1`"]
        pub enum SETCLR1W {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
        }
        impl SETCLR1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR1W::INDEPENDENT => 0,
                    SETCLR1W::REVERSED => 1,
                    SETCLR1W::REVERSED_H => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETCLR1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline]
            pub fn independent(self) -> &'a mut W {
                self.variant(SETCLR1W::INDEPENDENT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline]
            pub fn reversed(self) -> &'a mut W {
                self.variant(SETCLR1W::REVERSED)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline]
            pub fn reversed_h(self) -> &'a mut W {
                self.variant(SETCLR1W::REVERSED_H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR2`"]
        pub enum SETCLR2W {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
        }
        impl SETCLR2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR2W::INDEPENDENT => 0,
                    SETCLR2W::REVERSED => 1,
                    SETCLR2W::REVERSED_H => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETCLR2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline]
            pub fn independent(self) -> &'a mut W {
                self.variant(SETCLR2W::INDEPENDENT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline]
            pub fn reversed(self) -> &'a mut W {
                self.variant(SETCLR2W::REVERSED)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline]
            pub fn reversed_h(self) -> &'a mut W {
                self.variant(SETCLR2W::REVERSED_H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR3`"]
        pub enum SETCLR3W {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
        }
        impl SETCLR3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR3W::INDEPENDENT => 0,
                    SETCLR3W::REVERSED => 1,
                    SETCLR3W::REVERSED_H => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETCLR3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline]
            pub fn independent(self) -> &'a mut W {
                self.variant(SETCLR3W::INDEPENDENT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline]
            pub fn reversed(self) -> &'a mut W {
                self.variant(SETCLR3W::REVERSED)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline]
            pub fn reversed_h(self) -> &'a mut W {
                self.variant(SETCLR3W::REVERSED_H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR4`"]
        pub enum SETCLR4W {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
        }
        impl SETCLR4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR4W::INDEPENDENT => 0,
                    SETCLR4W::REVERSED => 1,
                    SETCLR4W::REVERSED_H => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETCLR4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline]
            pub fn independent(self) -> &'a mut W {
                self.variant(SETCLR4W::INDEPENDENT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline]
            pub fn reversed(self) -> &'a mut W {
                self.variant(SETCLR4W::REVERSED)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline]
            pub fn reversed_h(self) -> &'a mut W {
                self.variant(SETCLR4W::REVERSED_H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR5`"]
        pub enum SETCLR5W {
            #[doc = "Set and clear do not depend on any counter."]
            INDEPENDENT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            REVERSED,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            REVERSED_H,
        }
        impl SETCLR5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR5W::INDEPENDENT => 0,
                    SETCLR5W::REVERSED => 1,
                    SETCLR5W::REVERSED_H => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETCLR5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline]
            pub fn independent(self) -> &'a mut W {
                self.variant(SETCLR5W::INDEPENDENT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline]
            pub fn reversed(self) -> &'a mut W {
                self.variant(SETCLR5W::REVERSED)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline]
            pub fn reversed_h(self) -> &'a mut W {
                self.variant(SETCLR5W::REVERSED_H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr0(&self) -> SETCLR0R {
                SETCLR0R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr1(&self) -> SETCLR1R {
                SETCLR1R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr2(&self) -> SETCLR2R {
                SETCLR2R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr3(&self) -> SETCLR3R {
                SETCLR3R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:9 - Set/clear operation on output 4. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr4(&self) -> SETCLR4R {
                SETCLR4R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 10:11 - Set/clear operation on output 5. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr5(&self) -> SETCLR5R {
                SETCLR5R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr0(&mut self) -> _SETCLR0W {
                _SETCLR0W { w: self }
            }
            #[doc = "Bits 2:3 - Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr1(&mut self) -> _SETCLR1W {
                _SETCLR1W { w: self }
            }
            #[doc = "Bits 4:5 - Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr2(&mut self) -> _SETCLR2W {
                _SETCLR2W { w: self }
            }
            #[doc = "Bits 6:7 - Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr3(&mut self) -> _SETCLR3W {
                _SETCLR3W { w: self }
            }
            #[doc = "Bits 8:9 - Set/clear operation on output 4. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr4(&mut self) -> _SETCLR4W {
                _SETCLR4W { w: self }
            }
            #[doc = "Bits 10:11 - Set/clear operation on output 5. Value 0x3 is reserved. Do not program this value."]
            #[inline]
            pub fn setclr5(&mut self) -> _SETCLR5W {
                _SETCLR5W { w: self }
            }
        }
    }
    #[doc = "SCT conflict resolution register"]
    pub struct RES {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT conflict resolution register"]
    pub mod res {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RES {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `O0RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O0RESR {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR0 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR0 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O0RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    O0RESR::NO_CHANGE => 0,
                    O0RESR::SET_OUTPUT_OR_CLEAR => 0x01,
                    O0RESR::CLEAR_OUTPUT_OR_SET => 0x02,
                    O0RESR::TOGGLE_OUTPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> O0RESR {
                match value {
                    0 => O0RESR::NO_CHANGE,
                    1 => O0RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O0RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O0RESR::TOGGLE_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == O0RESR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O0RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O0RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT`"]
            #[inline]
            pub fn is_toggle_output(&self) -> bool {
                *self == O0RESR::TOGGLE_OUTPUT
            }
        }
        #[doc = "Possible values of the field `O1RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O1RESR {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR1 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR1 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O1RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    O1RESR::NO_CHANGE => 0,
                    O1RESR::SET_OUTPUT_OR_CLEAR => 0x01,
                    O1RESR::CLEAR_OUTPUT_OR_SET => 0x02,
                    O1RESR::TOGGLE_OUTPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> O1RESR {
                match value {
                    0 => O1RESR::NO_CHANGE,
                    1 => O1RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O1RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O1RESR::TOGGLE_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == O1RESR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O1RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O1RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT`"]
            #[inline]
            pub fn is_toggle_output(&self) -> bool {
                *self == O1RESR::TOGGLE_OUTPUT
            }
        }
        #[doc = "Possible values of the field `O2RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O2RESR {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR2 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output n (or set based on the SETCLR2 field)."]
            CLEAR_OUTPUT_N_OR_S,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O2RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    O2RESR::NO_CHANGE => 0,
                    O2RESR::SET_OUTPUT_OR_CLEAR => 0x01,
                    O2RESR::CLEAR_OUTPUT_N_OR_S => 0x02,
                    O2RESR::TOGGLE_OUTPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> O2RESR {
                match value {
                    0 => O2RESR::NO_CHANGE,
                    1 => O2RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O2RESR::CLEAR_OUTPUT_N_OR_S,
                    3 => O2RESR::TOGGLE_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == O2RESR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O2RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_N_OR_S`"]
            #[inline]
            pub fn is_clear_output_n_or_s(&self) -> bool {
                *self == O2RESR::CLEAR_OUTPUT_N_OR_S
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT`"]
            #[inline]
            pub fn is_toggle_output(&self) -> bool {
                *self == O2RESR::TOGGLE_OUTPUT
            }
        }
        #[doc = "Possible values of the field `O3RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O3RESR {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR3 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR3 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O3RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    O3RESR::NO_CHANGE => 0,
                    O3RESR::SET_OUTPUT_OR_CLEAR => 0x01,
                    O3RESR::CLEAR_OUTPUT_OR_SET => 0x02,
                    O3RESR::TOGGLE_OUTPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> O3RESR {
                match value {
                    0 => O3RESR::NO_CHANGE,
                    1 => O3RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O3RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O3RESR::TOGGLE_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == O3RESR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O3RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O3RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT`"]
            #[inline]
            pub fn is_toggle_output(&self) -> bool {
                *self == O3RESR::TOGGLE_OUTPUT
            }
        }
        #[doc = "Possible values of the field `O4RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O4RESR {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR4 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR4 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O4RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    O4RESR::NO_CHANGE => 0,
                    O4RESR::SET_OUTPUT_OR_CLEAR => 0x01,
                    O4RESR::CLEAR_OUTPUT_OR_SET => 0x02,
                    O4RESR::TOGGLE_OUTPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> O4RESR {
                match value {
                    0 => O4RESR::NO_CHANGE,
                    1 => O4RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O4RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O4RESR::TOGGLE_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == O4RESR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O4RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O4RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT`"]
            #[inline]
            pub fn is_toggle_output(&self) -> bool {
                *self == O4RESR::TOGGLE_OUTPUT
            }
        }
        #[doc = "Possible values of the field `O5RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O5RESR {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR5 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR5 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O5RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    O5RESR::NO_CHANGE => 0,
                    O5RESR::SET_OUTPUT_OR_CLEAR => 0x01,
                    O5RESR::CLEAR_OUTPUT_OR_SET => 0x02,
                    O5RESR::TOGGLE_OUTPUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> O5RESR {
                match value {
                    0 => O5RESR::NO_CHANGE,
                    1 => O5RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O5RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O5RESR::TOGGLE_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == O5RESR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O5RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O5RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT`"]
            #[inline]
            pub fn is_toggle_output(&self) -> bool {
                *self == O5RESR::TOGGLE_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `O0RES`"]
        pub enum O0RESW {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR0 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR0 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O0RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O0RESW::NO_CHANGE => 0,
                    O0RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O0RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O0RESW::TOGGLE_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O0RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O0RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: O0RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(O0RESW::NO_CHANGE)
            }
            #[doc = "Set output (or clear based on the SETCLR0 field)."]
            #[inline]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O0RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR0 field)."]
            #[inline]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O0RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline]
            pub fn toggle_output(self) -> &'a mut W {
                self.variant(O0RESW::TOGGLE_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O1RES`"]
        pub enum O1RESW {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR1 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR1 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O1RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O1RESW::NO_CHANGE => 0,
                    O1RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O1RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O1RESW::TOGGLE_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O1RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O1RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: O1RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(O1RESW::NO_CHANGE)
            }
            #[doc = "Set output (or clear based on the SETCLR1 field)."]
            #[inline]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O1RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR1 field)."]
            #[inline]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O1RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline]
            pub fn toggle_output(self) -> &'a mut W {
                self.variant(O1RESW::TOGGLE_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O2RES`"]
        pub enum O2RESW {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR2 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output n (or set based on the SETCLR2 field)."]
            CLEAR_OUTPUT_N_OR_S,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O2RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O2RESW::NO_CHANGE => 0,
                    O2RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O2RESW::CLEAR_OUTPUT_N_OR_S => 2,
                    O2RESW::TOGGLE_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O2RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O2RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: O2RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(O2RESW::NO_CHANGE)
            }
            #[doc = "Set output (or clear based on the SETCLR2 field)."]
            #[inline]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O2RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output n (or set based on the SETCLR2 field)."]
            #[inline]
            pub fn clear_output_n_or_s(self) -> &'a mut W {
                self.variant(O2RESW::CLEAR_OUTPUT_N_OR_S)
            }
            #[doc = "Toggle output."]
            #[inline]
            pub fn toggle_output(self) -> &'a mut W {
                self.variant(O2RESW::TOGGLE_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O3RES`"]
        pub enum O3RESW {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR3 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR3 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O3RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O3RESW::NO_CHANGE => 0,
                    O3RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O3RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O3RESW::TOGGLE_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O3RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O3RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: O3RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(O3RESW::NO_CHANGE)
            }
            #[doc = "Set output (or clear based on the SETCLR3 field)."]
            #[inline]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O3RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR3 field)."]
            #[inline]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O3RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline]
            pub fn toggle_output(self) -> &'a mut W {
                self.variant(O3RESW::TOGGLE_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O4RES`"]
        pub enum O4RESW {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR4 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR4 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O4RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O4RESW::NO_CHANGE => 0,
                    O4RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O4RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O4RESW::TOGGLE_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O4RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O4RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: O4RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(O4RESW::NO_CHANGE)
            }
            #[doc = "Set output (or clear based on the SETCLR4 field)."]
            #[inline]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O4RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR4 field)."]
            #[inline]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O4RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline]
            pub fn toggle_output(self) -> &'a mut W {
                self.variant(O4RESW::TOGGLE_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O5RES`"]
        pub enum O5RESW {
            #[doc = "No change."]
            NO_CHANGE,
            #[doc = "Set output (or clear based on the SETCLR5 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR5 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT,
        }
        impl O5RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O5RESW::NO_CHANGE => 0,
                    O5RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O5RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O5RESW::TOGGLE_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O5RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O5RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: O5RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(O5RESW::NO_CHANGE)
            }
            #[doc = "Set output (or clear based on the SETCLR5 field)."]
            #[inline]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O5RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR5 field)."]
            #[inline]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O5RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline]
            pub fn toggle_output(self) -> &'a mut W {
                self.variant(O5RESW::TOGGLE_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Effect of simultaneous set and clear on output 0."]
            #[inline]
            pub fn o0res(&self) -> O0RESR {
                O0RESR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Effect of simultaneous set and clear on output 1."]
            #[inline]
            pub fn o1res(&self) -> O1RESR {
                O1RESR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Effect of simultaneous set and clear on output 2."]
            #[inline]
            pub fn o2res(&self) -> O2RESR {
                O2RESR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - Effect of simultaneous set and clear on output 3."]
            #[inline]
            pub fn o3res(&self) -> O3RESR {
                O3RESR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:9 - Effect of simultaneous set and clear on output 4."]
            #[inline]
            pub fn o4res(&self) -> O4RESR {
                O4RESR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 10:11 - Effect of simultaneous set and clear on output 5."]
            #[inline]
            pub fn o5res(&self) -> O5RESR {
                O5RESR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Effect of simultaneous set and clear on output 0."]
            #[inline]
            pub fn o0res(&mut self) -> _O0RESW {
                _O0RESW { w: self }
            }
            #[doc = "Bits 2:3 - Effect of simultaneous set and clear on output 1."]
            #[inline]
            pub fn o1res(&mut self) -> _O1RESW {
                _O1RESW { w: self }
            }
            #[doc = "Bits 4:5 - Effect of simultaneous set and clear on output 2."]
            #[inline]
            pub fn o2res(&mut self) -> _O2RESW {
                _O2RESW { w: self }
            }
            #[doc = "Bits 6:7 - Effect of simultaneous set and clear on output 3."]
            #[inline]
            pub fn o3res(&mut self) -> _O3RESW {
                _O3RESW { w: self }
            }
            #[doc = "Bits 8:9 - Effect of simultaneous set and clear on output 4."]
            #[inline]
            pub fn o4res(&mut self) -> _O4RESW {
                _O4RESW { w: self }
            }
            #[doc = "Bits 10:11 - Effect of simultaneous set and clear on output 5."]
            #[inline]
            pub fn o5res(&mut self) -> _O5RESW {
                _O5RESW { w: self }
            }
        }
    }
    #[doc = "SCT DMA request 0 register"]
    pub struct DMAREQ0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT DMA request 0 register"]
    pub mod dmareq0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMAREQ0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEV_0R {
            bits: u8,
        }
        impl DEV_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRL0R {
            bits: bool,
        }
        impl DRL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRQ0R {
            bits: bool,
        }
        impl DRQ0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEV_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEV_0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRL0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRQ0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRQ0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets DMA request 0 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline]
            pub fn dev_0(&self) -> DEV_0R {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DEV_0R { bits }
            }
            #[doc = "Bit 30 - A 1 in this bit makes the SCT set DMA request 0 when it loads the Match_L/Unified registers from the Reload_L/Unified registers."]
            #[inline]
            pub fn drl0(&self) -> DRL0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DRL0R { bits }
            }
            #[doc = "Bit 31 - This read-only bit indicates the state of DMA Request 0"]
            #[inline]
            pub fn drq0(&self) -> DRQ0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DRQ0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets DMA request 0 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline]
            pub fn dev_0(&mut self) -> _DEV_0W {
                _DEV_0W { w: self }
            }
            #[doc = "Bit 30 - A 1 in this bit makes the SCT set DMA request 0 when it loads the Match_L/Unified registers from the Reload_L/Unified registers."]
            #[inline]
            pub fn drl0(&mut self) -> _DRL0W {
                _DRL0W { w: self }
            }
            #[doc = "Bit 31 - This read-only bit indicates the state of DMA Request 0"]
            #[inline]
            pub fn drq0(&mut self) -> _DRQ0W {
                _DRQ0W { w: self }
            }
        }
    }
    #[doc = "SCT DMA request 1 register"]
    pub struct DMAREQ1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT DMA request 1 register"]
    pub mod dmareq1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMAREQ1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEV_1R {
            bits: u8,
        }
        impl DEV_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRL1R {
            bits: bool,
        }
        impl DRL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRQ1R {
            bits: bool,
        }
        impl DRQ1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEV_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEV_1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRL1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRQ1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRQ1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets DMA request 1 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline]
            pub fn dev_1(&self) -> DEV_1R {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DEV_1R { bits }
            }
            #[doc = "Bit 30 - A 1 in this bit makes the SCT set DMA request 1 when it loads the Match L/Unified registers from the Reload L/Unified registers."]
            #[inline]
            pub fn drl1(&self) -> DRL1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DRL1R { bits }
            }
            #[doc = "Bit 31 - This read-only bit indicates the state of DMA Request 1."]
            #[inline]
            pub fn drq1(&self) -> DRQ1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DRQ1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets DMA request 1 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline]
            pub fn dev_1(&mut self) -> _DEV_1W {
                _DEV_1W { w: self }
            }
            #[doc = "Bit 30 - A 1 in this bit makes the SCT set DMA request 1 when it loads the Match L/Unified registers from the Reload L/Unified registers."]
            #[inline]
            pub fn drl1(&mut self) -> _DRL1W {
                _DRL1W { w: self }
            }
            #[doc = "Bit 31 - This read-only bit indicates the state of DMA Request 1."]
            #[inline]
            pub fn drq1(&mut self) -> _DRQ1W {
                _DRQ1W { w: self }
            }
        }
    }
    #[doc = "SCT event enable register"]
    pub struct EVEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT event enable register"]
    pub mod even {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IENR {
            bits: u8,
        }
        impl IENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - The SCT requests an interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7)."]
            #[inline]
            pub fn ien(&self) -> IENR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - The SCT requests an interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7)."]
            #[inline]
            pub fn ien(&mut self) -> _IENW {
                _IENW { w: self }
            }
        }
    }
    #[doc = "SCT event flag register"]
    pub struct EVFLAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT event flag register"]
    pub mod evflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FLAGR {
            bits: u8,
        }
        impl FLAGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLAGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7)."]
            #[inline]
            pub fn flag(&self) -> FLAGR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FLAGR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7)."]
            #[inline]
            pub fn flag(&mut self) -> _FLAGW {
                _FLAGW { w: self }
            }
        }
    }
    #[doc = "SCT conflict enable register"]
    pub struct CONEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT conflict enable register"]
    pub mod conen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NCENR {
            bits: u8,
        }
        impl NCENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NCENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - The SCT requests interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1,..., output 5 = bit 5)."]
            #[inline]
            pub fn ncen(&self) -> NCENR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NCENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - The SCT requests interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1,..., output 5 = bit 5)."]
            #[inline]
            pub fn ncen(&mut self) -> _NCENW {
                _NCENW { w: self }
            }
        }
    }
    #[doc = "SCT conflict flag register"]
    pub struct CONFLAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT conflict flag register"]
    pub mod conflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NCFLAGR {
            bits: u8,
        }
        impl NCFLAGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSERRLR {
            bits: bool,
        }
        impl BUSERRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSERRHR {
            bits: bool,
        }
        impl BUSERRHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _NCFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NCFLAGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BUSERRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BUSERRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BUSERRHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BUSERRHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - Bit n is one if a no-change conflict event occurred on output n since reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1,..., output 5 = bit 5)."]
            #[inline]
            pub fn ncflag(&self) -> NCFLAGR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NCFLAGR { bits }
            }
            #[doc = "Bit 30 - The most recent bus error from this SCT involved writing CTR L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the L/U counter was not halted. A word write to certain L and H registers can be half successful and half unsuccessful."]
            #[inline]
            pub fn buserrl(&self) -> BUSERRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSERRLR { bits }
            }
            #[doc = "Bit 31 - The most recent bus error from this SCT involved writing CTR H, STATE H, MATCH H, or the Output register when the H counter was not halted."]
            #[inline]
            pub fn buserrh(&self) -> BUSERRHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSERRHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Bit n is one if a no-change conflict event occurred on output n since reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1,..., output 5 = bit 5)."]
            #[inline]
            pub fn ncflag(&mut self) -> _NCFLAGW {
                _NCFLAGW { w: self }
            }
            #[doc = "Bit 30 - The most recent bus error from this SCT involved writing CTR L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the L/U counter was not halted. A word write to certain L and H registers can be half successful and half unsuccessful."]
            #[inline]
            pub fn buserrl(&mut self) -> _BUSERRLW {
                _BUSERRLW { w: self }
            }
            #[doc = "Bit 31 - The most recent bus error from this SCT involved writing CTR H, STATE H, MATCH H, or the Output register when the H counter was not halted."]
            #[inline]
            pub fn buserrh(&mut self) -> _BUSERRHW {
                _BUSERRHW { w: self }
            }
        }
    }
    #[doc = "SCT match value register of match channels 0 to 7; REGMOD0 to REGMODE7 = 0"]
    pub struct MATCH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT match value register of match channels 0 to 7; REGMOD0 to REGMODE7 = 0"]
    pub mod match_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MATCH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHN_LR {
            bits: u16,
        }
        impl MATCHN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHN_HR {
            bits: u16,
        }
        impl MATCHN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHN_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHN_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline]
            pub fn matchn_l(&self) -> MATCHN_LR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                MATCHN_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit value to be compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline]
            pub fn matchn_h(&self) -> MATCHN_HR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                MATCHN_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline]
            pub fn matchn_l(&mut self) -> _MATCHN_LW {
                _MATCHN_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit value to be compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline]
            pub fn matchn_h(&mut self) -> _MATCHN_HW {
                _MATCHN_HW { w: self }
            }
        }
    }
    #[doc = "SCT capture register of capture channel 0 to 7; REGMOD0 to REGMODE7 = 1"]
    pub struct CAP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT capture register of capture channel 0 to 7; REGMOD0 to REGMODE7 = 1"]
    pub mod cap {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CAP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPN_LR {
            bits: u16,
        }
        impl CAPN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPN_HR {
            bits: u16,
        }
        impl CAPN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPN_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPN_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured."]
            #[inline]
            pub fn capn_l(&self) -> CAPN_LR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CAPN_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured."]
            #[inline]
            pub fn capn_h(&self) -> CAPN_HR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CAPN_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured."]
            #[inline]
            pub fn capn_l(&mut self) -> _CAPN_LW {
                _CAPN_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured."]
            #[inline]
            pub fn capn_h(&mut self) -> _CAPN_HW {
                _CAPN_HW { w: self }
            }
        }
    }
    #[doc = "SCT match reload value register 0 to 7; REGMOD0 = 0 to REGMODE7 = 0"]
    pub struct MATCHREL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT match reload value register 0 to 7; REGMOD0 = 0 to REGMODE7 = 0"]
    pub mod matchrel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MATCHREL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RELOADN_LR {
            bits: u16,
        }
        impl RELOADN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RELOADN_HR {
            bits: u16,
        }
        impl RELOADN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RELOADN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RELOADN_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RELOADN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RELOADN_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline]
            pub fn reloadn_l(&self) -> RELOADN_LR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RELOADN_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline]
            pub fn reloadn_h(&self) -> RELOADN_HR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RELOADN_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline]
            pub fn reloadn_l(&mut self) -> _RELOADN_LW {
                _RELOADN_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline]
            pub fn reloadn_h(&mut self) -> _RELOADN_HW {
                _RELOADN_HW { w: self }
            }
        }
    }
    #[doc = "SCT capture control register 0 to 7; REGMOD0 = 1 to REGMODE7 = 1"]
    pub struct CAPCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT capture control register 0 to 7; REGMOD0 = 1 to REGMODE7 = 1"]
    pub mod capctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CAPCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPCONN_LR {
            bits: u8,
        }
        impl CAPCONN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPCONN_HR {
            bits: u8,
        }
        impl CAPCONN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPCONN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPCONN_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPCONN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPCONN_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7)."]
            #[inline]
            pub fn capconn_l(&self) -> CAPCONN_LR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CAPCONN_LR { bits }
            }
            #[doc = "Bits 16:23 - If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 7 = bit 23)."]
            #[inline]
            pub fn capconn_h(&self) -> CAPCONN_HR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CAPCONN_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7)."]
            #[inline]
            pub fn capconn_l(&mut self) -> _CAPCONN_LW {
                _CAPCONN_LW { w: self }
            }
            #[doc = "Bits 16:23 - If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 7 = bit 23)."]
            #[inline]
            pub fn capconn_h(&mut self) -> _CAPCONN_HW {
                _CAPCONN_HW { w: self }
            }
        }
    }
    #[doc = "SCT event state register 0"]
    pub struct EV_STATE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT event state register 0"]
    pub mod ev_state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV_STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEMSKNR {
            bits: u8,
        }
        impl STATEMSKNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEMSKNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEMSKNW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - If bit m is one, event n (n= 0 to 7) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7)."]
            #[inline]
            pub fn statemskn(&self) -> STATEMSKNR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEMSKNR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - If bit m is one, event n (n= 0 to 7) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7)."]
            #[inline]
            pub fn statemskn(&mut self) -> _STATEMSKNW {
                _STATEMSKNW { w: self }
            }
        }
    }
    #[doc = "SCT event control register 0"]
    pub struct EV_CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT event control register 0"]
    pub mod ev_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHSELR {
            bits: u8,
        }
        impl MATCHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HEVENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEVENTR {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE,
        }
        impl HEVENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HEVENTR::SELECTS_THE_L_STATE => false,
                    HEVENTR::SELECTS_THE_H_STATE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HEVENTR {
                match value {
                    false => HEVENTR::SELECTS_THE_L_STATE,
                    true => HEVENTR::SELECTS_THE_H_STATE,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_L_STATE`"]
            #[inline]
            pub fn is_selects_the_l_state(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_L_STATE
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_H_STATE`"]
            #[inline]
            pub fn is_selects_the_h_state(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_H_STATE
            }
        }
        #[doc = "Possible values of the field `OUTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTSELR {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS,
        }
        impl OUTSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTSELR::SELECTS_THE_INPUTS_E => false,
                    OUTSELR::SELECTS_THE_OUTPUTS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OUTSELR {
                match value {
                    false => OUTSELR::SELECTS_THE_INPUTS_E,
                    true => OUTSELR::SELECTS_THE_OUTPUTS,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_INPUTS_E`"]
            #[inline]
            pub fn is_selects_the_inputs_e(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_INPUTS_E
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_OUTPUTS`"]
            #[inline]
            pub fn is_selects_the_outputs(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_OUTPUTS
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOSELR {
            bits: u8,
        }
        impl IOSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IOCOND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONDR {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    IOCONDR::LOW => 0,
                    IOCONDR::RISE => 0x01,
                    IOCONDR::FALL => 0x02,
                    IOCONDR::HIGH => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> IOCONDR {
                match value {
                    0 => IOCONDR::LOW,
                    1 => IOCONDR::RISE,
                    2 => IOCONDR::FALL,
                    3 => IOCONDR::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == IOCONDR::LOW
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == IOCONDR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == IOCONDR::FALL
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == IOCONDR::HIGH
            }
        }
        #[doc = "Possible values of the field `COMBMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMBMODER {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND,
        }
        impl COMBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMBMODER::OR => 0,
                    COMBMODER::MATCH => 0x01,
                    COMBMODER::IO => 0x02,
                    COMBMODER::AND => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> COMBMODER {
                match value {
                    0 => COMBMODER::OR,
                    1 => COMBMODER::MATCH,
                    2 => COMBMODER::IO,
                    3 => COMBMODER::AND,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OR`"]
            #[inline]
            pub fn is_or(&self) -> bool {
                *self == COMBMODER::OR
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline]
            pub fn is_match_(&self) -> bool {
                *self == COMBMODER::MATCH
            }
            #[doc = "Checks if the value of the field is `IO`"]
            #[inline]
            pub fn is_io(&self) -> bool {
                *self == COMBMODER::IO
            }
            #[doc = "Checks if the value of the field is `AND`"]
            #[inline]
            pub fn is_and(&self) -> bool {
                *self == COMBMODER::AND
            }
        }
        #[doc = "Possible values of the field `STATELD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATELDR {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STATELDR::STATEV_VALUE_IS_ADDE => false,
                    STATELDR::STATEV_VALUE_IS_LOAD => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STATELDR {
                match value {
                    false => STATELDR::STATEV_VALUE_IS_ADDE,
                    true => STATELDR::STATEV_VALUE_IS_LOAD,
                }
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_ADDE`"]
            #[inline]
            pub fn is_statev_value_is_adde(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_ADDE
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_LOAD`"]
            #[inline]
            pub fn is_statev_value_is_load(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_LOAD
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEVR {
            bits: u8,
        }
        impl STATEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHMEMR {
            bits: bool,
        }
        impl MATCHMEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `DIRECTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRECTIONR {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DIRECTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIRECTIONR::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONR::COUNTING_UP => 0x01,
                    DIRECTIONR::COUNTING_DOWN => 0x02,
                    DIRECTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DIRECTIONR {
                match value {
                    0 => DIRECTIONR::DIRECTION_INDEPENDEN,
                    1 => DIRECTIONR::COUNTING_UP,
                    2 => DIRECTIONR::COUNTING_DOWN,
                    i => DIRECTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIRECTION_INDEPENDEN`"]
            #[inline]
            pub fn is_direction_independen(&self) -> bool {
                *self == DIRECTIONR::DIRECTION_INDEPENDEN
            }
            #[doc = "Checks if the value of the field is `COUNTING_UP`"]
            #[inline]
            pub fn is_counting_up(&self) -> bool {
                *self == DIRECTIONR::COUNTING_UP
            }
            #[doc = "Checks if the value of the field is `COUNTING_DOWN`"]
            #[inline]
            pub fn is_counting_down(&self) -> bool {
                *self == DIRECTIONR::COUNTING_DOWN
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HEVENT`"]
        pub enum HEVENTW {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE,
        }
        impl HEVENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HEVENTW::SELECTS_THE_L_STATE => false,
                    HEVENTW::SELECTS_THE_H_STATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HEVENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HEVENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HEVENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            #[inline]
            pub fn selects_the_l_state(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_L_STATE)
            }
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            #[inline]
            pub fn selects_the_h_state(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_H_STATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTSEL`"]
        pub enum OUTSELW {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS,
        }
        impl OUTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTSELW::SELECTS_THE_INPUTS_E => false,
                    OUTSELW::SELECTS_THE_OUTPUTS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OUTSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the inputs elected by IOSEL."]
            #[inline]
            pub fn selects_the_inputs_e(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_INPUTS_E)
            }
            #[doc = "Selects the outputs selected by IOSEL."]
            #[inline]
            pub fn selects_the_outputs(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_OUTPUTS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCOND`"]
        pub enum IOCONDW {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IOCONDW::LOW => 0,
                    IOCONDW::RISE => 1,
                    IOCONDW::FALL => 2,
                    IOCONDW::HIGH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOCONDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "LOW"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(IOCONDW::LOW)
            }
            #[doc = "Rise"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(IOCONDW::RISE)
            }
            #[doc = "Fall"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(IOCONDW::FALL)
            }
            #[doc = "HIGH"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(IOCONDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMBMODE`"]
        pub enum COMBMODEW {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND,
        }
        impl COMBMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMBMODEW::OR => 0,
                    COMBMODEW::MATCH => 1,
                    COMBMODEW::IO => 2,
                    COMBMODEW::AND => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMBMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMBMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            #[inline]
            pub fn or(self) -> &'a mut W {
                self.variant(COMBMODEW::OR)
            }
            #[doc = "MATCH. Uses the specified match only."]
            #[inline]
            pub fn match_(self) -> &'a mut W {
                self.variant(COMBMODEW::MATCH)
            }
            #[doc = "IO. Uses the specified I/O condition only."]
            #[inline]
            pub fn io(self) -> &'a mut W {
                self.variant(COMBMODEW::IO)
            }
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            #[inline]
            pub fn and(self) -> &'a mut W {
                self.variant(COMBMODEW::AND)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STATELD`"]
        pub enum STATELDW {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STATELDW::STATEV_VALUE_IS_ADDE => false,
                    STATELDW::STATEV_VALUE_IS_LOAD => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATELDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATELDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STATELDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            #[inline]
            pub fn statev_value_is_adde(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_ADDE)
            }
            #[doc = "STATEV value is loaded into STATE."]
            #[inline]
            pub fn statev_value_is_load(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_LOAD)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHMEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHMEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIRECTION`"]
        pub enum DIRECTIONW {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN,
        }
        impl DIRECTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIRECTIONW::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONW::COUNTING_UP => 1,
                    DIRECTIONW::COUNTING_DOWN => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRECTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRECTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DIRECTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            #[inline]
            pub fn direction_independen(self) -> &'a mut W {
                self.variant(DIRECTIONW::DIRECTION_INDEPENDEN)
            }
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            #[inline]
            pub fn counting_up(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_UP)
            }
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            #[inline]
            pub fn counting_down(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_DOWN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline]
            pub fn matchsel(&self) -> MATCHSELR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MATCHSELR { bits }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline]
            pub fn hevent(&self) -> HEVENTR {
                HEVENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline]
            pub fn outsel(&self) -> OUTSELR {
                OUTSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 6:9 - Selects the input or output signal number (0 to 3 for inputs or 0 to 5 for outputs) associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline]
            pub fn iosel(&self) -> IOSELR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IOSELR { bits }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline]
            pub fn iocond(&self) -> IOCONDR {
                IOCONDR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline]
            pub fn combmode(&self) -> COMBMODER {
                COMBMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline]
            pub fn stateld(&self) -> STATELDR {
                STATELDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline]
            pub fn statev(&self) -> STATEVR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEVR { bits }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline]
            pub fn matchmem(&self) -> MATCHMEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MATCHMEMR { bits }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline]
            pub fn direction(&self) -> DIRECTIONR {
                DIRECTIONR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline]
            pub fn matchsel(&mut self) -> _MATCHSELW {
                _MATCHSELW { w: self }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline]
            pub fn hevent(&mut self) -> _HEVENTW {
                _HEVENTW { w: self }
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline]
            pub fn outsel(&mut self) -> _OUTSELW {
                _OUTSELW { w: self }
            }
            #[doc = "Bits 6:9 - Selects the input or output signal number (0 to 3 for inputs or 0 to 5 for outputs) associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline]
            pub fn iosel(&mut self) -> _IOSELW {
                _IOSELW { w: self }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline]
            pub fn iocond(&mut self) -> _IOCONDW {
                _IOCONDW { w: self }
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline]
            pub fn combmode(&mut self) -> _COMBMODEW {
                _COMBMODEW { w: self }
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline]
            pub fn stateld(&mut self) -> _STATELDW {
                _STATELDW { w: self }
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline]
            pub fn statev(&mut self) -> _STATEVW {
                _STATEVW { w: self }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline]
            pub fn matchmem(&mut self) -> _MATCHMEMW {
                _MATCHMEMW { w: self }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline]
            pub fn direction(&mut self) -> _DIRECTIONW {
                _DIRECTIONW { w: self }
            }
        }
    }
    #[doc = "SCT output 0 set register"]
    pub struct OUT_SET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT output 0 set register"]
    pub mod out_set {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT_SET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SETR {
            bits: u8,
        }
        impl SETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7."]
            #[inline]
            pub fn set(&self) -> SETR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7."]
            #[inline]
            pub fn set(&mut self) -> _SETW {
                _SETW { w: self }
            }
        }
    }
    #[doc = "SCT output 0 clear register"]
    pub struct OUT_CLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCT output 0 clear register"]
    pub mod out_clr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT_CLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: u8,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7."]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 7 = bit 7."]
            #[inline]
            pub fn clr(&mut self) -> _CLRW {
                _CLRW { w: self }
            }
        }
    }
}
#[doc = "DMA controller"]
pub struct DMA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA {}
impl DMA {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dma::RegisterBlock {
        0x5000_8000 as *const _
    }
}
impl Deref for DMA {
    type Target = dma::RegisterBlock;
    fn deref(&self) -> &dma::RegisterBlock {
        unsafe { &*DMA::ptr() }
    }
}
#[doc = "DMA controller"]
pub mod dma {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - DMA control."]
        pub ctrl: CTRL,
        #[doc = "0x04 - Interrupt status."]
        pub intstat: INTSTAT,
        #[doc = "0x08 - SRAM address of the channel configuration table."]
        pub srambase: SRAMBASE,
        _reserved0: [u8; 20usize],
        #[doc = "0x20 - Channel Enable read and Set for all DMA channels."]
        pub enableset0: ENABLESET0,
        _reserved1: [u8; 4usize],
        #[doc = "0x28 - Channel Enable Clear for all DMA channels."]
        pub enableclr0: ENABLECLR0,
        _reserved2: [u8; 4usize],
        #[doc = "0x30 - Channel Active status for all DMA channels."]
        pub active0: ACTIVE0,
        _reserved3: [u8; 4usize],
        #[doc = "0x38 - Channel Busy status for all DMA channels."]
        pub busy0: BUSY0,
        _reserved4: [u8; 4usize],
        #[doc = "0x40 - Error Interrupt status for all DMA channels."]
        pub errint0: ERRINT0,
        _reserved5: [u8; 4usize],
        #[doc = "0x48 - Interrupt Enable read and Set for all DMA channels."]
        pub intenset0: INTENSET0,
        _reserved6: [u8; 4usize],
        #[doc = "0x50 - Interrupt Enable Clear for all DMA channels."]
        pub intenclr0: INTENCLR0,
        _reserved7: [u8; 4usize],
        #[doc = "0x58 - Interrupt A status for all DMA channels."]
        pub inta0: INTA0,
        _reserved8: [u8; 4usize],
        #[doc = "0x60 - Interrupt B status for all DMA channels."]
        pub intb0: INTB0,
        _reserved9: [u8; 4usize],
        #[doc = "0x68 - Set ValidPending control bits for all DMA channels."]
        pub setvalid0: SETVALID0,
        _reserved10: [u8; 4usize],
        #[doc = "0x70 - Set Trigger control bits for all DMA channels."]
        pub settrig0: SETTRIG0,
        _reserved11: [u8; 4usize],
        #[doc = "0x78 - Channel Abort control for all DMA channels."]
        pub abort0: ABORT0,
        _reserved12: [u8; 900usize],
        #[doc = "0x400 - Configuration register for DMA channel 0."]
        pub cfg0: CFG,
        #[doc = "0x404 - Control and status register for DMA channel 0."]
        pub ctlstat0: CTLSTAT,
        #[doc = "0x408 - Transfer configuration register for DMA channel 0."]
        pub xfercfg0: XFERCFG,
        _reserved13: [u8; 4usize],
        #[doc = "0x410 - Configuration register for DMA channel 0."]
        pub cfg1: CFG,
        #[doc = "0x414 - Control and status register for DMA channel 0."]
        pub ctlstat1: CTLSTAT,
        #[doc = "0x418 - Transfer configuration register for DMA channel 0."]
        pub xfercfg1: XFERCFG,
        _reserved14: [u8; 4usize],
        #[doc = "0x420 - Configuration register for DMA channel 0."]
        pub cfg2: CFG,
        #[doc = "0x424 - Control and status register for DMA channel 0."]
        pub ctlstat2: CTLSTAT,
        #[doc = "0x428 - Transfer configuration register for DMA channel 0."]
        pub xfercfg2: XFERCFG,
        _reserved15: [u8; 4usize],
        #[doc = "0x430 - Configuration register for DMA channel 0."]
        pub cfg3: CFG,
        #[doc = "0x434 - Control and status register for DMA channel 0."]
        pub ctlstat3: CTLSTAT,
        #[doc = "0x438 - Transfer configuration register for DMA channel 0."]
        pub xfercfg3: XFERCFG,
        _reserved16: [u8; 4usize],
        #[doc = "0x440 - Configuration register for DMA channel 0."]
        pub cfg4: CFG,
        #[doc = "0x444 - Control and status register for DMA channel 0."]
        pub ctlstat4: CTLSTAT,
        #[doc = "0x448 - Transfer configuration register for DMA channel 0."]
        pub xfercfg4: XFERCFG,
        _reserved17: [u8; 4usize],
        #[doc = "0x450 - Configuration register for DMA channel 0."]
        pub cfg5: CFG,
        #[doc = "0x454 - Control and status register for DMA channel 0."]
        pub ctlstat5: CTLSTAT,
        #[doc = "0x458 - Transfer configuration register for DMA channel 0."]
        pub xfercfg5: XFERCFG,
        _reserved18: [u8; 4usize],
        #[doc = "0x460 - Configuration register for DMA channel 0."]
        pub cfg6: CFG,
        #[doc = "0x464 - Control and status register for DMA channel 0."]
        pub ctlstat6: CTLSTAT,
        #[doc = "0x468 - Transfer configuration register for DMA channel 0."]
        pub xfercfg6: XFERCFG,
        _reserved19: [u8; 4usize],
        #[doc = "0x470 - Configuration register for DMA channel 0."]
        pub cfg7: CFG,
        #[doc = "0x474 - Control and status register for DMA channel 0."]
        pub ctlstat7: CTLSTAT,
        #[doc = "0x478 - Transfer configuration register for DMA channel 0."]
        pub xfercfg7: XFERCFG,
        _reserved20: [u8; 4usize],
        #[doc = "0x480 - Configuration register for DMA channel 0."]
        pub cfg8: CFG,
        #[doc = "0x484 - Control and status register for DMA channel 0."]
        pub ctlstat8: CTLSTAT,
        #[doc = "0x488 - Transfer configuration register for DMA channel 0."]
        pub xfercfg8: XFERCFG,
        _reserved21: [u8; 4usize],
        #[doc = "0x490 - Configuration register for DMA channel 0."]
        pub cfg9: CFG,
        #[doc = "0x494 - Control and status register for DMA channel 0."]
        pub ctlstat9: CTLSTAT,
        #[doc = "0x498 - Transfer configuration register for DMA channel 0."]
        pub xfercfg9: XFERCFG,
        _reserved22: [u8; 4usize],
        #[doc = "0x4a0 - Configuration register for DMA channel 0."]
        pub cfg10: CFG,
        #[doc = "0x4a4 - Control and status register for DMA channel 0."]
        pub ctlstat10: CTLSTAT,
        #[doc = "0x4a8 - Transfer configuration register for DMA channel 0."]
        pub xfercfg10: XFERCFG,
        _reserved23: [u8; 4usize],
        #[doc = "0x4b0 - Configuration register for DMA channel 0."]
        pub cfg11: CFG,
        #[doc = "0x4b4 - Control and status register for DMA channel 0."]
        pub ctlstat11: CTLSTAT,
        #[doc = "0x4b8 - Transfer configuration register for DMA channel 0."]
        pub xfercfg11: XFERCFG,
        _reserved24: [u8; 4usize],
        #[doc = "0x4c0 - Configuration register for DMA channel 0."]
        pub cfg12: CFG,
        #[doc = "0x4c4 - Control and status register for DMA channel 0."]
        pub ctlstat12: CTLSTAT,
        #[doc = "0x4c8 - Transfer configuration register for DMA channel 0."]
        pub xfercfg12: XFERCFG,
        _reserved25: [u8; 4usize],
        #[doc = "0x4d0 - Configuration register for DMA channel 0."]
        pub cfg13: CFG,
        #[doc = "0x4d4 - Control and status register for DMA channel 0."]
        pub ctlstat13: CTLSTAT,
        #[doc = "0x4d8 - Transfer configuration register for DMA channel 0."]
        pub xfercfg13: XFERCFG,
        _reserved26: [u8; 4usize],
        #[doc = "0x4e0 - Configuration register for DMA channel 0."]
        pub cfg14: CFG,
        #[doc = "0x4e4 - Control and status register for DMA channel 0."]
        pub ctlstat14: CTLSTAT,
        #[doc = "0x4e8 - Transfer configuration register for DMA channel 0."]
        pub xfercfg14: XFERCFG,
        _reserved27: [u8; 4usize],
        #[doc = "0x4f0 - Configuration register for DMA channel 0."]
        pub cfg15: CFG,
        #[doc = "0x4f4 - Control and status register for DMA channel 0."]
        pub ctlstat15: CTLSTAT,
        #[doc = "0x4f8 - Transfer configuration register for DMA channel 0."]
        pub xfercfg15: XFERCFG,
        _reserved28: [u8; 4usize],
        #[doc = "0x500 - Configuration register for DMA channel 0."]
        pub cfg16: CFG,
        #[doc = "0x504 - Control and status register for DMA channel 0."]
        pub ctlstat16: CTLSTAT,
        #[doc = "0x508 - Transfer configuration register for DMA channel 0."]
        pub xfercfg16: XFERCFG,
        _reserved29: [u8; 4usize],
        #[doc = "0x510 - Configuration register for DMA channel 0."]
        pub cfg17: CFG,
        #[doc = "0x514 - Control and status register for DMA channel 0."]
        pub ctlstat17: CTLSTAT,
        #[doc = "0x518 - Transfer configuration register for DMA channel 0."]
        pub xfercfg17: XFERCFG,
    }
    #[doc = "DMA control."]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA control."]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled."]
            DISABLED,
            #[doc = "Enabled. The DMA controller is enabled."]
            ENABLED,
        }
        impl ENABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENABLER::DISABLED => false,
                    ENABLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENABLER {
                match value {
                    false => ENABLER::DISABLED,
                    true => ENABLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled."]
            DISABLED,
            #[doc = "Enabled. The DMA controller is enabled."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENABLEW::DISABLED => false,
                    ENABLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enabled. The DMA controller is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - DMA controller master enable."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DMA controller master enable."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Interrupt status."]
    pub struct INTSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt status."]
    pub mod intstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `ACTIVEINT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACTIVEINTR {
            #[doc = "Not pending. No enabled interrupts are pending."]
            NOT_PENDING,
            #[doc = "Pending. At least one enabled interrupt is pending."]
            PENDING,
        }
        impl ACTIVEINTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACTIVEINTR::NOT_PENDING => false,
                    ACTIVEINTR::PENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACTIVEINTR {
                match value {
                    false => ACTIVEINTR::NOT_PENDING,
                    true => ACTIVEINTR::PENDING,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_PENDING`"]
            #[inline]
            pub fn is_not_pending(&self) -> bool {
                *self == ACTIVEINTR::NOT_PENDING
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline]
            pub fn is_pending(&self) -> bool {
                *self == ACTIVEINTR::PENDING
            }
        }
        #[doc = "Possible values of the field `ACTIVEERRINT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACTIVEERRINTR {
            #[doc = "Not pending. No error interrupts are pending."]
            NOT_PENDING,
            #[doc = "Pending. At least one error interrupt is pending."]
            PENDING,
        }
        impl ACTIVEERRINTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACTIVEERRINTR::NOT_PENDING => false,
                    ACTIVEERRINTR::PENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACTIVEERRINTR {
                match value {
                    false => ACTIVEERRINTR::NOT_PENDING,
                    true => ACTIVEERRINTR::PENDING,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_PENDING`"]
            #[inline]
            pub fn is_not_pending(&self) -> bool {
                *self == ACTIVEERRINTR::NOT_PENDING
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline]
            pub fn is_pending(&self) -> bool {
                *self == ACTIVEERRINTR::PENDING
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Summarizes whether any enabled interrupts are pending."]
            #[inline]
            pub fn activeint(&self) -> ACTIVEINTR {
                ACTIVEINTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Summarizes whether any error interrupts are pending."]
            #[inline]
            pub fn activeerrint(&self) -> ACTIVEERRINTR {
                ACTIVEERRINTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "SRAM address of the channel configuration table."]
    pub struct SRAMBASE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SRAM address of the channel configuration table."]
    pub mod srambase {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SRAMBASE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OFFSETR {
            bits: u32,
        }
        impl OFFSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x007f_ffff;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 9:31 - Address bits 31:9 of the beginning of the DMA descriptor table. For 18 channels, the table must begin on a 512 byte boundary."]
            #[inline]
            pub fn offset(&self) -> OFFSETR {
                let bits = {
                    const MASK: u32 = 0x007f_ffff;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OFFSETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 9:31 - Address bits 31:9 of the beginning of the DMA descriptor table. For 18 channels, the table must begin on a 512 byte boundary."]
            #[inline]
            pub fn offset(&mut self) -> _OFFSETW {
                _OFFSETW { w: self }
            }
        }
    }
    #[doc = "Channel Enable read and Set for all DMA channels."]
    pub struct ENABLESET0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Channel Enable read and Set for all DMA channels."]
    pub mod enableset0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLESET0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENAR {
            bits: u32,
        }
        impl ENAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Enable for DMA channels 17:0. Bit n enables or disables DMA channel n. 0 = disabled. 1 = enabled."]
            #[inline]
            pub fn ena(&self) -> ENAR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ENAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Enable for DMA channels 17:0. Bit n enables or disables DMA channel n. 0 = disabled. 1 = enabled."]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "Channel Enable Clear for all DMA channels."]
    pub struct ENABLECLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Channel Enable Clear for all DMA channels."]
    pub mod enableclr0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLECLR0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Writing ones to this register clears the corresponding bits in ENABLESET0. Bit n clears the channel enable bit n."]
            #[inline]
            pub fn clr(&mut self) -> _CLRW {
                _CLRW { w: self }
            }
        }
    }
    #[doc = "Channel Active status for all DMA channels."]
    pub struct ACTIVE0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Channel Active status for all DMA channels."]
    pub mod active0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ACTIVE0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACTR {
            bits: u32,
        }
        impl ACTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Active flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = not active. 1 = active."]
            #[inline]
            pub fn act(&self) -> ACTR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ACTR { bits }
            }
        }
    }
    #[doc = "Channel Busy status for all DMA channels."]
    pub struct BUSY0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Channel Busy status for all DMA channels."]
    pub mod busy0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::BUSY0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct BSYR {
            bits: u32,
        }
        impl BSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Busy flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = not busy. 1 = busy."]
            #[inline]
            pub fn bsy(&self) -> BSYR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                BSYR { bits }
            }
        }
    }
    #[doc = "Error Interrupt status for all DMA channels."]
    pub struct ERRINT0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Error Interrupt status for all DMA channels."]
    pub mod errint0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERRINT0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRR {
            bits: u32,
        }
        impl ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Error Interrupt flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = error interrupt is not active. 1 = error interrupt is active."]
            #[inline]
            pub fn err(&self) -> ERRR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Error Interrupt flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = error interrupt is not active. 1 = error interrupt is active."]
            #[inline]
            pub fn err(&mut self) -> _ERRW {
                _ERRW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable read and Set for all DMA channels."]
    pub struct INTENSET0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable read and Set for all DMA channels."]
    pub mod intenset0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTENR {
            bits: u32,
        }
        impl INTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Interrupt Enable read and set for DMA channel n. Bit n corresponds to DMA channel n. 0 = interrupt for DMA channel is disabled. 1 = interrupt for DMA channel is enabled."]
            #[inline]
            pub fn inten(&self) -> INTENR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                INTENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Interrupt Enable read and set for DMA channel n. Bit n corresponds to DMA channel n. 0 = interrupt for DMA channel is disabled. 1 = interrupt for DMA channel is enabled."]
            #[inline]
            pub fn inten(&mut self) -> _INTENW {
                _INTENW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear for all DMA channels."]
    pub struct INTENCLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear for all DMA channels."]
    pub mod intenclr0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Writing ones to this register clears corresponding bits in the INTENSET0. Bit n corresponds to DMA channel n."]
            #[inline]
            pub fn clr(&mut self) -> _CLRW {
                _CLRW { w: self }
            }
        }
    }
    #[doc = "Interrupt A status for all DMA channels."]
    pub struct INTA0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt A status for all DMA channels."]
    pub mod inta0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTA0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IAR {
            bits: u32,
        }
        impl IAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Interrupt A status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt A is not active. 1 = the DMA channel interrupt A is active."]
            #[inline]
            pub fn ia(&self) -> IAR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                IAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Interrupt A status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt A is not active. 1 = the DMA channel interrupt A is active."]
            #[inline]
            pub fn ia(&mut self) -> _IAW {
                _IAW { w: self }
            }
        }
    }
    #[doc = "Interrupt B status for all DMA channels."]
    pub struct INTB0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt B status for all DMA channels."]
    pub mod intb0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTB0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBR {
            bits: u32,
        }
        impl IBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Interrupt B status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt B is not active. 1 = the DMA channel interrupt B is active."]
            #[inline]
            pub fn ib(&self) -> IBR {
                let bits = {
                    const MASK: u32 = 0x0003_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                IBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Interrupt B status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt B is not active. 1 = the DMA channel interrupt B is active."]
            #[inline]
            pub fn ib(&mut self) -> _IBW {
                _IBW { w: self }
            }
        }
    }
    #[doc = "Set ValidPending control bits for all DMA channels."]
    pub struct SETVALID0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Set ValidPending control bits for all DMA channels."]
    pub mod setvalid0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SETVALID0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - SETVALID control for DMA channel n. Bit n corresponds to DMA channel n. 0 = no effect. 1 = sets the VALIDPENDING control bit for DMA channel n."]
            #[inline]
            pub fn sv(&mut self) -> _SVW {
                _SVW { w: self }
            }
        }
    }
    #[doc = "Set Trigger control bits for all DMA channels."]
    pub struct SETTRIG0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Set Trigger control bits for all DMA channels."]
    pub mod settrig0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SETTRIG0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Set Trigger control bit for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA channel n."]
            #[inline]
            pub fn trig(&mut self) -> _TRIGW {
                _TRIGW { w: self }
            }
        }
    }
    #[doc = "Channel Abort control for all DMA channels."]
    pub struct ABORT0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Channel Abort control for all DMA channels."]
    pub mod abort0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ABORT0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABORTCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABORTCTRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0003_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Abort control for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = aborts DMA operations on channel n."]
            #[inline]
            pub fn abortctrl(&mut self) -> _ABORTCTRLW {
                _ABORTCTRLW { w: self }
            }
        }
    }
    #[doc = "Configuration register for DMA channel 0."]
    pub struct CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Configuration register for DMA channel 0."]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PERIPHREQEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PERIPHREQENR {
            #[doc = "Disabled. Peripheral DMA requests are disabled."]
            DISABLED,
            #[doc = "Enabled. Peripheral DMA requests are enabled."]
            ENABLED,
        }
        impl PERIPHREQENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PERIPHREQENR::DISABLED => false,
                    PERIPHREQENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PERIPHREQENR {
                match value {
                    false => PERIPHREQENR::DISABLED,
                    true => PERIPHREQENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PERIPHREQENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PERIPHREQENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `HWTRIGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HWTRIGENR {
            #[doc = "Disabled. Hardware triggering is not used."]
            DISABLED,
            #[doc = "Enabled. Use hardware triggering."]
            ENABLED,
        }
        impl HWTRIGENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HWTRIGENR::DISABLED => false,
                    HWTRIGENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HWTRIGENR {
                match value {
                    false => HWTRIGENR::DISABLED,
                    true => HWTRIGENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == HWTRIGENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == HWTRIGENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TRIGPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGPOLR {
            #[doc = "Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE."]
            ACTIVE_LOW_FALLING,
            #[doc = "Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE."]
            ACTIVE_HIGH_RISING,
        }
        impl TRIGPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TRIGPOLR::ACTIVE_LOW_FALLING => false,
                    TRIGPOLR::ACTIVE_HIGH_RISING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TRIGPOLR {
                match value {
                    false => TRIGPOLR::ACTIVE_LOW_FALLING,
                    true => TRIGPOLR::ACTIVE_HIGH_RISING,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVE_LOW_FALLING`"]
            #[inline]
            pub fn is_active_low_falling(&self) -> bool {
                *self == TRIGPOLR::ACTIVE_LOW_FALLING
            }
            #[doc = "Checks if the value of the field is `ACTIVE_HIGH_RISING`"]
            #[inline]
            pub fn is_active_high_rising(&self) -> bool {
                *self == TRIGPOLR::ACTIVE_HIGH_RISING
            }
        }
        #[doc = "Possible values of the field `TRIGTYPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGTYPER {
            #[doc = "Edge. Hardware trigger is edge triggered. Transfers will be initiated and completed, as specified for a single trigger."]
            EDGE,
            #[doc = "Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel. Transfers continue as long as the trigger level is asserted.  Once the trigger is de-asserted, the transfer will be paused until the trigger is, again, asserted.  However, the transfer will not be paused until any remaining transfers within the current BURSTPOWER length are completed."]
            LEVEL,
        }
        impl TRIGTYPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TRIGTYPER::EDGE => false,
                    TRIGTYPER::LEVEL => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TRIGTYPER {
                match value {
                    false => TRIGTYPER::EDGE,
                    true => TRIGTYPER::LEVEL,
                }
            }
            #[doc = "Checks if the value of the field is `EDGE`"]
            #[inline]
            pub fn is_edge(&self) -> bool {
                *self == TRIGTYPER::EDGE
            }
            #[doc = "Checks if the value of the field is `LEVEL`"]
            #[inline]
            pub fn is_level(&self) -> bool {
                *self == TRIGTYPER::LEVEL
            }
        }
        #[doc = "Possible values of the field `TRIGBURST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGBURSTR {
            #[doc = "Single transfer. Hardware trigger causes a single transfer."]
            SINGLE_TRANSFER,
            #[doc = "Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete."]
            BURST_TRANSFER,
        }
        impl TRIGBURSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TRIGBURSTR::SINGLE_TRANSFER => false,
                    TRIGBURSTR::BURST_TRANSFER => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TRIGBURSTR {
                match value {
                    false => TRIGBURSTR::SINGLE_TRANSFER,
                    true => TRIGBURSTR::BURST_TRANSFER,
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE_TRANSFER`"]
            #[inline]
            pub fn is_single_transfer(&self) -> bool {
                *self == TRIGBURSTR::SINGLE_TRANSFER
            }
            #[doc = "Checks if the value of the field is `BURST_TRANSFER`"]
            #[inline]
            pub fn is_burst_transfer(&self) -> bool {
                *self == TRIGBURSTR::BURST_TRANSFER
            }
        }
        #[doc = r" Value of the field"]
        pub struct BURSTPOWERR {
            bits: u8,
        }
        impl BURSTPOWERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `SRCBURSTWRAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCBURSTWRAPR {
            #[doc = "Disabled. Source burst wrapping is not enabled for this DMA channel."]
            DISABLED,
            #[doc = "Enabled. Source burst wrapping is enabled for this DMA channel."]
            ENABLED,
        }
        impl SRCBURSTWRAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SRCBURSTWRAPR::DISABLED => false,
                    SRCBURSTWRAPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SRCBURSTWRAPR {
                match value {
                    false => SRCBURSTWRAPR::DISABLED,
                    true => SRCBURSTWRAPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SRCBURSTWRAPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SRCBURSTWRAPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DSTBURSTWRAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DSTBURSTWRAPR {
            #[doc = "Disabled. Destination burst wrapping is not enabled for this DMA channel."]
            DISABLED,
            #[doc = "Enabled. Destination burst wrapping is enabled for this DMA channel."]
            ENABLED,
        }
        impl DSTBURSTWRAPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DSTBURSTWRAPR::DISABLED => false,
                    DSTBURSTWRAPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DSTBURSTWRAPR {
                match value {
                    false => DSTBURSTWRAPR::DISABLED,
                    true => DSTBURSTWRAPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DSTBURSTWRAPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DSTBURSTWRAPR::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHPRIORITYR {
            bits: u8,
        }
        impl CHPRIORITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `PERIPHREQEN`"]
        pub enum PERIPHREQENW {
            #[doc = "Disabled. Peripheral DMA requests are disabled."]
            DISABLED,
            #[doc = "Enabled. Peripheral DMA requests are enabled."]
            ENABLED,
        }
        impl PERIPHREQENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PERIPHREQENW::DISABLED => false,
                    PERIPHREQENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERIPHREQENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERIPHREQENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PERIPHREQENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Peripheral DMA requests are disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PERIPHREQENW::DISABLED)
            }
            #[doc = "Enabled. Peripheral DMA requests are enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PERIPHREQENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HWTRIGEN`"]
        pub enum HWTRIGENW {
            #[doc = "Disabled. Hardware triggering is not used."]
            DISABLED,
            #[doc = "Enabled. Use hardware triggering."]
            ENABLED,
        }
        impl HWTRIGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HWTRIGENW::DISABLED => false,
                    HWTRIGENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HWTRIGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HWTRIGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HWTRIGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Hardware triggering is not used."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(HWTRIGENW::DISABLED)
            }
            #[doc = "Enabled. Use hardware triggering."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(HWTRIGENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TRIGPOL`"]
        pub enum TRIGPOLW {
            #[doc = "Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE."]
            ACTIVE_LOW_FALLING,
            #[doc = "Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE."]
            ACTIVE_HIGH_RISING,
        }
        impl TRIGPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TRIGPOLW::ACTIVE_LOW_FALLING => false,
                    TRIGPOLW::ACTIVE_HIGH_RISING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TRIGPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE."]
            #[inline]
            pub fn active_low_falling(self) -> &'a mut W {
                self.variant(TRIGPOLW::ACTIVE_LOW_FALLING)
            }
            #[doc = "Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE."]
            #[inline]
            pub fn active_high_rising(self) -> &'a mut W {
                self.variant(TRIGPOLW::ACTIVE_HIGH_RISING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TRIGTYPE`"]
        pub enum TRIGTYPEW {
            #[doc = "Edge. Hardware trigger is edge triggered. Transfers will be initiated and completed, as specified for a single trigger."]
            EDGE,
            #[doc = "Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel. Transfers continue as long as the trigger level is asserted.  Once the trigger is de-asserted, the transfer will be paused until the trigger is, again, asserted.  However, the transfer will not be paused until any remaining transfers within the current BURSTPOWER length are completed."]
            LEVEL,
        }
        impl TRIGTYPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TRIGTYPEW::EDGE => false,
                    TRIGTYPEW::LEVEL => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGTYPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGTYPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TRIGTYPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Edge. Hardware trigger is edge triggered. Transfers will be initiated and completed, as specified for a single trigger."]
            #[inline]
            pub fn edge(self) -> &'a mut W {
                self.variant(TRIGTYPEW::EDGE)
            }
            #[doc = "Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel. Transfers continue as long as the trigger level is asserted. Once the trigger is de-asserted, the transfer will be paused until the trigger is, again, asserted. However, the transfer will not be paused until any remaining transfers within the current BURSTPOWER length are completed."]
            #[inline]
            pub fn level(self) -> &'a mut W {
                self.variant(TRIGTYPEW::LEVEL)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TRIGBURST`"]
        pub enum TRIGBURSTW {
            #[doc = "Single transfer. Hardware trigger causes a single transfer."]
            SINGLE_TRANSFER,
            #[doc = "Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete."]
            BURST_TRANSFER,
        }
        impl TRIGBURSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TRIGBURSTW::SINGLE_TRANSFER => false,
                    TRIGBURSTW::BURST_TRANSFER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIGBURSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIGBURSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TRIGBURSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Single transfer. Hardware trigger causes a single transfer."]
            #[inline]
            pub fn single_transfer(self) -> &'a mut W {
                self.variant(TRIGBURSTW::SINGLE_TRANSFER)
            }
            #[doc = "Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete."]
            #[inline]
            pub fn burst_transfer(self) -> &'a mut W {
                self.variant(TRIGBURSTW::BURST_TRANSFER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BURSTPOWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BURSTPOWERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRCBURSTWRAP`"]
        pub enum SRCBURSTWRAPW {
            #[doc = "Disabled. Source burst wrapping is not enabled for this DMA channel."]
            DISABLED,
            #[doc = "Enabled. Source burst wrapping is enabled for this DMA channel."]
            ENABLED,
        }
        impl SRCBURSTWRAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SRCBURSTWRAPW::DISABLED => false,
                    SRCBURSTWRAPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRCBURSTWRAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRCBURSTWRAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRCBURSTWRAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Source burst wrapping is not enabled for this DMA channel."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SRCBURSTWRAPW::DISABLED)
            }
            #[doc = "Enabled. Source burst wrapping is enabled for this DMA channel."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SRCBURSTWRAPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DSTBURSTWRAP`"]
        pub enum DSTBURSTWRAPW {
            #[doc = "Disabled. Destination burst wrapping is not enabled for this DMA channel."]
            DISABLED,
            #[doc = "Enabled. Destination burst wrapping is enabled for this DMA channel."]
            ENABLED,
        }
        impl DSTBURSTWRAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DSTBURSTWRAPW::DISABLED => false,
                    DSTBURSTWRAPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSTBURSTWRAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSTBURSTWRAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DSTBURSTWRAPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Destination burst wrapping is not enabled for this DMA channel."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DSTBURSTWRAPW::DISABLED)
            }
            #[doc = "Enabled. Destination burst wrapping is enabled for this DMA channel."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DSTBURSTWRAPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHPRIORITYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHPRIORITYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller."]
            #[inline]
            pub fn periphreqen(&self) -> PERIPHREQENR {
                PERIPHREQENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Hardware Triggering Enable for this channel."]
            #[inline]
            pub fn hwtrigen(&self) -> HWTRIGENR {
                HWTRIGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Trigger Polarity. Selects the polarity of a hardware trigger for this channel."]
            #[inline]
            pub fn trigpol(&self) -> TRIGPOLR {
                TRIGPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Trigger Type. Selects hardware trigger as edge triggered or level triggered."]
            #[inline]
            pub fn trigtype(&self) -> TRIGTYPER {
                TRIGTYPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Trigger Burst. Selects whether hardware triggers cause a single or burst transfer."]
            #[inline]
            pub fn trigburst(&self) -> TRIGBURSTR {
                TRIGBURSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:11 - Burst Power is used in two ways. It always selects the address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported. The total transfer length as defined in the XFERCOUNT bits in the XFERCFG register must be an even multiple of the burst size."]
            #[inline]
            pub fn burstpower(&self) -> BURSTPOWERR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BURSTPOWERR { bits }
            }
            #[doc = "Bit 14 - Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst."]
            #[inline]
            pub fn srcburstwrap(&self) -> SRCBURSTWRAPR {
                SRCBURSTWRAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst."]
            #[inline]
            pub fn dstburstwrap(&self) -> DSTBURSTWRAPR {
                DSTBURSTWRAPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 16:18 - Priority of this channel when multiple DMA requests are pending. Eight priority levels are supported. 0x0 = highest priority. 0x7 = lowest priority."]
            #[inline]
            pub fn chpriority(&self) -> CHPRIORITYR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHPRIORITYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller."]
            #[inline]
            pub fn periphreqen(&mut self) -> _PERIPHREQENW {
                _PERIPHREQENW { w: self }
            }
            #[doc = "Bit 1 - Hardware Triggering Enable for this channel."]
            #[inline]
            pub fn hwtrigen(&mut self) -> _HWTRIGENW {
                _HWTRIGENW { w: self }
            }
            #[doc = "Bit 4 - Trigger Polarity. Selects the polarity of a hardware trigger for this channel."]
            #[inline]
            pub fn trigpol(&mut self) -> _TRIGPOLW {
                _TRIGPOLW { w: self }
            }
            #[doc = "Bit 5 - Trigger Type. Selects hardware trigger as edge triggered or level triggered."]
            #[inline]
            pub fn trigtype(&mut self) -> _TRIGTYPEW {
                _TRIGTYPEW { w: self }
            }
            #[doc = "Bit 6 - Trigger Burst. Selects whether hardware triggers cause a single or burst transfer."]
            #[inline]
            pub fn trigburst(&mut self) -> _TRIGBURSTW {
                _TRIGBURSTW { w: self }
            }
            #[doc = "Bits 8:11 - Burst Power is used in two ways. It always selects the address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported. The total transfer length as defined in the XFERCOUNT bits in the XFERCFG register must be an even multiple of the burst size."]
            #[inline]
            pub fn burstpower(&mut self) -> _BURSTPOWERW {
                _BURSTPOWERW { w: self }
            }
            #[doc = "Bit 14 - Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst."]
            #[inline]
            pub fn srcburstwrap(&mut self) -> _SRCBURSTWRAPW {
                _SRCBURSTWRAPW { w: self }
            }
            #[doc = "Bit 15 - Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst."]
            #[inline]
            pub fn dstburstwrap(&mut self) -> _DSTBURSTWRAPW {
                _DSTBURSTWRAPW { w: self }
            }
            #[doc = "Bits 16:18 - Priority of this channel when multiple DMA requests are pending. Eight priority levels are supported. 0x0 = highest priority. 0x7 = lowest priority."]
            #[inline]
            pub fn chpriority(&mut self) -> _CHPRIORITYW {
                _CHPRIORITYW { w: self }
            }
        }
    }
    #[doc = "Control and status register for DMA channel 0."]
    pub struct CTLSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control and status register for DMA channel 0."]
    pub mod ctlstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CTLSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `VALIDPENDING`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VALIDPENDINGR {
            #[doc = "No effect on DMA operation."]
            NO_EFFECT_ON_DMA_OPE,
            #[doc = "Valid pending."]
            VALID_PENDING,
        }
        impl VALIDPENDINGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    VALIDPENDINGR::NO_EFFECT_ON_DMA_OPE => false,
                    VALIDPENDINGR::VALID_PENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> VALIDPENDINGR {
                match value {
                    false => VALIDPENDINGR::NO_EFFECT_ON_DMA_OPE,
                    true => VALIDPENDINGR::VALID_PENDING,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_ON_DMA_OPE`"]
            #[inline]
            pub fn is_no_effect_on_dma_ope(&self) -> bool {
                *self == VALIDPENDINGR::NO_EFFECT_ON_DMA_OPE
            }
            #[doc = "Checks if the value of the field is `VALID_PENDING`"]
            #[inline]
            pub fn is_valid_pending(&self) -> bool {
                *self == VALIDPENDINGR::VALID_PENDING
            }
        }
        #[doc = "Possible values of the field `TRIG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TRIGR {
            #[doc = "Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out."]
            NOT_TRIGGERED,
            #[doc = "Triggered. The trigger for this DMA channel is set. DMA operations will be carried out."]
            TRIGGERED,
        }
        impl TRIGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TRIGR::NOT_TRIGGERED => false,
                    TRIGR::TRIGGERED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TRIGR {
                match value {
                    false => TRIGR::NOT_TRIGGERED,
                    true => TRIGR::TRIGGERED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_TRIGGERED`"]
            #[inline]
            pub fn is_not_triggered(&self) -> bool {
                *self == TRIGR::NOT_TRIGGERED
            }
            #[doc = "Checks if the value of the field is `TRIGGERED`"]
            #[inline]
            pub fn is_triggered(&self) -> bool {
                *self == TRIGR::TRIGGERED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel."]
            #[inline]
            pub fn validpending(&self) -> VALIDPENDINGR {
                VALIDPENDINGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1."]
            #[inline]
            pub fn trig(&self) -> TRIGR {
                TRIGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Transfer configuration register for DMA channel 0."]
    pub struct XFERCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transfer configuration register for DMA channel 0."]
    pub mod xfercfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XFERCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CFGVALID`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFGVALIDR {
            #[doc = "Not valid. The channel descriptor is not considered valid until validated by an associated SETVALID0 setting."]
            NOT_VALID,
            #[doc = "Valid. The current channel descriptor is considered valid."]
            VALID,
        }
        impl CFGVALIDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CFGVALIDR::NOT_VALID => false,
                    CFGVALIDR::VALID => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CFGVALIDR {
                match value {
                    false => CFGVALIDR::NOT_VALID,
                    true => CFGVALIDR::VALID,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_VALID`"]
            #[inline]
            pub fn is_not_valid(&self) -> bool {
                *self == CFGVALIDR::NOT_VALID
            }
            #[doc = "Checks if the value of the field is `VALID`"]
            #[inline]
            pub fn is_valid(&self) -> bool {
                *self == CFGVALIDR::VALID
            }
        }
        #[doc = "Possible values of the field `RELOAD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RELOADR {
            #[doc = "Disabled. Do not reload the channels' control structure when the current descriptor is exhausted."]
            DISABLED,
            #[doc = "Enabled. Reload the channels' control structure when the current descriptor is exhausted."]
            ENABLED,
        }
        impl RELOADR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RELOADR::DISABLED => false,
                    RELOADR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RELOADR {
                match value {
                    false => RELOADR::DISABLED,
                    true => RELOADR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RELOADR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RELOADR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SWTRIG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWTRIGR {
            #[doc = "When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel."]
            NOTSET,
            #[doc = "When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0."]
            SET,
        }
        impl SWTRIGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SWTRIGR::NOTSET => false,
                    SWTRIGR::SET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SWTRIGR {
                match value {
                    false => SWTRIGR::NOTSET,
                    true => SWTRIGR::SET,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSET`"]
            #[inline]
            pub fn is_notset(&self) -> bool {
                *self == SWTRIGR::NOTSET
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline]
            pub fn is_set(&self) -> bool {
                *self == SWTRIGR::SET
            }
        }
        #[doc = "Possible values of the field `CLRTRIG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLRTRIGR {
            #[doc = "Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started."]
            NOT_CLEARED,
            #[doc = "Cleared. The trigger is cleared when this descriptor is exhausted."]
            CLEARED,
        }
        impl CLRTRIGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CLRTRIGR::NOT_CLEARED => false,
                    CLRTRIGR::CLEARED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CLRTRIGR {
                match value {
                    false => CLRTRIGR::NOT_CLEARED,
                    true => CLRTRIGR::CLEARED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_CLEARED`"]
            #[inline]
            pub fn is_not_cleared(&self) -> bool {
                *self == CLRTRIGR::NOT_CLEARED
            }
            #[doc = "Checks if the value of the field is `CLEARED`"]
            #[inline]
            pub fn is_cleared(&self) -> bool {
                *self == CLRTRIGR::CLEARED
            }
        }
        #[doc = "Possible values of the field `SETINTA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETINTAR {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Set. The INTA flag for this channel will be set when the current descriptor is exhausted."]
            SET,
        }
        impl SETINTAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SETINTAR::NO_EFFECT => false,
                    SETINTAR::SET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SETINTAR {
                match value {
                    false => SETINTAR::NO_EFFECT,
                    true => SETINTAR::SET,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT`"]
            #[inline]
            pub fn is_no_effect(&self) -> bool {
                *self == SETINTAR::NO_EFFECT
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline]
            pub fn is_set(&self) -> bool {
                *self == SETINTAR::SET
            }
        }
        #[doc = "Possible values of the field `SETINTB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETINTBR {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Set. The INTB flag for this channel will be set when the current descriptor is exhausted."]
            SET,
        }
        impl SETINTBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SETINTBR::NO_EFFECT => false,
                    SETINTBR::SET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SETINTBR {
                match value {
                    false => SETINTBR::NO_EFFECT,
                    true => SETINTBR::SET,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT`"]
            #[inline]
            pub fn is_no_effect(&self) -> bool {
                *self == SETINTBR::NO_EFFECT
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline]
            pub fn is_set(&self) -> bool {
                *self == SETINTBR::SET
            }
        }
        #[doc = "Possible values of the field `WIDTH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WIDTHR {
            #[doc = "8-bit transfers are performed (8-bit source reads and destination writes)."]
            _8_BIT_TRANSFERS_ARE,
            #[doc = "16-bit transfers are performed (16-bit source reads and destination writes)."]
            _16_BIT_TRANSFERS_ARE,
            #[doc = "32-bit transfers are performed (32-bit source reads and destination writes)."]
            _32_BIT_TRANSFERS_ARE,
            #[doc = "Reserved setting, do not use."]
            RESERVED_SETTING,
        }
        impl WIDTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WIDTHR::_8_BIT_TRANSFERS_ARE => 0,
                    WIDTHR::_16_BIT_TRANSFERS_ARE => 0x01,
                    WIDTHR::_32_BIT_TRANSFERS_ARE => 0x02,
                    WIDTHR::RESERVED_SETTING => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WIDTHR {
                match value {
                    0 => WIDTHR::_8_BIT_TRANSFERS_ARE,
                    1 => WIDTHR::_16_BIT_TRANSFERS_ARE,
                    2 => WIDTHR::_32_BIT_TRANSFERS_ARE,
                    3 => WIDTHR::RESERVED_SETTING,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_8_BIT_TRANSFERS_ARE`"]
            #[inline]
            pub fn is_8_bit_transfers_are(&self) -> bool {
                *self == WIDTHR::_8_BIT_TRANSFERS_ARE
            }
            #[doc = "Checks if the value of the field is `_16_BIT_TRANSFERS_ARE`"]
            #[inline]
            pub fn is_16_bit_transfers_are(&self) -> bool {
                *self == WIDTHR::_16_BIT_TRANSFERS_ARE
            }
            #[doc = "Checks if the value of the field is `_32_BIT_TRANSFERS_ARE`"]
            #[inline]
            pub fn is_32_bit_transfers_are(&self) -> bool {
                *self == WIDTHR::_32_BIT_TRANSFERS_ARE
            }
            #[doc = "Checks if the value of the field is `RESERVED_SETTING`"]
            #[inline]
            pub fn is_reserved_setting(&self) -> bool {
                *self == WIDTHR::RESERVED_SETTING
            }
        }
        #[doc = "Possible values of the field `SRCINC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCINCR {
            #[doc = "No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device."]
            NO_INCREMENT,
            #[doc = "1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory."]
            _1_X_WIDTH,
            #[doc = "2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer."]
            _2_X_WIDTH,
            #[doc = "4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer."]
            _4_X_WIDTH,
        }
        impl SRCINCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCINCR::NO_INCREMENT => 0,
                    SRCINCR::_1_X_WIDTH => 0x01,
                    SRCINCR::_2_X_WIDTH => 0x02,
                    SRCINCR::_4_X_WIDTH => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRCINCR {
                match value {
                    0 => SRCINCR::NO_INCREMENT,
                    1 => SRCINCR::_1_X_WIDTH,
                    2 => SRCINCR::_2_X_WIDTH,
                    3 => SRCINCR::_4_X_WIDTH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_INCREMENT`"]
            #[inline]
            pub fn is_no_increment(&self) -> bool {
                *self == SRCINCR::NO_INCREMENT
            }
            #[doc = "Checks if the value of the field is `_1_X_WIDTH`"]
            #[inline]
            pub fn is_1_x_width(&self) -> bool {
                *self == SRCINCR::_1_X_WIDTH
            }
            #[doc = "Checks if the value of the field is `_2_X_WIDTH`"]
            #[inline]
            pub fn is_2_x_width(&self) -> bool {
                *self == SRCINCR::_2_X_WIDTH
            }
            #[doc = "Checks if the value of the field is `_4_X_WIDTH`"]
            #[inline]
            pub fn is_4_x_width(&self) -> bool {
                *self == SRCINCR::_4_X_WIDTH
            }
        }
        #[doc = "Possible values of the field `DSTINC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DSTINCR {
            #[doc = "No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device."]
            NO_INCREMENT,
            #[doc = "1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory."]
            _1_X_WIDTH,
            #[doc = "2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer."]
            _2_X_WIDTH,
            #[doc = "4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer."]
            _4_X_WIDTH,
        }
        impl DSTINCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DSTINCR::NO_INCREMENT => 0,
                    DSTINCR::_1_X_WIDTH => 0x01,
                    DSTINCR::_2_X_WIDTH => 0x02,
                    DSTINCR::_4_X_WIDTH => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DSTINCR {
                match value {
                    0 => DSTINCR::NO_INCREMENT,
                    1 => DSTINCR::_1_X_WIDTH,
                    2 => DSTINCR::_2_X_WIDTH,
                    3 => DSTINCR::_4_X_WIDTH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_INCREMENT`"]
            #[inline]
            pub fn is_no_increment(&self) -> bool {
                *self == DSTINCR::NO_INCREMENT
            }
            #[doc = "Checks if the value of the field is `_1_X_WIDTH`"]
            #[inline]
            pub fn is_1_x_width(&self) -> bool {
                *self == DSTINCR::_1_X_WIDTH
            }
            #[doc = "Checks if the value of the field is `_2_X_WIDTH`"]
            #[inline]
            pub fn is_2_x_width(&self) -> bool {
                *self == DSTINCR::_2_X_WIDTH
            }
            #[doc = "Checks if the value of the field is `_4_X_WIDTH`"]
            #[inline]
            pub fn is_4_x_width(&self) -> bool {
                *self == DSTINCR::_4_X_WIDTH
            }
        }
        #[doc = r" Value of the field"]
        pub struct XFERCOUNTR {
            bits: u16,
        }
        impl XFERCOUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `CFGVALID`"]
        pub enum CFGVALIDW {
            #[doc = "Not valid. The channel descriptor is not considered valid until validated by an associated SETVALID0 setting."]
            NOT_VALID,
            #[doc = "Valid. The current channel descriptor is considered valid."]
            VALID,
        }
        impl CFGVALIDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CFGVALIDW::NOT_VALID => false,
                    CFGVALIDW::VALID => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFGVALIDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFGVALIDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFGVALIDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not valid. The channel descriptor is not considered valid until validated by an associated SETVALID0 setting."]
            #[inline]
            pub fn not_valid(self) -> &'a mut W {
                self.variant(CFGVALIDW::NOT_VALID)
            }
            #[doc = "Valid. The current channel descriptor is considered valid."]
            #[inline]
            pub fn valid(self) -> &'a mut W {
                self.variant(CFGVALIDW::VALID)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RELOAD`"]
        pub enum RELOADW {
            #[doc = "Disabled. Do not reload the channels' control structure when the current descriptor is exhausted."]
            DISABLED,
            #[doc = "Enabled. Reload the channels' control structure when the current descriptor is exhausted."]
            ENABLED,
        }
        impl RELOADW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RELOADW::DISABLED => false,
                    RELOADW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RELOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RELOADW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RELOADW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Do not reload the channels' control structure when the current descriptor is exhausted."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RELOADW::DISABLED)
            }
            #[doc = "Enabled. Reload the channels' control structure when the current descriptor is exhausted."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RELOADW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWTRIG`"]
        pub enum SWTRIGW {
            #[doc = "When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel."]
            NOTSET,
            #[doc = "When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0."]
            SET,
        }
        impl SWTRIGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWTRIGW::NOTSET => false,
                    SWTRIGW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWTRIGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel."]
            #[inline]
            pub fn notset(self) -> &'a mut W {
                self.variant(SWTRIGW::NOTSET)
            }
            #[doc = "When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(SWTRIGW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLRTRIG`"]
        pub enum CLRTRIGW {
            #[doc = "Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started."]
            NOT_CLEARED,
            #[doc = "Cleared. The trigger is cleared when this descriptor is exhausted."]
            CLEARED,
        }
        impl CLRTRIGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLRTRIGW::NOT_CLEARED => false,
                    CLRTRIGW::CLEARED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRTRIGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRTRIGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLRTRIGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started."]
            #[inline]
            pub fn not_cleared(self) -> &'a mut W {
                self.variant(CLRTRIGW::NOT_CLEARED)
            }
            #[doc = "Cleared. The trigger is cleared when this descriptor is exhausted."]
            #[inline]
            pub fn cleared(self) -> &'a mut W {
                self.variant(CLRTRIGW::CLEARED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETINTA`"]
        pub enum SETINTAW {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Set. The INTA flag for this channel will be set when the current descriptor is exhausted."]
            SET,
        }
        impl SETINTAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SETINTAW::NO_EFFECT => false,
                    SETINTAW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETINTAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETINTAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETINTAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(SETINTAW::NO_EFFECT)
            }
            #[doc = "Set. The INTA flag for this channel will be set when the current descriptor is exhausted."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(SETINTAW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETINTB`"]
        pub enum SETINTBW {
            #[doc = "No effect."]
            NO_EFFECT,
            #[doc = "Set. The INTB flag for this channel will be set when the current descriptor is exhausted."]
            SET,
        }
        impl SETINTBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SETINTBW::NO_EFFECT => false,
                    SETINTBW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETINTBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETINTBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SETINTBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(SETINTBW::NO_EFFECT)
            }
            #[doc = "Set. The INTB flag for this channel will be set when the current descriptor is exhausted."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(SETINTBW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WIDTH`"]
        pub enum WIDTHW {
            #[doc = "8-bit transfers are performed (8-bit source reads and destination writes)."]
            _8_BIT_TRANSFERS_ARE,
            #[doc = "16-bit transfers are performed (16-bit source reads and destination writes)."]
            _16_BIT_TRANSFERS_ARE,
            #[doc = "32-bit transfers are performed (32-bit source reads and destination writes)."]
            _32_BIT_TRANSFERS_ARE,
            #[doc = "Reserved setting, do not use."]
            RESERVED_SETTING,
        }
        impl WIDTHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WIDTHW::_8_BIT_TRANSFERS_ARE => 0,
                    WIDTHW::_16_BIT_TRANSFERS_ARE => 1,
                    WIDTHW::_32_BIT_TRANSFERS_ARE => 2,
                    WIDTHW::RESERVED_SETTING => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WIDTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WIDTHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WIDTHW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "8-bit transfers are performed (8-bit source reads and destination writes)."]
            #[inline]
            pub fn _8_bit_transfers_are(self) -> &'a mut W {
                self.variant(WIDTHW::_8_BIT_TRANSFERS_ARE)
            }
            #[doc = "16-bit transfers are performed (16-bit source reads and destination writes)."]
            #[inline]
            pub fn _16_bit_transfers_are(self) -> &'a mut W {
                self.variant(WIDTHW::_16_BIT_TRANSFERS_ARE)
            }
            #[doc = "32-bit transfers are performed (32-bit source reads and destination writes)."]
            #[inline]
            pub fn _32_bit_transfers_are(self) -> &'a mut W {
                self.variant(WIDTHW::_32_BIT_TRANSFERS_ARE)
            }
            #[doc = "Reserved setting, do not use."]
            #[inline]
            pub fn reserved_setting(self) -> &'a mut W {
                self.variant(WIDTHW::RESERVED_SETTING)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRCINC`"]
        pub enum SRCINCW {
            #[doc = "No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device."]
            NO_INCREMENT,
            #[doc = "1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory."]
            _1_X_WIDTH,
            #[doc = "2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer."]
            _2_X_WIDTH,
            #[doc = "4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer."]
            _4_X_WIDTH,
        }
        impl SRCINCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRCINCW::NO_INCREMENT => 0,
                    SRCINCW::_1_X_WIDTH => 1,
                    SRCINCW::_2_X_WIDTH => 2,
                    SRCINCW::_4_X_WIDTH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRCINCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRCINCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRCINCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device."]
            #[inline]
            pub fn no_increment(self) -> &'a mut W {
                self.variant(SRCINCW::NO_INCREMENT)
            }
            #[doc = "1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory."]
            #[inline]
            pub fn _1_x_width(self) -> &'a mut W {
                self.variant(SRCINCW::_1_X_WIDTH)
            }
            #[doc = "2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer."]
            #[inline]
            pub fn _2_x_width(self) -> &'a mut W {
                self.variant(SRCINCW::_2_X_WIDTH)
            }
            #[doc = "4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer."]
            #[inline]
            pub fn _4_x_width(self) -> &'a mut W {
                self.variant(SRCINCW::_4_X_WIDTH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DSTINC`"]
        pub enum DSTINCW {
            #[doc = "No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device."]
            NO_INCREMENT,
            #[doc = "1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory."]
            _1_X_WIDTH,
            #[doc = "2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer."]
            _2_X_WIDTH,
            #[doc = "4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer."]
            _4_X_WIDTH,
        }
        impl DSTINCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DSTINCW::NO_INCREMENT => 0,
                    DSTINCW::_1_X_WIDTH => 1,
                    DSTINCW::_2_X_WIDTH => 2,
                    DSTINCW::_4_X_WIDTH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSTINCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSTINCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DSTINCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device."]
            #[inline]
            pub fn no_increment(self) -> &'a mut W {
                self.variant(DSTINCW::NO_INCREMENT)
            }
            #[doc = "1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory."]
            #[inline]
            pub fn _1_x_width(self) -> &'a mut W {
                self.variant(DSTINCW::_1_X_WIDTH)
            }
            #[doc = "2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer."]
            #[inline]
            pub fn _2_x_width(self) -> &'a mut W {
                self.variant(DSTINCW::_2_X_WIDTH)
            }
            #[doc = "4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer."]
            #[inline]
            pub fn _4_x_width(self) -> &'a mut W {
                self.variant(DSTINCW::_4_X_WIDTH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XFERCOUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XFERCOUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled."]
            #[inline]
            pub fn cfgvalid(&self) -> CFGVALIDR {
                CFGVALIDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers."]
            #[inline]
            pub fn reload(&self) -> RELOADR {
                RELOADR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Software Trigger."]
            #[inline]
            pub fn swtrig(&self) -> SWTRIGR {
                SWTRIGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Clear Trigger."]
            #[inline]
            pub fn clrtrig(&self) -> CLRTRIGR {
                CLRTRIGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed."]
            #[inline]
            pub fn setinta(&self) -> SETINTAR {
                SETINTAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed."]
            #[inline]
            pub fn setintb(&self) -> SETINTBR {
                SETINTBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:9 - Transfer width used for this DMA channel."]
            #[inline]
            pub fn width(&self) -> WIDTHR {
                WIDTHR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Determines whether the source address is incremented for each DMA transfer."]
            #[inline]
            pub fn srcinc(&self) -> SRCINCR {
                SRCINCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 14:15 - Determines whether the destination address is incremented for each DMA transfer."]
            #[inline]
            pub fn dstinc(&self) -> DSTINCR {
                DSTINCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:25 - Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed."]
            #[inline]
            pub fn xfercount(&self) -> XFERCOUNTR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                XFERCOUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled."]
            #[inline]
            pub fn cfgvalid(&mut self) -> _CFGVALIDW {
                _CFGVALIDW { w: self }
            }
            #[doc = "Bit 1 - Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers."]
            #[inline]
            pub fn reload(&mut self) -> _RELOADW {
                _RELOADW { w: self }
            }
            #[doc = "Bit 2 - Software Trigger."]
            #[inline]
            pub fn swtrig(&mut self) -> _SWTRIGW {
                _SWTRIGW { w: self }
            }
            #[doc = "Bit 3 - Clear Trigger."]
            #[inline]
            pub fn clrtrig(&mut self) -> _CLRTRIGW {
                _CLRTRIGW { w: self }
            }
            #[doc = "Bit 4 - Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed."]
            #[inline]
            pub fn setinta(&mut self) -> _SETINTAW {
                _SETINTAW { w: self }
            }
            #[doc = "Bit 5 - Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed."]
            #[inline]
            pub fn setintb(&mut self) -> _SETINTBW {
                _SETINTBW { w: self }
            }
            #[doc = "Bits 8:9 - Transfer width used for this DMA channel."]
            #[inline]
            pub fn width(&mut self) -> _WIDTHW {
                _WIDTHW { w: self }
            }
            #[doc = "Bits 12:13 - Determines whether the source address is incremented for each DMA transfer."]
            #[inline]
            pub fn srcinc(&mut self) -> _SRCINCW {
                _SRCINCW { w: self }
            }
            #[doc = "Bits 14:15 - Determines whether the destination address is incremented for each DMA transfer."]
            #[inline]
            pub fn dstinc(&mut self) -> _DSTINCW {
                _DSTINCW { w: self }
            }
            #[doc = "Bits 16:25 - Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed."]
            #[inline]
            pub fn xfercount(&mut self) -> _XFERCOUNTW {
                _XFERCOUNTW { w: self }
            }
        }
    }
}
#[doc = "General Purpose I/O port (GPIO)"]
pub struct GPIO_PORT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO_PORT {}
impl GPIO_PORT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpio_port::RegisterBlock {
        0xa000_0000 as *const _
    }
}
impl Deref for GPIO_PORT {
    type Target = gpio_port::RegisterBlock;
    fn deref(&self) -> &gpio_port::RegisterBlock {
        unsafe { &*GPIO_PORT::ptr() }
    }
}
#[doc = "General Purpose I/O port (GPIO)"]
pub mod gpio_port {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Byte pin registers port 0; pins PIO0_0 to PIO0_28"]
        pub b: [B; 29],
        _reserved0: [u8; 4067usize],
        #[doc = "0x1000 - Word pin registers port 0"]
        pub w: [W; 29],
        _reserved1: [u8; 3980usize],
        #[doc = "0x2000 - Direction registers port 0"]
        pub dir0: DIR0,
        _reserved2: [u8; 124usize],
        #[doc = "0x2080 - Mask register port 0"]
        pub mask0: MASK0,
        _reserved3: [u8; 124usize],
        #[doc = "0x2100 - Port pin register port 0"]
        pub pin0: PIN0,
        _reserved4: [u8; 124usize],
        #[doc = "0x2180 - Masked port register port 0"]
        pub mpin0: MPIN0,
        _reserved5: [u8; 124usize],
        #[doc = "0x2200 - Write: Set register for port 0 Read: output bits for port 0"]
        pub set0: SET0,
        _reserved6: [u8; 124usize],
        #[doc = "0x2280 - Clear port 0"]
        pub clr0: CLR0,
        _reserved7: [u8; 124usize],
        #[doc = "0x2300 - Toggle port 0"]
        pub not0: NOT0,
        _reserved8: [u8; 124usize],
        #[doc = "0x2380 - Set pin direction bits for port 0."]
        pub dirset0: DIRSET0,
        _reserved9: [u8; 124usize],
        #[doc = "0x2400 - Clear pin direction bits for port 0."]
        pub dirclr0: DIRCLR0,
        _reserved10: [u8; 124usize],
        #[doc = "0x2480 - Toggle pin direction bits for port 0."]
        pub dirnot0: DIRNOT0,
    }
    #[doc = "Byte pin registers port 0; pins PIO0_0 to PIO0_28"]
    pub struct B {
        register: ::vcell::VolatileCell<u8>,
    }
    #[doc = "Byte pin registers port 0; pins PIO0_0 to PIO0_28"]
    pub mod b {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::B {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PBYTER {
            bits: bool,
        }
        impl PBYTER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PBYTEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PBYTEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Read: state of the pin PIO0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: n = pin 0 to 28. Write: loads the pin's output bit."]
            #[inline]
            pub fn pbyte(&self) -> PBYTER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PBYTER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Read: state of the pin PIO0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: n = pin 0 to 28. Write: loads the pin's output bit."]
            #[inline]
            pub fn pbyte(&mut self) -> _PBYTEW {
                _PBYTEW { w: self }
            }
        }
    }
    #[doc = "Word pin registers port 0"]
    pub struct W {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Word pin registers port 0"]
    pub mod w {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::W {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PWORDR {
            bits: u32,
        }
        impl PWORDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWORDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWORDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: n = pin 0 to 28."]
            #[inline]
            pub fn pword(&self) -> PWORDR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PWORDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: n = pin 0 to 28."]
            #[inline]
            pub fn pword(&mut self) -> _PWORDW {
                _PWORDW { w: self }
            }
        }
    }
    #[doc = "Direction registers port 0"]
    pub struct DIR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Direction registers port 0"]
    pub mod dir0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRPR {
            bits: u32,
        }
        impl DIRPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:28 - Selects pin direction for pin PIO0_n (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 28 = PIO0_28). 0 = input. 1 = output."]
            #[inline]
            pub fn dirp(&self) -> DIRPR {
                let bits = {
                    const MASK: u32 = 0x1fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Selects pin direction for pin PIO0_n (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 28 = PIO0_28). 0 = input. 1 = output."]
            #[inline]
            pub fn dirp(&mut self) -> _DIRPW {
                _DIRPW { w: self }
            }
        }
    }
    #[doc = "Mask register port 0"]
    pub struct MASK0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Mask register port 0"]
    pub mod mask0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MASK0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASKPR {
            bits: u32,
        }
        impl MASKPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASKPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASKPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:28 - Controls which bits corresponding to PIO0_n are active in the MPORT register (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 28 = PIO0_28). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected."]
            #[inline]
            pub fn maskp(&self) -> MASKPR {
                let bits = {
                    const MASK: u32 = 0x1fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MASKPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Controls which bits corresponding to PIO0_n are active in the MPORT register (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 28 = PIO0_28). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected."]
            #[inline]
            pub fn maskp(&mut self) -> _MASKPW {
                _MASKPW { w: self }
            }
        }
    }
    #[doc = "Port pin register port 0"]
    pub struct PIN0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port pin register port 0"]
    pub mod pin0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIN0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PORTR {
            bits: u32,
        }
        impl PORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:28 - Reads pin states or loads output bits (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 38 = PIO0_28). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit."]
            #[inline]
            pub fn port(&self) -> PORTR {
                let bits = {
                    const MASK: u32 = 0x1fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PORTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Reads pin states or loads output bits (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 38 = PIO0_28). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit."]
            #[inline]
            pub fn port(&mut self) -> _PORTW {
                _PORTW { w: self }
            }
        }
    }
    #[doc = "Masked port register port 0"]
    pub struct MPIN0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Masked port register port 0"]
    pub mod mpin0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MPIN0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MPORTPR {
            bits: u32,
        }
        impl MPORTPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MPORTPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MPORTPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:28 - Masked port register (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0."]
            #[inline]
            pub fn mportp(&self) -> MPORTPR {
                let bits = {
                    const MASK: u32 = 0x1fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MPORTPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Masked port register (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0."]
            #[inline]
            pub fn mportp(&mut self) -> _MPORTPW {
                _MPORTPW { w: self }
            }
        }
    }
    #[doc = "Write: Set register for port 0 Read: output bits for port 0"]
    pub struct SET0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Write: Set register for port 0 Read: output bits for port 0"]
    pub mod set0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SET0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SETPR {
            bits: u32,
        }
        impl SETPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:28 - Read or set output bits (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit."]
            #[inline]
            pub fn setp(&self) -> SETPR {
                let bits = {
                    const MASK: u32 = 0x1fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SETPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Read or set output bits (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit."]
            #[inline]
            pub fn setp(&mut self) -> _SETPW {
                _SETPW { w: self }
            }
        }
    }
    #[doc = "Clear port 0"]
    pub struct CLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear port 0"]
    pub mod clr0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLR0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Clear output bits (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = No operation. 1 = Clear output bit."]
            #[inline]
            pub fn clrp(&mut self) -> _CLRPW {
                _CLRPW { w: self }
            }
        }
    }
    #[doc = "Toggle port 0"]
    pub struct NOT0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Toggle port 0"]
    pub mod not0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NOT0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _NOTPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NOTPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Toggle output bits (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = no operation. 1 = Toggle output bit."]
            #[inline]
            pub fn notp(&mut self) -> _NOTPW {
                _NOTPW { w: self }
            }
        }
    }
    #[doc = "Set pin direction bits for port 0."]
    pub struct DIRSET0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Set pin direction bits for port 0."]
    pub mod dirset0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRSET0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRSETPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRSETPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Set direction bits (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 28 = PIO0_28). 0 = No operation. 1 = Set direction bit."]
            #[inline]
            pub fn dirsetp(&mut self) -> _DIRSETPW {
                _DIRSETPW { w: self }
            }
        }
    }
    #[doc = "Clear pin direction bits for port 0."]
    pub struct DIRCLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear pin direction bits for port 0."]
    pub mod dirclr0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRCLR0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRCLRPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRCLRPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Clear direction bits (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = No operation. 1 = Clear direction bit."]
            #[inline]
            pub fn dirclrp(&mut self) -> _DIRCLRPW {
                _DIRCLRPW { w: self }
            }
        }
    }
    #[doc = "Toggle pin direction bits for port 0."]
    pub struct DIRNOT0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Toggle pin direction bits for port 0."]
    pub mod dirnot0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRNOT0 {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRNOTPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRNOTPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x1fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:28 - Toggle direction bits (bit 0 = PIO0_0, bit 1 =PIO0_1, ..., bit 28 = PIO0_28). 0 = no operation. 1 = Toggle direction bit."]
            #[inline]
            pub fn dirnotp(&mut self) -> _DIRNOTPW {
                _DIRNOTPW { w: self }
            }
        }
    }
}
#[doc = "Pin interrupt and pattern match engine"]
pub struct PIN_INT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PIN_INT {}
impl PIN_INT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const pin_int::RegisterBlock {
        0xa000_4000 as *const _
    }
}
impl Deref for PIN_INT {
    type Target = pin_int::RegisterBlock;
    fn deref(&self) -> &pin_int::RegisterBlock {
        unsafe { &*PIN_INT::ptr() }
    }
}
#[doc = "Pin interrupt and pattern match engine"]
pub mod pin_int {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Pin Interrupt Mode register"]
        pub isel: ISEL,
        #[doc = "0x04 - Pin interrupt level or rising edge interrupt enable register"]
        pub ienr: IENR,
        #[doc = "0x08 - Pin interrupt level (rising edge) interrupt set register"]
        pub sienr: SIENR,
        #[doc = "0x0c - Pin interrupt level or rising edge interrupt clear register"]
        pub cienr: CIENR,
        #[doc = "0x10 - Pin interrupt active level or falling edge interrupt enable register"]
        pub ienf: IENF,
        #[doc = "0x14 - Pin interrupt active level or falling edge interrupt set register"]
        pub sienf: SIENF,
        #[doc = "0x18 - Pin interrupt active level (falling edge) interrupt clear register"]
        pub cienf: CIENF,
        #[doc = "0x1c - Pin interrupt rising edge register"]
        pub rise: RISE,
        #[doc = "0x20 - Pin interrupt falling edge register"]
        pub fall: FALL,
        #[doc = "0x24 - Pin interrupt status register"]
        pub ist: IST,
        #[doc = "0x28 - GPIO pattern match interrupt control register"]
        pub pmctrl: PMCTRL,
        #[doc = "0x2c - GPIO pattern match interrupt bit-slice source register"]
        pub pmsrc: PMSRC,
        #[doc = "0x30 - GPIO pattern match interrupt bit slice configuration register"]
        pub pmcfg: PMCFG,
    }
    #[doc = "Pin Interrupt Mode register"]
    pub struct ISEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin Interrupt Mode register"]
    pub mod isel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ISEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMODER {
            bits: u8,
        }
        impl PMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMODEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive"]
            #[inline]
            pub fn pmode(&self) -> PMODER {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PMODER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive"]
            #[inline]
            pub fn pmode(&mut self) -> _PMODEW {
                _PMODEW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt level or rising edge interrupt enable register"]
    pub struct IENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt level or rising edge interrupt enable register"]
    pub mod ienr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IENR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENRLR {
            bits: u8,
        }
        impl ENRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt."]
            #[inline]
            pub fn enrl(&self) -> ENRLR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ENRLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt."]
            #[inline]
            pub fn enrl(&mut self) -> _ENRLW {
                _ENRLW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt level (rising edge) interrupt set register"]
    pub struct SIENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt level (rising edge) interrupt set register"]
    pub mod sienr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SIENR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETENRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETENRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt."]
            #[inline]
            pub fn setenrl(&mut self) -> _SETENRLW {
                _SETENRLW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt level or rising edge interrupt clear register"]
    pub struct CIENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt level or rising edge interrupt clear register"]
    pub mod cienr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CIENR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt."]
            #[inline]
            pub fn cenrl(&mut self) -> _CENRLW {
                _CENRLW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt active level or falling edge interrupt enable register"]
    pub struct IENF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt active level or falling edge interrupt enable register"]
    pub mod ienf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IENF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENAFR {
            bits: u8,
        }
        impl ENAFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH."]
            #[inline]
            pub fn enaf(&self) -> ENAFR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ENAFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH."]
            #[inline]
            pub fn enaf(&mut self) -> _ENAFW {
                _ENAFW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt active level or falling edge interrupt set register"]
    pub struct SIENF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt active level or falling edge interrupt set register"]
    pub mod sienf {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SIENF {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETENAFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETENAFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt."]
            #[inline]
            pub fn setenaf(&mut self) -> _SETENAFW {
                _SETENAFW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt active level (falling edge) interrupt clear register"]
    pub struct CIENF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt active level (falling edge) interrupt clear register"]
    pub mod cienf {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CIENF {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENAFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENAFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled."]
            #[inline]
            pub fn cenaf(&mut self) -> _CENAFW {
                _CENAFW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt rising edge register"]
    pub struct RISE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt rising edge register"]
    pub mod rise {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RISE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RDETR {
            bits: u8,
        }
        impl RDETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RDETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin."]
            #[inline]
            pub fn rdet(&self) -> RDETR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RDETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin."]
            #[inline]
            pub fn rdet(&mut self) -> _RDETW {
                _RDETW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt falling edge register"]
    pub struct FALL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt falling edge register"]
    pub mod fall {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FALL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FDETR {
            bits: u8,
        }
        impl FDETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FDETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin."]
            #[inline]
            pub fn fdet(&self) -> FDETR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FDETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin."]
            #[inline]
            pub fn fdet(&mut self) -> _FDETW {
                _FDETW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt status register"]
    pub struct IST {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin interrupt status register"]
    pub mod ist {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IST {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSTATR {
            bits: u8,
        }
        impl PSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSTATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register)."]
            #[inline]
            pub fn pstat(&self) -> PSTATR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PSTATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register)."]
            #[inline]
            pub fn pstat(&mut self) -> _PSTATW {
                _PSTATW { w: self }
            }
        }
    }
    #[doc = "GPIO pattern match interrupt control register"]
    pub struct PMCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "GPIO pattern match interrupt control register"]
    pub mod pmctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL_PMATCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEL_PMATCHR {
            #[doc = "Pin interrupt. Interrupts are driven in response to the standard pin interrupt function"]
            PIN_INTERRUPT_INTER,
            #[doc = "Pattern match. Interrupts are driven in response to pattern matches."]
            PATTERN_MATCH_INTER,
        }
        impl SEL_PMATCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SEL_PMATCHR::PIN_INTERRUPT_INTER => false,
                    SEL_PMATCHR::PATTERN_MATCH_INTER => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SEL_PMATCHR {
                match value {
                    false => SEL_PMATCHR::PIN_INTERRUPT_INTER,
                    true => SEL_PMATCHR::PATTERN_MATCH_INTER,
                }
            }
            #[doc = "Checks if the value of the field is `PIN_INTERRUPT_INTER`"]
            #[inline]
            pub fn is_pin_interrupt_inter(&self) -> bool {
                *self == SEL_PMATCHR::PIN_INTERRUPT_INTER
            }
            #[doc = "Checks if the value of the field is `PATTERN_MATCH_INTER`"]
            #[inline]
            pub fn is_pattern_match_inter(&self) -> bool {
                *self == SEL_PMATCHR::PATTERN_MATCH_INTER
            }
        }
        #[doc = "Possible values of the field `ENA_RXEV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA_RXEVR {
            #[doc = "Disabled. RxEv output to the cpu is disabled."]
            DISABLED_RXEV_OUTPU,
            #[doc = "Enabled. RxEv output to the cpu is enabled."]
            ENABLED_RXEV_OUTPUT,
        }
        impl ENA_RXEVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA_RXEVR::DISABLED_RXEV_OUTPU => false,
                    ENA_RXEVR::ENABLED_RXEV_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA_RXEVR {
                match value {
                    false => ENA_RXEVR::DISABLED_RXEV_OUTPU,
                    true => ENA_RXEVR::ENABLED_RXEV_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_RXEV_OUTPU`"]
            #[inline]
            pub fn is_disabled_rxev_outpu(&self) -> bool {
                *self == ENA_RXEVR::DISABLED_RXEV_OUTPU
            }
            #[doc = "Checks if the value of the field is `ENABLED_RXEV_OUTPUT`"]
            #[inline]
            pub fn is_enabled_rxev_output(&self) -> bool {
                *self == ENA_RXEVR::ENABLED_RXEV_OUTPUT
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMATR {
            bits: u8,
        }
        impl PMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SEL_PMATCH`"]
        pub enum SEL_PMATCHW {
            #[doc = "Pin interrupt. Interrupts are driven in response to the standard pin interrupt function"]
            PIN_INTERRUPT_INTER,
            #[doc = "Pattern match. Interrupts are driven in response to pattern matches."]
            PATTERN_MATCH_INTER,
        }
        impl SEL_PMATCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SEL_PMATCHW::PIN_INTERRUPT_INTER => false,
                    SEL_PMATCHW::PATTERN_MATCH_INTER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEL_PMATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEL_PMATCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SEL_PMATCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin interrupt. Interrupts are driven in response to the standard pin interrupt function"]
            #[inline]
            pub fn pin_interrupt_inter(self) -> &'a mut W {
                self.variant(SEL_PMATCHW::PIN_INTERRUPT_INTER)
            }
            #[doc = "Pattern match. Interrupts are driven in response to pattern matches."]
            #[inline]
            pub fn pattern_match_inter(self) -> &'a mut W {
                self.variant(SEL_PMATCHW::PATTERN_MATCH_INTER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA_RXEV`"]
        pub enum ENA_RXEVW {
            #[doc = "Disabled. RxEv output to the cpu is disabled."]
            DISABLED_RXEV_OUTPU,
            #[doc = "Enabled. RxEv output to the cpu is enabled."]
            ENABLED_RXEV_OUTPUT,
        }
        impl ENA_RXEVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA_RXEVW::DISABLED_RXEV_OUTPU => false,
                    ENA_RXEVW::ENABLED_RXEV_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA_RXEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA_RXEVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA_RXEVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. RxEv output to the cpu is disabled."]
            #[inline]
            pub fn disabled_rxev_outpu(self) -> &'a mut W {
                self.variant(ENA_RXEVW::DISABLED_RXEV_OUTPU)
            }
            #[doc = "Enabled. RxEv output to the cpu is enabled."]
            #[inline]
            pub fn enabled_rxev_output(self) -> &'a mut W {
                self.variant(ENA_RXEVW::ENABLED_RXEV_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function."]
            #[inline]
            pub fn sel_pmatch(&self) -> SEL_PMATCHR {
                SEL_PMATCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enables the RxEv output to the ARM cpu and/or to a GPIO output when the specified boolean expression evaluates to true."]
            #[inline]
            pub fn ena_rxev(&self) -> ENA_RXEVR {
                ENA_RXEVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 24:31 - This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs."]
            #[inline]
            pub fn pmat(&self) -> PMATR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PMATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function."]
            #[inline]
            pub fn sel_pmatch(&mut self) -> _SEL_PMATCHW {
                _SEL_PMATCHW { w: self }
            }
            #[doc = "Bit 1 - Enables the RxEv output to the ARM cpu and/or to a GPIO output when the specified boolean expression evaluates to true."]
            #[inline]
            pub fn ena_rxev(&mut self) -> _ENA_RXEVW {
                _ENA_RXEVW { w: self }
            }
            #[doc = "Bits 24:31 - This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs."]
            #[inline]
            pub fn pmat(&mut self) -> _PMATW {
                _PMATW { w: self }
            }
        }
    }
    #[doc = "GPIO pattern match interrupt bit-slice source register"]
    pub struct PMSRC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "GPIO pattern match interrupt bit-slice source register"]
    pub mod pmsrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMSRC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SRC0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC0R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 0."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 0."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 0."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 0."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 0."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 0."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 0."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 0."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC0R::INPUT_0_SELECTS_PIN => 0,
                    SRC0R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC0R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC0R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC0R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC0R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC0R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC0R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC0R {
                match value {
                    0 => SRC0R::INPUT_0_SELECTS_PIN,
                    1 => SRC0R::INPUT_1_SELECTS_PIN,
                    2 => SRC0R::INPUT_2_SELECTS_PIN,
                    3 => SRC0R::INPUT_3_SELECTS_PIN,
                    4 => SRC0R::INPUT_4_SELECTS_PIN,
                    5 => SRC0R::INPUT_5_SELECTS_PIN,
                    6 => SRC0R::INPUT_6_SELECTS_PIN,
                    7 => SRC0R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC1R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 1."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 1."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 1."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 1."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 1."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 1."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 1."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 1."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC1R::INPUT_0_SELECTS_PIN => 0,
                    SRC1R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC1R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC1R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC1R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC1R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC1R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC1R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC1R {
                match value {
                    0 => SRC1R::INPUT_0_SELECTS_PIN,
                    1 => SRC1R::INPUT_1_SELECTS_PIN,
                    2 => SRC1R::INPUT_2_SELECTS_PIN,
                    3 => SRC1R::INPUT_3_SELECTS_PIN,
                    4 => SRC1R::INPUT_4_SELECTS_PIN,
                    5 => SRC1R::INPUT_5_SELECTS_PIN,
                    6 => SRC1R::INPUT_6_SELECTS_PIN,
                    7 => SRC1R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC2R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 2."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 2."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 2."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 2."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 2."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 2."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 2."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 2."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC2R::INPUT_0_SELECTS_PIN => 0,
                    SRC2R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC2R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC2R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC2R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC2R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC2R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC2R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC2R {
                match value {
                    0 => SRC2R::INPUT_0_SELECTS_PIN,
                    1 => SRC2R::INPUT_1_SELECTS_PIN,
                    2 => SRC2R::INPUT_2_SELECTS_PIN,
                    3 => SRC2R::INPUT_3_SELECTS_PIN,
                    4 => SRC2R::INPUT_4_SELECTS_PIN,
                    5 => SRC2R::INPUT_5_SELECTS_PIN,
                    6 => SRC2R::INPUT_6_SELECTS_PIN,
                    7 => SRC2R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC3R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 3."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 3."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 3."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 3."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 3."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 3."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 3."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 3."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC3R::INPUT_0_SELECTS_PIN => 0,
                    SRC3R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC3R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC3R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC3R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC3R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC3R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC3R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC3R {
                match value {
                    0 => SRC3R::INPUT_0_SELECTS_PIN,
                    1 => SRC3R::INPUT_1_SELECTS_PIN,
                    2 => SRC3R::INPUT_2_SELECTS_PIN,
                    3 => SRC3R::INPUT_3_SELECTS_PIN,
                    4 => SRC3R::INPUT_4_SELECTS_PIN,
                    5 => SRC3R::INPUT_5_SELECTS_PIN,
                    6 => SRC3R::INPUT_6_SELECTS_PIN,
                    7 => SRC3R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC4R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 4."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 4."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 4."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 4."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 4."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 4."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 4."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 4."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC4R::INPUT_0_SELECTS_PIN => 0,
                    SRC4R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC4R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC4R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC4R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC4R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC4R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC4R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC4R {
                match value {
                    0 => SRC4R::INPUT_0_SELECTS_PIN,
                    1 => SRC4R::INPUT_1_SELECTS_PIN,
                    2 => SRC4R::INPUT_2_SELECTS_PIN,
                    3 => SRC4R::INPUT_3_SELECTS_PIN,
                    4 => SRC4R::INPUT_4_SELECTS_PIN,
                    5 => SRC4R::INPUT_5_SELECTS_PIN,
                    6 => SRC4R::INPUT_6_SELECTS_PIN,
                    7 => SRC4R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC5R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 5."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 5."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 5."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 5."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 5."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 5."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 5."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 5."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC5R::INPUT_0_SELECTS_PIN => 0,
                    SRC5R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC5R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC5R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC5R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC5R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC5R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC5R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC5R {
                match value {
                    0 => SRC5R::INPUT_0_SELECTS_PIN,
                    1 => SRC5R::INPUT_1_SELECTS_PIN,
                    2 => SRC5R::INPUT_2_SELECTS_PIN,
                    3 => SRC5R::INPUT_3_SELECTS_PIN,
                    4 => SRC5R::INPUT_4_SELECTS_PIN,
                    5 => SRC5R::INPUT_5_SELECTS_PIN,
                    6 => SRC5R::INPUT_6_SELECTS_PIN,
                    7 => SRC5R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC6R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 6."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 6."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 6."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 6."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 6."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 6."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 6."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 6."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC6R::INPUT_0_SELECTS_PIN => 0,
                    SRC6R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC6R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC6R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC6R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC6R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC6R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC6R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC6R {
                match value {
                    0 => SRC6R::INPUT_0_SELECTS_PIN,
                    1 => SRC6R::INPUT_1_SELECTS_PIN,
                    2 => SRC6R::INPUT_2_SELECTS_PIN,
                    3 => SRC6R::INPUT_3_SELECTS_PIN,
                    4 => SRC6R::INPUT_4_SELECTS_PIN,
                    5 => SRC6R::INPUT_5_SELECTS_PIN,
                    6 => SRC6R::INPUT_6_SELECTS_PIN,
                    7 => SRC6R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC7R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 7."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 7."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 7."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 7."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 7."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 7."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 7."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 7."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC7R::INPUT_0_SELECTS_PIN => 0,
                    SRC7R::INPUT_1_SELECTS_PIN => 0x01,
                    SRC7R::INPUT_2_SELECTS_PIN => 0x02,
                    SRC7R::INPUT_3_SELECTS_PIN => 0x03,
                    SRC7R::INPUT_4_SELECTS_PIN => 0x04,
                    SRC7R::INPUT_5_SELECTS_PIN => 0x05,
                    SRC7R::INPUT_6_SELECTS_PIN => 0x06,
                    SRC7R::INPUT_7_SELECTS_PIN => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRC7R {
                match value {
                    0 => SRC7R::INPUT_0_SELECTS_PIN,
                    1 => SRC7R::INPUT_1_SELECTS_PIN,
                    2 => SRC7R::INPUT_2_SELECTS_PIN,
                    3 => SRC7R::INPUT_3_SELECTS_PIN,
                    4 => SRC7R::INPUT_4_SELECTS_PIN,
                    5 => SRC7R::INPUT_5_SELECTS_PIN,
                    6 => SRC7R::INPUT_6_SELECTS_PIN,
                    7 => SRC7R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Values that can be written to the field `SRC0`"]
        pub enum SRC0W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 0."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 0."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 0."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 0."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 0."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 0."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 0."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 0."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC0W::INPUT_0_SELECTS_PIN => 0,
                    SRC0W::INPUT_1_SELECTS_PIN => 1,
                    SRC0W::INPUT_2_SELECTS_PIN => 2,
                    SRC0W::INPUT_3_SELECTS_PIN => 3,
                    SRC0W::INPUT_4_SELECTS_PIN => 4,
                    SRC0W::INPUT_5_SELECTS_PIN => 5,
                    SRC0W::INPUT_6_SELECTS_PIN => 6,
                    SRC0W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 0."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 0."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 0."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 0."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 0."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 0."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 0."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 0."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC1`"]
        pub enum SRC1W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 1."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 1."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 1."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 1."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 1."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 1."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 1."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 1."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC1W::INPUT_0_SELECTS_PIN => 0,
                    SRC1W::INPUT_1_SELECTS_PIN => 1,
                    SRC1W::INPUT_2_SELECTS_PIN => 2,
                    SRC1W::INPUT_3_SELECTS_PIN => 3,
                    SRC1W::INPUT_4_SELECTS_PIN => 4,
                    SRC1W::INPUT_5_SELECTS_PIN => 5,
                    SRC1W::INPUT_6_SELECTS_PIN => 6,
                    SRC1W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 1."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 1."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 1."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 1."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 1."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 1."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 1."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 1."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC2`"]
        pub enum SRC2W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 2."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 2."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 2."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 2."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 2."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 2."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 2."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 2."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC2W::INPUT_0_SELECTS_PIN => 0,
                    SRC2W::INPUT_1_SELECTS_PIN => 1,
                    SRC2W::INPUT_2_SELECTS_PIN => 2,
                    SRC2W::INPUT_3_SELECTS_PIN => 3,
                    SRC2W::INPUT_4_SELECTS_PIN => 4,
                    SRC2W::INPUT_5_SELECTS_PIN => 5,
                    SRC2W::INPUT_6_SELECTS_PIN => 6,
                    SRC2W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 2."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 2."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 2."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 2."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 2."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 2."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 2."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 2."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC3`"]
        pub enum SRC3W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 3."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 3."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 3."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 3."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 3."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 3."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 3."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 3."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC3W::INPUT_0_SELECTS_PIN => 0,
                    SRC3W::INPUT_1_SELECTS_PIN => 1,
                    SRC3W::INPUT_2_SELECTS_PIN => 2,
                    SRC3W::INPUT_3_SELECTS_PIN => 3,
                    SRC3W::INPUT_4_SELECTS_PIN => 4,
                    SRC3W::INPUT_5_SELECTS_PIN => 5,
                    SRC3W::INPUT_6_SELECTS_PIN => 6,
                    SRC3W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 3."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 3."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 3."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 3."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 3."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 3."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 3."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 3."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC4`"]
        pub enum SRC4W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 4."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 4."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 4."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 4."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 4."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 4."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 4."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 4."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC4W::INPUT_0_SELECTS_PIN => 0,
                    SRC4W::INPUT_1_SELECTS_PIN => 1,
                    SRC4W::INPUT_2_SELECTS_PIN => 2,
                    SRC4W::INPUT_3_SELECTS_PIN => 3,
                    SRC4W::INPUT_4_SELECTS_PIN => 4,
                    SRC4W::INPUT_5_SELECTS_PIN => 5,
                    SRC4W::INPUT_6_SELECTS_PIN => 6,
                    SRC4W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 4."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 4."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 4."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 4."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 4."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 4."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 4."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 4."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC5`"]
        pub enum SRC5W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 5."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 5."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 5."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 5."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 5."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 5."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 5."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 5."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC5W::INPUT_0_SELECTS_PIN => 0,
                    SRC5W::INPUT_1_SELECTS_PIN => 1,
                    SRC5W::INPUT_2_SELECTS_PIN => 2,
                    SRC5W::INPUT_3_SELECTS_PIN => 3,
                    SRC5W::INPUT_4_SELECTS_PIN => 4,
                    SRC5W::INPUT_5_SELECTS_PIN => 5,
                    SRC5W::INPUT_6_SELECTS_PIN => 6,
                    SRC5W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 5."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 5."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 5."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 5."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 5."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 5."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 5."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 5."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC6`"]
        pub enum SRC6W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 6."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 6."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 6."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 6."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 6."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 6."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 6."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 6."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC6W::INPUT_0_SELECTS_PIN => 0,
                    SRC6W::INPUT_1_SELECTS_PIN => 1,
                    SRC6W::INPUT_2_SELECTS_PIN => 2,
                    SRC6W::INPUT_3_SELECTS_PIN => 3,
                    SRC6W::INPUT_4_SELECTS_PIN => 4,
                    SRC6W::INPUT_5_SELECTS_PIN => 5,
                    SRC6W::INPUT_6_SELECTS_PIN => 6,
                    SRC6W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 6."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 6."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 6."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 6."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 6."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 6."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 6."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 6."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC7`"]
        pub enum SRC7W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 7."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 7."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 7."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 7."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 7."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 7."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 7."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 7."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC7W::INPUT_0_SELECTS_PIN => 0,
                    SRC7W::INPUT_1_SELECTS_PIN => 1,
                    SRC7W::INPUT_2_SELECTS_PIN => 2,
                    SRC7W::INPUT_3_SELECTS_PIN => 3,
                    SRC7W::INPUT_4_SELECTS_PIN => 4,
                    SRC7W::INPUT_5_SELECTS_PIN => 5,
                    SRC7W::INPUT_6_SELECTS_PIN => 6,
                    SRC7W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRC7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 7."]
            #[inline]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 7."]
            #[inline]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 7."]
            #[inline]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 7."]
            #[inline]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 7."]
            #[inline]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 7."]
            #[inline]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 7."]
            #[inline]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 7."]
            #[inline]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:10 - Selects the input source for bit slice 0"]
            #[inline]
            pub fn src0(&self) -> SRC0R {
                SRC0R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:13 - Selects the input source for bit slice 1"]
            #[inline]
            pub fn src1(&self) -> SRC1R {
                SRC1R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 14:16 - Selects the input source for bit slice 2"]
            #[inline]
            pub fn src2(&self) -> SRC2R {
                SRC2R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 17:19 - Selects the input source for bit slice 3"]
            #[inline]
            pub fn src3(&self) -> SRC3R {
                SRC3R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 20:22 - Selects the input source for bit slice 4"]
            #[inline]
            pub fn src4(&self) -> SRC4R {
                SRC4R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 23:25 - Selects the input source for bit slice 5"]
            #[inline]
            pub fn src5(&self) -> SRC5R {
                SRC5R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 26:28 - Selects the input source for bit slice 6"]
            #[inline]
            pub fn src6(&self) -> SRC6R {
                SRC6R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 29:31 - Selects the input source for bit slice 7"]
            #[inline]
            pub fn src7(&self) -> SRC7R {
                SRC7R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:10 - Selects the input source for bit slice 0"]
            #[inline]
            pub fn src0(&mut self) -> _SRC0W {
                _SRC0W { w: self }
            }
            #[doc = "Bits 11:13 - Selects the input source for bit slice 1"]
            #[inline]
            pub fn src1(&mut self) -> _SRC1W {
                _SRC1W { w: self }
            }
            #[doc = "Bits 14:16 - Selects the input source for bit slice 2"]
            #[inline]
            pub fn src2(&mut self) -> _SRC2W {
                _SRC2W { w: self }
            }
            #[doc = "Bits 17:19 - Selects the input source for bit slice 3"]
            #[inline]
            pub fn src3(&mut self) -> _SRC3W {
                _SRC3W { w: self }
            }
            #[doc = "Bits 20:22 - Selects the input source for bit slice 4"]
            #[inline]
            pub fn src4(&mut self) -> _SRC4W {
                _SRC4W { w: self }
            }
            #[doc = "Bits 23:25 - Selects the input source for bit slice 5"]
            #[inline]
            pub fn src5(&mut self) -> _SRC5W {
                _SRC5W { w: self }
            }
            #[doc = "Bits 26:28 - Selects the input source for bit slice 6"]
            #[inline]
            pub fn src6(&mut self) -> _SRC6W {
                _SRC6W { w: self }
            }
            #[doc = "Bits 29:31 - Selects the input source for bit slice 7"]
            #[inline]
            pub fn src7(&mut self) -> _SRC7W {
                _SRC7W { w: self }
            }
        }
    }
    #[doc = "GPIO pattern match interrupt bit slice configuration register"]
    pub struct PMCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "GPIO pattern match interrupt bit slice configuration register"]
    pub mod pmcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROD_ENDPTSR {
            bits: u8,
        }
        impl PROD_ENDPTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CFG0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG0R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG0R::CONSTANT_1_THIS_BIT => 0,
                    CFG0R::RISING_EDGE_MATCH_O => 0x01,
                    CFG0R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG0R::RISING_OR_FALLING_ED => 0x03,
                    CFG0R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG0R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG0R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG0R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG0R {
                match value {
                    0 => CFG0R::CONSTANT_1_THIS_BIT,
                    1 => CFG0R::RISING_EDGE_MATCH_O,
                    2 => CFG0R::FALLING_EDGE_MATCH_,
                    3 => CFG0R::RISING_OR_FALLING_ED,
                    4 => CFG0R::HIGH_LEVEL_MATCH_F,
                    5 => CFG0R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG0R::CONSTANT_0_THIS_BIT,
                    7 => CFG0R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG0R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG0R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG0R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG0R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG0R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG0R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG0R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG0R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG1R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG1R::CONSTANT_1_THIS_BIT => 0,
                    CFG1R::RISING_EDGE_MATCH_O => 0x01,
                    CFG1R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG1R::RISING_OR_FALLING_ED => 0x03,
                    CFG1R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG1R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG1R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG1R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG1R {
                match value {
                    0 => CFG1R::CONSTANT_1_THIS_BIT,
                    1 => CFG1R::RISING_EDGE_MATCH_O,
                    2 => CFG1R::FALLING_EDGE_MATCH_,
                    3 => CFG1R::RISING_OR_FALLING_ED,
                    4 => CFG1R::HIGH_LEVEL_MATCH_F,
                    5 => CFG1R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG1R::CONSTANT_0_THIS_BIT,
                    7 => CFG1R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG1R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG1R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG1R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG1R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG1R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG1R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG1R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG1R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG2R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG2R::CONSTANT_1_THIS_BIT => 0,
                    CFG2R::RISING_EDGE_MATCH_O => 0x01,
                    CFG2R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG2R::RISING_OR_FALLING_ED => 0x03,
                    CFG2R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG2R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG2R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG2R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG2R {
                match value {
                    0 => CFG2R::CONSTANT_1_THIS_BIT,
                    1 => CFG2R::RISING_EDGE_MATCH_O,
                    2 => CFG2R::FALLING_EDGE_MATCH_,
                    3 => CFG2R::RISING_OR_FALLING_ED,
                    4 => CFG2R::HIGH_LEVEL_MATCH_F,
                    5 => CFG2R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG2R::CONSTANT_0_THIS_BIT,
                    7 => CFG2R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG2R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG2R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG2R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG2R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG2R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG2R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG2R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG2R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG3R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG3R::CONSTANT_1_THIS_BIT => 0,
                    CFG3R::RISING_EDGE_MATCH_O => 0x01,
                    CFG3R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG3R::RISING_OR_FALLING_ED => 0x03,
                    CFG3R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG3R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG3R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG3R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG3R {
                match value {
                    0 => CFG3R::CONSTANT_1_THIS_BIT,
                    1 => CFG3R::RISING_EDGE_MATCH_O,
                    2 => CFG3R::FALLING_EDGE_MATCH_,
                    3 => CFG3R::RISING_OR_FALLING_ED,
                    4 => CFG3R::HIGH_LEVEL_MATCH_F,
                    5 => CFG3R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG3R::CONSTANT_0_THIS_BIT,
                    7 => CFG3R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG3R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG3R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG3R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG3R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG3R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG3R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG3R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG3R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG4R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG4R::CONSTANT_1_THIS_BIT => 0,
                    CFG4R::RISING_EDGE_MATCH_O => 0x01,
                    CFG4R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG4R::RISING_OR_FALLING_ED => 0x03,
                    CFG4R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG4R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG4R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG4R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG4R {
                match value {
                    0 => CFG4R::CONSTANT_1_THIS_BIT,
                    1 => CFG4R::RISING_EDGE_MATCH_O,
                    2 => CFG4R::FALLING_EDGE_MATCH_,
                    3 => CFG4R::RISING_OR_FALLING_ED,
                    4 => CFG4R::HIGH_LEVEL_MATCH_F,
                    5 => CFG4R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG4R::CONSTANT_0_THIS_BIT,
                    7 => CFG4R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG4R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG4R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG4R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG4R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG4R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG4R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG4R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG4R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG5R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG5R::CONSTANT_1_THIS_BIT => 0,
                    CFG5R::RISING_EDGE_MATCH_O => 0x01,
                    CFG5R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG5R::RISING_OR_FALLING_ED => 0x03,
                    CFG5R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG5R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG5R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG5R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG5R {
                match value {
                    0 => CFG5R::CONSTANT_1_THIS_BIT,
                    1 => CFG5R::RISING_EDGE_MATCH_O,
                    2 => CFG5R::FALLING_EDGE_MATCH_,
                    3 => CFG5R::RISING_OR_FALLING_ED,
                    4 => CFG5R::HIGH_LEVEL_MATCH_F,
                    5 => CFG5R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG5R::CONSTANT_0_THIS_BIT,
                    7 => CFG5R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG5R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG5R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG5R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG5R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG5R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG5R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG5R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG5R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG6R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG6R::CONSTANT_1_THIS_BIT => 0,
                    CFG6R::RISING_EDGE_MATCH_O => 0x01,
                    CFG6R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG6R::RISING_OR_FALLING_ED => 0x03,
                    CFG6R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG6R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG6R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG6R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG6R {
                match value {
                    0 => CFG6R::CONSTANT_1_THIS_BIT,
                    1 => CFG6R::RISING_EDGE_MATCH_O,
                    2 => CFG6R::FALLING_EDGE_MATCH_,
                    3 => CFG6R::RISING_OR_FALLING_ED,
                    4 => CFG6R::HIGH_LEVEL_MATCH_F,
                    5 => CFG6R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG6R::CONSTANT_0_THIS_BIT,
                    7 => CFG6R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG6R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG6R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG6R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG6R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG6R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG6R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG6R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG6R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG7R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG7R::CONSTANT_1_THIS_BIT => 0,
                    CFG7R::RISING_EDGE_MATCH_O => 0x01,
                    CFG7R::FALLING_EDGE_MATCH_ => 0x02,
                    CFG7R::RISING_OR_FALLING_ED => 0x03,
                    CFG7R::HIGH_LEVEL_MATCH_F => 0x04,
                    CFG7R::LOW_LEVEL_MATCH_OCC => 0x05,
                    CFG7R::CONSTANT_0_THIS_BIT => 0x06,
                    CFG7R::EVENT_MATCH_OCCURS_ => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CFG7R {
                match value {
                    0 => CFG7R::CONSTANT_1_THIS_BIT,
                    1 => CFG7R::RISING_EDGE_MATCH_O,
                    2 => CFG7R::FALLING_EDGE_MATCH_,
                    3 => CFG7R::RISING_OR_FALLING_ED,
                    4 => CFG7R::HIGH_LEVEL_MATCH_F,
                    5 => CFG7R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG7R::CONSTANT_0_THIS_BIT,
                    7 => CFG7R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG7R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG7R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG7R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG7R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG7R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG7R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG7R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG7R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _PROD_ENDPTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PROD_ENDPTSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG0`"]
        pub enum CFG0W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG0W::CONSTANT_1_THIS_BIT => 0,
                    CFG0W::RISING_EDGE_MATCH_O => 1,
                    CFG0W::FALLING_EDGE_MATCH_ => 2,
                    CFG0W::RISING_OR_FALLING_ED => 3,
                    CFG0W::HIGH_LEVEL_MATCH_F => 4,
                    CFG0W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG0W::CONSTANT_0_THIS_BIT => 6,
                    CFG0W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG0W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG0W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG0W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG0W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG0W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG0W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG0W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG0W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG1`"]
        pub enum CFG1W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG1W::CONSTANT_1_THIS_BIT => 0,
                    CFG1W::RISING_EDGE_MATCH_O => 1,
                    CFG1W::FALLING_EDGE_MATCH_ => 2,
                    CFG1W::RISING_OR_FALLING_ED => 3,
                    CFG1W::HIGH_LEVEL_MATCH_F => 4,
                    CFG1W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG1W::CONSTANT_0_THIS_BIT => 6,
                    CFG1W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG1W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG1W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG1W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG1W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG1W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG1W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG1W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG1W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG2`"]
        pub enum CFG2W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG2W::CONSTANT_1_THIS_BIT => 0,
                    CFG2W::RISING_EDGE_MATCH_O => 1,
                    CFG2W::FALLING_EDGE_MATCH_ => 2,
                    CFG2W::RISING_OR_FALLING_ED => 3,
                    CFG2W::HIGH_LEVEL_MATCH_F => 4,
                    CFG2W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG2W::CONSTANT_0_THIS_BIT => 6,
                    CFG2W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG2W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG2W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG2W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG2W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG2W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG2W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG2W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG2W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG3`"]
        pub enum CFG3W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG3W::CONSTANT_1_THIS_BIT => 0,
                    CFG3W::RISING_EDGE_MATCH_O => 1,
                    CFG3W::FALLING_EDGE_MATCH_ => 2,
                    CFG3W::RISING_OR_FALLING_ED => 3,
                    CFG3W::HIGH_LEVEL_MATCH_F => 4,
                    CFG3W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG3W::CONSTANT_0_THIS_BIT => 6,
                    CFG3W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG3W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG3W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG3W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG3W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG3W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG3W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG3W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG3W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG4`"]
        pub enum CFG4W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG4W::CONSTANT_1_THIS_BIT => 0,
                    CFG4W::RISING_EDGE_MATCH_O => 1,
                    CFG4W::FALLING_EDGE_MATCH_ => 2,
                    CFG4W::RISING_OR_FALLING_ED => 3,
                    CFG4W::HIGH_LEVEL_MATCH_F => 4,
                    CFG4W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG4W::CONSTANT_0_THIS_BIT => 6,
                    CFG4W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG4W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG4W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG4W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG4W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG4W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG4W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG4W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG4W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG5`"]
        pub enum CFG5W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG5W::CONSTANT_1_THIS_BIT => 0,
                    CFG5W::RISING_EDGE_MATCH_O => 1,
                    CFG5W::FALLING_EDGE_MATCH_ => 2,
                    CFG5W::RISING_OR_FALLING_ED => 3,
                    CFG5W::HIGH_LEVEL_MATCH_F => 4,
                    CFG5W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG5W::CONSTANT_0_THIS_BIT => 6,
                    CFG5W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG5W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG5W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG5W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG5W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG5W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG5W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG5W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG5W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG6`"]
        pub enum CFG6W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG6W::CONSTANT_1_THIS_BIT => 0,
                    CFG6W::RISING_EDGE_MATCH_O => 1,
                    CFG6W::FALLING_EDGE_MATCH_ => 2,
                    CFG6W::RISING_OR_FALLING_ED => 3,
                    CFG6W::HIGH_LEVEL_MATCH_F => 4,
                    CFG6W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG6W::CONSTANT_0_THIS_BIT => 6,
                    CFG6W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG6W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG6W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG6W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG6W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG6W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG6W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG6W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG6W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG7`"]
        pub enum CFG7W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG7W::CONSTANT_1_THIS_BIT => 0,
                    CFG7W::RISING_EDGE_MATCH_O => 1,
                    CFG7W::FALLING_EDGE_MATCH_ => 2,
                    CFG7W::RISING_OR_FALLING_ED => 3,
                    CFG7W::HIGH_LEVEL_MATCH_F => 4,
                    CFG7W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG7W::CONSTANT_0_THIS_BIT => 6,
                    CFG7W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CFG7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG7W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG7W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG7W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG7W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG7W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG7W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG7W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG7W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - A 1 in any bit of this field causes the corresponding bit slice to be the final component of a product term in the boolean expression. This has two effects: 1. The interrupt request associated with this bit-slice will be asserted whenever a match to that product term is detected. 2. The next bit slice will start a new, independent product term in the boolean expression (i.e. an OR will be inserted in the boolean expression following the element controlled by this bit slice)."]
            #[inline]
            pub fn prod_endpts(&self) -> PROD_ENDPTSR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PROD_ENDPTSR { bits }
            }
            #[doc = "Bits 8:10 - Specifies the match-contribution condition for bit slice 0."]
            #[inline]
            pub fn cfg0(&self) -> CFG0R {
                CFG0R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:13 - Specifies the match-contribution condition for bit slice 1."]
            #[inline]
            pub fn cfg1(&self) -> CFG1R {
                CFG1R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 14:16 - Specifies the match-contribution condition for bit slice 2."]
            #[inline]
            pub fn cfg2(&self) -> CFG2R {
                CFG2R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 17:19 - Specifies the match-contribution condition for bit slice 3."]
            #[inline]
            pub fn cfg3(&self) -> CFG3R {
                CFG3R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 20:22 - Specifies the match-contribution condition for bit slice 4."]
            #[inline]
            pub fn cfg4(&self) -> CFG4R {
                CFG4R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 23:25 - Specifies the match-contribution condition for bit slice 5."]
            #[inline]
            pub fn cfg5(&self) -> CFG5R {
                CFG5R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 26:28 - Specifies the match-contribution condition for bit slice 6."]
            #[inline]
            pub fn cfg6(&self) -> CFG6R {
                CFG6R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 29:31 - Specifies the match-contribution condition for bit slice 7."]
            #[inline]
            pub fn cfg7(&self) -> CFG7R {
                CFG7R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - A 1 in any bit of this field causes the corresponding bit slice to be the final component of a product term in the boolean expression. This has two effects: 1. The interrupt request associated with this bit-slice will be asserted whenever a match to that product term is detected. 2. The next bit slice will start a new, independent product term in the boolean expression (i.e. an OR will be inserted in the boolean expression following the element controlled by this bit slice)."]
            #[inline]
            pub fn prod_endpts(&mut self) -> _PROD_ENDPTSW {
                _PROD_ENDPTSW { w: self }
            }
            #[doc = "Bits 8:10 - Specifies the match-contribution condition for bit slice 0."]
            #[inline]
            pub fn cfg0(&mut self) -> _CFG0W {
                _CFG0W { w: self }
            }
            #[doc = "Bits 11:13 - Specifies the match-contribution condition for bit slice 1."]
            #[inline]
            pub fn cfg1(&mut self) -> _CFG1W {
                _CFG1W { w: self }
            }
            #[doc = "Bits 14:16 - Specifies the match-contribution condition for bit slice 2."]
            #[inline]
            pub fn cfg2(&mut self) -> _CFG2W {
                _CFG2W { w: self }
            }
            #[doc = "Bits 17:19 - Specifies the match-contribution condition for bit slice 3."]
            #[inline]
            pub fn cfg3(&mut self) -> _CFG3W {
                _CFG3W { w: self }
            }
            #[doc = "Bits 20:22 - Specifies the match-contribution condition for bit slice 4."]
            #[inline]
            pub fn cfg4(&mut self) -> _CFG4W {
                _CFG4W { w: self }
            }
            #[doc = "Bits 23:25 - Specifies the match-contribution condition for bit slice 5."]
            #[inline]
            pub fn cfg5(&mut self) -> _CFG5W {
                _CFG5W { w: self }
            }
            #[doc = "Bits 26:28 - Specifies the match-contribution condition for bit slice 6."]
            #[inline]
            pub fn cfg6(&mut self) -> _CFG6W {
                _CFG6W { w: self }
            }
            #[doc = "Bits 29:31 - Specifies the match-contribution condition for bit slice 7."]
            #[inline]
            pub fn cfg7(&mut self) -> _CFG7W {
                _CFG7W { w: self }
            }
        }
    }
}
#[allow(private_no_mangle_statics)]
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "WWDT"]
    pub WWDT: WWDT,
    #[doc = "MRT"]
    pub MRT: MRT,
    #[doc = "WKT"]
    pub WKT: WKT,
    #[doc = "SWM"]
    pub SWM: SWM,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "PMU"]
    pub PMU: PMU,
    #[doc = "CMP"]
    pub CMP: CMP,
    #[doc = "DMATRIGMUX"]
    pub DMATRIGMUX: DMATRIGMUX,
    #[doc = "INPUTMUX"]
    pub INPUTMUX: INPUTMUX,
    #[doc = "FLASHCTRL"]
    pub FLASHCTRL: FLASHCTRL,
    #[doc = "IOCON"]
    pub IOCON: IOCON,
    #[doc = "SYSCON"]
    pub SYSCON: SYSCON,
    #[doc = "I2C0"]
    pub I2C0: I2C0,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "SPI0"]
    pub SPI0: SPI0,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "USART0"]
    pub USART0: USART0,
    #[doc = "USART1"]
    pub USART1: USART1,
    #[doc = "USART2"]
    pub USART2: USART2,
    #[doc = "I2C2"]
    pub I2C2: I2C2,
    #[doc = "I2C3"]
    pub I2C3: I2C3,
    #[doc = "CRC"]
    pub CRC: CRC,
    #[doc = "SCT"]
    pub SCT: SCT,
    #[doc = "DMA"]
    pub DMA: DMA,
    #[doc = "GPIO_PORT"]
    pub GPIO_PORT: GPIO_PORT,
    #[doc = "PIN_INT"]
    pub PIN_INT: PIN_INT,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`"]
    pub unsafe fn steal() -> Self {
        debug_assert!(!DEVICE_PERIPHERALS);
        DEVICE_PERIPHERALS = true;
        Peripherals {
            WWDT: WWDT {
                _marker: PhantomData,
            },
            MRT: MRT {
                _marker: PhantomData,
            },
            WKT: WKT {
                _marker: PhantomData,
            },
            SWM: SWM {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            PMU: PMU {
                _marker: PhantomData,
            },
            CMP: CMP {
                _marker: PhantomData,
            },
            DMATRIGMUX: DMATRIGMUX {
                _marker: PhantomData,
            },
            INPUTMUX: INPUTMUX {
                _marker: PhantomData,
            },
            FLASHCTRL: FLASHCTRL {
                _marker: PhantomData,
            },
            IOCON: IOCON {
                _marker: PhantomData,
            },
            SYSCON: SYSCON {
                _marker: PhantomData,
            },
            I2C0: I2C0 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            USART0: USART0 {
                _marker: PhantomData,
            },
            USART1: USART1 {
                _marker: PhantomData,
            },
            USART2: USART2 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            I2C3: I2C3 {
                _marker: PhantomData,
            },
            CRC: CRC {
                _marker: PhantomData,
            },
            SCT: SCT {
                _marker: PhantomData,
            },
            DMA: DMA {
                _marker: PhantomData,
            },
            GPIO_PORT: GPIO_PORT {
                _marker: PhantomData,
            },
            PIN_INT: PIN_INT {
                _marker: PhantomData,
            },
        }
    }
}
