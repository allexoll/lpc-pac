# ! [ doc = "Peripheral access API for LPC11UXX microcontrollers (generated using svd2rust v0.14.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.14.0/svd2rust/#peripheral-api" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ no_std ] extern crate cortex_m ; # [ cfg ( feature = "rt" ) ] extern crate cortex_m_rt ; extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [ doc = r" Number available in the NVIC for configuring priority" ] pub const NVIC_PRIO_BITS : u8 = 2 ; # [ cfg ( feature = "rt" ) ] extern "C" { fn PIN_INT0 ( ) ; fn PIN_INT1 ( ) ; fn PIN_INT2 ( ) ; fn PIN_INT3 ( ) ; fn PIN_INT4 ( ) ; fn PIN_INT5 ( ) ; fn PIN_INT6 ( ) ; fn PIN_INT7 ( ) ; fn GINT0 ( ) ; fn GINT1 ( ) ; fn SSP1 ( ) ; fn I2C ( ) ; fn CT16B0 ( ) ; fn CT16B1 ( ) ; fn CT32B0 ( ) ; fn CT32B1 ( ) ; fn SSP0 ( ) ; fn USART ( ) ; fn USB_IRQ ( ) ; fn USB_FIQ ( ) ; fn ADC ( ) ; fn WDT ( ) ; fn BOD_IRQ ( ) ; fn FLASH_IRQ ( ) ; fn USBWAKEUP ( ) ; } # [ doc ( hidden ) ] pub union Vector { _handler : unsafe extern "C" fn ( ) , _reserved : u32 , } # [ cfg ( feature = "rt" ) ] # [ doc ( hidden ) ] # [ link_section = ".vector_table.interrupts" ] # [ no_mangle ] pub static __INTERRUPTS : [ Vector ; 31 ] = [ Vector { _handler : PIN_INT0 } , Vector { _handler : PIN_INT1 } , Vector { _handler : PIN_INT2 } , Vector { _handler : PIN_INT3 } , Vector { _handler : PIN_INT4 } , Vector { _handler : PIN_INT5 } , Vector { _handler : PIN_INT6 } , Vector { _handler : PIN_INT7 } , Vector { _handler : GINT0 } , Vector { _handler : GINT1 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : SSP1 } , Vector { _handler : I2C } , Vector { _handler : CT16B0 } , Vector { _handler : CT16B1 } , Vector { _handler : CT32B0 } , Vector { _handler : CT32B1 } , Vector { _handler : SSP0 } , Vector { _handler : USART } , Vector { _handler : USB_IRQ } , Vector { _handler : USB_FIQ } , Vector { _handler : ADC } , Vector { _handler : WDT } , Vector { _handler : BOD_IRQ } , Vector { _handler : FLASH_IRQ } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : USBWAKEUP } , ] ; # [ doc = r" Enumeration of all the interrupts" ] pub enum Interrupt { # [ doc = "0 - PIN_INT0" ] PIN_INT0 , # [ doc = "1 - PIN_INT1" ] PIN_INT1 , # [ doc = "2 - PIN_INT2" ] PIN_INT2 , # [ doc = "3 - PIN_INT3" ] PIN_INT3 , # [ doc = "4 - PIN_INT4" ] PIN_INT4 , # [ doc = "5 - PIN_INT5" ] PIN_INT5 , # [ doc = "6 - PIN_INT6" ] PIN_INT6 , # [ doc = "7 - PIN_INT7" ] PIN_INT7 , # [ doc = "8 - GINT0" ] GINT0 , # [ doc = "9 - GINT1" ] GINT1 , # [ doc = "14 - SSP1" ] SSP1 , # [ doc = "15 - I2C" ] I2C , # [ doc = "16 - CT16B0" ] CT16B0 , # [ doc = "17 - CT16B1" ] CT16B1 , # [ doc = "18 - CT32B0" ] CT32B0 , # [ doc = "19 - CT32B1" ] CT32B1 , # [ doc = "20 - SSP0" ] SSP0 , # [ doc = "21 - USART" ] USART , # [ doc = "22 - USB_IRQ" ] USB_IRQ , # [ doc = "23 - USB_FIQ" ] USB_FIQ , # [ doc = "24 - ADC" ] ADC , # [ doc = "25 - WDT" ] WDT , # [ doc = "26 - BOD_IRQ" ] BOD_IRQ , # [ doc = "27 - FLASH_IRQ" ] FLASH_IRQ , # [ doc = "30 - USBWAKEUP" ] USBWAKEUP , } unsafe impl :: bare_metal :: Nr for Interrupt { # [ inline ] fn nr ( & self ) -> u8 { match * self { Interrupt :: PIN_INT0 => 0 , Interrupt :: PIN_INT1 => 1 , Interrupt :: PIN_INT2 => 2 , Interrupt :: PIN_INT3 => 3 , Interrupt :: PIN_INT4 => 4 , Interrupt :: PIN_INT5 => 5 , Interrupt :: PIN_INT6 => 6 , Interrupt :: PIN_INT7 => 7 , Interrupt :: GINT0 => 8 , Interrupt :: GINT1 => 9 , Interrupt :: SSP1 => 14 , Interrupt :: I2C => 15 , Interrupt :: CT16B0 => 16 , Interrupt :: CT16B1 => 17 , Interrupt :: CT32B0 => 18 , Interrupt :: CT32B1 => 19 , Interrupt :: SSP0 => 20 , Interrupt :: USART => 21 , Interrupt :: USB_IRQ => 22 , Interrupt :: USB_FIQ => 23 , Interrupt :: ADC => 24 , Interrupt :: WDT => 25 , Interrupt :: BOD_IRQ => 26 , Interrupt :: FLASH_IRQ => 27 , Interrupt :: USBWAKEUP => 30 , } } } pub use cortex_m :: peripheral :: Peripherals as CorePeripherals ; # [ cfg ( feature = "rt" ) ] pub use cortex_m_rt :: interrupt ; # [ cfg ( feature = "rt" ) ] pub use self :: Interrupt as interrupt ; pub use cortex_m :: peripheral :: { CBP , CPUID , DCB , DWT , FPB , ITM , MPU , NVIC , SCB , SYST , TPIU , } ; # [ doc = "I2C-bus controller" ] pub struct I2C { _marker : PhantomData < * const ( ) > } unsafe impl Send for I2C { } impl I2C { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const i2c :: RegisterBlock { 0x4000_0000 as * const _ } } impl Deref for I2C { type Target = i2c :: RegisterBlock ; fn deref ( & self ) -> & i2c :: RegisterBlock { unsafe { & * I2C :: ptr ( ) } } } # [ doc = "I2C-bus controller" ] pub mod i2c { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register." ] pub conset : CONSET , # [ doc = "0x04 - I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed." ] pub stat : STAT , # [ doc = "0x08 - I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register." ] pub dat : DAT , # [ doc = "0x0c - I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub adr0 : ADR0 , # [ doc = "0x10 - SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock." ] pub sclh : SCLH , # [ doc = "0x14 - SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode." ] pub scll : SCLL , # [ doc = "0x18 - I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register." ] pub conclr : CONCLR , # [ doc = "0x1c - Monitor mode control register." ] pub mmctrl : MMCTRL , # [ doc = "0x20 - I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub adr1 : ADR , # [ doc = "0x24 - I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub adr2 : ADR , # [ doc = "0x28 - I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub adr3 : ADR , # [ doc = "0x2c - Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus." ] pub data_buffer : DATA_BUFFER , # [ doc = "0x30 - I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000)." ] pub mask : [ MASK ; 4 ] , } # [ doc = "I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register." ] pub struct CONSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register." ] pub mod conset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct AAR { bits : bool , } impl AAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SIR { bits : bool , } impl SIR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct STOR { bits : bool , } impl STOR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct STAR { bits : bool , } impl STAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct I2ENR { bits : bool , } impl I2ENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _AAW < 'a > { w : & 'a mut W , } impl < 'a > _AAW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SIW < 'a > { w : & 'a mut W , } impl < 'a > _SIW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _STOW < 'a > { w : & 'a mut W , } impl < 'a > _STOW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _STAW < 'a > { w : & 'a mut W , } impl < 'a > _STAW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _I2ENW < 'a > { w : & 'a mut W , } impl < 'a > _I2ENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Assert acknowledge flag." ] # [ inline ] pub fn aa ( & self ) -> AAR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; AAR { bits } } # [ doc = "Bit 3 - I2C interrupt flag." ] # [ inline ] pub fn si ( & self ) -> SIR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SIR { bits } } # [ doc = "Bit 4 - STOP flag." ] # [ inline ] pub fn sto ( & self ) -> STOR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; STOR { bits } } # [ doc = "Bit 5 - START flag." ] # [ inline ] pub fn sta ( & self ) -> STAR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; STAR { bits } } # [ doc = "Bit 6 - I2C interface enable." ] # [ inline ] pub fn i2en ( & self ) -> I2ENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; I2ENR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Assert acknowledge flag." ] # [ inline ] pub fn aa ( & mut self ) -> _AAW { _AAW { w : self } } # [ doc = "Bit 3 - I2C interrupt flag." ] # [ inline ] pub fn si ( & mut self ) -> _SIW { _SIW { w : self } } # [ doc = "Bit 4 - STOP flag." ] # [ inline ] pub fn sto ( & mut self ) -> _STOW { _STOW { w : self } } # [ doc = "Bit 5 - START flag." ] # [ inline ] pub fn sta ( & mut self ) -> _STAW { _STAW { w : self } } # [ doc = "Bit 6 - I2C interface enable." ] # [ inline ] pub fn i2en ( & mut self ) -> _I2ENW { _I2ENW { w : self } } } } # [ doc = "I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed." ] pub struct STAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed." ] pub mod stat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: STAT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct STATUSR { bits : u8 , } impl STATUSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 3:7 - These bits give the actual status information about the I2C interface." ] # [ inline ] pub fn status ( & self ) -> STATUSR { let bits = { const MASK : u8 = 0x1f ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; STATUSR { bits } } } } # [ doc = "I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register." ] pub struct DAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register." ] pub mod dat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DAT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DATAR { bits : u8 , } impl DATAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DATAW < 'a > { w : & 'a mut W , } impl < 'a > _DATAW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - This register holds data values that have been received or are to be transmitted." ] # [ inline ] pub fn data ( & self ) -> DATAR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DATAR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - This register holds data values that have been received or are to be transmitted." ] # [ inline ] pub fn data ( & mut self ) -> _DATAW { _DATAW { w : self } } } } # [ doc = "I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub struct ADR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub mod adr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ADR0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct GCR { bits : bool , } impl GCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ADDRESSR { bits : u8 , } impl ADDRESSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _GCW < 'a > { w : & 'a mut W , } impl < 'a > _GCW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ADDRESSW < 'a > { w : & 'a mut W , } impl < 'a > _ADDRESSW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - General Call enable bit." ] # [ inline ] pub fn gc ( & self ) -> GCR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; GCR { bits } } # [ doc = "Bits 1:7 - The I2C device address for slave mode." ] # [ inline ] pub fn address ( & self ) -> ADDRESSR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ADDRESSR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - General Call enable bit." ] # [ inline ] pub fn gc ( & mut self ) -> _GCW { _GCW { w : self } } # [ doc = "Bits 1:7 - The I2C device address for slave mode." ] # [ inline ] pub fn address ( & mut self ) -> _ADDRESSW { _ADDRESSW { w : self } } } } # [ doc = "SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock." ] pub struct SCLH { register : :: vcell :: VolatileCell < u32 > } # [ doc = "SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock." ] pub mod sclh { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SCLH { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct SCLHR { bits : u16 , } impl SCLHR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _SCLHW < 'a > { w : & 'a mut W , } impl < 'a > _SCLHW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Count for SCL HIGH time period selection." ] # [ inline ] pub fn sclh ( & self ) -> SCLHR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; SCLHR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x04 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Count for SCL HIGH time period selection." ] # [ inline ] pub fn sclh ( & mut self ) -> _SCLHW { _SCLHW { w : self } } } } # [ doc = "SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode." ] pub struct SCLL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode." ] pub mod scll { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SCLL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct SCLLR { bits : u16 , } impl SCLLR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _SCLLW < 'a > { w : & 'a mut W , } impl < 'a > _SCLLW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Count for SCL low time period selection." ] # [ inline ] pub fn scll ( & self ) -> SCLLR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; SCLLR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x04 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Count for SCL low time period selection." ] # [ inline ] pub fn scll ( & mut self ) -> _SCLLW { _SCLLW { w : self } } } } # [ doc = "I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register." ] pub struct CONCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register." ] pub mod conclr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONCLR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _AACW < 'a > { w : & 'a mut W , } impl < 'a > _AACW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SICW < 'a > { w : & 'a mut W , } impl < 'a > _SICW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _STACW < 'a > { w : & 'a mut W , } impl < 'a > _STACW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _I2ENCW < 'a > { w : & 'a mut W , } impl < 'a > _I2ENCW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Assert acknowledge Clear bit." ] # [ inline ] pub fn aac ( & mut self ) -> _AACW { _AACW { w : self } } # [ doc = "Bit 3 - I2C interrupt Clear bit." ] # [ inline ] pub fn sic ( & mut self ) -> _SICW { _SICW { w : self } } # [ doc = "Bit 5 - START flag Clear bit." ] # [ inline ] pub fn stac ( & mut self ) -> _STACW { _STACW { w : self } } # [ doc = "Bit 6 - I2C interface Disable bit." ] # [ inline ] pub fn i2enc ( & mut self ) -> _I2ENCW { _I2ENCW { w : self } } } } # [ doc = "Monitor mode control register." ] pub struct MMCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Monitor mode control register." ] pub mod mmctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MMCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MM_ENA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MM_ENAR { # [ doc = "Monitor mode disabled." ] MONITOR_MODE_DISABLE , # [ doc = "The I2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I 2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line." ] THE_I2C_MODULE_WILL_ } impl MM_ENAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MM_ENAR :: MONITOR_MODE_DISABLE => false , MM_ENAR :: THE_I2C_MODULE_WILL_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MM_ENAR { match value { false => MM_ENAR :: MONITOR_MODE_DISABLE , true => MM_ENAR :: THE_I2C_MODULE_WILL_ , } } # [ doc = "Checks if the value of the field is `MONITOR_MODE_DISABLE`" ] # [ inline ] pub fn is_monitor_mode_disable ( & self ) -> bool { * self == MM_ENAR :: MONITOR_MODE_DISABLE } # [ doc = "Checks if the value of the field is `THE_I2C_MODULE_WILL_`" ] # [ inline ] pub fn is_the_i2c_module_will_ ( & self ) -> bool { * self == MM_ENAR :: THE_I2C_MODULE_WILL_ } } # [ doc = "Possible values of the field `ENA_SCL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA_SCLR { # [ doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line." ] HIGH , # [ doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.\\[1\\]" ] NORMAL } impl ENA_SCLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA_SCLR :: HIGH => false , ENA_SCLR :: NORMAL => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA_SCLR { match value { false => ENA_SCLR :: HIGH , true => ENA_SCLR :: NORMAL , } } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == ENA_SCLR :: HIGH } # [ doc = "Checks if the value of the field is `NORMAL`" ] # [ inline ] pub fn is_normal ( & self ) -> bool { * self == ENA_SCLR :: NORMAL } } # [ doc = "Possible values of the field `MATCH_ALL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MATCH_ALLR { # [ doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned." ] MATCH , # [ doc = "When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus." ] ANYADDRESS } impl MATCH_ALLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MATCH_ALLR :: MATCH => false , MATCH_ALLR :: ANYADDRESS => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MATCH_ALLR { match value { false => MATCH_ALLR :: MATCH , true => MATCH_ALLR :: ANYADDRESS , } } # [ doc = "Checks if the value of the field is `MATCH`" ] # [ inline ] pub fn is_match_ ( & self ) -> bool { * self == MATCH_ALLR :: MATCH } # [ doc = "Checks if the value of the field is `ANYADDRESS`" ] # [ inline ] pub fn is_anyaddress ( & self ) -> bool { * self == MATCH_ALLR :: ANYADDRESS } } # [ doc = "Values that can be written to the field `MM_ENA`" ] pub enum MM_ENAW { # [ doc = "Monitor mode disabled." ] MONITOR_MODE_DISABLE , # [ doc = "The I2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I 2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line." ] THE_I2C_MODULE_WILL_ } impl MM_ENAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MM_ENAW :: MONITOR_MODE_DISABLE => false , MM_ENAW :: THE_I2C_MODULE_WILL_ => true } } } # [ doc = r" Proxy" ] pub struct _MM_ENAW < 'a > { w : & 'a mut W , } impl < 'a > _MM_ENAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MM_ENAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Monitor mode disabled." ] # [ inline ] pub fn monitor_mode_disable ( self ) -> & 'a mut W { self . variant ( MM_ENAW :: MONITOR_MODE_DISABLE ) } # [ doc = "The I2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I 2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line." ] # [ inline ] pub fn the_i2c_module_will_ ( self ) -> & 'a mut W { self . variant ( MM_ENAW :: THE_I2C_MODULE_WILL_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA_SCL`" ] pub enum ENA_SCLW { # [ doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line." ] HIGH , # [ doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.\\[1\\]" ] NORMAL } impl ENA_SCLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA_SCLW :: HIGH => false , ENA_SCLW :: NORMAL => true } } } # [ doc = r" Proxy" ] pub struct _ENA_SCLW < 'a > { w : & 'a mut W , } impl < 'a > _ENA_SCLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA_SCLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( ENA_SCLW :: HIGH ) } # [ doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.\\[1\\]" ] # [ inline ] pub fn normal ( self ) -> & 'a mut W { self . variant ( ENA_SCLW :: NORMAL ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MATCH_ALL`" ] pub enum MATCH_ALLW { # [ doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned." ] MATCH , # [ doc = "When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus." ] ANYADDRESS } impl MATCH_ALLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MATCH_ALLW :: MATCH => false , MATCH_ALLW :: ANYADDRESS => true } } } # [ doc = r" Proxy" ] pub struct _MATCH_ALLW < 'a > { w : & 'a mut W , } impl < 'a > _MATCH_ALLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MATCH_ALLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above. That is, the module will respond as a normal slave as far as address-recognition is concerned." ] # [ inline ] pub fn match_ ( self ) -> & 'a mut W { self . variant ( MATCH_ALLW :: MATCH ) } # [ doc = "When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus." ] # [ inline ] pub fn anyaddress ( self ) -> & 'a mut W { self . variant ( MATCH_ALLW :: ANYADDRESS ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Monitor mode enable." ] # [ inline ] pub fn mm_ena ( & self ) -> MM_ENAR { MM_ENAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - SCL output enable." ] # [ inline ] pub fn ena_scl ( & self ) -> ENA_SCLR { ENA_SCLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Select interrupt register match." ] # [ inline ] pub fn match_all ( & self ) -> MATCH_ALLR { MATCH_ALLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Monitor mode enable." ] # [ inline ] pub fn mm_ena ( & mut self ) -> _MM_ENAW { _MM_ENAW { w : self } } # [ doc = "Bit 1 - SCL output enable." ] # [ inline ] pub fn ena_scl ( & mut self ) -> _ENA_SCLW { _ENA_SCLW { w : self } } # [ doc = "Bit 2 - Select interrupt register match." ] # [ inline ] pub fn match_all ( & mut self ) -> _MATCH_ALLW { _MATCH_ALLW { w : self } } } } # [ doc = "I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub struct ADR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ] pub mod adr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ADR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct GCR { bits : bool , } impl GCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ADDRESSR { bits : u8 , } impl ADDRESSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _GCW < 'a > { w : & 'a mut W , } impl < 'a > _GCW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ADDRESSW < 'a > { w : & 'a mut W , } impl < 'a > _ADDRESSW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - General Call enable bit." ] # [ inline ] pub fn gc ( & self ) -> GCR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; GCR { bits } } # [ doc = "Bits 1:7 - The I2C device address for slave mode." ] # [ inline ] pub fn address ( & self ) -> ADDRESSR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ADDRESSR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - General Call enable bit." ] # [ inline ] pub fn gc ( & mut self ) -> _GCW { _GCW { w : self } } # [ doc = "Bits 1:7 - The I2C device address for slave mode." ] # [ inline ] pub fn address ( & mut self ) -> _ADDRESSW { _ADDRESSW { w : self } } } } # [ doc = "Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus." ] pub struct DATA_BUFFER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus." ] pub mod data_buffer { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: DATA_BUFFER { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct DATAR { bits : u8 , } impl DATAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - This register holds contents of the 8 MSBs of the DAT shift register." ] # [ inline ] pub fn data ( & self ) -> DATAR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DATAR { bits } } } } # [ doc = "I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000)." ] pub struct MASK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000)." ] pub mod mask { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MASK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MASKR { bits : u8 , } impl MASKR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _MASKW < 'a > { w : & 'a mut W , } impl < 'a > _MASKW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 1:7 - Mask bits." ] # [ inline ] pub fn mask ( & self ) -> MASKR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; MASKR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 1:7 - Mask bits." ] # [ inline ] pub fn mask ( & mut self ) -> _MASKW { _MASKW { w : self } } } } } # [ doc = "Windowed Watchdog Timer (WWDT)" ] pub struct WWDT { _marker : PhantomData < * const ( ) > } unsafe impl Send for WWDT { } impl WWDT { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const wwdt :: RegisterBlock { 0x4000_4000 as * const _ } } impl Deref for WWDT { type Target = wwdt :: RegisterBlock ; fn deref ( & self ) -> & wwdt :: RegisterBlock { unsafe { & * WWDT :: ptr ( ) } } } # [ doc = "Windowed Watchdog Timer (WWDT)" ] pub mod wwdt { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer." ] pub mod_ : MOD , # [ doc = "0x04 - Watchdog timer constant register. This 24-bit register determines the time-out value." ] pub tc : TC , # [ doc = "0x08 - Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC." ] pub feed : FEED , # [ doc = "0x0c - Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer." ] pub tv : TV , # [ doc = "0x10 - Watchdog clock select register." ] pub clksel : CLKSEL , # [ doc = "0x14 - Watchdog Warning Interrupt compare value." ] pub warnint : WARNINT , # [ doc = "0x18 - Watchdog Window compare value." ] pub window : WINDOW , } # [ doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer." ] pub struct MOD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer." ] pub mod mod_ { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MOD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `WDEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDENR { # [ doc = "The watchdog timer is stopped." ] STOPPED , # [ doc = "The watchdog timer is running." ] RUNNING } impl WDENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WDENR :: STOPPED => false , WDENR :: RUNNING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WDENR { match value { false => WDENR :: STOPPED , true => WDENR :: RUNNING , } } # [ doc = "Checks if the value of the field is `STOPPED`" ] # [ inline ] pub fn is_stopped ( & self ) -> bool { * self == WDENR :: STOPPED } # [ doc = "Checks if the value of the field is `RUNNING`" ] # [ inline ] pub fn is_running ( & self ) -> bool { * self == WDENR :: RUNNING } } # [ doc = "Possible values of the field `WDRESET`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDRESETR { # [ doc = "A watchdog timeout will not cause a chip reset." ] INTERRUPT , # [ doc = "A watchdog timeout will cause a chip reset." ] RESET } impl WDRESETR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WDRESETR :: INTERRUPT => false , WDRESETR :: RESET => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WDRESETR { match value { false => WDRESETR :: INTERRUPT , true => WDRESETR :: RESET , } } # [ doc = "Checks if the value of the field is `INTERRUPT`" ] # [ inline ] pub fn is_interrupt ( & self ) -> bool { * self == WDRESETR :: INTERRUPT } # [ doc = "Checks if the value of the field is `RESET`" ] # [ inline ] pub fn is_reset ( & self ) -> bool { * self == WDRESETR :: RESET } } # [ doc = r" Value of the field" ] pub struct WDTOFR { bits : bool , } impl WDTOFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct WDINTR { bits : bool , } impl WDINTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `WDPROTECT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDPROTECTR { # [ doc = "The watchdog time-out value (TC) can be changed at any time." ] NOT_LOCKED , # [ doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW." ] LOCKED } impl WDPROTECTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WDPROTECTR :: NOT_LOCKED => false , WDPROTECTR :: LOCKED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WDPROTECTR { match value { false => WDPROTECTR :: NOT_LOCKED , true => WDPROTECTR :: LOCKED , } } # [ doc = "Checks if the value of the field is `NOT_LOCKED`" ] # [ inline ] pub fn is_not_locked ( & self ) -> bool { * self == WDPROTECTR :: NOT_LOCKED } # [ doc = "Checks if the value of the field is `LOCKED`" ] # [ inline ] pub fn is_locked ( & self ) -> bool { * self == WDPROTECTR :: LOCKED } } # [ doc = r" Value of the field" ] pub struct LOCKR { bits : bool , } impl LOCKR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Values that can be written to the field `WDEN`" ] pub enum WDENW { # [ doc = "The watchdog timer is stopped." ] STOPPED , # [ doc = "The watchdog timer is running." ] RUNNING } impl WDENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WDENW :: STOPPED => false , WDENW :: RUNNING => true } } } # [ doc = r" Proxy" ] pub struct _WDENW < 'a > { w : & 'a mut W , } impl < 'a > _WDENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WDENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The watchdog timer is stopped." ] # [ inline ] pub fn stopped ( self ) -> & 'a mut W { self . variant ( WDENW :: STOPPED ) } # [ doc = "The watchdog timer is running." ] # [ inline ] pub fn running ( self ) -> & 'a mut W { self . variant ( WDENW :: RUNNING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WDRESET`" ] pub enum WDRESETW { # [ doc = "A watchdog timeout will not cause a chip reset." ] INTERRUPT , # [ doc = "A watchdog timeout will cause a chip reset." ] RESET } impl WDRESETW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WDRESETW :: INTERRUPT => false , WDRESETW :: RESET => true } } } # [ doc = r" Proxy" ] pub struct _WDRESETW < 'a > { w : & 'a mut W , } impl < 'a > _WDRESETW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WDRESETW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "A watchdog timeout will not cause a chip reset." ] # [ inline ] pub fn interrupt ( self ) -> & 'a mut W { self . variant ( WDRESETW :: INTERRUPT ) } # [ doc = "A watchdog timeout will cause a chip reset." ] # [ inline ] pub fn reset ( self ) -> & 'a mut W { self . variant ( WDRESETW :: RESET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _WDTOFW < 'a > { w : & 'a mut W , } impl < 'a > _WDTOFW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _WDINTW < 'a > { w : & 'a mut W , } impl < 'a > _WDINTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WDPROTECT`" ] pub enum WDPROTECTW { # [ doc = "The watchdog time-out value (TC) can be changed at any time." ] NOT_LOCKED , # [ doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW." ] LOCKED } impl WDPROTECTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WDPROTECTW :: NOT_LOCKED => false , WDPROTECTW :: LOCKED => true } } } # [ doc = r" Proxy" ] pub struct _WDPROTECTW < 'a > { w : & 'a mut W , } impl < 'a > _WDPROTECTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WDPROTECTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The watchdog time-out value (TC) can be changed at any time." ] # [ inline ] pub fn not_locked ( self ) -> & 'a mut W { self . variant ( WDPROTECTW :: NOT_LOCKED ) } # [ doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW." ] # [ inline ] pub fn locked ( self ) -> & 'a mut W { self . variant ( WDPROTECTW :: LOCKED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _LOCKW < 'a > { w : & 'a mut W , } impl < 'a > _LOCKW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Watchdog enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0." ] # [ inline ] pub fn wden ( & self ) -> WDENR { WDENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0." ] # [ inline ] pub fn wdreset ( & self ) -> WDRESETR { WDRESETR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1." ] # [ inline ] pub fn wdtof ( & self ) -> WDTOFR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; WDTOFR { bits } } # [ doc = "Bit 3 - Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software." ] # [ inline ] pub fn wdint ( & self ) -> WDINTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; WDINTR { bits } } # [ doc = "Bit 4 - Watchdog update mode. This bit can be set once by software and is only cleared by a reset." ] # [ inline ] pub fn wdprotect ( & self ) -> WDPROTECTR { WDPROTECTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - A 1 in this bit prevents disabling or powering down the clock source selected by bit 0 of the WDCLKSRC register and also prevents switching to a clock source that is disabled or powered down. This bit can be set once by software and is only cleared by any reset. If this bit is one and the WWDT clock source is the IRC when Deep-sleep or Power-down modes are entered, the IRC remains running thereby increasing power consumption in Deep-sleep mode and potentially preventing the part of entering Power-down mode correctly (see Section 15.7)." ] # [ inline ] pub fn lock ( & self ) -> LOCKR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; LOCKR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Watchdog enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0." ] # [ inline ] pub fn wden ( & mut self ) -> _WDENW { _WDENW { w : self } } # [ doc = "Bit 1 - Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0." ] # [ inline ] pub fn wdreset ( & mut self ) -> _WDRESETW { _WDRESETW { w : self } } # [ doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1." ] # [ inline ] pub fn wdtof ( & mut self ) -> _WDTOFW { _WDTOFW { w : self } } # [ doc = "Bit 3 - Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software." ] # [ inline ] pub fn wdint ( & mut self ) -> _WDINTW { _WDINTW { w : self } } # [ doc = "Bit 4 - Watchdog update mode. This bit can be set once by software and is only cleared by a reset." ] # [ inline ] pub fn wdprotect ( & mut self ) -> _WDPROTECTW { _WDPROTECTW { w : self } } # [ doc = "Bit 5 - A 1 in this bit prevents disabling or powering down the clock source selected by bit 0 of the WDCLKSRC register and also prevents switching to a clock source that is disabled or powered down. This bit can be set once by software and is only cleared by any reset. If this bit is one and the WWDT clock source is the IRC when Deep-sleep or Power-down modes are entered, the IRC remains running thereby increasing power consumption in Deep-sleep mode and potentially preventing the part of entering Power-down mode correctly (see Section 15.7)." ] # [ inline ] pub fn lock ( & mut self ) -> _LOCKW { _LOCKW { w : self } } } } # [ doc = "Watchdog timer constant register. This 24-bit register determines the time-out value." ] pub struct TC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog timer constant register. This 24-bit register determines the time-out value." ] pub mod tc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct COUNTR { bits : u32 , } impl COUNTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _COUNTW < 'a > { w : & 'a mut W , } impl < 'a > _COUNTW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - Watchdog time-out value." ] # [ inline ] pub fn count ( & self ) -> COUNTR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; COUNTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:23 - Watchdog time-out value." ] # [ inline ] pub fn count ( & mut self ) -> _COUNTW { _COUNTW { w : self } } } } # [ doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC." ] pub struct FEED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC." ] pub mod feed { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FEED { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _FEEDW < 'a > { w : & 'a mut W , } impl < 'a > _FEEDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Feed value should be 0xAA followed by 0x55." ] # [ inline ] pub fn feed ( & mut self ) -> _FEEDW { _FEEDW { w : self } } } } # [ doc = "Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer." ] pub struct TV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer." ] pub mod tv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: TV { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct COUNTR { bits : u32 , } impl COUNTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - Counter timer value." ] # [ inline ] pub fn count ( & self ) -> COUNTR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; COUNTR { bits } } } } # [ doc = "Watchdog clock select register." ] pub struct CLKSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog clock select register." ] pub mod clksel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CLKSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CLKSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CLKSELR { # [ doc = "IRC" ] IRC , # [ doc = "Watchdog oscillator (WDOSC)" ] WATCHDOG_OSCILLATOR_ } impl CLKSELR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CLKSELR :: IRC => false , CLKSELR :: WATCHDOG_OSCILLATOR_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CLKSELR { match value { false => CLKSELR :: IRC , true => CLKSELR :: WATCHDOG_OSCILLATOR_ , } } # [ doc = "Checks if the value of the field is `IRC`" ] # [ inline ] pub fn is_irc ( & self ) -> bool { * self == CLKSELR :: IRC } # [ doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR_`" ] # [ inline ] pub fn is_watchdog_oscillator_ ( & self ) -> bool { * self == CLKSELR :: WATCHDOG_OSCILLATOR_ } } # [ doc = r" Value of the field" ] pub struct LOCKR { bits : bool , } impl LOCKR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Values that can be written to the field `CLKSEL`" ] pub enum CLKSELW { # [ doc = "IRC" ] IRC , # [ doc = "Watchdog oscillator (WDOSC)" ] WATCHDOG_OSCILLATOR_ } impl CLKSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CLKSELW :: IRC => false , CLKSELW :: WATCHDOG_OSCILLATOR_ => true } } } # [ doc = r" Proxy" ] pub struct _CLKSELW < 'a > { w : & 'a mut W , } impl < 'a > _CLKSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CLKSELW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "IRC" ] # [ inline ] pub fn irc ( self ) -> & 'a mut W { self . variant ( CLKSELW :: IRC ) } # [ doc = "Watchdog oscillator (WDOSC)" ] # [ inline ] pub fn watchdog_oscillator_ ( self ) -> & 'a mut W { self . variant ( CLKSELW :: WATCHDOG_OSCILLATOR_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _LOCKW < 'a > { w : & 'a mut W , } impl < 'a > _LOCKW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Selects source of WDT clock" ] # [ inline ] pub fn clksel ( & self ) -> CLKSELR { CLKSELR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - If this bit is set to one writing to this register does not affect bit 0. The clock source can only be changed by first clearing this bit, then writing the new value of bit 0." ] # [ inline ] pub fn lock ( & self ) -> LOCKR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; LOCKR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Selects source of WDT clock" ] # [ inline ] pub fn clksel ( & mut self ) -> _CLKSELW { _CLKSELW { w : self } } # [ doc = "Bit 31 - If this bit is set to one writing to this register does not affect bit 0. The clock source can only be changed by first clearing this bit, then writing the new value of bit 0." ] # [ inline ] pub fn lock ( & mut self ) -> _LOCKW { _LOCKW { w : self } } } } # [ doc = "Watchdog Warning Interrupt compare value." ] pub struct WARNINT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog Warning Interrupt compare value." ] pub mod warnint { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: WARNINT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct WARNINTR { bits : u16 , } impl WARNINTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _WARNINTW < 'a > { w : & 'a mut W , } impl < 'a > _WARNINTW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:9 - Watchdog warning interrupt compare value." ] # [ inline ] pub fn warnint ( & self ) -> WARNINTR { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; WARNINTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:9 - Watchdog warning interrupt compare value." ] # [ inline ] pub fn warnint ( & mut self ) -> _WARNINTW { _WARNINTW { w : self } } } } # [ doc = "Watchdog Window compare value." ] pub struct WINDOW { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog Window compare value." ] pub mod window { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: WINDOW { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct WINDOWR { bits : u32 , } impl WINDOWR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _WINDOWW < 'a > { w : & 'a mut W , } impl < 'a > _WINDOWW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - Watchdog window value." ] # [ inline ] pub fn window ( & self ) -> WINDOWR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; WINDOWR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x00ff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:23 - Watchdog window value." ] # [ inline ] pub fn window ( & mut self ) -> _WINDOWW { _WINDOWW { w : self } } } } } # [ doc = "USART" ] pub struct USART { _marker : PhantomData < * const ( ) > } unsafe impl Send for USART { } impl USART { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const usart :: RegisterBlock { 0x4000_8000 as * const _ } } impl Deref for USART { type Target = usart :: RegisterBlock ; fn deref ( & self ) -> & usart :: RegisterBlock { unsafe { & * USART :: ptr ( ) } } } # [ doc = "USART" ] pub mod usart { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)" ] pub rbr : RBR , # [ doc = "0x04 - Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)" ] pub dlm : DLM , # [ doc = "0x08 - Interrupt ID Register. Identifies which interrupt(s) are pending." ] pub iir : IIR , # [ doc = "0x0c - Line Control Register. Contains controls for frame formatting and break generation." ] pub lcr : LCR , # [ doc = "0x10 - Modem Control Register." ] pub mcr : MCR , # [ doc = "0x14 - Line Status Register. Contains flags for transmit and receive status, including line errors." ] pub lsr : LSR , # [ doc = "0x18 - Modem Status Register." ] pub msr : MSR , # [ doc = "0x1c - Scratch Pad Register. Eight-bit temporary storage for software." ] pub scr : SCR , # [ doc = "0x20 - Auto-baud Control Register. Contains controls for the auto-baud feature." ] pub acr : ACR , # [ doc = "0x24 - IrDA Control Register. Enables and configures the IrDA (remote control) mode." ] pub icr : ICR , # [ doc = "0x28 - Fractional Divider Register. Generates a clock input for the baud rate divider." ] pub fdr : FDR , # [ doc = "0x2c - Oversampling Register. Controls the degree of oversampling during each bit time." ] pub osr : OSR , # [ doc = "0x30 - Transmit Enable Register. Turns off USART transmitter for use with software flow control." ] pub ter : TER , _reserved0 : [ u8 ; 12usize ] , # [ doc = "0x40 - Half duplex enable register." ] pub hden : HDEN , _reserved1 : [ u8 ; 4usize ] , # [ doc = "0x48 - Smart Card Interface Control register. Enables and configures the Smart Card Interface feature." ] pub scictrl : SCICTRL , # [ doc = "0x4c - RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes." ] pub rs485ctrl : RS485CTRL , # [ doc = "0x50 - RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode." ] pub rs485adrmatch : RS485ADRMATCH , # [ doc = "0x54 - RS-485/EIA-485 direction control delay." ] pub rs485dly : RS485DLY , # [ doc = "0x58 - Synchronous mode control register." ] pub syncctrl : SYNCCTRL , } # [ doc = "Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)" ] pub struct RBR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)" ] pub mod rbr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RBR { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct RBRR { bits : u8 , } impl RBRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - The USART Receiver Buffer Register contains the oldest received byte in the USART RX FIFO." ] # [ inline ] pub fn rbr ( & self ) -> RBRR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; RBRR { bits } } } } # [ doc = "Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)" ] pub struct THR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)" ] pub mod thr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: THR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _THRW < 'a > { w : & 'a mut W , } impl < 'a > _THRW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Writing to the USART Transmit Holding Register causes the data to be stored in the USART transmit FIFO. The byte will be sent when it is the oldest byte in the FIFO and the transmitter is available." ] # [ inline ] pub fn thr ( & mut self ) -> _THRW { _THRW { w : self } } } } # [ doc = "Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)" ] pub struct DLL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)" ] pub mod dll { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DLL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DLLSBR { bits : u8 , } impl DLLSBR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DLLSBW < 'a > { w : & 'a mut W , } impl < 'a > _DLLSBW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - The USART Divisor Latch LSB Register, along with the DLM register, determines the baud rate of the USART." ] # [ inline ] pub fn dllsb ( & self ) -> DLLSBR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DLLSBR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - The USART Divisor Latch LSB Register, along with the DLM register, determines the baud rate of the USART." ] # [ inline ] pub fn dllsb ( & mut self ) -> _DLLSBW { _DLLSBW { w : self } } } } # [ doc = "Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)" ] pub struct DLM { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)" ] pub mod dlm { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DLM { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DLMSBR { bits : u8 , } impl DLMSBR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DLMSBW < 'a > { w : & 'a mut W , } impl < 'a > _DLMSBW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - The USART Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the USART." ] # [ inline ] pub fn dlmsb ( & self ) -> DLMSBR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DLMSBR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - The USART Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the USART." ] # [ inline ] pub fn dlmsb ( & mut self ) -> _DLMSBW { _DLMSBW { w : self } } } } # [ doc = "Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential USART interrupts. (DLAB=0)" ] pub struct IER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential USART interrupts. (DLAB=0)" ] pub mod ier { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RBRINTEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RBRINTENR { # [ doc = "Disable the RDA interrupt." ] DISABLE_THE_RDA_INTE , # [ doc = "Enable the RDA interrupt." ] ENABLE_THE_RDA_INTER } impl RBRINTENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RBRINTENR :: DISABLE_THE_RDA_INTE => false , RBRINTENR :: ENABLE_THE_RDA_INTER => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RBRINTENR { match value { false => RBRINTENR :: DISABLE_THE_RDA_INTE , true => RBRINTENR :: ENABLE_THE_RDA_INTER , } } # [ doc = "Checks if the value of the field is `DISABLE_THE_RDA_INTE`" ] # [ inline ] pub fn is_disable_the_rda_inte ( & self ) -> bool { * self == RBRINTENR :: DISABLE_THE_RDA_INTE } # [ doc = "Checks if the value of the field is `ENABLE_THE_RDA_INTER`" ] # [ inline ] pub fn is_enable_the_rda_inter ( & self ) -> bool { * self == RBRINTENR :: ENABLE_THE_RDA_INTER } } # [ doc = "Possible values of the field `THREINTEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum THREINTENR { # [ doc = "Disable the THRE interrupt." ] DISABLE_THE_THRE_INT , # [ doc = "Enable the THRE interrupt." ] ENABLE_THE_THRE_INTE } impl THREINTENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { THREINTENR :: DISABLE_THE_THRE_INT => false , THREINTENR :: ENABLE_THE_THRE_INTE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> THREINTENR { match value { false => THREINTENR :: DISABLE_THE_THRE_INT , true => THREINTENR :: ENABLE_THE_THRE_INTE , } } # [ doc = "Checks if the value of the field is `DISABLE_THE_THRE_INT`" ] # [ inline ] pub fn is_disable_the_thre_int ( & self ) -> bool { * self == THREINTENR :: DISABLE_THE_THRE_INT } # [ doc = "Checks if the value of the field is `ENABLE_THE_THRE_INTE`" ] # [ inline ] pub fn is_enable_the_thre_inte ( & self ) -> bool { * self == THREINTENR :: ENABLE_THE_THRE_INTE } } # [ doc = "Possible values of the field `RLSINTEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RLSINTENR { # [ doc = "Disable the RLS interrupt." ] DISABLE_THE_RLS_INTE , # [ doc = "Enable the RLS interrupt." ] ENABLE_THE_RLS_INTER } impl RLSINTENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RLSINTENR :: DISABLE_THE_RLS_INTE => false , RLSINTENR :: ENABLE_THE_RLS_INTER => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RLSINTENR { match value { false => RLSINTENR :: DISABLE_THE_RLS_INTE , true => RLSINTENR :: ENABLE_THE_RLS_INTER , } } # [ doc = "Checks if the value of the field is `DISABLE_THE_RLS_INTE`" ] # [ inline ] pub fn is_disable_the_rls_inte ( & self ) -> bool { * self == RLSINTENR :: DISABLE_THE_RLS_INTE } # [ doc = "Checks if the value of the field is `ENABLE_THE_RLS_INTER`" ] # [ inline ] pub fn is_enable_the_rls_inter ( & self ) -> bool { * self == RLSINTENR :: ENABLE_THE_RLS_INTER } } # [ doc = "Possible values of the field `MSINTEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MSINTENR { # [ doc = "Disable the MS interrupt." ] DISABLE_THE_MS_INTER , # [ doc = "Enable the MS interrupt." ] ENABLE_THE_MS_INTERR } impl MSINTENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MSINTENR :: DISABLE_THE_MS_INTER => false , MSINTENR :: ENABLE_THE_MS_INTERR => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MSINTENR { match value { false => MSINTENR :: DISABLE_THE_MS_INTER , true => MSINTENR :: ENABLE_THE_MS_INTERR , } } # [ doc = "Checks if the value of the field is `DISABLE_THE_MS_INTER`" ] # [ inline ] pub fn is_disable_the_ms_inter ( & self ) -> bool { * self == MSINTENR :: DISABLE_THE_MS_INTER } # [ doc = "Checks if the value of the field is `ENABLE_THE_MS_INTERR`" ] # [ inline ] pub fn is_enable_the_ms_interr ( & self ) -> bool { * self == MSINTENR :: ENABLE_THE_MS_INTERR } } # [ doc = "Possible values of the field `ABEOINTEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ABEOINTENR { # [ doc = "Disable end of auto-baud Interrupt." ] DISABLE_END_OF_AUTO_ , # [ doc = "Enable end of auto-baud Interrupt." ] ENABLE_END_OF_AUTO_B } impl ABEOINTENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ABEOINTENR :: DISABLE_END_OF_AUTO_ => false , ABEOINTENR :: ENABLE_END_OF_AUTO_B => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ABEOINTENR { match value { false => ABEOINTENR :: DISABLE_END_OF_AUTO_ , true => ABEOINTENR :: ENABLE_END_OF_AUTO_B , } } # [ doc = "Checks if the value of the field is `DISABLE_END_OF_AUTO_`" ] # [ inline ] pub fn is_disable_end_of_auto_ ( & self ) -> bool { * self == ABEOINTENR :: DISABLE_END_OF_AUTO_ } # [ doc = "Checks if the value of the field is `ENABLE_END_OF_AUTO_B`" ] # [ inline ] pub fn is_enable_end_of_auto_b ( & self ) -> bool { * self == ABEOINTENR :: ENABLE_END_OF_AUTO_B } } # [ doc = "Possible values of the field `ABTOINTEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ABTOINTENR { # [ doc = "Disable auto-baud time-out Interrupt." ] DISABLE_AUTO_BAUD_TI , # [ doc = "Enable auto-baud time-out Interrupt." ] ENABLE_AUTO_BAUD_TIM } impl ABTOINTENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ABTOINTENR :: DISABLE_AUTO_BAUD_TI => false , ABTOINTENR :: ENABLE_AUTO_BAUD_TIM => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ABTOINTENR { match value { false => ABTOINTENR :: DISABLE_AUTO_BAUD_TI , true => ABTOINTENR :: ENABLE_AUTO_BAUD_TIM , } } # [ doc = "Checks if the value of the field is `DISABLE_AUTO_BAUD_TI`" ] # [ inline ] pub fn is_disable_auto_baud_ti ( & self ) -> bool { * self == ABTOINTENR :: DISABLE_AUTO_BAUD_TI } # [ doc = "Checks if the value of the field is `ENABLE_AUTO_BAUD_TIM`" ] # [ inline ] pub fn is_enable_auto_baud_tim ( & self ) -> bool { * self == ABTOINTENR :: ENABLE_AUTO_BAUD_TIM } } # [ doc = "Values that can be written to the field `RBRINTEN`" ] pub enum RBRINTENW { # [ doc = "Disable the RDA interrupt." ] DISABLE_THE_RDA_INTE , # [ doc = "Enable the RDA interrupt." ] ENABLE_THE_RDA_INTER } impl RBRINTENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RBRINTENW :: DISABLE_THE_RDA_INTE => false , RBRINTENW :: ENABLE_THE_RDA_INTER => true } } } # [ doc = r" Proxy" ] pub struct _RBRINTENW < 'a > { w : & 'a mut W , } impl < 'a > _RBRINTENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RBRINTENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable the RDA interrupt." ] # [ inline ] pub fn disable_the_rda_inte ( self ) -> & 'a mut W { self . variant ( RBRINTENW :: DISABLE_THE_RDA_INTE ) } # [ doc = "Enable the RDA interrupt." ] # [ inline ] pub fn enable_the_rda_inter ( self ) -> & 'a mut W { self . variant ( RBRINTENW :: ENABLE_THE_RDA_INTER ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `THREINTEN`" ] pub enum THREINTENW { # [ doc = "Disable the THRE interrupt." ] DISABLE_THE_THRE_INT , # [ doc = "Enable the THRE interrupt." ] ENABLE_THE_THRE_INTE } impl THREINTENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { THREINTENW :: DISABLE_THE_THRE_INT => false , THREINTENW :: ENABLE_THE_THRE_INTE => true } } } # [ doc = r" Proxy" ] pub struct _THREINTENW < 'a > { w : & 'a mut W , } impl < 'a > _THREINTENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : THREINTENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable the THRE interrupt." ] # [ inline ] pub fn disable_the_thre_int ( self ) -> & 'a mut W { self . variant ( THREINTENW :: DISABLE_THE_THRE_INT ) } # [ doc = "Enable the THRE interrupt." ] # [ inline ] pub fn enable_the_thre_inte ( self ) -> & 'a mut W { self . variant ( THREINTENW :: ENABLE_THE_THRE_INTE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RLSINTEN`" ] pub enum RLSINTENW { # [ doc = "Disable the RLS interrupt." ] DISABLE_THE_RLS_INTE , # [ doc = "Enable the RLS interrupt." ] ENABLE_THE_RLS_INTER } impl RLSINTENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RLSINTENW :: DISABLE_THE_RLS_INTE => false , RLSINTENW :: ENABLE_THE_RLS_INTER => true } } } # [ doc = r" Proxy" ] pub struct _RLSINTENW < 'a > { w : & 'a mut W , } impl < 'a > _RLSINTENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RLSINTENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable the RLS interrupt." ] # [ inline ] pub fn disable_the_rls_inte ( self ) -> & 'a mut W { self . variant ( RLSINTENW :: DISABLE_THE_RLS_INTE ) } # [ doc = "Enable the RLS interrupt." ] # [ inline ] pub fn enable_the_rls_inter ( self ) -> & 'a mut W { self . variant ( RLSINTENW :: ENABLE_THE_RLS_INTER ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MSINTEN`" ] pub enum MSINTENW { # [ doc = "Disable the MS interrupt." ] DISABLE_THE_MS_INTER , # [ doc = "Enable the MS interrupt." ] ENABLE_THE_MS_INTERR } impl MSINTENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MSINTENW :: DISABLE_THE_MS_INTER => false , MSINTENW :: ENABLE_THE_MS_INTERR => true } } } # [ doc = r" Proxy" ] pub struct _MSINTENW < 'a > { w : & 'a mut W , } impl < 'a > _MSINTENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MSINTENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable the MS interrupt." ] # [ inline ] pub fn disable_the_ms_inter ( self ) -> & 'a mut W { self . variant ( MSINTENW :: DISABLE_THE_MS_INTER ) } # [ doc = "Enable the MS interrupt." ] # [ inline ] pub fn enable_the_ms_interr ( self ) -> & 'a mut W { self . variant ( MSINTENW :: ENABLE_THE_MS_INTERR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ABEOINTEN`" ] pub enum ABEOINTENW { # [ doc = "Disable end of auto-baud Interrupt." ] DISABLE_END_OF_AUTO_ , # [ doc = "Enable end of auto-baud Interrupt." ] ENABLE_END_OF_AUTO_B } impl ABEOINTENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ABEOINTENW :: DISABLE_END_OF_AUTO_ => false , ABEOINTENW :: ENABLE_END_OF_AUTO_B => true } } } # [ doc = r" Proxy" ] pub struct _ABEOINTENW < 'a > { w : & 'a mut W , } impl < 'a > _ABEOINTENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ABEOINTENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable end of auto-baud Interrupt." ] # [ inline ] pub fn disable_end_of_auto_ ( self ) -> & 'a mut W { self . variant ( ABEOINTENW :: DISABLE_END_OF_AUTO_ ) } # [ doc = "Enable end of auto-baud Interrupt." ] # [ inline ] pub fn enable_end_of_auto_b ( self ) -> & 'a mut W { self . variant ( ABEOINTENW :: ENABLE_END_OF_AUTO_B ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ABTOINTEN`" ] pub enum ABTOINTENW { # [ doc = "Disable auto-baud time-out Interrupt." ] DISABLE_AUTO_BAUD_TI , # [ doc = "Enable auto-baud time-out Interrupt." ] ENABLE_AUTO_BAUD_TIM } impl ABTOINTENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ABTOINTENW :: DISABLE_AUTO_BAUD_TI => false , ABTOINTENW :: ENABLE_AUTO_BAUD_TIM => true } } } # [ doc = r" Proxy" ] pub struct _ABTOINTENW < 'a > { w : & 'a mut W , } impl < 'a > _ABTOINTENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ABTOINTENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable auto-baud time-out Interrupt." ] # [ inline ] pub fn disable_auto_baud_ti ( self ) -> & 'a mut W { self . variant ( ABTOINTENW :: DISABLE_AUTO_BAUD_TI ) } # [ doc = "Enable auto-baud time-out Interrupt." ] # [ inline ] pub fn enable_auto_baud_tim ( self ) -> & 'a mut W { self . variant ( ABTOINTENW :: ENABLE_AUTO_BAUD_TIM ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - RBR Interrupt Enable. Enables the Receive Data Available interrupt. It also controls the Character Receive Time-out interrupt." ] # [ inline ] pub fn rbrinten ( & self ) -> RBRINTENR { RBRINTENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - THRE Interrupt Enable. Enables the THRE interrupt. The status of this interrupt can be read from LSR\\[5\\]." ] # [ inline ] pub fn threinten ( & self ) -> THREINTENR { THREINTENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enables the Receive Line Status interrupt. The status of this interrupt can be read from LSR\\[4:1\\]." ] # [ inline ] pub fn rlsinten ( & self ) -> RLSINTENR { RLSINTENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enables the Modem Status interrupt. The components of this interrupt can be read from the MSR." ] # [ inline ] pub fn msinten ( & self ) -> MSINTENR { MSINTENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Enables the end of auto-baud interrupt." ] # [ inline ] pub fn abeointen ( & self ) -> ABEOINTENR { ABEOINTENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Enables the auto-baud time-out interrupt." ] # [ inline ] pub fn abtointen ( & self ) -> ABTOINTENR { ABTOINTENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - RBR Interrupt Enable. Enables the Receive Data Available interrupt. It also controls the Character Receive Time-out interrupt." ] # [ inline ] pub fn rbrinten ( & mut self ) -> _RBRINTENW { _RBRINTENW { w : self } } # [ doc = "Bit 1 - THRE Interrupt Enable. Enables the THRE interrupt. The status of this interrupt can be read from LSR\\[5\\]." ] # [ inline ] pub fn threinten ( & mut self ) -> _THREINTENW { _THREINTENW { w : self } } # [ doc = "Bit 2 - Enables the Receive Line Status interrupt. The status of this interrupt can be read from LSR\\[4:1\\]." ] # [ inline ] pub fn rlsinten ( & mut self ) -> _RLSINTENW { _RLSINTENW { w : self } } # [ doc = "Bit 3 - Enables the Modem Status interrupt. The components of this interrupt can be read from the MSR." ] # [ inline ] pub fn msinten ( & mut self ) -> _MSINTENW { _MSINTENW { w : self } } # [ doc = "Bit 8 - Enables the end of auto-baud interrupt." ] # [ inline ] pub fn abeointen ( & mut self ) -> _ABEOINTENW { _ABEOINTENW { w : self } } # [ doc = "Bit 9 - Enables the auto-baud time-out interrupt." ] # [ inline ] pub fn abtointen ( & mut self ) -> _ABTOINTENW { _ABTOINTENW { w : self } } } } # [ doc = "Interrupt ID Register. Identifies which interrupt(s) are pending." ] pub struct IIR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt ID Register. Identifies which interrupt(s) are pending." ] pub mod iir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: IIR { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `INTSTATUS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTSTATUSR { # [ doc = "At least one interrupt is pending." ] AT_LEAST_ONE_INTERRU , # [ doc = "No interrupt is pending." ] NO_INTERRUPT_IS_PEND } impl INTSTATUSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INTSTATUSR :: AT_LEAST_ONE_INTERRU => false , INTSTATUSR :: NO_INTERRUPT_IS_PEND => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INTSTATUSR { match value { false => INTSTATUSR :: AT_LEAST_ONE_INTERRU , true => INTSTATUSR :: NO_INTERRUPT_IS_PEND , } } # [ doc = "Checks if the value of the field is `AT_LEAST_ONE_INTERRU`" ] # [ inline ] pub fn is_at_least_one_interru ( & self ) -> bool { * self == INTSTATUSR :: AT_LEAST_ONE_INTERRU } # [ doc = "Checks if the value of the field is `NO_INTERRUPT_IS_PEND`" ] # [ inline ] pub fn is_no_interrupt_is_pend ( & self ) -> bool { * self == INTSTATUSR :: NO_INTERRUPT_IS_PEND } } # [ doc = "Possible values of the field `INTID`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTIDR { # [ doc = "1   - Receive Line Status (RLS)." ] _1_RECEIVE_LINE_S , # [ doc = "2a - Receive Data Available (RDA)." ] _2A_RECEIVE_DATA_AV , # [ doc = "2b - Character Time-out Indicator (CTI)." ] _2B_CHARACTER_TIME_ , # [ doc = "3   - THRE Interrupt." ] _3_THRE_INTERRUPT , # [ doc = "4   - Modem status" ] _4_MODEM_STATUS , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl INTIDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { INTIDR :: _1_RECEIVE_LINE_S => 0x03 , INTIDR :: _2A_RECEIVE_DATA_AV => 0x02 , INTIDR :: _2B_CHARACTER_TIME_ => 0x06 , INTIDR :: _3_THRE_INTERRUPT => 0x01 , INTIDR :: _4_MODEM_STATUS => 0 , INTIDR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> INTIDR { match value { 3 => INTIDR :: _1_RECEIVE_LINE_S , 2 => INTIDR :: _2A_RECEIVE_DATA_AV , 6 => INTIDR :: _2B_CHARACTER_TIME_ , 1 => INTIDR :: _3_THRE_INTERRUPT , 0 => INTIDR :: _4_MODEM_STATUS , i => INTIDR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `_1_RECEIVE_LINE_S`" ] # [ inline ] pub fn is_1_receive_line_s ( & self ) -> bool { * self == INTIDR :: _1_RECEIVE_LINE_S } # [ doc = "Checks if the value of the field is `_2A_RECEIVE_DATA_AV`" ] # [ inline ] pub fn is_2a_receive_data_av ( & self ) -> bool { * self == INTIDR :: _2A_RECEIVE_DATA_AV } # [ doc = "Checks if the value of the field is `_2B_CHARACTER_TIME_`" ] # [ inline ] pub fn is_2b_character_time_ ( & self ) -> bool { * self == INTIDR :: _2B_CHARACTER_TIME_ } # [ doc = "Checks if the value of the field is `_3_THRE_INTERRUPT`" ] # [ inline ] pub fn is_3_thre_interrupt ( & self ) -> bool { * self == INTIDR :: _3_THRE_INTERRUPT } # [ doc = "Checks if the value of the field is `_4_MODEM_STATUS`" ] # [ inline ] pub fn is_4_modem_status ( & self ) -> bool { * self == INTIDR :: _4_MODEM_STATUS } } # [ doc = r" Value of the field" ] pub struct FIFOENR { bits : u8 , } impl FIFOENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct ABEOINTR { bits : bool , } impl ABEOINTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ABTOINTR { bits : bool , } impl ABTOINTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt status. Note that IIR\\[0\\] is active low. The pending interrupt can be determined by evaluating IIR\\[3:1\\]." ] # [ inline ] pub fn intstatus ( & self ) -> INTSTATUSR { INTSTATUSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 1:3 - Interrupt identification. IER\\[3:1\\] identifies an interrupt corresponding to the USART Rx FIFO. All other values of IER\\[3:1\\] not listed below are reserved." ] # [ inline ] pub fn intid ( & self ) -> INTIDR { INTIDR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 6:7 - These bits are equivalent to FCR\\[0\\]." ] # [ inline ] pub fn fifoen ( & self ) -> FIFOENR { let bits = { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; FIFOENR { bits } } # [ doc = "Bit 8 - End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled." ] # [ inline ] pub fn abeoint ( & self ) -> ABEOINTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ABEOINTR { bits } } # [ doc = "Bit 9 - Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled." ] # [ inline ] pub fn abtoint ( & self ) -> ABTOINTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ABTOINTR { bits } } } } # [ doc = "FIFO Control Register. Controls USART FIFO usage and modes." ] pub struct FCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "FIFO Control Register. Controls USART FIFO usage and modes." ] pub mod fcr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FCR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = "Values that can be written to the field `FIFOEN`" ] pub enum FIFOENW { # [ doc = "USART FIFOs are disabled. Must not be used in the application." ] DISABLED , # [ doc = "Active high enable for both USART Rx and TX FIFOs and FCR\\[7:1\\] access. This bit must be set for proper USART operation. Any transition on this bit will automatically clear the USART FIFOs." ] ENABLED } impl FIFOENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FIFOENW :: DISABLED => false , FIFOENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _FIFOENW < 'a > { w : & 'a mut W , } impl < 'a > _FIFOENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FIFOENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "USART FIFOs are disabled. Must not be used in the application." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( FIFOENW :: DISABLED ) } # [ doc = "Active high enable for both USART Rx and TX FIFOs and FCR\\[7:1\\] access. This bit must be set for proper USART operation. Any transition on this bit will automatically clear the USART FIFOs." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( FIFOENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RXFIFORES`" ] pub enum RXFIFORESW { # [ doc = "No impact on either of USART FIFOs." ] NO_IMPACT , # [ doc = "Writing a logic 1 to FCR\\[1\\] will clear all bytes in USART Rx FIFO, reset the pointer logic. This bit is self-clearing." ] CLEAR } impl RXFIFORESW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXFIFORESW :: NO_IMPACT => false , RXFIFORESW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _RXFIFORESW < 'a > { w : & 'a mut W , } impl < 'a > _RXFIFORESW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXFIFORESW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No impact on either of USART FIFOs." ] # [ inline ] pub fn no_impact ( self ) -> & 'a mut W { self . variant ( RXFIFORESW :: NO_IMPACT ) } # [ doc = "Writing a logic 1 to FCR\\[1\\] will clear all bytes in USART Rx FIFO, reset the pointer logic. This bit is self-clearing." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( RXFIFORESW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `TXFIFORES`" ] pub enum TXFIFORESW { # [ doc = "No impact on either of USART FIFOs." ] NO_IMPACT , # [ doc = "Writing a logic 1 to FCR\\[2\\] will clear all bytes in USART TX FIFO, reset the pointer logic. This bit is self-clearing." ] CLEAR } impl TXFIFORESW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TXFIFORESW :: NO_IMPACT => false , TXFIFORESW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _TXFIFORESW < 'a > { w : & 'a mut W , } impl < 'a > _TXFIFORESW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TXFIFORESW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No impact on either of USART FIFOs." ] # [ inline ] pub fn no_impact ( self ) -> & 'a mut W { self . variant ( TXFIFORESW :: NO_IMPACT ) } # [ doc = "Writing a logic 1 to FCR\\[2\\] will clear all bytes in USART TX FIFO, reset the pointer logic. This bit is self-clearing." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( TXFIFORESW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RXTL`" ] pub enum RXTLW { # [ doc = "Trigger level 0 (1 character or 0x01)." ] TRIGGER_LEVEL_0_1_C , # [ doc = "Trigger level 1 (4 characters or 0x04)." ] TRIGGER_LEVEL_1_4_C , # [ doc = "Trigger level 2 (8 characters or 0x08)." ] TRIGGER_LEVEL_2_8_C , # [ doc = "Trigger level 3 (14 characters or 0x0E)." ] TRIGGER_LEVEL_3_14_ } impl RXTLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { RXTLW :: TRIGGER_LEVEL_0_1_C => 0 , RXTLW :: TRIGGER_LEVEL_1_4_C => 1 , RXTLW :: TRIGGER_LEVEL_2_8_C => 2 , RXTLW :: TRIGGER_LEVEL_3_14_ => 3 } } } # [ doc = r" Proxy" ] pub struct _RXTLW < 'a > { w : & 'a mut W , } impl < 'a > _RXTLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXTLW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Trigger level 0 (1 character or 0x01)." ] # [ inline ] pub fn trigger_level_0_1_c ( self ) -> & 'a mut W { self . variant ( RXTLW :: TRIGGER_LEVEL_0_1_C ) } # [ doc = "Trigger level 1 (4 characters or 0x04)." ] # [ inline ] pub fn trigger_level_1_4_c ( self ) -> & 'a mut W { self . variant ( RXTLW :: TRIGGER_LEVEL_1_4_C ) } # [ doc = "Trigger level 2 (8 characters or 0x08)." ] # [ inline ] pub fn trigger_level_2_8_c ( self ) -> & 'a mut W { self . variant ( RXTLW :: TRIGGER_LEVEL_2_8_C ) } # [ doc = "Trigger level 3 (14 characters or 0x0E)." ] # [ inline ] pub fn trigger_level_3_14_ ( self ) -> & 'a mut W { self . variant ( RXTLW :: TRIGGER_LEVEL_3_14_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - FIFO enable" ] # [ inline ] pub fn fifoen ( & mut self ) -> _FIFOENW { _FIFOENW { w : self } } # [ doc = "Bit 1 - RX FIFO Reset" ] # [ inline ] pub fn rxfifores ( & mut self ) -> _RXFIFORESW { _RXFIFORESW { w : self } } # [ doc = "Bit 2 - TX FIFO Reset" ] # [ inline ] pub fn txfifores ( & mut self ) -> _TXFIFORESW { _TXFIFORESW { w : self } } # [ doc = "Bits 6:7 - RX Trigger Level. These two bits determine how many receiver USART FIFO characters must be written before an interrupt is activated." ] # [ inline ] pub fn rxtl ( & mut self ) -> _RXTLW { _RXTLW { w : self } } } } # [ doc = "Line Control Register. Contains controls for frame formatting and break generation." ] pub struct LCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Line Control Register. Contains controls for frame formatting and break generation." ] pub mod lcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: LCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `WLS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WLSR { # [ doc = "5-bit character length." ] _5_BIT_CHARACTER_LENG , # [ doc = "6-bit character length." ] _6_BIT_CHARACTER_LENG , # [ doc = "7-bit character length." ] _7_BIT_CHARACTER_LENG , # [ doc = "8-bit character length." ] _8_BIT_CHARACTER_LENG } impl WLSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { WLSR :: _5_BIT_CHARACTER_LENG => 0 , WLSR :: _6_BIT_CHARACTER_LENG => 0x01 , WLSR :: _7_BIT_CHARACTER_LENG => 0x02 , WLSR :: _8_BIT_CHARACTER_LENG => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> WLSR { match value { 0 => WLSR :: _5_BIT_CHARACTER_LENG , 1 => WLSR :: _6_BIT_CHARACTER_LENG , 2 => WLSR :: _7_BIT_CHARACTER_LENG , 3 => WLSR :: _8_BIT_CHARACTER_LENG , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `_5_BIT_CHARACTER_LENG`" ] # [ inline ] pub fn is_5_bit_character_leng ( & self ) -> bool { * self == WLSR :: _5_BIT_CHARACTER_LENG } # [ doc = "Checks if the value of the field is `_6_BIT_CHARACTER_LENG`" ] # [ inline ] pub fn is_6_bit_character_leng ( & self ) -> bool { * self == WLSR :: _6_BIT_CHARACTER_LENG } # [ doc = "Checks if the value of the field is `_7_BIT_CHARACTER_LENG`" ] # [ inline ] pub fn is_7_bit_character_leng ( & self ) -> bool { * self == WLSR :: _7_BIT_CHARACTER_LENG } # [ doc = "Checks if the value of the field is `_8_BIT_CHARACTER_LENG`" ] # [ inline ] pub fn is_8_bit_character_leng ( & self ) -> bool { * self == WLSR :: _8_BIT_CHARACTER_LENG } } # [ doc = "Possible values of the field `SBS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SBSR { # [ doc = "1 stop bit." ] _1_STOP_BIT_ , # [ doc = "2 stop bits (1.5 if LCR\\[1:0\\]=00)." ] _2_STOP_BITS_1_5_IF_ } impl SBSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SBSR :: _1_STOP_BIT_ => false , SBSR :: _2_STOP_BITS_1_5_IF_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SBSR { match value { false => SBSR :: _1_STOP_BIT_ , true => SBSR :: _2_STOP_BITS_1_5_IF_ , } } # [ doc = "Checks if the value of the field is `_1_STOP_BIT_`" ] # [ inline ] pub fn is_1_stop_bit_ ( & self ) -> bool { * self == SBSR :: _1_STOP_BIT_ } # [ doc = "Checks if the value of the field is `_2_STOP_BITS_1_5_IF_`" ] # [ inline ] pub fn is_2_stop_bits_1_5_if_ ( & self ) -> bool { * self == SBSR :: _2_STOP_BITS_1_5_IF_ } } # [ doc = "Possible values of the field `PE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PER { # [ doc = "Disable parity generation and checking." ] DISABLE_PARITY_GENER , # [ doc = "Enable parity generation and checking." ] ENABLE_PARITY_GENERA } impl PER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PER :: DISABLE_PARITY_GENER => false , PER :: ENABLE_PARITY_GENERA => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PER { match value { false => PER :: DISABLE_PARITY_GENER , true => PER :: ENABLE_PARITY_GENERA , } } # [ doc = "Checks if the value of the field is `DISABLE_PARITY_GENER`" ] # [ inline ] pub fn is_disable_parity_gener ( & self ) -> bool { * self == PER :: DISABLE_PARITY_GENER } # [ doc = "Checks if the value of the field is `ENABLE_PARITY_GENERA`" ] # [ inline ] pub fn is_enable_parity_genera ( & self ) -> bool { * self == PER :: ENABLE_PARITY_GENERA } } # [ doc = "Possible values of the field `PS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSR { # [ doc = "Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd." ] ODD_PARITY_NUMBER_O , # [ doc = "Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even." ] EVEN_PARITY_NUMBER_ , # [ doc = "Forced 1 stick parity." ] FORCED_1_STICK_PARIT , # [ doc = "Forced 0 stick parity." ] FORCED_0_STICK_PARIT } impl PSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PSR :: ODD_PARITY_NUMBER_O => 0 , PSR :: EVEN_PARITY_NUMBER_ => 0x01 , PSR :: FORCED_1_STICK_PARIT => 0x02 , PSR :: FORCED_0_STICK_PARIT => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PSR { match value { 0 => PSR :: ODD_PARITY_NUMBER_O , 1 => PSR :: EVEN_PARITY_NUMBER_ , 2 => PSR :: FORCED_1_STICK_PARIT , 3 => PSR :: FORCED_0_STICK_PARIT , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `ODD_PARITY_NUMBER_O`" ] # [ inline ] pub fn is_odd_parity_number_o ( & self ) -> bool { * self == PSR :: ODD_PARITY_NUMBER_O } # [ doc = "Checks if the value of the field is `EVEN_PARITY_NUMBER_`" ] # [ inline ] pub fn is_even_parity_number_ ( & self ) -> bool { * self == PSR :: EVEN_PARITY_NUMBER_ } # [ doc = "Checks if the value of the field is `FORCED_1_STICK_PARIT`" ] # [ inline ] pub fn is_forced_1_stick_parit ( & self ) -> bool { * self == PSR :: FORCED_1_STICK_PARIT } # [ doc = "Checks if the value of the field is `FORCED_0_STICK_PARIT`" ] # [ inline ] pub fn is_forced_0_stick_parit ( & self ) -> bool { * self == PSR :: FORCED_0_STICK_PARIT } } # [ doc = "Possible values of the field `BC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BCR { # [ doc = "Disable break transmission." ] DISABLE_BREAK_TRANSM , # [ doc = "Enable break transmission. Output pin USART TXD is forced to logic 0 when LCR\\[6\\] is active high." ] ENABLE_BREAK_TRANSMI } impl BCR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BCR :: DISABLE_BREAK_TRANSM => false , BCR :: ENABLE_BREAK_TRANSMI => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BCR { match value { false => BCR :: DISABLE_BREAK_TRANSM , true => BCR :: ENABLE_BREAK_TRANSMI , } } # [ doc = "Checks if the value of the field is `DISABLE_BREAK_TRANSM`" ] # [ inline ] pub fn is_disable_break_transm ( & self ) -> bool { * self == BCR :: DISABLE_BREAK_TRANSM } # [ doc = "Checks if the value of the field is `ENABLE_BREAK_TRANSMI`" ] # [ inline ] pub fn is_enable_break_transmi ( & self ) -> bool { * self == BCR :: ENABLE_BREAK_TRANSMI } } # [ doc = "Possible values of the field `DLAB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DLABR { # [ doc = "Disable access to Divisor Latches." ] DISABLE_ACCESS_TO_DI , # [ doc = "Enable access to Divisor Latches." ] ENABLE_ACCESS_TO_DIV } impl DLABR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DLABR :: DISABLE_ACCESS_TO_DI => false , DLABR :: ENABLE_ACCESS_TO_DIV => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DLABR { match value { false => DLABR :: DISABLE_ACCESS_TO_DI , true => DLABR :: ENABLE_ACCESS_TO_DIV , } } # [ doc = "Checks if the value of the field is `DISABLE_ACCESS_TO_DI`" ] # [ inline ] pub fn is_disable_access_to_di ( & self ) -> bool { * self == DLABR :: DISABLE_ACCESS_TO_DI } # [ doc = "Checks if the value of the field is `ENABLE_ACCESS_TO_DIV`" ] # [ inline ] pub fn is_enable_access_to_div ( & self ) -> bool { * self == DLABR :: ENABLE_ACCESS_TO_DIV } } # [ doc = "Values that can be written to the field `WLS`" ] pub enum WLSW { # [ doc = "5-bit character length." ] _5_BIT_CHARACTER_LENG , # [ doc = "6-bit character length." ] _6_BIT_CHARACTER_LENG , # [ doc = "7-bit character length." ] _7_BIT_CHARACTER_LENG , # [ doc = "8-bit character length." ] _8_BIT_CHARACTER_LENG } impl WLSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { WLSW :: _5_BIT_CHARACTER_LENG => 0 , WLSW :: _6_BIT_CHARACTER_LENG => 1 , WLSW :: _7_BIT_CHARACTER_LENG => 2 , WLSW :: _8_BIT_CHARACTER_LENG => 3 } } } # [ doc = r" Proxy" ] pub struct _WLSW < 'a > { w : & 'a mut W , } impl < 'a > _WLSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WLSW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "5-bit character length." ] # [ inline ] pub fn _5_bit_character_leng ( self ) -> & 'a mut W { self . variant ( WLSW :: _5_BIT_CHARACTER_LENG ) } # [ doc = "6-bit character length." ] # [ inline ] pub fn _6_bit_character_leng ( self ) -> & 'a mut W { self . variant ( WLSW :: _6_BIT_CHARACTER_LENG ) } # [ doc = "7-bit character length." ] # [ inline ] pub fn _7_bit_character_leng ( self ) -> & 'a mut W { self . variant ( WLSW :: _7_BIT_CHARACTER_LENG ) } # [ doc = "8-bit character length." ] # [ inline ] pub fn _8_bit_character_leng ( self ) -> & 'a mut W { self . variant ( WLSW :: _8_BIT_CHARACTER_LENG ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SBS`" ] pub enum SBSW { # [ doc = "1 stop bit." ] _1_STOP_BIT_ , # [ doc = "2 stop bits (1.5 if LCR\\[1:0\\]=00)." ] _2_STOP_BITS_1_5_IF_ } impl SBSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SBSW :: _1_STOP_BIT_ => false , SBSW :: _2_STOP_BITS_1_5_IF_ => true } } } # [ doc = r" Proxy" ] pub struct _SBSW < 'a > { w : & 'a mut W , } impl < 'a > _SBSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SBSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "1 stop bit." ] # [ inline ] pub fn _1_stop_bit_ ( self ) -> & 'a mut W { self . variant ( SBSW :: _1_STOP_BIT_ ) } # [ doc = "2 stop bits (1.5 if LCR\\[1:0\\]=00)." ] # [ inline ] pub fn _2_stop_bits_1_5_if_ ( self ) -> & 'a mut W { self . variant ( SBSW :: _2_STOP_BITS_1_5_IF_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PE`" ] pub enum PEW { # [ doc = "Disable parity generation and checking." ] DISABLE_PARITY_GENER , # [ doc = "Enable parity generation and checking." ] ENABLE_PARITY_GENERA } impl PEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PEW :: DISABLE_PARITY_GENER => false , PEW :: ENABLE_PARITY_GENERA => true } } } # [ doc = r" Proxy" ] pub struct _PEW < 'a > { w : & 'a mut W , } impl < 'a > _PEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable parity generation and checking." ] # [ inline ] pub fn disable_parity_gener ( self ) -> & 'a mut W { self . variant ( PEW :: DISABLE_PARITY_GENER ) } # [ doc = "Enable parity generation and checking." ] # [ inline ] pub fn enable_parity_genera ( self ) -> & 'a mut W { self . variant ( PEW :: ENABLE_PARITY_GENERA ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PS`" ] pub enum PSW { # [ doc = "Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd." ] ODD_PARITY_NUMBER_O , # [ doc = "Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even." ] EVEN_PARITY_NUMBER_ , # [ doc = "Forced 1 stick parity." ] FORCED_1_STICK_PARIT , # [ doc = "Forced 0 stick parity." ] FORCED_0_STICK_PARIT } impl PSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PSW :: ODD_PARITY_NUMBER_O => 0 , PSW :: EVEN_PARITY_NUMBER_ => 1 , PSW :: FORCED_1_STICK_PARIT => 2 , PSW :: FORCED_0_STICK_PARIT => 3 } } } # [ doc = r" Proxy" ] pub struct _PSW < 'a > { w : & 'a mut W , } impl < 'a > _PSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PSW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd." ] # [ inline ] pub fn odd_parity_number_o ( self ) -> & 'a mut W { self . variant ( PSW :: ODD_PARITY_NUMBER_O ) } # [ doc = "Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even." ] # [ inline ] pub fn even_parity_number_ ( self ) -> & 'a mut W { self . variant ( PSW :: EVEN_PARITY_NUMBER_ ) } # [ doc = "Forced 1 stick parity." ] # [ inline ] pub fn forced_1_stick_parit ( self ) -> & 'a mut W { self . variant ( PSW :: FORCED_1_STICK_PARIT ) } # [ doc = "Forced 0 stick parity." ] # [ inline ] pub fn forced_0_stick_parit ( self ) -> & 'a mut W { self . variant ( PSW :: FORCED_0_STICK_PARIT ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BC`" ] pub enum BCW { # [ doc = "Disable break transmission." ] DISABLE_BREAK_TRANSM , # [ doc = "Enable break transmission. Output pin USART TXD is forced to logic 0 when LCR\\[6\\] is active high." ] ENABLE_BREAK_TRANSMI } impl BCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BCW :: DISABLE_BREAK_TRANSM => false , BCW :: ENABLE_BREAK_TRANSMI => true } } } # [ doc = r" Proxy" ] pub struct _BCW < 'a > { w : & 'a mut W , } impl < 'a > _BCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BCW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable break transmission." ] # [ inline ] pub fn disable_break_transm ( self ) -> & 'a mut W { self . variant ( BCW :: DISABLE_BREAK_TRANSM ) } # [ doc = "Enable break transmission. Output pin USART TXD is forced to logic 0 when LCR\\[6\\] is active high." ] # [ inline ] pub fn enable_break_transmi ( self ) -> & 'a mut W { self . variant ( BCW :: ENABLE_BREAK_TRANSMI ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DLAB`" ] pub enum DLABW { # [ doc = "Disable access to Divisor Latches." ] DISABLE_ACCESS_TO_DI , # [ doc = "Enable access to Divisor Latches." ] ENABLE_ACCESS_TO_DIV } impl DLABW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DLABW :: DISABLE_ACCESS_TO_DI => false , DLABW :: ENABLE_ACCESS_TO_DIV => true } } } # [ doc = r" Proxy" ] pub struct _DLABW < 'a > { w : & 'a mut W , } impl < 'a > _DLABW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DLABW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable access to Divisor Latches." ] # [ inline ] pub fn disable_access_to_di ( self ) -> & 'a mut W { self . variant ( DLABW :: DISABLE_ACCESS_TO_DI ) } # [ doc = "Enable access to Divisor Latches." ] # [ inline ] pub fn enable_access_to_div ( self ) -> & 'a mut W { self . variant ( DLABW :: ENABLE_ACCESS_TO_DIV ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Word Length Select" ] # [ inline ] pub fn wls ( & self ) -> WLSR { WLSR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 2 - Stop Bit Select" ] # [ inline ] pub fn sbs ( & self ) -> SBSR { SBSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Parity Enable" ] # [ inline ] pub fn pe ( & self ) -> PER { PER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 4:5 - Parity Select" ] # [ inline ] pub fn ps ( & self ) -> PSR { PSR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 6 - Break Control" ] # [ inline ] pub fn bc ( & self ) -> BCR { BCR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Divisor Latch Access Bit" ] # [ inline ] pub fn dlab ( & self ) -> DLABR { DLABR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Word Length Select" ] # [ inline ] pub fn wls ( & mut self ) -> _WLSW { _WLSW { w : self } } # [ doc = "Bit 2 - Stop Bit Select" ] # [ inline ] pub fn sbs ( & mut self ) -> _SBSW { _SBSW { w : self } } # [ doc = "Bit 3 - Parity Enable" ] # [ inline ] pub fn pe ( & mut self ) -> _PEW { _PEW { w : self } } # [ doc = "Bits 4:5 - Parity Select" ] # [ inline ] pub fn ps ( & mut self ) -> _PSW { _PSW { w : self } } # [ doc = "Bit 6 - Break Control" ] # [ inline ] pub fn bc ( & mut self ) -> _BCW { _BCW { w : self } } # [ doc = "Bit 7 - Divisor Latch Access Bit" ] # [ inline ] pub fn dlab ( & mut self ) -> _DLABW { _DLABW { w : self } } } } # [ doc = "Modem Control Register." ] pub struct MCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Modem Control Register." ] pub mod mcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DTRCTRLR { bits : bool , } impl DTRCTRLR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RTSCTRLR { bits : bool , } impl RTSCTRLR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `LMS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LMSR { # [ doc = "Disable modem loopback mode." ] DISABLE_MODEM_LOOPBA , # [ doc = "Enable modem loopback mode." ] ENABLE_MODEM_LOOPBAC } impl LMSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LMSR :: DISABLE_MODEM_LOOPBA => false , LMSR :: ENABLE_MODEM_LOOPBAC => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LMSR { match value { false => LMSR :: DISABLE_MODEM_LOOPBA , true => LMSR :: ENABLE_MODEM_LOOPBAC , } } # [ doc = "Checks if the value of the field is `DISABLE_MODEM_LOOPBA`" ] # [ inline ] pub fn is_disable_modem_loopba ( & self ) -> bool { * self == LMSR :: DISABLE_MODEM_LOOPBA } # [ doc = "Checks if the value of the field is `ENABLE_MODEM_LOOPBAC`" ] # [ inline ] pub fn is_enable_modem_loopbac ( & self ) -> bool { * self == LMSR :: ENABLE_MODEM_LOOPBAC } } # [ doc = "Possible values of the field `RTSEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RTSENR { # [ doc = "Disable auto-rts flow control." ] DISABLE_AUTO_RTS_FLO , # [ doc = "Enable auto-rts flow control." ] ENABLE_AUTO_RTS_FLOW } impl RTSENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RTSENR :: DISABLE_AUTO_RTS_FLO => false , RTSENR :: ENABLE_AUTO_RTS_FLOW => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RTSENR { match value { false => RTSENR :: DISABLE_AUTO_RTS_FLO , true => RTSENR :: ENABLE_AUTO_RTS_FLOW , } } # [ doc = "Checks if the value of the field is `DISABLE_AUTO_RTS_FLO`" ] # [ inline ] pub fn is_disable_auto_rts_flo ( & self ) -> bool { * self == RTSENR :: DISABLE_AUTO_RTS_FLO } # [ doc = "Checks if the value of the field is `ENABLE_AUTO_RTS_FLOW`" ] # [ inline ] pub fn is_enable_auto_rts_flow ( & self ) -> bool { * self == RTSENR :: ENABLE_AUTO_RTS_FLOW } } # [ doc = "Possible values of the field `CTSEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CTSENR { # [ doc = "Disable auto-cts flow control." ] DISABLE_AUTO_CTS_FLO , # [ doc = "Enable auto-cts flow control." ] ENABLE_AUTO_CTS_FLOW } impl CTSENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CTSENR :: DISABLE_AUTO_CTS_FLO => false , CTSENR :: ENABLE_AUTO_CTS_FLOW => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CTSENR { match value { false => CTSENR :: DISABLE_AUTO_CTS_FLO , true => CTSENR :: ENABLE_AUTO_CTS_FLOW , } } # [ doc = "Checks if the value of the field is `DISABLE_AUTO_CTS_FLO`" ] # [ inline ] pub fn is_disable_auto_cts_flo ( & self ) -> bool { * self == CTSENR :: DISABLE_AUTO_CTS_FLO } # [ doc = "Checks if the value of the field is `ENABLE_AUTO_CTS_FLOW`" ] # [ inline ] pub fn is_enable_auto_cts_flow ( & self ) -> bool { * self == CTSENR :: ENABLE_AUTO_CTS_FLOW } } # [ doc = r" Proxy" ] pub struct _DTRCTRLW < 'a > { w : & 'a mut W , } impl < 'a > _DTRCTRLW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RTSCTRLW < 'a > { w : & 'a mut W , } impl < 'a > _RTSCTRLW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `LMS`" ] pub enum LMSW { # [ doc = "Disable modem loopback mode." ] DISABLE_MODEM_LOOPBA , # [ doc = "Enable modem loopback mode." ] ENABLE_MODEM_LOOPBAC } impl LMSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { LMSW :: DISABLE_MODEM_LOOPBA => false , LMSW :: ENABLE_MODEM_LOOPBAC => true } } } # [ doc = r" Proxy" ] pub struct _LMSW < 'a > { w : & 'a mut W , } impl < 'a > _LMSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : LMSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable modem loopback mode." ] # [ inline ] pub fn disable_modem_loopba ( self ) -> & 'a mut W { self . variant ( LMSW :: DISABLE_MODEM_LOOPBA ) } # [ doc = "Enable modem loopback mode." ] # [ inline ] pub fn enable_modem_loopbac ( self ) -> & 'a mut W { self . variant ( LMSW :: ENABLE_MODEM_LOOPBAC ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RTSEN`" ] pub enum RTSENW { # [ doc = "Disable auto-rts flow control." ] DISABLE_AUTO_RTS_FLO , # [ doc = "Enable auto-rts flow control." ] ENABLE_AUTO_RTS_FLOW } impl RTSENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RTSENW :: DISABLE_AUTO_RTS_FLO => false , RTSENW :: ENABLE_AUTO_RTS_FLOW => true } } } # [ doc = r" Proxy" ] pub struct _RTSENW < 'a > { w : & 'a mut W , } impl < 'a > _RTSENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RTSENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable auto-rts flow control." ] # [ inline ] pub fn disable_auto_rts_flo ( self ) -> & 'a mut W { self . variant ( RTSENW :: DISABLE_AUTO_RTS_FLO ) } # [ doc = "Enable auto-rts flow control." ] # [ inline ] pub fn enable_auto_rts_flow ( self ) -> & 'a mut W { self . variant ( RTSENW :: ENABLE_AUTO_RTS_FLOW ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CTSEN`" ] pub enum CTSENW { # [ doc = "Disable auto-cts flow control." ] DISABLE_AUTO_CTS_FLO , # [ doc = "Enable auto-cts flow control." ] ENABLE_AUTO_CTS_FLOW } impl CTSENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CTSENW :: DISABLE_AUTO_CTS_FLO => false , CTSENW :: ENABLE_AUTO_CTS_FLOW => true } } } # [ doc = r" Proxy" ] pub struct _CTSENW < 'a > { w : & 'a mut W , } impl < 'a > _CTSENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CTSENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable auto-cts flow control." ] # [ inline ] pub fn disable_auto_cts_flo ( self ) -> & 'a mut W { self . variant ( CTSENW :: DISABLE_AUTO_CTS_FLO ) } # [ doc = "Enable auto-cts flow control." ] # [ inline ] pub fn enable_auto_cts_flow ( self ) -> & 'a mut W { self . variant ( CTSENW :: ENABLE_AUTO_CTS_FLOW ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Source for modem output pin DTR. This bit reads as 0 when modem loopback mode is active." ] # [ inline ] pub fn dtrctrl ( & self ) -> DTRCTRLR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DTRCTRLR { bits } } # [ doc = "Bit 1 - Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active." ] # [ inline ] pub fn rtsctrl ( & self ) -> RTSCTRLR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RTSCTRLR { bits } } # [ doc = "Bit 4 - Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD, has no effect on loopback and output pin, TXD is held in marking state. The DSR, CTS, DCD, and RI pins are ignored. Externally, DTR and RTS are set inactive. Internally, the upper four bits of the MSR are driven by the lower four bits of the MCR. This permits modem status interrupts to be generated in loopback mode by writing the lower four bits of MCR." ] # [ inline ] pub fn lms ( & self ) -> LMSR { LMSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - RTS enable" ] # [ inline ] pub fn rtsen ( & self ) -> RTSENR { RTSENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - CTS enable" ] # [ inline ] pub fn ctsen ( & self ) -> CTSENR { CTSENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Source for modem output pin DTR. This bit reads as 0 when modem loopback mode is active." ] # [ inline ] pub fn dtrctrl ( & mut self ) -> _DTRCTRLW { _DTRCTRLW { w : self } } # [ doc = "Bit 1 - Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active." ] # [ inline ] pub fn rtsctrl ( & mut self ) -> _RTSCTRLW { _RTSCTRLW { w : self } } # [ doc = "Bit 4 - Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD, has no effect on loopback and output pin, TXD is held in marking state. The DSR, CTS, DCD, and RI pins are ignored. Externally, DTR and RTS are set inactive. Internally, the upper four bits of the MSR are driven by the lower four bits of the MCR. This permits modem status interrupts to be generated in loopback mode by writing the lower four bits of MCR." ] # [ inline ] pub fn lms ( & mut self ) -> _LMSW { _LMSW { w : self } } # [ doc = "Bit 6 - RTS enable" ] # [ inline ] pub fn rtsen ( & mut self ) -> _RTSENW { _RTSENW { w : self } } # [ doc = "Bit 7 - CTS enable" ] # [ inline ] pub fn ctsen ( & mut self ) -> _CTSENW { _CTSENW { w : self } } } } # [ doc = "Line Status Register. Contains flags for transmit and receive status, including line errors." ] pub struct LSR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Line Status Register. Contains flags for transmit and receive status, including line errors." ] pub mod lsr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: LSR { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `RDR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RDRR { # [ doc = "RBR is empty." ] RBR_IS_EMPTY_ , # [ doc = "RBR contains valid data." ] RBR_CONTAINS_VALID_D } impl RDRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RDRR :: RBR_IS_EMPTY_ => false , RDRR :: RBR_CONTAINS_VALID_D => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RDRR { match value { false => RDRR :: RBR_IS_EMPTY_ , true => RDRR :: RBR_CONTAINS_VALID_D , } } # [ doc = "Checks if the value of the field is `RBR_IS_EMPTY_`" ] # [ inline ] pub fn is_rbr_is_empty_ ( & self ) -> bool { * self == RDRR :: RBR_IS_EMPTY_ } # [ doc = "Checks if the value of the field is `RBR_CONTAINS_VALID_D`" ] # [ inline ] pub fn is_rbr_contains_valid_d ( & self ) -> bool { * self == RDRR :: RBR_CONTAINS_VALID_D } } # [ doc = "Possible values of the field `OE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OER { # [ doc = "Overrun error status is inactive." ] INACTIVE , # [ doc = "Overrun error status is active." ] ACTIVE } impl OER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OER :: INACTIVE => false , OER :: ACTIVE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OER { match value { false => OER :: INACTIVE , true => OER :: ACTIVE , } } # [ doc = "Checks if the value of the field is `INACTIVE`" ] # [ inline ] pub fn is_inactive ( & self ) -> bool { * self == OER :: INACTIVE } # [ doc = "Checks if the value of the field is `ACTIVE`" ] # [ inline ] pub fn is_active ( & self ) -> bool { * self == OER :: ACTIVE } } # [ doc = "Possible values of the field `PE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PER { # [ doc = "Parity error status is inactive." ] INACTIVE , # [ doc = "Parity error status is active." ] ACTIVE } impl PER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PER :: INACTIVE => false , PER :: ACTIVE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PER { match value { false => PER :: INACTIVE , true => PER :: ACTIVE , } } # [ doc = "Checks if the value of the field is `INACTIVE`" ] # [ inline ] pub fn is_inactive ( & self ) -> bool { * self == PER :: INACTIVE } # [ doc = "Checks if the value of the field is `ACTIVE`" ] # [ inline ] pub fn is_active ( & self ) -> bool { * self == PER :: ACTIVE } } # [ doc = "Possible values of the field `FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FER { # [ doc = "Framing error status is inactive." ] INACTIVE , # [ doc = "Framing error status is active." ] ACTIVE } impl FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FER :: INACTIVE => false , FER :: ACTIVE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FER { match value { false => FER :: INACTIVE , true => FER :: ACTIVE , } } # [ doc = "Checks if the value of the field is `INACTIVE`" ] # [ inline ] pub fn is_inactive ( & self ) -> bool { * self == FER :: INACTIVE } # [ doc = "Checks if the value of the field is `ACTIVE`" ] # [ inline ] pub fn is_active ( & self ) -> bool { * self == FER :: ACTIVE } } # [ doc = "Possible values of the field `BI`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BIR { # [ doc = "Break interrupt status is inactive." ] INACTIVE , # [ doc = "Break interrupt status is active." ] ACTIVE } impl BIR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BIR :: INACTIVE => false , BIR :: ACTIVE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BIR { match value { false => BIR :: INACTIVE , true => BIR :: ACTIVE , } } # [ doc = "Checks if the value of the field is `INACTIVE`" ] # [ inline ] pub fn is_inactive ( & self ) -> bool { * self == BIR :: INACTIVE } # [ doc = "Checks if the value of the field is `ACTIVE`" ] # [ inline ] pub fn is_active ( & self ) -> bool { * self == BIR :: ACTIVE } } # [ doc = "Possible values of the field `THRE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum THRER { # [ doc = "THR contains valid data." ] THR_CONTAINS_VALID_D , # [ doc = "THR is empty." ] THR_IS_EMPTY_ } impl THRER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { THRER :: THR_CONTAINS_VALID_D => false , THRER :: THR_IS_EMPTY_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> THRER { match value { false => THRER :: THR_CONTAINS_VALID_D , true => THRER :: THR_IS_EMPTY_ , } } # [ doc = "Checks if the value of the field is `THR_CONTAINS_VALID_D`" ] # [ inline ] pub fn is_thr_contains_valid_d ( & self ) -> bool { * self == THRER :: THR_CONTAINS_VALID_D } # [ doc = "Checks if the value of the field is `THR_IS_EMPTY_`" ] # [ inline ] pub fn is_thr_is_empty_ ( & self ) -> bool { * self == THRER :: THR_IS_EMPTY_ } } # [ doc = "Possible values of the field `TEMT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TEMTR { # [ doc = "THR and/or the TSR contains valid data." ] VALID_D , # [ doc = "THR and the TSR are empty." ] EMPTY } impl TEMTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TEMTR :: VALID_D => false , TEMTR :: EMPTY => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TEMTR { match value { false => TEMTR :: VALID_D , true => TEMTR :: EMPTY , } } # [ doc = "Checks if the value of the field is `VALID_D`" ] # [ inline ] pub fn is_valid_d ( & self ) -> bool { * self == TEMTR :: VALID_D } # [ doc = "Checks if the value of the field is `EMPTY`" ] # [ inline ] pub fn is_empty ( & self ) -> bool { * self == TEMTR :: EMPTY } } # [ doc = "Possible values of the field `RXFE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXFER { # [ doc = "RBR contains no USART RX errors or FCR\\[0\\]=0." ] NO_ERROR , # [ doc = "USART RBR contains at least one USART RX error." ] ERRO } impl RXFER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXFER :: NO_ERROR => false , RXFER :: ERRO => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXFER { match value { false => RXFER :: NO_ERROR , true => RXFER :: ERRO , } } # [ doc = "Checks if the value of the field is `NO_ERROR`" ] # [ inline ] pub fn is_no_error ( & self ) -> bool { * self == RXFER :: NO_ERROR } # [ doc = "Checks if the value of the field is `ERRO`" ] # [ inline ] pub fn is_erro ( & self ) -> bool { * self == RXFER :: ERRO } } # [ doc = r" Value of the field" ] pub struct TXERRR { bits : bool , } impl TXERRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Receiver Data Ready:LSR\\[0\\] is set when the RBR holds an unread character and is cleared when the USART RBR FIFO is empty." ] # [ inline ] pub fn rdr ( & self ) -> RDRR { RDRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Overrun Error. The overrun error condition is set as soon as it occurs. A LSR read clears LSR\\[1\\]. LSR\\[1\\] is set when USART RSR has a new character assembled and the USART RBR FIFO is full. In this case, the USART RBR FIFO will not be overwritten and the character in the USART RSR will be lost." ] # [ inline ] pub fn oe ( & self ) -> OER { OER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. A LSR read clears LSR\\[2\\]. Time of parity error detection is dependent on FCR\\[0\\]. Note: A parity error is associated with the character at the top of the USART RBR FIFO." ] # [ inline ] pub fn pe ( & self ) -> PER { PER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. A LSR read clears LSR\\[3\\]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to re-synchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the USART RBR FIFO." ] # [ inline ] pub fn fe ( & self ) -> FER { FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Break Interrupt. When RXD1 is held in the spacing state (all zeros) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). A LSR read clears this status bit. The time of break detection is dependent on FCR\\[0\\]. Note: The break interrupt is associated with the character at the top of the USART RBR FIFO." ] # [ inline ] pub fn bi ( & self ) -> BIR { BIR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty USART THR and is cleared on a THR write." ] # [ inline ] pub fn thre ( & self ) -> THRER { THRER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data." ] # [ inline ] pub fn temt ( & self ) -> TEMTR { TEMTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Error in RX FIFO. LSR\\[7\\] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the USART FIFO." ] # [ inline ] pub fn rxfe ( & self ) -> RXFER { RXFER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Tx Error. In smart card T=0 operation, this bit is set when the smart card has NACKed a transmitted character, one more than the number of times indicated by the TXRETRY field." ] # [ inline ] pub fn txerr ( & self ) -> TXERRR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXERRR { bits } } } } # [ doc = "Modem Status Register." ] pub struct MSR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Modem Status Register." ] pub mod msr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: MSR { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `DCTS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DCTSR { # [ doc = "No change detected on modem input, CTS." ] NO_CHANGE_DETECTED_O , # [ doc = "State change detected on modem input, CTS." ] STATE_CHANGE_DETECTE } impl DCTSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DCTSR :: NO_CHANGE_DETECTED_O => false , DCTSR :: STATE_CHANGE_DETECTE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DCTSR { match value { false => DCTSR :: NO_CHANGE_DETECTED_O , true => DCTSR :: STATE_CHANGE_DETECTE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE_DETECTED_O`" ] # [ inline ] pub fn is_no_change_detected_o ( & self ) -> bool { * self == DCTSR :: NO_CHANGE_DETECTED_O } # [ doc = "Checks if the value of the field is `STATE_CHANGE_DETECTE`" ] # [ inline ] pub fn is_state_change_detecte ( & self ) -> bool { * self == DCTSR :: STATE_CHANGE_DETECTE } } # [ doc = "Possible values of the field `DDSR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DDSRR { # [ doc = "No change detected on modem input, DSR." ] NO_CHANGE_DETECTED_O , # [ doc = "State change detected on modem input, DSR." ] STATE_CHANGE_DETECTE } impl DDSRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DDSRR :: NO_CHANGE_DETECTED_O => false , DDSRR :: STATE_CHANGE_DETECTE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DDSRR { match value { false => DDSRR :: NO_CHANGE_DETECTED_O , true => DDSRR :: STATE_CHANGE_DETECTE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE_DETECTED_O`" ] # [ inline ] pub fn is_no_change_detected_o ( & self ) -> bool { * self == DDSRR :: NO_CHANGE_DETECTED_O } # [ doc = "Checks if the value of the field is `STATE_CHANGE_DETECTE`" ] # [ inline ] pub fn is_state_change_detecte ( & self ) -> bool { * self == DDSRR :: STATE_CHANGE_DETECTE } } # [ doc = "Possible values of the field `TERI`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TERIR { # [ doc = "No change detected on modem input, RI." ] NO_CHANGE_DETECTED_O , # [ doc = "Low-to-high transition detected on RI." ] LOW_TO_HIGH_TRANSITI } impl TERIR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TERIR :: NO_CHANGE_DETECTED_O => false , TERIR :: LOW_TO_HIGH_TRANSITI => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TERIR { match value { false => TERIR :: NO_CHANGE_DETECTED_O , true => TERIR :: LOW_TO_HIGH_TRANSITI , } } # [ doc = "Checks if the value of the field is `NO_CHANGE_DETECTED_O`" ] # [ inline ] pub fn is_no_change_detected_o ( & self ) -> bool { * self == TERIR :: NO_CHANGE_DETECTED_O } # [ doc = "Checks if the value of the field is `LOW_TO_HIGH_TRANSITI`" ] # [ inline ] pub fn is_low_to_high_transiti ( & self ) -> bool { * self == TERIR :: LOW_TO_HIGH_TRANSITI } } # [ doc = "Possible values of the field `DDCD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DDCDR { # [ doc = "No change detected on modem input, DCD." ] NO_CHANGE_DETECTED_O , # [ doc = "State change detected on modem input, DCD." ] STATE_CHANGE_DETECTE } impl DDCDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DDCDR :: NO_CHANGE_DETECTED_O => false , DDCDR :: STATE_CHANGE_DETECTE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DDCDR { match value { false => DDCDR :: NO_CHANGE_DETECTED_O , true => DDCDR :: STATE_CHANGE_DETECTE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE_DETECTED_O`" ] # [ inline ] pub fn is_no_change_detected_o ( & self ) -> bool { * self == DDCDR :: NO_CHANGE_DETECTED_O } # [ doc = "Checks if the value of the field is `STATE_CHANGE_DETECTE`" ] # [ inline ] pub fn is_state_change_detecte ( & self ) -> bool { * self == DDCDR :: STATE_CHANGE_DETECTE } } # [ doc = r" Value of the field" ] pub struct CTSR { bits : bool , } impl CTSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DSRR { bits : bool , } impl DSRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RIR { bits : bool , } impl RIR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DCDR { bits : bool , } impl DCDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Delta CTS. Set upon state change of input CTS. Cleared on an MSR read." ] # [ inline ] pub fn dcts ( & self ) -> DCTSR { DCTSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Delta DSR. Set upon state change of input DSR. Cleared on an MSR read." ] # [ inline ] pub fn ddsr ( & self ) -> DDSRR { DDSRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Trailing Edge RI. Set upon low to high transition of input RI. Cleared on an MSR read." ] # [ inline ] pub fn teri ( & self ) -> TERIR { TERIR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Delta DCD. Set upon state change of input DCD. Cleared on an MSR read." ] # [ inline ] pub fn ddcd ( & self ) -> DDCDR { DDCDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Clear To Send State. Complement of input signal CTS. This bit is connected to MCR\\[1\\] in modem loopback mode." ] # [ inline ] pub fn cts ( & self ) -> CTSR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CTSR { bits } } # [ doc = "Bit 5 - Data Set Ready State. Complement of input signal DSR. This bit is connected to MCR\\[0\\] in modem loopback mode." ] # [ inline ] pub fn dsr ( & self ) -> DSRR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DSRR { bits } } # [ doc = "Bit 6 - Ring Indicator State. Complement of input RI. This bit is connected to MCR\\[2\\] in modem loopback mode." ] # [ inline ] pub fn ri ( & self ) -> RIR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RIR { bits } } # [ doc = "Bit 7 - Data Carrier Detect State. Complement of input DCD. This bit is connected to MCR\\[3\\] in modem loopback mode." ] # [ inline ] pub fn dcd ( & self ) -> DCDR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DCDR { bits } } } } # [ doc = "Scratch Pad Register. Eight-bit temporary storage for software." ] pub struct SCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Scratch Pad Register. Eight-bit temporary storage for software." ] pub mod scr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PADR { bits : u8 , } impl PADR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _PADW < 'a > { w : & 'a mut W , } impl < 'a > _PADW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - A readable, writable byte." ] # [ inline ] pub fn pad ( & self ) -> PADR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; PADR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - A readable, writable byte." ] # [ inline ] pub fn pad ( & mut self ) -> _PADW { _PADW { w : self } } } } # [ doc = "Auto-baud Control Register. Contains controls for the auto-baud feature." ] pub struct ACR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Auto-baud Control Register. Contains controls for the auto-baud feature." ] pub mod acr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ACR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `START`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STARTR { # [ doc = "Auto-baud stop (auto-baud is not running)." ] AUTO_BAUD_STOP_AUTO , # [ doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion." ] AUTO_BAUD_START_AUT } impl STARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { STARTR :: AUTO_BAUD_STOP_AUTO => false , STARTR :: AUTO_BAUD_START_AUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> STARTR { match value { false => STARTR :: AUTO_BAUD_STOP_AUTO , true => STARTR :: AUTO_BAUD_START_AUT , } } # [ doc = "Checks if the value of the field is `AUTO_BAUD_STOP_AUTO`" ] # [ inline ] pub fn is_auto_baud_stop_auto ( & self ) -> bool { * self == STARTR :: AUTO_BAUD_STOP_AUTO } # [ doc = "Checks if the value of the field is `AUTO_BAUD_START_AUT`" ] # [ inline ] pub fn is_auto_baud_start_aut ( & self ) -> bool { * self == STARTR :: AUTO_BAUD_START_AUT } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Mode 0." ] MODE_0_ , # [ doc = "Mode 1." ] MODE_1_ } impl MODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MODER :: MODE_0_ => false , MODER :: MODE_1_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MODER { match value { false => MODER :: MODE_0_ , true => MODER :: MODE_1_ , } } # [ doc = "Checks if the value of the field is `MODE_0_`" ] # [ inline ] pub fn is_mode_0_ ( & self ) -> bool { * self == MODER :: MODE_0_ } # [ doc = "Checks if the value of the field is `MODE_1_`" ] # [ inline ] pub fn is_mode_1_ ( & self ) -> bool { * self == MODER :: MODE_1_ } } # [ doc = "Possible values of the field `AUTORESTART`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum AUTORESTARTR { # [ doc = "No restart" ] NO_RESTART , # [ doc = "Restart in case of time-out (counter restarts at next USART Rx falling edge)" ] RESTART_IN_CASE_OF_T } impl AUTORESTARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { AUTORESTARTR :: NO_RESTART => false , AUTORESTARTR :: RESTART_IN_CASE_OF_T => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> AUTORESTARTR { match value { false => AUTORESTARTR :: NO_RESTART , true => AUTORESTARTR :: RESTART_IN_CASE_OF_T , } } # [ doc = "Checks if the value of the field is `NO_RESTART`" ] # [ inline ] pub fn is_no_restart ( & self ) -> bool { * self == AUTORESTARTR :: NO_RESTART } # [ doc = "Checks if the value of the field is `RESTART_IN_CASE_OF_T`" ] # [ inline ] pub fn is_restart_in_case_of_t ( & self ) -> bool { * self == AUTORESTARTR :: RESTART_IN_CASE_OF_T } } # [ doc = "Possible values of the field `ABEOINTCLR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ABEOINTCLRR { # [ doc = "Writing a 0 has no impact." ] NO_IMPACT , # [ doc = "Writing a 1 will clear the corresponding interrupt in the IIR." ] CLEAR } impl ABEOINTCLRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ABEOINTCLRR :: NO_IMPACT => false , ABEOINTCLRR :: CLEAR => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ABEOINTCLRR { match value { false => ABEOINTCLRR :: NO_IMPACT , true => ABEOINTCLRR :: CLEAR , } } # [ doc = "Checks if the value of the field is `NO_IMPACT`" ] # [ inline ] pub fn is_no_impact ( & self ) -> bool { * self == ABEOINTCLRR :: NO_IMPACT } # [ doc = "Checks if the value of the field is `CLEAR`" ] # [ inline ] pub fn is_clear ( & self ) -> bool { * self == ABEOINTCLRR :: CLEAR } } # [ doc = "Possible values of the field `ABTOINTCLR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ABTOINTCLRR { # [ doc = "Writing a 0 has no impact." ] NO_IMPACT , # [ doc = "Writing a 1 will clear the corresponding interrupt in the IIR." ] CLEAR } impl ABTOINTCLRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ABTOINTCLRR :: NO_IMPACT => false , ABTOINTCLRR :: CLEAR => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ABTOINTCLRR { match value { false => ABTOINTCLRR :: NO_IMPACT , true => ABTOINTCLRR :: CLEAR , } } # [ doc = "Checks if the value of the field is `NO_IMPACT`" ] # [ inline ] pub fn is_no_impact ( & self ) -> bool { * self == ABTOINTCLRR :: NO_IMPACT } # [ doc = "Checks if the value of the field is `CLEAR`" ] # [ inline ] pub fn is_clear ( & self ) -> bool { * self == ABTOINTCLRR :: CLEAR } } # [ doc = "Values that can be written to the field `START`" ] pub enum STARTW { # [ doc = "Auto-baud stop (auto-baud is not running)." ] AUTO_BAUD_STOP_AUTO , # [ doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion." ] AUTO_BAUD_START_AUT } impl STARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { STARTW :: AUTO_BAUD_STOP_AUTO => false , STARTW :: AUTO_BAUD_START_AUT => true } } } # [ doc = r" Proxy" ] pub struct _STARTW < 'a > { w : & 'a mut W , } impl < 'a > _STARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : STARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Auto-baud stop (auto-baud is not running)." ] # [ inline ] pub fn auto_baud_stop_auto ( self ) -> & 'a mut W { self . variant ( STARTW :: AUTO_BAUD_STOP_AUTO ) } # [ doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion." ] # [ inline ] pub fn auto_baud_start_aut ( self ) -> & 'a mut W { self . variant ( STARTW :: AUTO_BAUD_START_AUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Mode 0." ] MODE_0_ , # [ doc = "Mode 1." ] MODE_1_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MODEW :: MODE_0_ => false , MODEW :: MODE_1_ => true } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Mode 0." ] # [ inline ] pub fn mode_0_ ( self ) -> & 'a mut W { self . variant ( MODEW :: MODE_0_ ) } # [ doc = "Mode 1." ] # [ inline ] pub fn mode_1_ ( self ) -> & 'a mut W { self . variant ( MODEW :: MODE_1_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `AUTORESTART`" ] pub enum AUTORESTARTW { # [ doc = "No restart" ] NO_RESTART , # [ doc = "Restart in case of time-out (counter restarts at next USART Rx falling edge)" ] RESTART_IN_CASE_OF_T } impl AUTORESTARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { AUTORESTARTW :: NO_RESTART => false , AUTORESTARTW :: RESTART_IN_CASE_OF_T => true } } } # [ doc = r" Proxy" ] pub struct _AUTORESTARTW < 'a > { w : & 'a mut W , } impl < 'a > _AUTORESTARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : AUTORESTARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No restart" ] # [ inline ] pub fn no_restart ( self ) -> & 'a mut W { self . variant ( AUTORESTARTW :: NO_RESTART ) } # [ doc = "Restart in case of time-out (counter restarts at next USART Rx falling edge)" ] # [ inline ] pub fn restart_in_case_of_t ( self ) -> & 'a mut W { self . variant ( AUTORESTARTW :: RESTART_IN_CASE_OF_T ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ABEOINTCLR`" ] pub enum ABEOINTCLRW { # [ doc = "Writing a 0 has no impact." ] NO_IMPACT , # [ doc = "Writing a 1 will clear the corresponding interrupt in the IIR." ] CLEAR } impl ABEOINTCLRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ABEOINTCLRW :: NO_IMPACT => false , ABEOINTCLRW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ABEOINTCLRW < 'a > { w : & 'a mut W , } impl < 'a > _ABEOINTCLRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ABEOINTCLRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Writing a 0 has no impact." ] # [ inline ] pub fn no_impact ( self ) -> & 'a mut W { self . variant ( ABEOINTCLRW :: NO_IMPACT ) } # [ doc = "Writing a 1 will clear the corresponding interrupt in the IIR." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ABEOINTCLRW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ABTOINTCLR`" ] pub enum ABTOINTCLRW { # [ doc = "Writing a 0 has no impact." ] NO_IMPACT , # [ doc = "Writing a 1 will clear the corresponding interrupt in the IIR." ] CLEAR } impl ABTOINTCLRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ABTOINTCLRW :: NO_IMPACT => false , ABTOINTCLRW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ABTOINTCLRW < 'a > { w : & 'a mut W , } impl < 'a > _ABTOINTCLRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ABTOINTCLRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Writing a 0 has no impact." ] # [ inline ] pub fn no_impact ( self ) -> & 'a mut W { self . variant ( ABTOINTCLRW :: NO_IMPACT ) } # [ doc = "Writing a 1 will clear the corresponding interrupt in the IIR." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ABTOINTCLRW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - This bit is automatically cleared after auto-baud completion." ] # [ inline ] pub fn start ( & self ) -> STARTR { STARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Auto-baud mode select bit." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Start mode" ] # [ inline ] pub fn autorestart ( & self ) -> AUTORESTARTR { AUTORESTARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - End of auto-baud interrupt clear bit (write only accessible)." ] # [ inline ] pub fn abeointclr ( & self ) -> ABEOINTCLRR { ABEOINTCLRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Auto-baud time-out interrupt clear bit (write only accessible)." ] # [ inline ] pub fn abtointclr ( & self ) -> ABTOINTCLRR { ABTOINTCLRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - This bit is automatically cleared after auto-baud completion." ] # [ inline ] pub fn start ( & mut self ) -> _STARTW { _STARTW { w : self } } # [ doc = "Bit 1 - Auto-baud mode select bit." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 2 - Start mode" ] # [ inline ] pub fn autorestart ( & mut self ) -> _AUTORESTARTW { _AUTORESTARTW { w : self } } # [ doc = "Bit 8 - End of auto-baud interrupt clear bit (write only accessible)." ] # [ inline ] pub fn abeointclr ( & mut self ) -> _ABEOINTCLRW { _ABEOINTCLRW { w : self } } # [ doc = "Bit 9 - Auto-baud time-out interrupt clear bit (write only accessible)." ] # [ inline ] pub fn abtointclr ( & mut self ) -> _ABTOINTCLRW { _ABTOINTCLRW { w : self } } } } # [ doc = "IrDA Control Register. Enables and configures the IrDA (remote control) mode." ] pub struct ICR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "IrDA Control Register. Enables and configures the IrDA (remote control) mode." ] pub mod icr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ICR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `IRDAEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRDAENR { # [ doc = "IrDA mode is disabled, USARTn acts as a standard USART." ] IRDA_MODE_IS_DISABLE , # [ doc = "IrDA mode is enabled." ] IRDA_MODE_IS_ENABLED } impl IRDAENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IRDAENR :: IRDA_MODE_IS_DISABLE => false , IRDAENR :: IRDA_MODE_IS_ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IRDAENR { match value { false => IRDAENR :: IRDA_MODE_IS_DISABLE , true => IRDAENR :: IRDA_MODE_IS_ENABLED , } } # [ doc = "Checks if the value of the field is `IRDA_MODE_IS_DISABLE`" ] # [ inline ] pub fn is_irda_mode_is_disable ( & self ) -> bool { * self == IRDAENR :: IRDA_MODE_IS_DISABLE } # [ doc = "Checks if the value of the field is `IRDA_MODE_IS_ENABLED`" ] # [ inline ] pub fn is_irda_mode_is_enabled ( & self ) -> bool { * self == IRDAENR :: IRDA_MODE_IS_ENABLED } } # [ doc = "Possible values of the field `IRDAINV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRDAINVR { # [ doc = "The serial input is not inverted." ] INVERTED , # [ doc = "The serial input is inverted. This has no effect on the serial output." ] NOT_INVERTED } impl IRDAINVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IRDAINVR :: INVERTED => false , IRDAINVR :: NOT_INVERTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IRDAINVR { match value { false => IRDAINVR :: INVERTED , true => IRDAINVR :: NOT_INVERTED , } } # [ doc = "Checks if the value of the field is `INVERTED`" ] # [ inline ] pub fn is_inverted ( & self ) -> bool { * self == IRDAINVR :: INVERTED } # [ doc = "Checks if the value of the field is `NOT_INVERTED`" ] # [ inline ] pub fn is_not_inverted ( & self ) -> bool { * self == IRDAINVR :: NOT_INVERTED } } # [ doc = "Possible values of the field `FIXPULSEEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FIXPULSEENR { # [ doc = "IrDA fixed pulse width mode disabled." ] DISABLED , # [ doc = "IrDA fixed pulse width mode enabled." ] ENABLED } impl FIXPULSEENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FIXPULSEENR :: DISABLED => false , FIXPULSEENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FIXPULSEENR { match value { false => FIXPULSEENR :: DISABLED , true => FIXPULSEENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == FIXPULSEENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == FIXPULSEENR :: ENABLED } } # [ doc = "Possible values of the field `PULSEDIV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PULSEDIVR { # [ doc = "3 / (16 x baud rate)" ] _3_DIV_16_X_BAUD_RATE , # [ doc = "2 x TPCLK" ] _2_X_TPCLK , # [ doc = "4 x TPCLK" ] _4_X_TPCLK , # [ doc = "8 x TPCLK" ] _8_X_TPCLK , # [ doc = "16 x TPCLK" ] _16_X_TPCLK , # [ doc = "32 x TPCLK" ] _32_X_TPCLK , # [ doc = "64 x TPCLK" ] _64_X_TPCLK , # [ doc = "128 x TPCLK" ] _128_X_TPCLK } impl PULSEDIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PULSEDIVR :: _3_DIV_16_X_BAUD_RATE => 0 , PULSEDIVR :: _2_X_TPCLK => 0x01 , PULSEDIVR :: _4_X_TPCLK => 0x02 , PULSEDIVR :: _8_X_TPCLK => 0x03 , PULSEDIVR :: _16_X_TPCLK => 0x04 , PULSEDIVR :: _32_X_TPCLK => 0x05 , PULSEDIVR :: _64_X_TPCLK => 0x06 , PULSEDIVR :: _128_X_TPCLK => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PULSEDIVR { match value { 0 => PULSEDIVR :: _3_DIV_16_X_BAUD_RATE , 1 => PULSEDIVR :: _2_X_TPCLK , 2 => PULSEDIVR :: _4_X_TPCLK , 3 => PULSEDIVR :: _8_X_TPCLK , 4 => PULSEDIVR :: _16_X_TPCLK , 5 => PULSEDIVR :: _32_X_TPCLK , 6 => PULSEDIVR :: _64_X_TPCLK , 7 => PULSEDIVR :: _128_X_TPCLK , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `_3_DIV_16_X_BAUD_RATE`" ] # [ inline ] pub fn is_3_div_16_x_baud_rate ( & self ) -> bool { * self == PULSEDIVR :: _3_DIV_16_X_BAUD_RATE } # [ doc = "Checks if the value of the field is `_2_X_TPCLK`" ] # [ inline ] pub fn is_2_x_tpclk ( & self ) -> bool { * self == PULSEDIVR :: _2_X_TPCLK } # [ doc = "Checks if the value of the field is `_4_X_TPCLK`" ] # [ inline ] pub fn is_4_x_tpclk ( & self ) -> bool { * self == PULSEDIVR :: _4_X_TPCLK } # [ doc = "Checks if the value of the field is `_8_X_TPCLK`" ] # [ inline ] pub fn is_8_x_tpclk ( & self ) -> bool { * self == PULSEDIVR :: _8_X_TPCLK } # [ doc = "Checks if the value of the field is `_16_X_TPCLK`" ] # [ inline ] pub fn is_16_x_tpclk ( & self ) -> bool { * self == PULSEDIVR :: _16_X_TPCLK } # [ doc = "Checks if the value of the field is `_32_X_TPCLK`" ] # [ inline ] pub fn is_32_x_tpclk ( & self ) -> bool { * self == PULSEDIVR :: _32_X_TPCLK } # [ doc = "Checks if the value of the field is `_64_X_TPCLK`" ] # [ inline ] pub fn is_64_x_tpclk ( & self ) -> bool { * self == PULSEDIVR :: _64_X_TPCLK } # [ doc = "Checks if the value of the field is `_128_X_TPCLK`" ] # [ inline ] pub fn is_128_x_tpclk ( & self ) -> bool { * self == PULSEDIVR :: _128_X_TPCLK } } # [ doc = "Values that can be written to the field `IRDAEN`" ] pub enum IRDAENW { # [ doc = "IrDA mode is disabled, USARTn acts as a standard USART." ] IRDA_MODE_IS_DISABLE , # [ doc = "IrDA mode is enabled." ] IRDA_MODE_IS_ENABLED } impl IRDAENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IRDAENW :: IRDA_MODE_IS_DISABLE => false , IRDAENW :: IRDA_MODE_IS_ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _IRDAENW < 'a > { w : & 'a mut W , } impl < 'a > _IRDAENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IRDAENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "IrDA mode is disabled, USARTn acts as a standard USART." ] # [ inline ] pub fn irda_mode_is_disable ( self ) -> & 'a mut W { self . variant ( IRDAENW :: IRDA_MODE_IS_DISABLE ) } # [ doc = "IrDA mode is enabled." ] # [ inline ] pub fn irda_mode_is_enabled ( self ) -> & 'a mut W { self . variant ( IRDAENW :: IRDA_MODE_IS_ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IRDAINV`" ] pub enum IRDAINVW { # [ doc = "The serial input is not inverted." ] INVERTED , # [ doc = "The serial input is inverted. This has no effect on the serial output." ] NOT_INVERTED } impl IRDAINVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IRDAINVW :: INVERTED => false , IRDAINVW :: NOT_INVERTED => true } } } # [ doc = r" Proxy" ] pub struct _IRDAINVW < 'a > { w : & 'a mut W , } impl < 'a > _IRDAINVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IRDAINVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The serial input is not inverted." ] # [ inline ] pub fn inverted ( self ) -> & 'a mut W { self . variant ( IRDAINVW :: INVERTED ) } # [ doc = "The serial input is inverted. This has no effect on the serial output." ] # [ inline ] pub fn not_inverted ( self ) -> & 'a mut W { self . variant ( IRDAINVW :: NOT_INVERTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FIXPULSEEN`" ] pub enum FIXPULSEENW { # [ doc = "IrDA fixed pulse width mode disabled." ] DISABLED , # [ doc = "IrDA fixed pulse width mode enabled." ] ENABLED } impl FIXPULSEENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FIXPULSEENW :: DISABLED => false , FIXPULSEENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _FIXPULSEENW < 'a > { w : & 'a mut W , } impl < 'a > _FIXPULSEENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FIXPULSEENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "IrDA fixed pulse width mode disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( FIXPULSEENW :: DISABLED ) } # [ doc = "IrDA fixed pulse width mode enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( FIXPULSEENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PULSEDIV`" ] pub enum PULSEDIVW { # [ doc = "3 / (16 x baud rate)" ] _3_DIV_16_X_BAUD_RATE , # [ doc = "2 x TPCLK" ] _2_X_TPCLK , # [ doc = "4 x TPCLK" ] _4_X_TPCLK , # [ doc = "8 x TPCLK" ] _8_X_TPCLK , # [ doc = "16 x TPCLK" ] _16_X_TPCLK , # [ doc = "32 x TPCLK" ] _32_X_TPCLK , # [ doc = "64 x TPCLK" ] _64_X_TPCLK , # [ doc = "128 x TPCLK" ] _128_X_TPCLK } impl PULSEDIVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PULSEDIVW :: _3_DIV_16_X_BAUD_RATE => 0 , PULSEDIVW :: _2_X_TPCLK => 1 , PULSEDIVW :: _4_X_TPCLK => 2 , PULSEDIVW :: _8_X_TPCLK => 3 , PULSEDIVW :: _16_X_TPCLK => 4 , PULSEDIVW :: _32_X_TPCLK => 5 , PULSEDIVW :: _64_X_TPCLK => 6 , PULSEDIVW :: _128_X_TPCLK => 7 } } } # [ doc = r" Proxy" ] pub struct _PULSEDIVW < 'a > { w : & 'a mut W , } impl < 'a > _PULSEDIVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PULSEDIVW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "3 / (16 x baud rate)" ] # [ inline ] pub fn _3_div_16_x_baud_rate ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _3_DIV_16_X_BAUD_RATE ) } # [ doc = "2 x TPCLK" ] # [ inline ] pub fn _2_x_tpclk ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _2_X_TPCLK ) } # [ doc = "4 x TPCLK" ] # [ inline ] pub fn _4_x_tpclk ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _4_X_TPCLK ) } # [ doc = "8 x TPCLK" ] # [ inline ] pub fn _8_x_tpclk ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _8_X_TPCLK ) } # [ doc = "16 x TPCLK" ] # [ inline ] pub fn _16_x_tpclk ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _16_X_TPCLK ) } # [ doc = "32 x TPCLK" ] # [ inline ] pub fn _32_x_tpclk ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _32_X_TPCLK ) } # [ doc = "64 x TPCLK" ] # [ inline ] pub fn _64_x_tpclk ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _64_X_TPCLK ) } # [ doc = "128 x TPCLK" ] # [ inline ] pub fn _128_x_tpclk ( self ) -> & 'a mut W { self . variant ( PULSEDIVW :: _128_X_TPCLK ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - IrDA mode enable" ] # [ inline ] pub fn irdaen ( & self ) -> IRDAENR { IRDAENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Serial input inverter" ] # [ inline ] pub fn irdainv ( & self ) -> IRDAINVR { IRDAINVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - IrDA fixed pulse width mode." ] # [ inline ] pub fn fixpulseen ( & self ) -> FIXPULSEENR { FIXPULSEENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 3:5 - Configures the pulse width when FixPulseEn = 1." ] # [ inline ] pub fn pulsediv ( & self ) -> PULSEDIVR { PULSEDIVR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - IrDA mode enable" ] # [ inline ] pub fn irdaen ( & mut self ) -> _IRDAENW { _IRDAENW { w : self } } # [ doc = "Bit 1 - Serial input inverter" ] # [ inline ] pub fn irdainv ( & mut self ) -> _IRDAINVW { _IRDAINVW { w : self } } # [ doc = "Bit 2 - IrDA fixed pulse width mode." ] # [ inline ] pub fn fixpulseen ( & mut self ) -> _FIXPULSEENW { _FIXPULSEENW { w : self } } # [ doc = "Bits 3:5 - Configures the pulse width when FixPulseEn = 1." ] # [ inline ] pub fn pulsediv ( & mut self ) -> _PULSEDIVW { _PULSEDIVW { w : self } } } } # [ doc = "Fractional Divider Register. Generates a clock input for the baud rate divider." ] pub struct FDR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Fractional Divider Register. Generates a clock input for the baud rate divider." ] pub mod fdr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FDR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVADDVALR { bits : u8 , } impl DIVADDVALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct MULVALR { bits : u8 , } impl MULVALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DIVADDVALW < 'a > { w : & 'a mut W , } impl < 'a > _DIVADDVALW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MULVALW < 'a > { w : & 'a mut W , } impl < 'a > _MULVALW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the USART baud rate." ] # [ inline ] pub fn divaddval ( & self ) -> DIVADDVALR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVADDVALR { bits } } # [ doc = "Bits 4:7 - Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for USART to operate properly, regardless of whether the fractional baud rate generator is used or not." ] # [ inline ] pub fn mulval ( & self ) -> MULVALR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; MULVALR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x10 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:3 - Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the USART baud rate." ] # [ inline ] pub fn divaddval ( & mut self ) -> _DIVADDVALW { _DIVADDVALW { w : self } } # [ doc = "Bits 4:7 - Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for USART to operate properly, regardless of whether the fractional baud rate generator is used or not." ] # [ inline ] pub fn mulval ( & mut self ) -> _MULVALW { _MULVALW { w : self } } } } # [ doc = "Oversampling Register. Controls the degree of oversampling during each bit time." ] pub struct OSR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Oversampling Register. Controls the degree of oversampling during each bit time." ] pub mod osr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: OSR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct OSFRACR { bits : u8 , } impl OSFRACR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct OSINTR { bits : u8 , } impl OSINTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct FDINTR { bits : u8 , } impl FDINTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _OSFRACW < 'a > { w : & 'a mut W , } impl < 'a > _OSFRACW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _OSINTW < 'a > { w : & 'a mut W , } impl < 'a > _OSINTW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDINTW < 'a > { w : & 'a mut W , } impl < 'a > _FDINTW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 1:3 - Fractional part of the oversampling ratio, in units of 1/8th of an input clock period. (001 = 0.125, ..., 111 = 0.875)" ] # [ inline ] pub fn osfrac ( & self ) -> OSFRACR { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; OSFRACR { bits } } # [ doc = "Bits 4:7 - Integer part of the oversampling ratio, minus 1. The reset values equate to the normal operating mode of 16 input clocks per bit time." ] # [ inline ] pub fn osint ( & self ) -> OSINTR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; OSINTR { bits } } # [ doc = "Bits 8:14 - In Smart Card mode, these bits act as a more-significant extension of the OSint field, allowing an oversampling ratio up to 2048 as required by ISO7816-3. In Smart Card mode, bits 14:4 should initially be set to 371, yielding an oversampling ratio of 372." ] # [ inline ] pub fn fdint ( & self ) -> FDINTR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; FDINTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xf0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 1:3 - Fractional part of the oversampling ratio, in units of 1/8th of an input clock period. (001 = 0.125, ..., 111 = 0.875)" ] # [ inline ] pub fn osfrac ( & mut self ) -> _OSFRACW { _OSFRACW { w : self } } # [ doc = "Bits 4:7 - Integer part of the oversampling ratio, minus 1. The reset values equate to the normal operating mode of 16 input clocks per bit time." ] # [ inline ] pub fn osint ( & mut self ) -> _OSINTW { _OSINTW { w : self } } # [ doc = "Bits 8:14 - In Smart Card mode, these bits act as a more-significant extension of the OSint field, allowing an oversampling ratio up to 2048 as required by ISO7816-3. In Smart Card mode, bits 14:4 should initially be set to 371, yielding an oversampling ratio of 372." ] # [ inline ] pub fn fdint ( & mut self ) -> _FDINTW { _FDINTW { w : self } } } } # [ doc = "Transmit Enable Register. Turns off USART transmitter for use with software flow control." ] pub struct TER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Transmit Enable Register. Turns off USART transmitter for use with software flow control." ] pub mod ter { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TXENR { bits : bool , } impl TXENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _TXENW < 'a > { w : & 'a mut W , } impl < 'a > _TXENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 7 - When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character." ] # [ inline ] pub fn txen ( & self ) -> TXENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXENR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x80 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 7 - When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character." ] # [ inline ] pub fn txen ( & mut self ) -> _TXENW { _TXENW { w : self } } } } # [ doc = "Half duplex enable register." ] pub struct HDEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Half duplex enable register." ] pub mod hden { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: HDEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `HDEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HDENR { # [ doc = "Disable half-duplex mode." ] DISABLE_HALF_DUPLEX_ , # [ doc = "Enable half-duplex mode." ] ENABLE_HALF_DUPLEX_M } impl HDENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HDENR :: DISABLE_HALF_DUPLEX_ => false , HDENR :: ENABLE_HALF_DUPLEX_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HDENR { match value { false => HDENR :: DISABLE_HALF_DUPLEX_ , true => HDENR :: ENABLE_HALF_DUPLEX_M , } } # [ doc = "Checks if the value of the field is `DISABLE_HALF_DUPLEX_`" ] # [ inline ] pub fn is_disable_half_duplex_ ( & self ) -> bool { * self == HDENR :: DISABLE_HALF_DUPLEX_ } # [ doc = "Checks if the value of the field is `ENABLE_HALF_DUPLEX_M`" ] # [ inline ] pub fn is_enable_half_duplex_m ( & self ) -> bool { * self == HDENR :: ENABLE_HALF_DUPLEX_M } } # [ doc = "Values that can be written to the field `HDEN`" ] pub enum HDENW { # [ doc = "Disable half-duplex mode." ] DISABLE_HALF_DUPLEX_ , # [ doc = "Enable half-duplex mode." ] ENABLE_HALF_DUPLEX_M } impl HDENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HDENW :: DISABLE_HALF_DUPLEX_ => false , HDENW :: ENABLE_HALF_DUPLEX_M => true } } } # [ doc = r" Proxy" ] pub struct _HDENW < 'a > { w : & 'a mut W , } impl < 'a > _HDENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HDENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable half-duplex mode." ] # [ inline ] pub fn disable_half_duplex_ ( self ) -> & 'a mut W { self . variant ( HDENW :: DISABLE_HALF_DUPLEX_ ) } # [ doc = "Enable half-duplex mode." ] # [ inline ] pub fn enable_half_duplex_m ( self ) -> & 'a mut W { self . variant ( HDENW :: ENABLE_HALF_DUPLEX_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Half-duplex mode enable" ] # [ inline ] pub fn hden ( & self ) -> HDENR { HDENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Half-duplex mode enable" ] # [ inline ] pub fn hden ( & mut self ) -> _HDENW { _HDENW { w : self } } } } # [ doc = "Smart Card Interface Control register. Enables and configures the Smart Card Interface feature." ] pub struct SCICTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Smart Card Interface Control register. Enables and configures the Smart Card Interface feature." ] pub mod scictrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SCICTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SCIEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCIENR { # [ doc = "Smart card interface disabled." ] SMART_CARD_INTERFACE , # [ doc = "Asynchronous half duplex smart card interface is enabled." ] ASYNCHRONOUS_HALF_DU } impl SCIENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SCIENR :: SMART_CARD_INTERFACE => false , SCIENR :: ASYNCHRONOUS_HALF_DU => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SCIENR { match value { false => SCIENR :: SMART_CARD_INTERFACE , true => SCIENR :: ASYNCHRONOUS_HALF_DU , } } # [ doc = "Checks if the value of the field is `SMART_CARD_INTERFACE`" ] # [ inline ] pub fn is_smart_card_interface ( & self ) -> bool { * self == SCIENR :: SMART_CARD_INTERFACE } # [ doc = "Checks if the value of the field is `ASYNCHRONOUS_HALF_DU`" ] # [ inline ] pub fn is_asynchronous_half_du ( & self ) -> bool { * self == SCIENR :: ASYNCHRONOUS_HALF_DU } } # [ doc = "Possible values of the field `NACKDIS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NACKDISR { # [ doc = "A NACK response is enabled." ] ENABLED , # [ doc = "A NACK response is inhibited." ] DISABLED } impl NACKDISR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { NACKDISR :: ENABLED => false , NACKDISR :: DISABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> NACKDISR { match value { false => NACKDISR :: ENABLED , true => NACKDISR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == NACKDISR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == NACKDISR :: DISABLED } } # [ doc = "Possible values of the field `PROTSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PROTSELR { # [ doc = "T = 0" ] T_EQ_0 , # [ doc = "T = 1" ] T_EQ_1 } impl PROTSELR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PROTSELR :: T_EQ_0 => false , PROTSELR :: T_EQ_1 => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PROTSELR { match value { false => PROTSELR :: T_EQ_0 , true => PROTSELR :: T_EQ_1 , } } # [ doc = "Checks if the value of the field is `T_EQ_0`" ] # [ inline ] pub fn is_t_eq_0 ( & self ) -> bool { * self == PROTSELR :: T_EQ_0 } # [ doc = "Checks if the value of the field is `T_EQ_1`" ] # [ inline ] pub fn is_t_eq_1 ( & self ) -> bool { * self == PROTSELR :: T_EQ_1 } } # [ doc = r" Value of the field" ] pub struct TXRETRYR { bits : u8 , } impl TXRETRYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct XTRAGUARDR { bits : u8 , } impl XTRAGUARDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Values that can be written to the field `SCIEN`" ] pub enum SCIENW { # [ doc = "Smart card interface disabled." ] SMART_CARD_INTERFACE , # [ doc = "Asynchronous half duplex smart card interface is enabled." ] ASYNCHRONOUS_HALF_DU } impl SCIENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SCIENW :: SMART_CARD_INTERFACE => false , SCIENW :: ASYNCHRONOUS_HALF_DU => true } } } # [ doc = r" Proxy" ] pub struct _SCIENW < 'a > { w : & 'a mut W , } impl < 'a > _SCIENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SCIENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Smart card interface disabled." ] # [ inline ] pub fn smart_card_interface ( self ) -> & 'a mut W { self . variant ( SCIENW :: SMART_CARD_INTERFACE ) } # [ doc = "Asynchronous half duplex smart card interface is enabled." ] # [ inline ] pub fn asynchronous_half_du ( self ) -> & 'a mut W { self . variant ( SCIENW :: ASYNCHRONOUS_HALF_DU ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `NACKDIS`" ] pub enum NACKDISW { # [ doc = "A NACK response is enabled." ] ENABLED , # [ doc = "A NACK response is inhibited." ] DISABLED } impl NACKDISW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { NACKDISW :: ENABLED => false , NACKDISW :: DISABLED => true } } } # [ doc = r" Proxy" ] pub struct _NACKDISW < 'a > { w : & 'a mut W , } impl < 'a > _NACKDISW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : NACKDISW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "A NACK response is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( NACKDISW :: ENABLED ) } # [ doc = "A NACK response is inhibited." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( NACKDISW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PROTSEL`" ] pub enum PROTSELW { # [ doc = "T = 0" ] T_EQ_0 , # [ doc = "T = 1" ] T_EQ_1 } impl PROTSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PROTSELW :: T_EQ_0 => false , PROTSELW :: T_EQ_1 => true } } } # [ doc = r" Proxy" ] pub struct _PROTSELW < 'a > { w : & 'a mut W , } impl < 'a > _PROTSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PROTSELW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "T = 0" ] # [ inline ] pub fn t_eq_0 ( self ) -> & 'a mut W { self . variant ( PROTSELW :: T_EQ_0 ) } # [ doc = "T = 1" ] # [ inline ] pub fn t_eq_1 ( self ) -> & 'a mut W { self . variant ( PROTSELW :: T_EQ_1 ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXRETRYW < 'a > { w : & 'a mut W , } impl < 'a > _TXRETRYW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _XTRAGUARDW < 'a > { w : & 'a mut W , } impl < 'a > _XTRAGUARDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Smart Card Interface Enable." ] # [ inline ] pub fn scien ( & self ) -> SCIENR { SCIENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - NACK response disable. Only applicable in T=0." ] # [ inline ] pub fn nackdis ( & self ) -> NACKDISR { NACKDISR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Protocol selection as defined in the ISO7816-3 standard." ] # [ inline ] pub fn protsel ( & self ) -> PROTSELR { PROTSELR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 5:7 - When the protocol selection T bit (above) is 0, the field controls the maximum number of retransmissions that the USART will attempt if the remote device signals NACK. When NACK has occurred this number of times plus one, the Tx Error bit in the LSR is set, an interrupt is requested if enabled, and the USART is locked until the FIFO is cleared." ] # [ inline ] pub fn txretry ( & self ) -> TXRETRYR { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; TXRETRYR { bits } } # [ doc = "Bits 8:15 - When the protocol selection T bit (above) is 0, this field indicates the number of bit times (ETUs) by which the guard time after a character transmitted by the USART should exceed the nominal 2 bit times. 0xFF in this field may indicate that there is just a single bit after a character and 11 bit times/character" ] # [ inline ] pub fn xtraguard ( & self ) -> XTRAGUARDR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; XTRAGUARDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Smart Card Interface Enable." ] # [ inline ] pub fn scien ( & mut self ) -> _SCIENW { _SCIENW { w : self } } # [ doc = "Bit 1 - NACK response disable. Only applicable in T=0." ] # [ inline ] pub fn nackdis ( & mut self ) -> _NACKDISW { _NACKDISW { w : self } } # [ doc = "Bit 2 - Protocol selection as defined in the ISO7816-3 standard." ] # [ inline ] pub fn protsel ( & mut self ) -> _PROTSELW { _PROTSELW { w : self } } # [ doc = "Bits 5:7 - When the protocol selection T bit (above) is 0, the field controls the maximum number of retransmissions that the USART will attempt if the remote device signals NACK. When NACK has occurred this number of times plus one, the Tx Error bit in the LSR is set, an interrupt is requested if enabled, and the USART is locked until the FIFO is cleared." ] # [ inline ] pub fn txretry ( & mut self ) -> _TXRETRYW { _TXRETRYW { w : self } } # [ doc = "Bits 8:15 - When the protocol selection T bit (above) is 0, this field indicates the number of bit times (ETUs) by which the guard time after a character transmitted by the USART should exceed the nominal 2 bit times. 0xFF in this field may indicate that there is just a single bit after a character and 11 bit times/character" ] # [ inline ] pub fn xtraguard ( & mut self ) -> _XTRAGUARDW { _XTRAGUARDW { w : self } } } } # [ doc = "RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes." ] pub struct RS485CTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes." ] pub mod rs485ctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RS485CTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `NMMEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMMENR { # [ doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled." ] DISABLED , # [ doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt." ] ENABLED } impl NMMENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { NMMENR :: DISABLED => false , NMMENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> NMMENR { match value { false => NMMENR :: DISABLED , true => NMMENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == NMMENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == NMMENR :: ENABLED } } # [ doc = "Possible values of the field `RXDIS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXDISR { # [ doc = "The receiver is enabled." ] THE_RECEIVER_IS_ENAB , # [ doc = "The receiver is disabled." ] THE_RECEIVER_IS_DISA } impl RXDISR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXDISR :: THE_RECEIVER_IS_ENAB => false , RXDISR :: THE_RECEIVER_IS_DISA => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXDISR { match value { false => RXDISR :: THE_RECEIVER_IS_ENAB , true => RXDISR :: THE_RECEIVER_IS_DISA , } } # [ doc = "Checks if the value of the field is `THE_RECEIVER_IS_ENAB`" ] # [ inline ] pub fn is_the_receiver_is_enab ( & self ) -> bool { * self == RXDISR :: THE_RECEIVER_IS_ENAB } # [ doc = "Checks if the value of the field is `THE_RECEIVER_IS_DISA`" ] # [ inline ] pub fn is_the_receiver_is_disa ( & self ) -> bool { * self == RXDISR :: THE_RECEIVER_IS_DISA } } # [ doc = "Possible values of the field `AADEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum AADENR { # [ doc = "Auto Address Detect (AAD) is disabled." ] AUTO_ADDRESS_DETECT_DISABLE , # [ doc = "Auto Address Detect (AAD) is enabled." ] AUTO_ADDRESS_DETECT_ENABLE } impl AADENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { AADENR :: AUTO_ADDRESS_DETECT_DISABLE => false , AADENR :: AUTO_ADDRESS_DETECT_ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> AADENR { match value { false => AADENR :: AUTO_ADDRESS_DETECT_DISABLE , true => AADENR :: AUTO_ADDRESS_DETECT_ENABLE , } } # [ doc = "Checks if the value of the field is `AUTO_ADDRESS_DETECT_DISABLE`" ] # [ inline ] pub fn is_auto_address_detect_disable ( & self ) -> bool { * self == AADENR :: AUTO_ADDRESS_DETECT_DISABLE } # [ doc = "Checks if the value of the field is `AUTO_ADDRESS_DETECT_ENABLE`" ] # [ inline ] pub fn is_auto_address_detect_enable ( & self ) -> bool { * self == AADENR :: AUTO_ADDRESS_DETECT_ENABLE } } # [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELR { # [ doc = "If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control." ] RTS , # [ doc = "If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control." ] DTR } impl SELR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SELR :: RTS => false , SELR :: DTR => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SELR { match value { false => SELR :: RTS , true => SELR :: DTR , } } # [ doc = "Checks if the value of the field is `RTS`" ] # [ inline ] pub fn is_rts ( & self ) -> bool { * self == SELR :: RTS } # [ doc = "Checks if the value of the field is `DTR`" ] # [ inline ] pub fn is_dtr ( & self ) -> bool { * self == SELR :: DTR } } # [ doc = "Possible values of the field `DCTRL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DCTRLR { # [ doc = "Disable Auto Direction Control." ] DISABLE_AUTO_DIRECTI , # [ doc = "Enable Auto Direction Control." ] ENABLE_AUTO_DIRECTIO } impl DCTRLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DCTRLR :: DISABLE_AUTO_DIRECTI => false , DCTRLR :: ENABLE_AUTO_DIRECTIO => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DCTRLR { match value { false => DCTRLR :: DISABLE_AUTO_DIRECTI , true => DCTRLR :: ENABLE_AUTO_DIRECTIO , } } # [ doc = "Checks if the value of the field is `DISABLE_AUTO_DIRECTI`" ] # [ inline ] pub fn is_disable_auto_directi ( & self ) -> bool { * self == DCTRLR :: DISABLE_AUTO_DIRECTI } # [ doc = "Checks if the value of the field is `ENABLE_AUTO_DIRECTIO`" ] # [ inline ] pub fn is_enable_auto_directio ( & self ) -> bool { * self == DCTRLR :: ENABLE_AUTO_DIRECTIO } } # [ doc = "Possible values of the field `OINV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OINVR { # [ doc = "The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted." ] LOW , # [ doc = "The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted." ] HIGH } impl OINVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OINVR :: LOW => false , OINVR :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OINVR { match value { false => OINVR :: LOW , true => OINVR :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == OINVR :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == OINVR :: HIGH } } # [ doc = "Values that can be written to the field `NMMEN`" ] pub enum NMMENW { # [ doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled." ] DISABLED , # [ doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt." ] ENABLED } impl NMMENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { NMMENW :: DISABLED => false , NMMENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _NMMENW < 'a > { w : & 'a mut W , } impl < 'a > _NMMENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : NMMENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( NMMENW :: DISABLED ) } # [ doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( NMMENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RXDIS`" ] pub enum RXDISW { # [ doc = "The receiver is enabled." ] THE_RECEIVER_IS_ENAB , # [ doc = "The receiver is disabled." ] THE_RECEIVER_IS_DISA } impl RXDISW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXDISW :: THE_RECEIVER_IS_ENAB => false , RXDISW :: THE_RECEIVER_IS_DISA => true } } } # [ doc = r" Proxy" ] pub struct _RXDISW < 'a > { w : & 'a mut W , } impl < 'a > _RXDISW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXDISW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The receiver is enabled." ] # [ inline ] pub fn the_receiver_is_enab ( self ) -> & 'a mut W { self . variant ( RXDISW :: THE_RECEIVER_IS_ENAB ) } # [ doc = "The receiver is disabled." ] # [ inline ] pub fn the_receiver_is_disa ( self ) -> & 'a mut W { self . variant ( RXDISW :: THE_RECEIVER_IS_DISA ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `AADEN`" ] pub enum AADENW { # [ doc = "Auto Address Detect (AAD) is disabled." ] AUTO_ADDRESS_DETECT_DISABLE , # [ doc = "Auto Address Detect (AAD) is enabled." ] AUTO_ADDRESS_DETECT_ENABLE } impl AADENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { AADENW :: AUTO_ADDRESS_DETECT_DISABLE => false , AADENW :: AUTO_ADDRESS_DETECT_ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _AADENW < 'a > { w : & 'a mut W , } impl < 'a > _AADENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : AADENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Auto Address Detect (AAD) is disabled." ] # [ inline ] pub fn auto_address_detect_disable ( self ) -> & 'a mut W { self . variant ( AADENW :: AUTO_ADDRESS_DETECT_DISABLE ) } # [ doc = "Auto Address Detect (AAD) is enabled." ] # [ inline ] pub fn auto_address_detect_enable ( self ) -> & 'a mut W { self . variant ( AADENW :: AUTO_ADDRESS_DETECT_ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SEL`" ] pub enum SELW { # [ doc = "If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control." ] RTS , # [ doc = "If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control." ] DTR } impl SELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SELW :: RTS => false , SELW :: DTR => true } } } # [ doc = r" Proxy" ] pub struct _SELW < 'a > { w : & 'a mut W , } impl < 'a > _SELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control." ] # [ inline ] pub fn rts ( self ) -> & 'a mut W { self . variant ( SELW :: RTS ) } # [ doc = "If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control." ] # [ inline ] pub fn dtr ( self ) -> & 'a mut W { self . variant ( SELW :: DTR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DCTRL`" ] pub enum DCTRLW { # [ doc = "Disable Auto Direction Control." ] DISABLE_AUTO_DIRECTI , # [ doc = "Enable Auto Direction Control." ] ENABLE_AUTO_DIRECTIO } impl DCTRLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DCTRLW :: DISABLE_AUTO_DIRECTI => false , DCTRLW :: ENABLE_AUTO_DIRECTIO => true } } } # [ doc = r" Proxy" ] pub struct _DCTRLW < 'a > { w : & 'a mut W , } impl < 'a > _DCTRLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DCTRLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable Auto Direction Control." ] # [ inline ] pub fn disable_auto_directi ( self ) -> & 'a mut W { self . variant ( DCTRLW :: DISABLE_AUTO_DIRECTI ) } # [ doc = "Enable Auto Direction Control." ] # [ inline ] pub fn enable_auto_directio ( self ) -> & 'a mut W { self . variant ( DCTRLW :: ENABLE_AUTO_DIRECTIO ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OINV`" ] pub enum OINVW { # [ doc = "The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted." ] LOW , # [ doc = "The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted." ] HIGH } impl OINVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OINVW :: LOW => false , OINVW :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _OINVW < 'a > { w : & 'a mut W , } impl < 'a > _OINVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OINVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( OINVW :: LOW ) } # [ doc = "The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( OINVW :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - NMM enable." ] # [ inline ] pub fn nmmen ( & self ) -> NMMENR { NMMENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Receiver enable." ] # [ inline ] pub fn rxdis ( & self ) -> RXDISR { RXDISR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - AAD enable." ] # [ inline ] pub fn aaden ( & self ) -> AADENR { AADENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Select direction control pin" ] # [ inline ] pub fn sel ( & self ) -> SELR { SELR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Auto direction control enable." ] # [ inline ] pub fn dctrl ( & self ) -> DCTRLR { DCTRLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Polarity control. This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin." ] # [ inline ] pub fn oinv ( & self ) -> OINVR { OINVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - NMM enable." ] # [ inline ] pub fn nmmen ( & mut self ) -> _NMMENW { _NMMENW { w : self } } # [ doc = "Bit 1 - Receiver enable." ] # [ inline ] pub fn rxdis ( & mut self ) -> _RXDISW { _RXDISW { w : self } } # [ doc = "Bit 2 - AAD enable." ] # [ inline ] pub fn aaden ( & mut self ) -> _AADENW { _AADENW { w : self } } # [ doc = "Bit 3 - Select direction control pin" ] # [ inline ] pub fn sel ( & mut self ) -> _SELW { _SELW { w : self } } # [ doc = "Bit 4 - Auto direction control enable." ] # [ inline ] pub fn dctrl ( & mut self ) -> _DCTRLW { _DCTRLW { w : self } } # [ doc = "Bit 5 - Polarity control. This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin." ] # [ inline ] pub fn oinv ( & mut self ) -> _OINVW { _OINVW { w : self } } } } # [ doc = "RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode." ] pub struct RS485ADRMATCH { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode." ] pub mod rs485adrmatch { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RS485ADRMATCH { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ADRMATCHR { bits : u8 , } impl ADRMATCHR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _ADRMATCHW < 'a > { w : & 'a mut W , } impl < 'a > _ADRMATCHW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Contains the address match value." ] # [ inline ] pub fn adrmatch ( & self ) -> ADRMATCHR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ADRMATCHR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Contains the address match value." ] # [ inline ] pub fn adrmatch ( & mut self ) -> _ADRMATCHW { _ADRMATCHW { w : self } } } } # [ doc = "RS-485/EIA-485 direction control delay." ] pub struct RS485DLY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RS-485/EIA-485 direction control delay." ] pub mod rs485dly { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RS485DLY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DLYR { bits : u8 , } impl DLYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DLYW < 'a > { w : & 'a mut W , } impl < 'a > _DLYW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter." ] # [ inline ] pub fn dly ( & self ) -> DLYR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DLYR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter." ] # [ inline ] pub fn dly ( & mut self ) -> _DLYW { _DLYW { w : self } } } } # [ doc = "Synchronous mode control register." ] pub struct SYNCCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Synchronous mode control register." ] pub mod syncctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYNCCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SYNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYNCR { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl SYNCR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SYNCR :: DISABLED => false , SYNCR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SYNCR { match value { false => SYNCR :: DISABLED , true => SYNCR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == SYNCR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == SYNCR :: ENABLED } } # [ doc = "Possible values of the field `CSRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CSRCR { # [ doc = "Synchronous slave mode (SCLK in)" ] SYNCHRONOUS_SLAVE_MO , # [ doc = "Synchronous master mode (SCLK out)" ] SYNCHRONOUS_MASTER_M } impl CSRCR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CSRCR :: SYNCHRONOUS_SLAVE_MO => false , CSRCR :: SYNCHRONOUS_MASTER_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CSRCR { match value { false => CSRCR :: SYNCHRONOUS_SLAVE_MO , true => CSRCR :: SYNCHRONOUS_MASTER_M , } } # [ doc = "Checks if the value of the field is `SYNCHRONOUS_SLAVE_MO`" ] # [ inline ] pub fn is_synchronous_slave_mo ( & self ) -> bool { * self == CSRCR :: SYNCHRONOUS_SLAVE_MO } # [ doc = "Checks if the value of the field is `SYNCHRONOUS_MASTER_M`" ] # [ inline ] pub fn is_synchronous_master_m ( & self ) -> bool { * self == CSRCR :: SYNCHRONOUS_MASTER_M } } # [ doc = "Possible values of the field `FES`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FESR { # [ doc = "RxD is sampled on the rising edge of SCLK " ] RISING , # [ doc = "RxD is sampled on the falling edge of SCLK" ] FALLING } impl FESR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FESR :: RISING => false , FESR :: FALLING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FESR { match value { false => FESR :: RISING , true => FESR :: FALLING , } } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ] pub fn is_rising ( & self ) -> bool { * self == FESR :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ] pub fn is_falling ( & self ) -> bool { * self == FESR :: FALLING } } # [ doc = "Possible values of the field `TSBYPASS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TSBYPASSR { # [ doc = "The input clock is synchronized prior to being used in clock edge detection logic" ] SYNC , # [ doc = "The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability." ] NOSYNC } impl TSBYPASSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TSBYPASSR :: SYNC => false , TSBYPASSR :: NOSYNC => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TSBYPASSR { match value { false => TSBYPASSR :: SYNC , true => TSBYPASSR :: NOSYNC , } } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ] pub fn is_sync ( & self ) -> bool { * self == TSBYPASSR :: SYNC } # [ doc = "Checks if the value of the field is `NOSYNC`" ] # [ inline ] pub fn is_nosync ( & self ) -> bool { * self == TSBYPASSR :: NOSYNC } } # [ doc = "Possible values of the field `CSCEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CSCENR { # [ doc = "SCLK cycles only when characters are being sent on TxD" ] SCLK_CYCLES_ONLY_WHE , # [ doc = "SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)" ] SCLK_RUNS_CONTINUOUS } impl CSCENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CSCENR :: SCLK_CYCLES_ONLY_WHE => false , CSCENR :: SCLK_RUNS_CONTINUOUS => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CSCENR { match value { false => CSCENR :: SCLK_CYCLES_ONLY_WHE , true => CSCENR :: SCLK_RUNS_CONTINUOUS , } } # [ doc = "Checks if the value of the field is `SCLK_CYCLES_ONLY_WHE`" ] # [ inline ] pub fn is_sclk_cycles_only_whe ( & self ) -> bool { * self == CSCENR :: SCLK_CYCLES_ONLY_WHE } # [ doc = "Checks if the value of the field is `SCLK_RUNS_CONTINUOUS`" ] # [ inline ] pub fn is_sclk_runs_continuous ( & self ) -> bool { * self == CSCENR :: SCLK_RUNS_CONTINUOUS } } # [ doc = "Possible values of the field `SSDIS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SSDISR { # [ doc = "Send start and stop bits as in other modes." ] SEND_START_AND_STOP_ , # [ doc = "Do not send start/stop bits." ] DO_NOT_SEND_STARTSTOP } impl SSDISR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SSDISR :: SEND_START_AND_STOP_ => false , SSDISR :: DO_NOT_SEND_STARTSTOP => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SSDISR { match value { false => SSDISR :: SEND_START_AND_STOP_ , true => SSDISR :: DO_NOT_SEND_STARTSTOP , } } # [ doc = "Checks if the value of the field is `SEND_START_AND_STOP_`" ] # [ inline ] pub fn is_send_start_and_stop_ ( & self ) -> bool { * self == SSDISR :: SEND_START_AND_STOP_ } # [ doc = "Checks if the value of the field is `DO_NOT_SEND_STARTSTOP`" ] # [ inline ] pub fn is_do_not_send_startstop ( & self ) -> bool { * self == SSDISR :: DO_NOT_SEND_STARTSTOP } } # [ doc = "Possible values of the field `CCCLR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCCLRR { # [ doc = "CSCEN is under software control." ] CSCEN_IS_UNDER_SOFTW , # [ doc = "Hardware clears CSCEN after each character is received." ] HARDWARE_CLEARS_CSCE } impl CCCLRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CCCLRR :: CSCEN_IS_UNDER_SOFTW => false , CCCLRR :: HARDWARE_CLEARS_CSCE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CCCLRR { match value { false => CCCLRR :: CSCEN_IS_UNDER_SOFTW , true => CCCLRR :: HARDWARE_CLEARS_CSCE , } } # [ doc = "Checks if the value of the field is `CSCEN_IS_UNDER_SOFTW`" ] # [ inline ] pub fn is_cscen_is_under_softw ( & self ) -> bool { * self == CCCLRR :: CSCEN_IS_UNDER_SOFTW } # [ doc = "Checks if the value of the field is `HARDWARE_CLEARS_CSCE`" ] # [ inline ] pub fn is_hardware_clears_csce ( & self ) -> bool { * self == CCCLRR :: HARDWARE_CLEARS_CSCE } } # [ doc = "Values that can be written to the field `SYNC`" ] pub enum SYNCW { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl SYNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYNCW :: DISABLED => false , SYNCW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _SYNCW < 'a > { w : & 'a mut W , } impl < 'a > _SYNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYNCW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( SYNCW :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( SYNCW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CSRC`" ] pub enum CSRCW { # [ doc = "Synchronous slave mode (SCLK in)" ] SYNCHRONOUS_SLAVE_MO , # [ doc = "Synchronous master mode (SCLK out)" ] SYNCHRONOUS_MASTER_M } impl CSRCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CSRCW :: SYNCHRONOUS_SLAVE_MO => false , CSRCW :: SYNCHRONOUS_MASTER_M => true } } } # [ doc = r" Proxy" ] pub struct _CSRCW < 'a > { w : & 'a mut W , } impl < 'a > _CSRCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CSRCW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Synchronous slave mode (SCLK in)" ] # [ inline ] pub fn synchronous_slave_mo ( self ) -> & 'a mut W { self . variant ( CSRCW :: SYNCHRONOUS_SLAVE_MO ) } # [ doc = "Synchronous master mode (SCLK out)" ] # [ inline ] pub fn synchronous_master_m ( self ) -> & 'a mut W { self . variant ( CSRCW :: SYNCHRONOUS_MASTER_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FES`" ] pub enum FESW { # [ doc = "RxD is sampled on the rising edge of SCLK " ] RISING , # [ doc = "RxD is sampled on the falling edge of SCLK" ] FALLING } impl FESW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FESW :: RISING => false , FESW :: FALLING => true } } } # [ doc = r" Proxy" ] pub struct _FESW < 'a > { w : & 'a mut W , } impl < 'a > _FESW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FESW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RxD is sampled on the rising edge of SCLK" ] # [ inline ] pub fn rising ( self ) -> & 'a mut W { self . variant ( FESW :: RISING ) } # [ doc = "RxD is sampled on the falling edge of SCLK" ] # [ inline ] pub fn falling ( self ) -> & 'a mut W { self . variant ( FESW :: FALLING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `TSBYPASS`" ] pub enum TSBYPASSW { # [ doc = "The input clock is synchronized prior to being used in clock edge detection logic" ] SYNC , # [ doc = "The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability." ] NOSYNC } impl TSBYPASSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TSBYPASSW :: SYNC => false , TSBYPASSW :: NOSYNC => true } } } # [ doc = r" Proxy" ] pub struct _TSBYPASSW < 'a > { w : & 'a mut W , } impl < 'a > _TSBYPASSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TSBYPASSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The input clock is synchronized prior to being used in clock edge detection logic" ] # [ inline ] pub fn sync ( self ) -> & 'a mut W { self . variant ( TSBYPASSW :: SYNC ) } # [ doc = "The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability." ] # [ inline ] pub fn nosync ( self ) -> & 'a mut W { self . variant ( TSBYPASSW :: NOSYNC ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CSCEN`" ] pub enum CSCENW { # [ doc = "SCLK cycles only when characters are being sent on TxD" ] SCLK_CYCLES_ONLY_WHE , # [ doc = "SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)" ] SCLK_RUNS_CONTINUOUS } impl CSCENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CSCENW :: SCLK_CYCLES_ONLY_WHE => false , CSCENW :: SCLK_RUNS_CONTINUOUS => true } } } # [ doc = r" Proxy" ] pub struct _CSCENW < 'a > { w : & 'a mut W , } impl < 'a > _CSCENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CSCENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "SCLK cycles only when characters are being sent on TxD" ] # [ inline ] pub fn sclk_cycles_only_whe ( self ) -> & 'a mut W { self . variant ( CSCENW :: SCLK_CYCLES_ONLY_WHE ) } # [ doc = "SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)" ] # [ inline ] pub fn sclk_runs_continuous ( self ) -> & 'a mut W { self . variant ( CSCENW :: SCLK_RUNS_CONTINUOUS ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SSDIS`" ] pub enum SSDISW { # [ doc = "Send start and stop bits as in other modes." ] SEND_START_AND_STOP_ , # [ doc = "Do not send start/stop bits." ] DO_NOT_SEND_STARTSTOP } impl SSDISW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SSDISW :: SEND_START_AND_STOP_ => false , SSDISW :: DO_NOT_SEND_STARTSTOP => true } } } # [ doc = r" Proxy" ] pub struct _SSDISW < 'a > { w : & 'a mut W , } impl < 'a > _SSDISW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SSDISW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Send start and stop bits as in other modes." ] # [ inline ] pub fn send_start_and_stop_ ( self ) -> & 'a mut W { self . variant ( SSDISW :: SEND_START_AND_STOP_ ) } # [ doc = "Do not send start/stop bits." ] # [ inline ] pub fn do_not_send_startstop ( self ) -> & 'a mut W { self . variant ( SSDISW :: DO_NOT_SEND_STARTSTOP ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CCCLR`" ] pub enum CCCLRW { # [ doc = "CSCEN is under software control." ] CSCEN_IS_UNDER_SOFTW , # [ doc = "Hardware clears CSCEN after each character is received." ] HARDWARE_CLEARS_CSCE } impl CCCLRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CCCLRW :: CSCEN_IS_UNDER_SOFTW => false , CCCLRW :: HARDWARE_CLEARS_CSCE => true } } } # [ doc = r" Proxy" ] pub struct _CCCLRW < 'a > { w : & 'a mut W , } impl < 'a > _CCCLRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CCCLRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CSCEN is under software control." ] # [ inline ] pub fn cscen_is_under_softw ( self ) -> & 'a mut W { self . variant ( CCCLRW :: CSCEN_IS_UNDER_SOFTW ) } # [ doc = "Hardware clears CSCEN after each character is received." ] # [ inline ] pub fn hardware_clears_csce ( self ) -> & 'a mut W { self . variant ( CCCLRW :: HARDWARE_CLEARS_CSCE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enables synchronous mode." ] # [ inline ] pub fn sync ( & self ) -> SYNCR { SYNCR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Clock source select." ] # [ inline ] pub fn csrc ( & self ) -> CSRCR { CSRCR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Falling edge sampling." ] # [ inline ] pub fn fes ( & self ) -> FESR { FESR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Transmit synchronization bypass in synchronous slave mode." ] # [ inline ] pub fn tsbypass ( & self ) -> TSBYPASSR { TSBYPASSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Continuous master clock enable (used only when CSRC is 1)" ] # [ inline ] pub fn cscen ( & self ) -> CSCENR { CSCENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Start/stop bits" ] # [ inline ] pub fn ssdis ( & self ) -> SSDISR { SSDISR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Continuous clock clear" ] # [ inline ] pub fn ccclr ( & self ) -> CCCLRR { CCCLRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enables synchronous mode." ] # [ inline ] pub fn sync ( & mut self ) -> _SYNCW { _SYNCW { w : self } } # [ doc = "Bit 1 - Clock source select." ] # [ inline ] pub fn csrc ( & mut self ) -> _CSRCW { _CSRCW { w : self } } # [ doc = "Bit 2 - Falling edge sampling." ] # [ inline ] pub fn fes ( & mut self ) -> _FESW { _FESW { w : self } } # [ doc = "Bit 3 - Transmit synchronization bypass in synchronous slave mode." ] # [ inline ] pub fn tsbypass ( & mut self ) -> _TSBYPASSW { _TSBYPASSW { w : self } } # [ doc = "Bit 4 - Continuous master clock enable (used only when CSRC is 1)" ] # [ inline ] pub fn cscen ( & mut self ) -> _CSCENW { _CSCENW { w : self } } # [ doc = "Bit 5 - Start/stop bits" ] # [ inline ] pub fn ssdis ( & mut self ) -> _SSDISW { _SSDISW { w : self } } # [ doc = "Bit 6 - Continuous clock clear" ] # [ inline ] pub fn ccclr ( & mut self ) -> _CCCLRW { _CCCLRW { w : self } } } } } # [ doc = "16-bit counter/timers CT16B0" ] pub struct CT16B0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for CT16B0 { } impl CT16B0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ct16b0 :: RegisterBlock { 0x4000_c000 as * const _ } } impl Deref for CT16B0 { type Target = ct16b0 :: RegisterBlock ; fn deref ( & self ) -> & ct16b0 :: RegisterBlock { unsafe { & * CT16B0 :: ptr ( ) } } } # [ doc = "16-bit counter/timers CT16B0" ] pub mod ct16b0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub ir : IR , # [ doc = "0x04 - Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub tcr : TCR , # [ doc = "0x08 - Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub tc : TC , # [ doc = "0x0c - Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub pr : PR , # [ doc = "0x10 - Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub pc : PC , # [ doc = "0x14 - Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mcr : MCR , # [ doc = "0x18 - Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mr : [ MR ; 4 ] , # [ doc = "0x28 - Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub ccr : CCR , # [ doc = "0x2c - Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input." ] pub cr0 : CR0 , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0x34 - Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT16B0_CAP1 input." ] pub cr1 : CR1 , _reserved1 : [ u8 ; 4usize ] , # [ doc = "0x3c - External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub emr : EMR , _reserved2 : [ u8 ; 48usize ] , # [ doc = "0x70 - Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub ctcr : CTCR , # [ doc = "0x74 - PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub pwmc : PWMC , } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub struct IR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub mod ir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MR0INTR { bits : bool , } impl MR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR1INTR { bits : bool , } impl MR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR2INTR { bits : bool , } impl MR2INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR3INTR { bits : bool , } impl MR3INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR0INTR { bits : bool , } impl CR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR1INTR { bits : bool , } impl CR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _MR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR2INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR2INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR3INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR3INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & self ) -> MR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR0INTR { bits } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & self ) -> MR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR1INTR { bits } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & self ) -> MR2INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR2INTR { bits } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & self ) -> MR3INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR3INTR { bits } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & self ) -> CR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR0INTR { bits } } # [ doc = "Bit 6 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & self ) -> CR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR1INTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & mut self ) -> _MR0INTW { _MR0INTW { w : self } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & mut self ) -> _MR1INTW { _MR1INTW { w : self } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & mut self ) -> _MR2INTW { _MR2INTW { w : self } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & mut self ) -> _MR3INTW { _MR3INTW { w : self } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & mut self ) -> _CR0INTW { _CR0INTW { w : self } } # [ doc = "Bit 6 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & mut self ) -> _CR1INTW { _CR1INTW { w : self } } } } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub struct TCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub mod tcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CENR { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CENR :: THE_COUNTERS_ARE_DIS => false , CENR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CENR { match value { false => CENR :: THE_COUNTERS_ARE_DIS , true => CENR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `THE_COUNTERS_ARE_DIS`" ] # [ inline ] pub fn is_the_counters_are_dis ( & self ) -> bool { * self == CENR :: THE_COUNTERS_ARE_DIS } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CENR :: THE_TIMER_COUNTER_AN } } # [ doc = "Possible values of the field `CRST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRSTR { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CRSTR :: DO_NOTHING_ => false , CRSTR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CRSTR { match value { false => CRSTR :: DO_NOTHING_ , true => CRSTR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == CRSTR :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CRSTR :: THE_TIMER_COUNTER_AN } } # [ doc = "Values that can be written to the field `CEN`" ] pub enum CENW { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CENW :: THE_COUNTERS_ARE_DIS => false , CENW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CENW < 'a > { w : & 'a mut W , } impl < 'a > _CENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The counters are disabled." ] # [ inline ] pub fn the_counters_are_dis ( self ) -> & 'a mut W { self . variant ( CENW :: THE_COUNTERS_ARE_DIS ) } # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CENW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CRST`" ] pub enum CRSTW { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CRSTW :: DO_NOTHING_ => false , CRSTW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CRSTW < 'a > { w : & 'a mut W , } impl < 'a > _CRSTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CRSTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Do nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( CRSTW :: DO_NOTHING_ ) } # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CRSTW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & self ) -> CENR { CENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & self ) -> CRSTR { CRSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & mut self ) -> _CENW { _CENW { w : self } } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & mut self ) -> _CRSTW { _CRSTW { w : self } } } } # [ doc = "Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub struct TC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub mod tc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TCR { bits : u16 , } impl TCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _TCW < 'a > { w : & 'a mut W , } impl < 'a > _TCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter value." ] # [ inline ] pub fn tc ( & self ) -> TCR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; TCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Timer counter value." ] # [ inline ] pub fn tc ( & mut self ) -> _TCW { _TCW { w : self } } } } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub struct PR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub mod pr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCVALR { bits : u16 , } impl PCVALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCVALW < 'a > { w : & 'a mut W , } impl < 'a > _PCVALW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Prescale value." ] # [ inline ] pub fn pcval ( & self ) -> PCVALR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; PCVALR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Prescale value." ] # [ inline ] pub fn pcval ( & mut self ) -> _PCVALW { _PCVALW { w : self } } } } # [ doc = "Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub struct PC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub mod pc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCR { bits : u16 , } impl PCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCW < 'a > { w : & 'a mut W , } impl < 'a > _PCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Prescale counter value." ] # [ inline ] pub fn pc ( & self ) -> PCR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; PCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Prescale counter value." ] # [ inline ] pub fn pc ( & mut self ) -> _PCW { _PCW { w : self } } } } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub struct MCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mod mcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MR0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0IR :: ENABLED => true , MR0IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0IR { match value { true => MR0IR :: ENABLED , false => MR0IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0IR :: DISABLED } } # [ doc = "Possible values of the field `MR0R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0RR :: ENABLED => true , MR0RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0RR { match value { true => MR0RR :: ENABLED , false => MR0RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0RR :: DISABLED } } # [ doc = "Possible values of the field `MR0S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0SR :: ENABLED => true , MR0SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0SR { match value { true => MR0SR :: ENABLED , false => MR0SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0SR :: DISABLED } } # [ doc = "Possible values of the field `MR1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1IR :: ENABLED => true , MR1IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1IR { match value { true => MR1IR :: ENABLED , false => MR1IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1IR :: DISABLED } } # [ doc = "Possible values of the field `MR1R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1RR :: ENABLED => true , MR1RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1RR { match value { true => MR1RR :: ENABLED , false => MR1RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1RR :: DISABLED } } # [ doc = "Possible values of the field `MR1S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1SR :: ENABLED => true , MR1SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1SR { match value { true => MR1SR :: ENABLED , false => MR1SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1SR :: DISABLED } } # [ doc = "Possible values of the field `MR2I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2IR :: ENABLED => true , MR2IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2IR { match value { true => MR2IR :: ENABLED , false => MR2IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2IR :: DISABLED } } # [ doc = "Possible values of the field `MR2R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2RR :: ENABLED => true , MR2RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2RR { match value { true => MR2RR :: ENABLED , false => MR2RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2RR :: DISABLED } } # [ doc = "Possible values of the field `MR2S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2SR :: ENABLED => true , MR2SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2SR { match value { true => MR2SR :: ENABLED , false => MR2SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2SR :: DISABLED } } # [ doc = "Possible values of the field `MR3I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3IR :: ENABLED => true , MR3IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3IR { match value { true => MR3IR :: ENABLED , false => MR3IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3IR :: DISABLED } } # [ doc = "Possible values of the field `MR3R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3RR :: ENABLED => true , MR3RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3RR { match value { true => MR3RR :: ENABLED , false => MR3RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3RR :: DISABLED } } # [ doc = "Possible values of the field `MR3S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3SR :: ENABLED => true , MR3SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3SR { match value { true => MR3SR :: ENABLED , false => MR3SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3SR :: DISABLED } } # [ doc = "Values that can be written to the field `MR0I`" ] pub enum MR0IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0IW :: ENABLED => true , MR0IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0IW < 'a > { w : & 'a mut W , } impl < 'a > _MR0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0R`" ] pub enum MR0RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0RW :: ENABLED => true , MR0RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0RW < 'a > { w : & 'a mut W , } impl < 'a > _MR0RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0S`" ] pub enum MR0SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0SW :: ENABLED => true , MR0SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0SW < 'a > { w : & 'a mut W , } impl < 'a > _MR0SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1I`" ] pub enum MR1IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1IW :: ENABLED => true , MR1IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1IW < 'a > { w : & 'a mut W , } impl < 'a > _MR1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1R`" ] pub enum MR1RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1RW :: ENABLED => true , MR1RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1RW < 'a > { w : & 'a mut W , } impl < 'a > _MR1RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1S`" ] pub enum MR1SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1SW :: ENABLED => true , MR1SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1SW < 'a > { w : & 'a mut W , } impl < 'a > _MR1SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2I`" ] pub enum MR2IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2IW :: ENABLED => true , MR2IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2IW < 'a > { w : & 'a mut W , } impl < 'a > _MR2IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2R`" ] pub enum MR2RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2RW :: ENABLED => true , MR2RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2RW < 'a > { w : & 'a mut W , } impl < 'a > _MR2RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2S`" ] pub enum MR2SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2SW :: ENABLED => true , MR2SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2SW < 'a > { w : & 'a mut W , } impl < 'a > _MR2SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3I`" ] pub enum MR3IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3IW :: ENABLED => true , MR3IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3IW < 'a > { w : & 'a mut W , } impl < 'a > _MR3IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3R`" ] pub enum MR3RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3RW :: ENABLED => true , MR3RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3RW < 'a > { w : & 'a mut W , } impl < 'a > _MR3RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3S`" ] pub enum MR3SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3SW :: ENABLED => true , MR3SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3SW < 'a > { w : & 'a mut W , } impl < 'a > _MR3SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & self ) -> MR0IR { MR0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & self ) -> MR0RR { MR0RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & self ) -> MR0SR { MR0SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & self ) -> MR1IR { MR1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & self ) -> MR1RR { MR1RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & self ) -> MR1SR { MR1SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & self ) -> MR2IR { MR2IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & self ) -> MR2RR { MR2RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & self ) -> MR2SR { MR2SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & self ) -> MR3IR { MR3IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & self ) -> MR3RR { MR3RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & self ) -> MR3SR { MR3SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & mut self ) -> _MR0IW { _MR0IW { w : self } } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & mut self ) -> _MR0RW { _MR0RW { w : self } } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & mut self ) -> _MR0SW { _MR0SW { w : self } } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & mut self ) -> _MR1IW { _MR1IW { w : self } } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & mut self ) -> _MR1RW { _MR1RW { w : self } } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & mut self ) -> _MR1SW { _MR1SW { w : self } } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & mut self ) -> _MR2IW { _MR2IW { w : self } } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & mut self ) -> _MR2RW { _MR2RW { w : self } } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & mut self ) -> _MR2SW { _MR2SW { w : self } } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & mut self ) -> _MR3IW { _MR3IW { w : self } } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & mut self ) -> _MR3RW { _MR3RW { w : self } } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & mut self ) -> _MR3SW { _MR3SW { w : self } } } } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub struct MR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mod mr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MATCHR { bits : u16 , } impl MATCHR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _MATCHW < 'a > { w : & 'a mut W , } impl < 'a > _MATCHW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter match value." ] # [ inline ] pub fn match_ ( & self ) -> MATCHR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; MATCHR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Timer counter match value." ] # [ inline ] pub fn match_ ( & mut self ) -> _MATCHW { _MATCHW { w : self } } } } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub struct CCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub mod ccr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CAP0RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0RER :: ENABLED_ => true , CAP0RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0RER { match value { true => CAP0RER :: ENABLED_ , false => CAP0RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0FER :: ENABLED_ => true , CAP0FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0FER { match value { true => CAP0FER :: ENABLED_ , false => CAP0FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0IR :: ENABLED_ => true , CAP0IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0IR { match value { true => CAP0IR :: ENABLED_ , false => CAP0IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0IR :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1RER :: ENABLED_ => true , CAP1RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1RER { match value { true => CAP1RER :: ENABLED_ , false => CAP1RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1FER :: ENABLED_ => true , CAP1FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1FER { match value { true => CAP1FER :: ENABLED_ , false => CAP1FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1IR :: ENABLED_ => true , CAP1IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1IR { match value { true => CAP1IR :: ENABLED_ , false => CAP1IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1IR :: DISABLED_ } } # [ doc = "Values that can be written to the field `CAP0RE`" ] pub enum CAP0REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0REW :: ENABLED_ => true , CAP0REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0FE`" ] pub enum CAP0FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0FEW :: ENABLED_ => true , CAP0FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0I`" ] pub enum CAP0IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0IW :: ENABLED_ => true , CAP0IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1RE`" ] pub enum CAP1REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1REW :: ENABLED_ => true , CAP1REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1FE`" ] pub enum CAP1FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1FEW :: ENABLED_ => true , CAP1FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1I`" ] pub enum CAP1IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1IW :: ENABLED_ => true , CAP1IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Capture on CT16B0_CAP0 rising edge: a sequence of 0 then 1 on CT16B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & self ) -> CAP0RER { CAP0RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Capture on CT16B0_CAP0 falling edge: a sequence of 1 then 0 on CT16B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & self ) -> CAP0FER { CAP0FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Interrupt on CT16B0_CAP0 event: a CR0 load due to a CT16B0_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & self ) -> CAP0IR { CAP0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Capture on CT16B0_CAP1 rising edge: a sequence of 0 then 1 on CT16B0_CAP1 will cause CR1 to be loaded with the contents of TC. This bit is reserved for 16-bit timer1 CT16B1." ] # [ inline ] pub fn cap1re ( & self ) -> CAP1RER { CAP1RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Capture on CT16B0_CAP1 falling edge: a sequence of 1 then 0 on CT16B0_CAP1 will cause CR1 to be loaded with the contents of TC. This bit is reserved for 16-bit timer1 CT16B1." ] # [ inline ] pub fn cap1fe ( & self ) -> CAP1FER { CAP1FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Interrupt on CT16B0_CAP1 event: a CR1 load due to a CT16B0_CAP1 event will generate an interrupt. This bit is reserved for 16-bit timer1 CT16B1." ] # [ inline ] pub fn cap1i ( & self ) -> CAP1IR { CAP1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Capture on CT16B0_CAP0 rising edge: a sequence of 0 then 1 on CT16B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & mut self ) -> _CAP0REW { _CAP0REW { w : self } } # [ doc = "Bit 1 - Capture on CT16B0_CAP0 falling edge: a sequence of 1 then 0 on CT16B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & mut self ) -> _CAP0FEW { _CAP0FEW { w : self } } # [ doc = "Bit 2 - Interrupt on CT16B0_CAP0 event: a CR0 load due to a CT16B0_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & mut self ) -> _CAP0IW { _CAP0IW { w : self } } # [ doc = "Bit 6 - Capture on CT16B0_CAP1 rising edge: a sequence of 0 then 1 on CT16B0_CAP1 will cause CR1 to be loaded with the contents of TC. This bit is reserved for 16-bit timer1 CT16B1." ] # [ inline ] pub fn cap1re ( & mut self ) -> _CAP1REW { _CAP1REW { w : self } } # [ doc = "Bit 7 - Capture on CT16B0_CAP1 falling edge: a sequence of 1 then 0 on CT16B0_CAP1 will cause CR1 to be loaded with the contents of TC. This bit is reserved for 16-bit timer1 CT16B1." ] # [ inline ] pub fn cap1fe ( & mut self ) -> _CAP1FEW { _CAP1FEW { w : self } } # [ doc = "Bit 8 - Interrupt on CT16B0_CAP1 event: a CR1 load due to a CT16B0_CAP1 event will generate an interrupt. This bit is reserved for 16-bit timer1 CT16B1." ] # [ inline ] pub fn cap1i ( & mut self ) -> _CAP1IW { _CAP1IW { w : self } } } } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input." ] pub struct CR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input." ] pub mod cr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: CR0 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u16 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; CAPR { bits } } } } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT16B0_CAP1 input." ] pub struct CR1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT16B0_CAP1 input." ] pub mod cr1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: CR1 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u16 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; CAPR { bits } } } } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub struct EMR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub mod emr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EMR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EM0R { bits : bool , } impl EM0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM1R { bits : bool , } impl EM1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM2R { bits : bool , } impl EM2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM3R { bits : bool , } impl EM3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `EMC0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC0R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC0R :: DO_NOTHING_ => 0 , EMC0R :: CLEAR_THE_CORRESPOND => 0x01 , EMC0R :: SET_THE_CORRESPONDIN => 0x02 , EMC0R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC0R { match value { 0 => EMC0R :: DO_NOTHING_ , 1 => EMC0R :: CLEAR_THE_CORRESPOND , 2 => EMC0R :: SET_THE_CORRESPONDIN , 3 => EMC0R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC0R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC0R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC0R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC0R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC1R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC1R :: DO_NOTHING_ => 0 , EMC1R :: CLEAR_THE_CORRESPOND => 0x01 , EMC1R :: SET_THE_CORRESPONDIN => 0x02 , EMC1R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC1R { match value { 0 => EMC1R :: DO_NOTHING_ , 1 => EMC1R :: CLEAR_THE_CORRESPOND , 2 => EMC1R :: SET_THE_CORRESPONDIN , 3 => EMC1R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC1R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC1R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC1R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC1R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC2R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC2R :: DO_NOTHING_ => 0 , EMC2R :: CLEAR_THE_CORRESPOND => 0x01 , EMC2R :: SET_THE_CORRESPONDIN => 0x02 , EMC2R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC2R { match value { 0 => EMC2R :: DO_NOTHING_ , 1 => EMC2R :: CLEAR_THE_CORRESPOND , 2 => EMC2R :: SET_THE_CORRESPONDIN , 3 => EMC2R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC2R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC2R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC2R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC2R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC3R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC3R :: DO_NOTHING_ => 0 , EMC3R :: CLEAR_THE_CORRESPOND => 0x01 , EMC3R :: SET_THE_CORRESPONDIN => 0x02 , EMC3R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC3R { match value { 0 => EMC3R :: DO_NOTHING_ , 1 => EMC3R :: CLEAR_THE_CORRESPOND , 2 => EMC3R :: SET_THE_CORRESPONDIN , 3 => EMC3R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC3R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC3R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC3R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC3R :: TOGGLE_THE_CORRESPON } } # [ doc = r" Proxy" ] pub struct _EM0W < 'a > { w : & 'a mut W , } impl < 'a > _EM0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM1W < 'a > { w : & 'a mut W , } impl < 'a > _EM1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM2W < 'a > { w : & 'a mut W , } impl < 'a > _EM2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM3W < 'a > { w : & 'a mut W , } impl < 'a > _EM3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC0`" ] pub enum EMC0W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC0W :: DO_NOTHING_ => 0 , EMC0W :: CLEAR_THE_CORRESPOND => 1 , EMC0W :: SET_THE_CORRESPONDIN => 2 , EMC0W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC0W < 'a > { w : & 'a mut W , } impl < 'a > _EMC0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC0W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC0W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC0W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT0 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC0W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC0W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC1`" ] pub enum EMC1W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC1W :: DO_NOTHING_ => 0 , EMC1W :: CLEAR_THE_CORRESPOND => 1 , EMC1W :: SET_THE_CORRESPONDIN => 2 , EMC1W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC1W < 'a > { w : & 'a mut W , } impl < 'a > _EMC1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC1W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC1W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT1 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC1W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT1 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC1W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC1W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC2`" ] pub enum EMC2W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC2W :: DO_NOTHING_ => 0 , EMC2W :: CLEAR_THE_CORRESPOND => 1 , EMC2W :: SET_THE_CORRESPONDIN => 2 , EMC2W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC2W < 'a > { w : & 'a mut W , } impl < 'a > _EMC2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC2W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC2W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT2 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC2W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT2 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC2W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC2W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC3`" ] pub enum EMC3W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC3W :: DO_NOTHING_ => 0 , EMC3W :: CLEAR_THE_CORRESPOND => 1 , EMC3W :: SET_THE_CORRESPONDIN => 2 , EMC3W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC3W < 'a > { w : & 'a mut W , } impl < 'a > _EMC3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC3W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC3W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT3 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC3W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT3 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC3W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC3W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & self ) -> EM0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM0R { bits } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & self ) -> EM1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM1R { bits } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of match channel 2. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output." ] # [ inline ] pub fn em2 ( & self ) -> EM2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM2R { bits } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output." ] # [ inline ] pub fn em3 ( & self ) -> EM3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM3R { bits } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0. Table 296 shows the encoding of these bits." ] # [ inline ] pub fn emc0 ( & self ) -> EMC0R { EMC0R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & self ) -> EMC1R { EMC1R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & self ) -> EMC2R { EMC2R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & self ) -> EMC3R { EMC3R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & mut self ) -> _EM0W { _EM0W { w : self } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & mut self ) -> _EM1W { _EM1W { w : self } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of match channel 2. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output." ] # [ inline ] pub fn em2 ( & mut self ) -> _EM2W { _EM2W { w : self } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output." ] # [ inline ] pub fn em3 ( & mut self ) -> _EM3W { _EM3W { w : self } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0. Table 296 shows the encoding of these bits." ] # [ inline ] pub fn emc0 ( & mut self ) -> _EMC0W { _EMC0W { w : self } } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & mut self ) -> _EMC1W { _EMC1W { w : self } } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & mut self ) -> _EMC2W { _EMC2W { w : self } } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & mut self ) -> _EMC3W { _EMC3W { w : self } } } } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub struct CTCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub mod ctcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CTCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CTM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CTMR { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CTMR :: TIMER_MODE_EVERY_RI => 0 , CTMR :: COUNTER_MODE_TC_IS_RISING => 0x01 , CTMR :: COUNTER_MODE_TC_IS_FALLING => 0x02 , CTMR :: COUNTER_MODE_TC_IS_BOTH => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CTMR { match value { 0 => CTMR :: TIMER_MODE_EVERY_RI , 1 => CTMR :: COUNTER_MODE_TC_IS_RISING , 2 => CTMR :: COUNTER_MODE_TC_IS_FALLING , 3 => CTMR :: COUNTER_MODE_TC_IS_BOTH , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `TIMER_MODE_EVERY_RI`" ] # [ inline ] pub fn is_timer_mode_every_ri ( & self ) -> bool { * self == CTMR :: TIMER_MODE_EVERY_RI } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_RISING`" ] # [ inline ] pub fn is_counter_mode_tc_is_rising ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_RISING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_FALLING`" ] # [ inline ] pub fn is_counter_mode_tc_is_falling ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_FALLING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_BOTH`" ] # [ inline ] pub fn is_counter_mode_tc_is_both ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_BOTH } } # [ doc = "Possible values of the field `CIS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CISR { # [ doc = "CT16B0_CAP0." ] CT16B0_CAP0_ , # [ doc = "Reserved." ] RESERVED_1 , # [ doc = "CT16B0_CAP1." ] CT16B0_CAP1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl CISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CISR :: CT16B0_CAP0_ => 0 , CISR :: RESERVED_1 => 0x01 , CISR :: CT16B0_CAP1_ => 0x02 , CISR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CISR { match value { 0 => CISR :: CT16B0_CAP0_ , 1 => CISR :: RESERVED_1 , 2 => CISR :: CT16B0_CAP1_ , i => CISR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `CT16B0_CAP0_`" ] # [ inline ] pub fn is_ct16b0_cap0_ ( & self ) -> bool { * self == CISR :: CT16B0_CAP0_ } # [ doc = "Checks if the value of the field is `RESERVED_1`" ] # [ inline ] pub fn is_reserved_1 ( & self ) -> bool { * self == CISR :: RESERVED_1 } # [ doc = "Checks if the value of the field is `CT16B0_CAP1_`" ] # [ inline ] pub fn is_ct16b0_cap1_ ( & self ) -> bool { * self == CISR :: CT16B0_CAP1_ } } # [ doc = r" Value of the field" ] pub struct ENCCR { bits : bool , } impl ENCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `SELCC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELCCR { # [ doc = "Rising Edge of CT16B0_CAP0 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP0 , # [ doc = "Falling Edge of CT16B0_CAP0 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP0 , # [ doc = "Reserved." ] RESERVED_2 , # [ doc = "Reserved." ] RESERVED_3 , # [ doc = "Rising Edge of CT16B0_CAP1 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP1 , # [ doc = "Falling Edge of CT16B0_CAP1 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP1 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SELCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELCCR :: RISING_EDGE_OF_CT16B_CAP0 => 0 , SELCCR :: FALLING_EDGE_OF_CT16_CAP0 => 0x01 , SELCCR :: RESERVED_2 => 0x02 , SELCCR :: RESERVED_3 => 0x03 , SELCCR :: RISING_EDGE_OF_CT16B_CAP1 => 0x04 , SELCCR :: FALLING_EDGE_OF_CT16_CAP1 => 0x05 , SELCCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELCCR { match value { 0 => SELCCR :: RISING_EDGE_OF_CT16B_CAP0 , 1 => SELCCR :: FALLING_EDGE_OF_CT16_CAP0 , 2 => SELCCR :: RESERVED_2 , 3 => SELCCR :: RESERVED_3 , 4 => SELCCR :: RISING_EDGE_OF_CT16B_CAP1 , 5 => SELCCR :: FALLING_EDGE_OF_CT16_CAP1 , i => SELCCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT16B_CAP0`" ] # [ inline ] pub fn is_rising_edge_of_ct16b_cap0 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT16B_CAP0 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT16_CAP0`" ] # [ inline ] pub fn is_falling_edge_of_ct16_cap0 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT16_CAP0 } # [ doc = "Checks if the value of the field is `RESERVED_2`" ] # [ inline ] pub fn is_reserved_2 ( & self ) -> bool { * self == SELCCR :: RESERVED_2 } # [ doc = "Checks if the value of the field is `RESERVED_3`" ] # [ inline ] pub fn is_reserved_3 ( & self ) -> bool { * self == SELCCR :: RESERVED_3 } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT16B_CAP1`" ] # [ inline ] pub fn is_rising_edge_of_ct16b_cap1 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT16B_CAP1 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT16_CAP1`" ] # [ inline ] pub fn is_falling_edge_of_ct16_cap1 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT16_CAP1 } } # [ doc = "Values that can be written to the field `CTM`" ] pub enum CTMW { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CTMW :: TIMER_MODE_EVERY_RI => 0 , CTMW :: COUNTER_MODE_TC_IS_RISING => 1 , CTMW :: COUNTER_MODE_TC_IS_FALLING => 2 , CTMW :: COUNTER_MODE_TC_IS_BOTH => 3 } } } # [ doc = r" Proxy" ] pub struct _CTMW < 'a > { w : & 'a mut W , } impl < 'a > _CTMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CTMW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Timer Mode: every rising PCLK edge" ] # [ inline ] pub fn timer_mode_every_ri ( self ) -> & 'a mut W { self . variant ( CTMW :: TIMER_MODE_EVERY_RI ) } # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_rising ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_RISING ) } # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_falling ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_FALLING ) } # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_both ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_BOTH ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CIS`" ] pub enum CISW { # [ doc = "CT16B0_CAP0." ] CT16B0_CAP0_ , # [ doc = "Reserved." ] RESERVED_1 , # [ doc = "CT16B0_CAP1." ] CT16B0_CAP1_ } impl CISW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CISW :: CT16B0_CAP0_ => 0 , CISW :: RESERVED_1 => 1 , CISW :: CT16B0_CAP1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _CISW < 'a > { w : & 'a mut W , } impl < 'a > _CISW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CISW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CT16B0_CAP0." ] # [ inline ] pub fn ct16b0_cap0_ ( self ) -> & 'a mut W { self . variant ( CISW :: CT16B0_CAP0_ ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_1 ( self ) -> & 'a mut W { self . variant ( CISW :: RESERVED_1 ) } # [ doc = "CT16B0_CAP1." ] # [ inline ] pub fn ct16b0_cap1_ ( self ) -> & 'a mut W { self . variant ( CISW :: CT16B0_CAP1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENCCW < 'a > { w : & 'a mut W , } impl < 'a > _ENCCW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SELCC`" ] pub enum SELCCW { # [ doc = "Rising Edge of CT16B0_CAP0 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP0 , # [ doc = "Falling Edge of CT16B0_CAP0 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP0 , # [ doc = "Reserved." ] RESERVED_2 , # [ doc = "Reserved." ] RESERVED_3 , # [ doc = "Rising Edge of CT16B0_CAP1 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP1 , # [ doc = "Falling Edge of CT16B0_CAP1 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP1 } impl SELCCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELCCW :: RISING_EDGE_OF_CT16B_CAP0 => 0 , SELCCW :: FALLING_EDGE_OF_CT16_CAP0 => 1 , SELCCW :: RESERVED_2 => 2 , SELCCW :: RESERVED_3 => 3 , SELCCW :: RISING_EDGE_OF_CT16B_CAP1 => 4 , SELCCW :: FALLING_EDGE_OF_CT16_CAP1 => 5 } } } # [ doc = r" Proxy" ] pub struct _SELCCW < 'a > { w : & 'a mut W , } impl < 'a > _SELCCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELCCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Rising Edge of CT16B0_CAP0 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn rising_edge_of_ct16b_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT16B_CAP0 ) } # [ doc = "Falling Edge of CT16B0_CAP0 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn falling_edge_of_ct16_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT16_CAP0 ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_2 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RESERVED_2 ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_3 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RESERVED_3 ) } # [ doc = "Rising Edge of CT16B0_CAP1 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn rising_edge_of_ct16b_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT16B_CAP1 ) } # [ doc = "Falling Edge of CT16B0_CAP1 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn falling_edge_of_ct16_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT16_CAP1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & self ) -> CTMR { CTMR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. Values 0x1 and 0x3 are reserved." ] # [ inline ] pub fn cis ( & self ) -> CISR { CISR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & self ) -> ENCCR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENCCR { bits } } # [ doc = "Bits 5:7 - Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved." ] # [ inline ] pub fn selcc ( & self ) -> SELCCR { SELCCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & mut self ) -> _CTMW { _CTMW { w : self } } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. Values 0x1 and 0x3 are reserved." ] # [ inline ] pub fn cis ( & mut self ) -> _CISW { _CISW { w : self } } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & mut self ) -> _ENCCW { _ENCCW { w : self } } # [ doc = "Bits 5:7 - Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved." ] # [ inline ] pub fn selcc ( & mut self ) -> _SELCCW { _SELCCW { w : self } } } } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub struct PWMC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub mod pwmc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PWMC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PWMEN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN0R { # [ doc = "CT16Bn_MAT0 is controlled by EM0." ] CT16BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN0R :: CT16BN_MAT0_IS_CONTR => false , PWMEN0R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN0R { match value { false => PWMEN0R :: CT16BN_MAT0_IS_CONTR , true => PWMEN0R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT0_IS_CONTR`" ] # [ inline ] pub fn is_ct16bn_mat0_is_contr ( & self ) -> bool { * self == PWMEN0R :: CT16BN_MAT0_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN0R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN1R { # [ doc = "CT16Bn_MAT01 is controlled by EM1." ] CT16BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT16Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN1R :: CT16BN_MAT01_IS_CONT => false , PWMEN1R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN1R { match value { false => PWMEN1R :: CT16BN_MAT01_IS_CONT , true => PWMEN1R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT01_IS_CONT`" ] # [ inline ] pub fn is_ct16bn_mat01_is_cont ( & self ) -> bool { * self == PWMEN1R :: CT16BN_MAT01_IS_CONT } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN1R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN2R { # [ doc = "CT16Bn_MAT2 is controlled by EM2." ] CT16BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN2R :: CT16BN_MAT2_IS_CONTR => false , PWMEN2R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN2R { match value { false => PWMEN2R :: CT16BN_MAT2_IS_CONTR , true => PWMEN2R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT2_IS_CONTR`" ] # [ inline ] pub fn is_ct16bn_mat2_is_contr ( & self ) -> bool { * self == PWMEN2R :: CT16BN_MAT2_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN2R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN3R { # [ doc = "CT16Bn_MAT3 is controlled by EM3." ] CT16BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN3R :: CT16BN_MAT3_IS_CONTR => false , PWMEN3R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN3R { match value { false => PWMEN3R :: CT16BN_MAT3_IS_CONTR , true => PWMEN3R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT3_IS_CONTR`" ] # [ inline ] pub fn is_ct16bn_mat3_is_contr ( & self ) -> bool { * self == PWMEN3R :: CT16BN_MAT3_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN3R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Values that can be written to the field `PWMEN0`" ] pub enum PWMEN0W { # [ doc = "CT16Bn_MAT0 is controlled by EM0." ] CT16BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN0W :: CT16BN_MAT0_IS_CONTR => false , PWMEN0W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN0W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT0 is controlled by EM0." ] # [ inline ] pub fn ct16bn_mat0_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: CT16BN_MAT0_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT0." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN1`" ] pub enum PWMEN1W { # [ doc = "CT16Bn_MAT01 is controlled by EM1." ] CT16BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT16Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN1W :: CT16BN_MAT01_IS_CONT => false , PWMEN1W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN1W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT01 is controlled by EM1." ] # [ inline ] pub fn ct16bn_mat01_is_cont ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: CT16BN_MAT01_IS_CONT ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT1." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN2`" ] pub enum PWMEN2W { # [ doc = "CT16Bn_MAT2 is controlled by EM2." ] CT16BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN2W :: CT16BN_MAT2_IS_CONTR => false , PWMEN2W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN2W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT2 is controlled by EM2." ] # [ inline ] pub fn ct16bn_mat2_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: CT16BN_MAT2_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT2." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN3`" ] pub enum PWMEN3W { # [ doc = "CT16Bn_MAT3 is controlled by EM3." ] CT16BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN3W :: CT16BN_MAT3_IS_CONTR => false , PWMEN3W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN3W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT3 is controlled by EM3." ] # [ inline ] pub fn ct16bn_mat3_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: CT16BN_MAT3_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT3." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & self ) -> PWMEN0R { PWMEN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & self ) -> PWMEN1R { PWMEN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & self ) -> PWMEN2R { PWMEN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - PWM mode enable for channel3." ] # [ inline ] pub fn pwmen3 ( & self ) -> PWMEN3R { PWMEN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & mut self ) -> _PWMEN0W { _PWMEN0W { w : self } } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & mut self ) -> _PWMEN1W { _PWMEN1W { w : self } } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & mut self ) -> _PWMEN2W { _PWMEN2W { w : self } } # [ doc = "Bit 3 - PWM mode enable for channel3." ] # [ inline ] pub fn pwmen3 ( & mut self ) -> _PWMEN3W { _PWMEN3W { w : self } } } } } # [ doc = "16-bit counter/timers CT16B1" ] pub struct CT16B1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for CT16B1 { } impl CT16B1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ct16b1 :: RegisterBlock { 0x4001_0000 as * const _ } } impl Deref for CT16B1 { type Target = ct16b1 :: RegisterBlock ; fn deref ( & self ) -> & ct16b1 :: RegisterBlock { unsafe { & * CT16B1 :: ptr ( ) } } } # [ doc = "16-bit counter/timers CT16B1" ] pub mod ct16b1 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub ir : IR , # [ doc = "0x04 - Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub tcr : TCR , # [ doc = "0x08 - Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub tc : TC , # [ doc = "0x0c - Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub pr : PR , # [ doc = "0x10 - Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub pc : PC , # [ doc = "0x14 - Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mcr : MCR , # [ doc = "0x18 - Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mr : [ MR ; 4 ] , # [ doc = "0x28 - Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub ccr : CCR , # [ doc = "0x2c - Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input." ] pub cr0 : CR0 , # [ doc = "0x30 - Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT16B1_CAP1 input." ] pub cr1 : CR1 , _reserved0 : [ u8 ; 8usize ] , # [ doc = "0x3c - External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub emr : EMR , _reserved1 : [ u8 ; 48usize ] , # [ doc = "0x70 - Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub ctcr : CTCR , # [ doc = "0x74 - PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub pwmc : PWMC , } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub struct IR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub mod ir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MR0INTR { bits : bool , } impl MR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR1INTR { bits : bool , } impl MR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR2INTR { bits : bool , } impl MR2INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR3INTR { bits : bool , } impl MR3INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR0INTR { bits : bool , } impl CR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR1INTR { bits : bool , } impl CR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _MR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR2INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR2INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR3INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR3INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & self ) -> MR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR0INTR { bits } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & self ) -> MR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR1INTR { bits } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & self ) -> MR2INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR2INTR { bits } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & self ) -> MR3INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR3INTR { bits } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & self ) -> CR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR0INTR { bits } } # [ doc = "Bit 5 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & self ) -> CR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR1INTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & mut self ) -> _MR0INTW { _MR0INTW { w : self } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & mut self ) -> _MR1INTW { _MR1INTW { w : self } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & mut self ) -> _MR2INTW { _MR2INTW { w : self } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & mut self ) -> _MR3INTW { _MR3INTW { w : self } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & mut self ) -> _CR0INTW { _CR0INTW { w : self } } # [ doc = "Bit 5 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & mut self ) -> _CR1INTW { _CR1INTW { w : self } } } } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub struct TCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub mod tcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CENR { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CENR :: THE_COUNTERS_ARE_DIS => false , CENR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CENR { match value { false => CENR :: THE_COUNTERS_ARE_DIS , true => CENR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `THE_COUNTERS_ARE_DIS`" ] # [ inline ] pub fn is_the_counters_are_dis ( & self ) -> bool { * self == CENR :: THE_COUNTERS_ARE_DIS } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CENR :: THE_TIMER_COUNTER_AN } } # [ doc = "Possible values of the field `CRST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRSTR { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CRSTR :: DO_NOTHING_ => false , CRSTR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CRSTR { match value { false => CRSTR :: DO_NOTHING_ , true => CRSTR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == CRSTR :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CRSTR :: THE_TIMER_COUNTER_AN } } # [ doc = "Values that can be written to the field `CEN`" ] pub enum CENW { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CENW :: THE_COUNTERS_ARE_DIS => false , CENW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CENW < 'a > { w : & 'a mut W , } impl < 'a > _CENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The counters are disabled." ] # [ inline ] pub fn the_counters_are_dis ( self ) -> & 'a mut W { self . variant ( CENW :: THE_COUNTERS_ARE_DIS ) } # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CENW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CRST`" ] pub enum CRSTW { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CRSTW :: DO_NOTHING_ => false , CRSTW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CRSTW < 'a > { w : & 'a mut W , } impl < 'a > _CRSTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CRSTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Do nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( CRSTW :: DO_NOTHING_ ) } # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CRSTW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & self ) -> CENR { CENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & self ) -> CRSTR { CRSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & mut self ) -> _CENW { _CENW { w : self } } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & mut self ) -> _CRSTW { _CRSTW { w : self } } } } # [ doc = "Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub struct TC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub mod tc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TCR { bits : u16 , } impl TCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _TCW < 'a > { w : & 'a mut W , } impl < 'a > _TCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter value." ] # [ inline ] pub fn tc ( & self ) -> TCR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; TCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Timer counter value." ] # [ inline ] pub fn tc ( & mut self ) -> _TCW { _TCW { w : self } } } } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub struct PR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub mod pr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCVALR { bits : u16 , } impl PCVALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCVALW < 'a > { w : & 'a mut W , } impl < 'a > _PCVALW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Prescale value." ] # [ inline ] pub fn pcval ( & self ) -> PCVALR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; PCVALR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Prescale value." ] # [ inline ] pub fn pcval ( & mut self ) -> _PCVALW { _PCVALW { w : self } } } } # [ doc = "Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub struct PC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub mod pc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCR { bits : u16 , } impl PCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCW < 'a > { w : & 'a mut W , } impl < 'a > _PCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Prescale counter value." ] # [ inline ] pub fn pc ( & self ) -> PCR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; PCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Prescale counter value." ] # [ inline ] pub fn pc ( & mut self ) -> _PCW { _PCW { w : self } } } } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub struct MCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mod mcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MR0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0IR :: ENABLED => true , MR0IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0IR { match value { true => MR0IR :: ENABLED , false => MR0IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0IR :: DISABLED } } # [ doc = "Possible values of the field `MR0R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0RR :: ENABLED => true , MR0RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0RR { match value { true => MR0RR :: ENABLED , false => MR0RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0RR :: DISABLED } } # [ doc = "Possible values of the field `MR0S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0SR :: ENABLED => true , MR0SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0SR { match value { true => MR0SR :: ENABLED , false => MR0SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0SR :: DISABLED } } # [ doc = "Possible values of the field `MR1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1IR :: ENABLED => true , MR1IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1IR { match value { true => MR1IR :: ENABLED , false => MR1IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1IR :: DISABLED } } # [ doc = "Possible values of the field `MR1R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1RR :: ENABLED => true , MR1RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1RR { match value { true => MR1RR :: ENABLED , false => MR1RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1RR :: DISABLED } } # [ doc = "Possible values of the field `MR1S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1SR :: ENABLED => true , MR1SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1SR { match value { true => MR1SR :: ENABLED , false => MR1SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1SR :: DISABLED } } # [ doc = "Possible values of the field `MR2I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2IR :: ENABLED => true , MR2IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2IR { match value { true => MR2IR :: ENABLED , false => MR2IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2IR :: DISABLED } } # [ doc = "Possible values of the field `MR2R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2RR :: ENABLED => true , MR2RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2RR { match value { true => MR2RR :: ENABLED , false => MR2RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2RR :: DISABLED } } # [ doc = "Possible values of the field `MR2S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2SR :: ENABLED => true , MR2SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2SR { match value { true => MR2SR :: ENABLED , false => MR2SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2SR :: DISABLED } } # [ doc = "Possible values of the field `MR3I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3IR :: ENABLED => true , MR3IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3IR { match value { true => MR3IR :: ENABLED , false => MR3IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3IR :: DISABLED } } # [ doc = "Possible values of the field `MR3R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3RR :: ENABLED => true , MR3RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3RR { match value { true => MR3RR :: ENABLED , false => MR3RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3RR :: DISABLED } } # [ doc = "Possible values of the field `MR3S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3SR :: ENABLED => true , MR3SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3SR { match value { true => MR3SR :: ENABLED , false => MR3SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3SR :: DISABLED } } # [ doc = "Values that can be written to the field `MR0I`" ] pub enum MR0IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0IW :: ENABLED => true , MR0IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0IW < 'a > { w : & 'a mut W , } impl < 'a > _MR0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0R`" ] pub enum MR0RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0RW :: ENABLED => true , MR0RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0RW < 'a > { w : & 'a mut W , } impl < 'a > _MR0RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0S`" ] pub enum MR0SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0SW :: ENABLED => true , MR0SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0SW < 'a > { w : & 'a mut W , } impl < 'a > _MR0SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1I`" ] pub enum MR1IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1IW :: ENABLED => true , MR1IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1IW < 'a > { w : & 'a mut W , } impl < 'a > _MR1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1R`" ] pub enum MR1RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1RW :: ENABLED => true , MR1RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1RW < 'a > { w : & 'a mut W , } impl < 'a > _MR1RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1S`" ] pub enum MR1SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1SW :: ENABLED => true , MR1SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1SW < 'a > { w : & 'a mut W , } impl < 'a > _MR1SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2I`" ] pub enum MR2IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2IW :: ENABLED => true , MR2IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2IW < 'a > { w : & 'a mut W , } impl < 'a > _MR2IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2R`" ] pub enum MR2RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2RW :: ENABLED => true , MR2RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2RW < 'a > { w : & 'a mut W , } impl < 'a > _MR2RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2S`" ] pub enum MR2SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2SW :: ENABLED => true , MR2SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2SW < 'a > { w : & 'a mut W , } impl < 'a > _MR2SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3I`" ] pub enum MR3IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3IW :: ENABLED => true , MR3IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3IW < 'a > { w : & 'a mut W , } impl < 'a > _MR3IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3R`" ] pub enum MR3RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3RW :: ENABLED => true , MR3RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3RW < 'a > { w : & 'a mut W , } impl < 'a > _MR3RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3S`" ] pub enum MR3SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3SW :: ENABLED => true , MR3SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3SW < 'a > { w : & 'a mut W , } impl < 'a > _MR3SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & self ) -> MR0IR { MR0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & self ) -> MR0RR { MR0RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & self ) -> MR0SR { MR0SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & self ) -> MR1IR { MR1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & self ) -> MR1RR { MR1RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & self ) -> MR1SR { MR1SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & self ) -> MR2IR { MR2IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & self ) -> MR2RR { MR2RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & self ) -> MR2SR { MR2SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & self ) -> MR3IR { MR3IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & self ) -> MR3RR { MR3RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & self ) -> MR3SR { MR3SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & mut self ) -> _MR0IW { _MR0IW { w : self } } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & mut self ) -> _MR0RW { _MR0RW { w : self } } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & mut self ) -> _MR0SW { _MR0SW { w : self } } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & mut self ) -> _MR1IW { _MR1IW { w : self } } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & mut self ) -> _MR1RW { _MR1RW { w : self } } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & mut self ) -> _MR1SW { _MR1SW { w : self } } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & mut self ) -> _MR2IW { _MR2IW { w : self } } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & mut self ) -> _MR2RW { _MR2RW { w : self } } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & mut self ) -> _MR2SW { _MR2SW { w : self } } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & mut self ) -> _MR3IW { _MR3IW { w : self } } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & mut self ) -> _MR3RW { _MR3RW { w : self } } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & mut self ) -> _MR3SW { _MR3SW { w : self } } } } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub struct MR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mod mr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MATCHR { bits : u16 , } impl MATCHR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _MATCHW < 'a > { w : & 'a mut W , } impl < 'a > _MATCHW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter match value." ] # [ inline ] pub fn match_ ( & self ) -> MATCHR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; MATCHR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Timer counter match value." ] # [ inline ] pub fn match_ ( & mut self ) -> _MATCHW { _MATCHW { w : self } } } } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub struct CCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub mod ccr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CAP0RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0RER :: ENABLED_ => true , CAP0RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0RER { match value { true => CAP0RER :: ENABLED_ , false => CAP0RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0FER :: ENABLED_ => true , CAP0FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0FER { match value { true => CAP0FER :: ENABLED_ , false => CAP0FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0IR :: ENABLED_ => true , CAP0IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0IR { match value { true => CAP0IR :: ENABLED_ , false => CAP0IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0IR :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1RER :: ENABLED_ => true , CAP1RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1RER { match value { true => CAP1RER :: ENABLED_ , false => CAP1RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1FER :: ENABLED_ => true , CAP1FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1FER { match value { true => CAP1FER :: ENABLED_ , false => CAP1FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1IR :: ENABLED_ => true , CAP1IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1IR { match value { true => CAP1IR :: ENABLED_ , false => CAP1IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1IR :: DISABLED_ } } # [ doc = "Values that can be written to the field `CAP0RE`" ] pub enum CAP0REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0REW :: ENABLED_ => true , CAP0REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0FE`" ] pub enum CAP0FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0FEW :: ENABLED_ => true , CAP0FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0I`" ] pub enum CAP0IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0IW :: ENABLED_ => true , CAP0IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1RE`" ] pub enum CAP1REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1REW :: ENABLED_ => true , CAP1REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1FE`" ] pub enum CAP1FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1FEW :: ENABLED_ => true , CAP1FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1I`" ] pub enum CAP1IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1IW :: ENABLED_ => true , CAP1IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Capture on CT16B1_CAP0 rising edge: a sequence of 0 then 1 on CT16B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & self ) -> CAP0RER { CAP0RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Capture on CT16B11_CAP0 falling edge: a sequence of 1 then 0 on CT16B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & self ) -> CAP0FER { CAP0FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Interrupt on CT16B1_CAP0 event: a CR0 load due to a CT16B1_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & self ) -> CAP0IR { CAP0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Capture on CT16B1_CAP1 rising edge: a sequence of 0 then 1 on CT16B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1re ( & self ) -> CAP1RER { CAP1RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Capture on CT16B1_CAP1 falling edge: a sequence of 1 then 0 on CT16B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1fe ( & self ) -> CAP1FER { CAP1FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Interrupt on CT16B1_CAP1 event: a CR1 load due to a CT16B0_CAP1 event will generate an interrupt." ] # [ inline ] pub fn cap1i ( & self ) -> CAP1IR { CAP1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Capture on CT16B1_CAP0 rising edge: a sequence of 0 then 1 on CT16B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & mut self ) -> _CAP0REW { _CAP0REW { w : self } } # [ doc = "Bit 1 - Capture on CT16B11_CAP0 falling edge: a sequence of 1 then 0 on CT16B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & mut self ) -> _CAP0FEW { _CAP0FEW { w : self } } # [ doc = "Bit 2 - Interrupt on CT16B1_CAP0 event: a CR0 load due to a CT16B1_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & mut self ) -> _CAP0IW { _CAP0IW { w : self } } # [ doc = "Bit 3 - Capture on CT16B1_CAP1 rising edge: a sequence of 0 then 1 on CT16B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1re ( & mut self ) -> _CAP1REW { _CAP1REW { w : self } } # [ doc = "Bit 4 - Capture on CT16B1_CAP1 falling edge: a sequence of 1 then 0 on CT16B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1fe ( & mut self ) -> _CAP1FEW { _CAP1FEW { w : self } } # [ doc = "Bit 5 - Interrupt on CT16B1_CAP1 event: a CR1 load due to a CT16B0_CAP1 event will generate an interrupt." ] # [ inline ] pub fn cap1i ( & mut self ) -> _CAP1IW { _CAP1IW { w : self } } } } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input." ] pub struct CR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input." ] pub mod cr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: CR0 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u16 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; CAPR { bits } } } } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT16B1_CAP1 input." ] pub struct CR1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT16B1_CAP1 input." ] pub mod cr1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: CR1 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u16 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; CAPR { bits } } } } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub struct EMR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub mod emr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EMR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EM0R { bits : bool , } impl EM0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM1R { bits : bool , } impl EM1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM2R { bits : bool , } impl EM2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM3R { bits : bool , } impl EM3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `EMC0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC0R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC0R :: DO_NOTHING_ => 0 , EMC0R :: CLEAR_THE_CORRESPOND => 0x01 , EMC0R :: SET_THE_CORRESPONDIN => 0x02 , EMC0R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC0R { match value { 0 => EMC0R :: DO_NOTHING_ , 1 => EMC0R :: CLEAR_THE_CORRESPOND , 2 => EMC0R :: SET_THE_CORRESPONDIN , 3 => EMC0R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC0R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC0R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC0R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC0R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC1R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC1R :: DO_NOTHING_ => 0 , EMC1R :: CLEAR_THE_CORRESPOND => 0x01 , EMC1R :: SET_THE_CORRESPONDIN => 0x02 , EMC1R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC1R { match value { 0 => EMC1R :: DO_NOTHING_ , 1 => EMC1R :: CLEAR_THE_CORRESPOND , 2 => EMC1R :: SET_THE_CORRESPONDIN , 3 => EMC1R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC1R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC1R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC1R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC1R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC2R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC2R :: DO_NOTHING_ => 0 , EMC2R :: CLEAR_THE_CORRESPOND => 0x01 , EMC2R :: SET_THE_CORRESPONDIN => 0x02 , EMC2R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC2R { match value { 0 => EMC2R :: DO_NOTHING_ , 1 => EMC2R :: CLEAR_THE_CORRESPOND , 2 => EMC2R :: SET_THE_CORRESPONDIN , 3 => EMC2R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC2R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC2R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC2R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC2R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC3R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC3R :: DO_NOTHING_ => 0 , EMC3R :: CLEAR_THE_CORRESPOND => 0x01 , EMC3R :: SET_THE_CORRESPONDIN => 0x02 , EMC3R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC3R { match value { 0 => EMC3R :: DO_NOTHING_ , 1 => EMC3R :: CLEAR_THE_CORRESPOND , 2 => EMC3R :: SET_THE_CORRESPONDIN , 3 => EMC3R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC3R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC3R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC3R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC3R :: TOGGLE_THE_CORRESPON } } # [ doc = r" Proxy" ] pub struct _EM0W < 'a > { w : & 'a mut W , } impl < 'a > _EM0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM1W < 'a > { w : & 'a mut W , } impl < 'a > _EM1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM2W < 'a > { w : & 'a mut W , } impl < 'a > _EM2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM3W < 'a > { w : & 'a mut W , } impl < 'a > _EM3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC0`" ] pub enum EMC0W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC0W :: DO_NOTHING_ => 0 , EMC0W :: CLEAR_THE_CORRESPOND => 1 , EMC0W :: SET_THE_CORRESPONDIN => 2 , EMC0W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC0W < 'a > { w : & 'a mut W , } impl < 'a > _EMC0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC0W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC0W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC0W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT0 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC0W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC0W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC1`" ] pub enum EMC1W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC1W :: DO_NOTHING_ => 0 , EMC1W :: CLEAR_THE_CORRESPOND => 1 , EMC1W :: SET_THE_CORRESPONDIN => 2 , EMC1W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC1W < 'a > { w : & 'a mut W , } impl < 'a > _EMC1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC1W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC1W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT1 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC1W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT1 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC1W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC1W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC2`" ] pub enum EMC2W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC2W :: DO_NOTHING_ => 0 , EMC2W :: CLEAR_THE_CORRESPOND => 1 , EMC2W :: SET_THE_CORRESPONDIN => 2 , EMC2W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC2W < 'a > { w : & 'a mut W , } impl < 'a > _EMC2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC2W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC2W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT2 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC2W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT2 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC2W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC2W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC3`" ] pub enum EMC3W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC3W :: DO_NOTHING_ => 0 , EMC3W :: CLEAR_THE_CORRESPOND => 1 , EMC3W :: SET_THE_CORRESPONDIN => 2 , EMC3W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC3W < 'a > { w : & 'a mut W , } impl < 'a > _EMC3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC3W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC3W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MAT3 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC3W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MAT3 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC3W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC3W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & self ) -> EM0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM0R { bits } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & self ) -> EM1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM1R { bits } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of match channel 2. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output." ] # [ inline ] pub fn em2 ( & self ) -> EM2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM2R { bits } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output." ] # [ inline ] pub fn em3 ( & self ) -> EM3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM3R { bits } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0. Table 296 shows the encoding of these bits." ] # [ inline ] pub fn emc0 ( & self ) -> EMC0R { EMC0R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & self ) -> EMC1R { EMC1R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & self ) -> EMC2R { EMC2R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & self ) -> EMC3R { EMC3R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & mut self ) -> _EM0W { _EM0W { w : self } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & mut self ) -> _EM1W { _EM1W { w : self } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of match channel 2. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output." ] # [ inline ] pub fn em2 ( & mut self ) -> _EM2W { _EM2W { w : self } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output." ] # [ inline ] pub fn em3 ( & mut self ) -> _EM3W { _EM3W { w : self } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0. Table 296 shows the encoding of these bits." ] # [ inline ] pub fn emc0 ( & mut self ) -> _EMC0W { _EMC0W { w : self } } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & mut self ) -> _EMC1W { _EMC1W { w : self } } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & mut self ) -> _EMC2W { _EMC2W { w : self } } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & mut self ) -> _EMC3W { _EMC3W { w : self } } } } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub struct CTCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub mod ctcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CTCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CTM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CTMR { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CTMR :: TIMER_MODE_EVERY_RI => 0 , CTMR :: COUNTER_MODE_TC_IS_RISING => 0x01 , CTMR :: COUNTER_MODE_TC_IS_FALLING => 0x02 , CTMR :: COUNTER_MODE_TC_IS_BOTH => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CTMR { match value { 0 => CTMR :: TIMER_MODE_EVERY_RI , 1 => CTMR :: COUNTER_MODE_TC_IS_RISING , 2 => CTMR :: COUNTER_MODE_TC_IS_FALLING , 3 => CTMR :: COUNTER_MODE_TC_IS_BOTH , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `TIMER_MODE_EVERY_RI`" ] # [ inline ] pub fn is_timer_mode_every_ri ( & self ) -> bool { * self == CTMR :: TIMER_MODE_EVERY_RI } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_RISING`" ] # [ inline ] pub fn is_counter_mode_tc_is_rising ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_RISING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_FALLING`" ] # [ inline ] pub fn is_counter_mode_tc_is_falling ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_FALLING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_BOTH`" ] # [ inline ] pub fn is_counter_mode_tc_is_both ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_BOTH } } # [ doc = "Possible values of the field `CIS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CISR { # [ doc = "CT16B1_CAP0." ] CT16B1_CAP0_ , # [ doc = "CT16B1_CAP1." ] CT16B1_CAP1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl CISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CISR :: CT16B1_CAP0_ => 0 , CISR :: CT16B1_CAP1_ => 0x01 , CISR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CISR { match value { 0 => CISR :: CT16B1_CAP0_ , 1 => CISR :: CT16B1_CAP1_ , i => CISR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `CT16B1_CAP0_`" ] # [ inline ] pub fn is_ct16b1_cap0_ ( & self ) -> bool { * self == CISR :: CT16B1_CAP0_ } # [ doc = "Checks if the value of the field is `CT16B1_CAP1_`" ] # [ inline ] pub fn is_ct16b1_cap1_ ( & self ) -> bool { * self == CISR :: CT16B1_CAP1_ } } # [ doc = r" Value of the field" ] pub struct ENCCR { bits : bool , } impl ENCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `SELCC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELCCR { # [ doc = "Rising Edge of CT16B1_CAP0 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP0 , # [ doc = "Falling Edge of CT16B1_CAP0 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP0 , # [ doc = "Rising Edge of CT16B1_CAP1 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP1 , # [ doc = "Falling Edge of CT16B1_CAP1 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP1 , # [ doc = "Reserved." ] RESERVED_4 , # [ doc = "Reserved." ] RESERVED_5 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SELCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELCCR :: RISING_EDGE_OF_CT16B_CAP0 => 0 , SELCCR :: FALLING_EDGE_OF_CT16_CAP0 => 0x01 , SELCCR :: RISING_EDGE_OF_CT16B_CAP1 => 0x02 , SELCCR :: FALLING_EDGE_OF_CT16_CAP1 => 0x03 , SELCCR :: RESERVED_4 => 0x04 , SELCCR :: RESERVED_5 => 0x05 , SELCCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELCCR { match value { 0 => SELCCR :: RISING_EDGE_OF_CT16B_CAP0 , 1 => SELCCR :: FALLING_EDGE_OF_CT16_CAP0 , 2 => SELCCR :: RISING_EDGE_OF_CT16B_CAP1 , 3 => SELCCR :: FALLING_EDGE_OF_CT16_CAP1 , 4 => SELCCR :: RESERVED_4 , 5 => SELCCR :: RESERVED_5 , i => SELCCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT16B_CAP0`" ] # [ inline ] pub fn is_rising_edge_of_ct16b_cap0 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT16B_CAP0 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT16_CAP0`" ] # [ inline ] pub fn is_falling_edge_of_ct16_cap0 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT16_CAP0 } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT16B_CAP1`" ] # [ inline ] pub fn is_rising_edge_of_ct16b_cap1 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT16B_CAP1 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT16_CAP1`" ] # [ inline ] pub fn is_falling_edge_of_ct16_cap1 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT16_CAP1 } # [ doc = "Checks if the value of the field is `RESERVED_4`" ] # [ inline ] pub fn is_reserved_4 ( & self ) -> bool { * self == SELCCR :: RESERVED_4 } # [ doc = "Checks if the value of the field is `RESERVED_5`" ] # [ inline ] pub fn is_reserved_5 ( & self ) -> bool { * self == SELCCR :: RESERVED_5 } } # [ doc = "Values that can be written to the field `CTM`" ] pub enum CTMW { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CTMW :: TIMER_MODE_EVERY_RI => 0 , CTMW :: COUNTER_MODE_TC_IS_RISING => 1 , CTMW :: COUNTER_MODE_TC_IS_FALLING => 2 , CTMW :: COUNTER_MODE_TC_IS_BOTH => 3 } } } # [ doc = r" Proxy" ] pub struct _CTMW < 'a > { w : & 'a mut W , } impl < 'a > _CTMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CTMW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Timer Mode: every rising PCLK edge" ] # [ inline ] pub fn timer_mode_every_ri ( self ) -> & 'a mut W { self . variant ( CTMW :: TIMER_MODE_EVERY_RI ) } # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_rising ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_RISING ) } # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_falling ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_FALLING ) } # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_both ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_BOTH ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CIS`" ] pub enum CISW { # [ doc = "CT16B1_CAP0." ] CT16B1_CAP0_ , # [ doc = "CT16B1_CAP1." ] CT16B1_CAP1_ } impl CISW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CISW :: CT16B1_CAP0_ => 0 , CISW :: CT16B1_CAP1_ => 1 } } } # [ doc = r" Proxy" ] pub struct _CISW < 'a > { w : & 'a mut W , } impl < 'a > _CISW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CISW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CT16B1_CAP0." ] # [ inline ] pub fn ct16b1_cap0_ ( self ) -> & 'a mut W { self . variant ( CISW :: CT16B1_CAP0_ ) } # [ doc = "CT16B1_CAP1." ] # [ inline ] pub fn ct16b1_cap1_ ( self ) -> & 'a mut W { self . variant ( CISW :: CT16B1_CAP1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENCCW < 'a > { w : & 'a mut W , } impl < 'a > _ENCCW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SELCC`" ] pub enum SELCCW { # [ doc = "Rising Edge of CT16B1_CAP0 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP0 , # [ doc = "Falling Edge of CT16B1_CAP0 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP0 , # [ doc = "Rising Edge of CT16B1_CAP1 clears the timer (if bit 4 is set)." ] RISING_EDGE_OF_CT16B_CAP1 , # [ doc = "Falling Edge of CT16B1_CAP1 clears the timer (if bit 4 is set)." ] FALLING_EDGE_OF_CT16_CAP1 , # [ doc = "Reserved." ] RESERVED_4 , # [ doc = "Reserved." ] RESERVED_5 } impl SELCCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELCCW :: RISING_EDGE_OF_CT16B_CAP0 => 0 , SELCCW :: FALLING_EDGE_OF_CT16_CAP0 => 1 , SELCCW :: RISING_EDGE_OF_CT16B_CAP1 => 2 , SELCCW :: FALLING_EDGE_OF_CT16_CAP1 => 3 , SELCCW :: RESERVED_4 => 4 , SELCCW :: RESERVED_5 => 5 } } } # [ doc = r" Proxy" ] pub struct _SELCCW < 'a > { w : & 'a mut W , } impl < 'a > _SELCCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELCCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Rising Edge of CT16B1_CAP0 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn rising_edge_of_ct16b_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT16B_CAP0 ) } # [ doc = "Falling Edge of CT16B1_CAP0 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn falling_edge_of_ct16_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT16_CAP0 ) } # [ doc = "Rising Edge of CT16B1_CAP1 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn rising_edge_of_ct16b_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT16B_CAP1 ) } # [ doc = "Falling Edge of CT16B1_CAP1 clears the timer (if bit 4 is set)." ] # [ inline ] pub fn falling_edge_of_ct16_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT16_CAP1 ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_4 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RESERVED_4 ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_5 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RESERVED_5 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & self ) -> CTMR { CTMR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. Values 0x2 to 0x3 are reserved." ] # [ inline ] pub fn cis ( & self ) -> CISR { CISR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & self ) -> ENCCR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENCCR { bits } } # [ doc = "Bits 5:7 - When bit 4 is a 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x6 to 0x7 are reserved." ] # [ inline ] pub fn selcc ( & self ) -> SELCCR { SELCCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & mut self ) -> _CTMW { _CTMW { w : self } } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. Values 0x2 to 0x3 are reserved." ] # [ inline ] pub fn cis ( & mut self ) -> _CISW { _CISW { w : self } } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & mut self ) -> _ENCCW { _ENCCW { w : self } } # [ doc = "Bits 5:7 - When bit 4 is a 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x6 to 0x7 are reserved." ] # [ inline ] pub fn selcc ( & mut self ) -> _SELCCW { _SELCCW { w : self } } } } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub struct PWMC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT\\[1:0\\] and CT16B1_MAT\\[1:0\\]." ] pub mod pwmc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PWMC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PWMEN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN0R { # [ doc = "CT16Bn_MAT0 is controlled by EM0." ] CT16BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN0R :: CT16BN_MAT0_IS_CONTR => false , PWMEN0R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN0R { match value { false => PWMEN0R :: CT16BN_MAT0_IS_CONTR , true => PWMEN0R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT0_IS_CONTR`" ] # [ inline ] pub fn is_ct16bn_mat0_is_contr ( & self ) -> bool { * self == PWMEN0R :: CT16BN_MAT0_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN0R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN1R { # [ doc = "CT16Bn_MAT01 is controlled by EM1." ] CT16BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT16Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN1R :: CT16BN_MAT01_IS_CONT => false , PWMEN1R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN1R { match value { false => PWMEN1R :: CT16BN_MAT01_IS_CONT , true => PWMEN1R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT01_IS_CONT`" ] # [ inline ] pub fn is_ct16bn_mat01_is_cont ( & self ) -> bool { * self == PWMEN1R :: CT16BN_MAT01_IS_CONT } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN1R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN2R { # [ doc = "CT16Bn_MAT2 is controlled by EM2." ] CT16BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN2R :: CT16BN_MAT2_IS_CONTR => false , PWMEN2R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN2R { match value { false => PWMEN2R :: CT16BN_MAT2_IS_CONTR , true => PWMEN2R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT2_IS_CONTR`" ] # [ inline ] pub fn is_ct16bn_mat2_is_contr ( & self ) -> bool { * self == PWMEN2R :: CT16BN_MAT2_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN2R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN3R { # [ doc = "CT16Bn_MAT3 is controlled by EM3." ] CT16BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN3R :: CT16BN_MAT3_IS_CONTR => false , PWMEN3R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN3R { match value { false => PWMEN3R :: CT16BN_MAT3_IS_CONTR , true => PWMEN3R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT16BN_MAT3_IS_CONTR`" ] # [ inline ] pub fn is_ct16bn_mat3_is_contr ( & self ) -> bool { * self == PWMEN3R :: CT16BN_MAT3_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN3R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Values that can be written to the field `PWMEN0`" ] pub enum PWMEN0W { # [ doc = "CT16Bn_MAT0 is controlled by EM0." ] CT16BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN0W :: CT16BN_MAT0_IS_CONTR => false , PWMEN0W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN0W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT0 is controlled by EM0." ] # [ inline ] pub fn ct16bn_mat0_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: CT16BN_MAT0_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT0." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN1`" ] pub enum PWMEN1W { # [ doc = "CT16Bn_MAT01 is controlled by EM1." ] CT16BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT16Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN1W :: CT16BN_MAT01_IS_CONT => false , PWMEN1W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN1W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT01 is controlled by EM1." ] # [ inline ] pub fn ct16bn_mat01_is_cont ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: CT16BN_MAT01_IS_CONT ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT1." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN2`" ] pub enum PWMEN2W { # [ doc = "CT16Bn_MAT2 is controlled by EM2." ] CT16BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN2W :: CT16BN_MAT2_IS_CONTR => false , PWMEN2W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN2W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT2 is controlled by EM2." ] # [ inline ] pub fn ct16bn_mat2_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: CT16BN_MAT2_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT2." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN3`" ] pub enum PWMEN3W { # [ doc = "CT16Bn_MAT3 is controlled by EM3." ] CT16BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT16Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN3W :: CT16BN_MAT3_IS_CONTR => false , PWMEN3W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN3W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT16Bn_MAT3 is controlled by EM3." ] # [ inline ] pub fn ct16bn_mat3_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: CT16BN_MAT3_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT16Bn_MAT3." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & self ) -> PWMEN0R { PWMEN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & self ) -> PWMEN1R { PWMEN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & self ) -> PWMEN2R { PWMEN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - PWM mode enable for channel3." ] # [ inline ] pub fn pwmen3 ( & self ) -> PWMEN3R { PWMEN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & mut self ) -> _PWMEN0W { _PWMEN0W { w : self } } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & mut self ) -> _PWMEN1W { _PWMEN1W { w : self } } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & mut self ) -> _PWMEN2W { _PWMEN2W { w : self } } # [ doc = "Bit 3 - PWM mode enable for channel3." ] # [ inline ] pub fn pwmen3 ( & mut self ) -> _PWMEN3W { _PWMEN3W { w : self } } } } } # [ doc = "32-bit counter/timers CT32B0" ] pub struct CT32B0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for CT32B0 { } impl CT32B0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ct32b0 :: RegisterBlock { 0x4001_4000 as * const _ } } impl Deref for CT32B0 { type Target = ct32b0 :: RegisterBlock ; fn deref ( & self ) -> & ct32b0 :: RegisterBlock { unsafe { & * CT32B0 :: ptr ( ) } } } # [ doc = "32-bit counter/timers CT32B0" ] pub mod ct32b0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub ir : IR , # [ doc = "0x04 - Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub tcr : TCR , # [ doc = "0x08 - Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub tc : TC , # [ doc = "0x0c - Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub pr : PR , # [ doc = "0x10 - Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub pc : PC , # [ doc = "0x14 - Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mcr : MCR , # [ doc = "0x18 - Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mr : [ MR ; 4 ] , # [ doc = "0x28 - Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub ccr : CCR , # [ doc = "0x2c - Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input." ] pub cr0 : CR0 , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0x34 - Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT32B0_CAP1 input." ] pub cr1 : CR1 , _reserved1 : [ u8 ; 4usize ] , # [ doc = "0x3c - External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT\\[3:0\\]." ] pub emr : EMR , _reserved2 : [ u8 ; 48usize ] , # [ doc = "0x70 - Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub ctcr : CTCR , # [ doc = "0x74 - PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT\\[3:0\\]." ] pub pwmc : PWMC , } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub struct IR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub mod ir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MR0INTR { bits : bool , } impl MR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR1INTR { bits : bool , } impl MR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR2INTR { bits : bool , } impl MR2INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR3INTR { bits : bool , } impl MR3INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR0INTR { bits : bool , } impl CR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR1INTR { bits : bool , } impl CR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _MR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR2INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR2INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR3INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR3INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & self ) -> MR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR0INTR { bits } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & self ) -> MR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR1INTR { bits } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & self ) -> MR2INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR2INTR { bits } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & self ) -> MR3INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR3INTR { bits } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & self ) -> CR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR0INTR { bits } } # [ doc = "Bit 6 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & self ) -> CR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR1INTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & mut self ) -> _MR0INTW { _MR0INTW { w : self } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & mut self ) -> _MR1INTW { _MR1INTW { w : self } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & mut self ) -> _MR2INTW { _MR2INTW { w : self } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & mut self ) -> _MR3INTW { _MR3INTW { w : self } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & mut self ) -> _CR0INTW { _CR0INTW { w : self } } # [ doc = "Bit 6 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & mut self ) -> _CR1INTW { _CR1INTW { w : self } } } } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub struct TCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub mod tcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CENR { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CENR :: THE_COUNTERS_ARE_DIS => false , CENR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CENR { match value { false => CENR :: THE_COUNTERS_ARE_DIS , true => CENR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `THE_COUNTERS_ARE_DIS`" ] # [ inline ] pub fn is_the_counters_are_dis ( & self ) -> bool { * self == CENR :: THE_COUNTERS_ARE_DIS } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CENR :: THE_TIMER_COUNTER_AN } } # [ doc = "Possible values of the field `CRST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRSTR { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CRSTR :: DO_NOTHING_ => false , CRSTR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CRSTR { match value { false => CRSTR :: DO_NOTHING_ , true => CRSTR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == CRSTR :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CRSTR :: THE_TIMER_COUNTER_AN } } # [ doc = "Values that can be written to the field `CEN`" ] pub enum CENW { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CENW :: THE_COUNTERS_ARE_DIS => false , CENW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CENW < 'a > { w : & 'a mut W , } impl < 'a > _CENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The counters are disabled." ] # [ inline ] pub fn the_counters_are_dis ( self ) -> & 'a mut W { self . variant ( CENW :: THE_COUNTERS_ARE_DIS ) } # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CENW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CRST`" ] pub enum CRSTW { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CRSTW :: DO_NOTHING_ => false , CRSTW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CRSTW < 'a > { w : & 'a mut W , } impl < 'a > _CRSTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CRSTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Do nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( CRSTW :: DO_NOTHING_ ) } # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CRSTW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & self ) -> CENR { CENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & self ) -> CRSTR { CRSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & mut self ) -> _CENW { _CENW { w : self } } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & mut self ) -> _CRSTW { _CRSTW { w : self } } } } # [ doc = "Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub struct TC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub mod tc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TCR { bits : u32 , } impl TCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _TCW < 'a > { w : & 'a mut W , } impl < 'a > _TCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter value." ] # [ inline ] pub fn tc ( & self ) -> TCR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; TCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Timer counter value." ] # [ inline ] pub fn tc ( & mut self ) -> _TCW { _TCW { w : self } } } } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub struct PR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub mod pr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCVALR { bits : u32 , } impl PCVALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCVALW < 'a > { w : & 'a mut W , } impl < 'a > _PCVALW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Prescaler value." ] # [ inline ] pub fn pcval ( & self ) -> PCVALR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PCVALR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Prescaler value." ] # [ inline ] pub fn pcval ( & mut self ) -> _PCVALW { _PCVALW { w : self } } } } # [ doc = "Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub struct PC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub mod pc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCR { bits : u32 , } impl PCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCW < 'a > { w : & 'a mut W , } impl < 'a > _PCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Prescale counter value." ] # [ inline ] pub fn pc ( & self ) -> PCR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Prescale counter value." ] # [ inline ] pub fn pc ( & mut self ) -> _PCW { _PCW { w : self } } } } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub struct MCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mod mcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MR0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0IR :: ENABLED => true , MR0IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0IR { match value { true => MR0IR :: ENABLED , false => MR0IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0IR :: DISABLED } } # [ doc = "Possible values of the field `MR0R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0RR :: ENABLED => true , MR0RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0RR { match value { true => MR0RR :: ENABLED , false => MR0RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0RR :: DISABLED } } # [ doc = "Possible values of the field `MR0S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0SR :: ENABLED => true , MR0SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0SR { match value { true => MR0SR :: ENABLED , false => MR0SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0SR :: DISABLED } } # [ doc = "Possible values of the field `MR1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1IR :: ENABLED => true , MR1IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1IR { match value { true => MR1IR :: ENABLED , false => MR1IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1IR :: DISABLED } } # [ doc = "Possible values of the field `MR1R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1RR :: ENABLED => true , MR1RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1RR { match value { true => MR1RR :: ENABLED , false => MR1RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1RR :: DISABLED } } # [ doc = "Possible values of the field `MR1S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1SR :: ENABLED => true , MR1SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1SR { match value { true => MR1SR :: ENABLED , false => MR1SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1SR :: DISABLED } } # [ doc = "Possible values of the field `MR2I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2IR :: ENABLED => true , MR2IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2IR { match value { true => MR2IR :: ENABLED , false => MR2IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2IR :: DISABLED } } # [ doc = "Possible values of the field `MR2R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2RR :: ENABLED => true , MR2RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2RR { match value { true => MR2RR :: ENABLED , false => MR2RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2RR :: DISABLED } } # [ doc = "Possible values of the field `MR2S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2SR :: ENABLED => true , MR2SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2SR { match value { true => MR2SR :: ENABLED , false => MR2SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2SR :: DISABLED } } # [ doc = "Possible values of the field `MR3I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3IR :: ENABLED => true , MR3IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3IR { match value { true => MR3IR :: ENABLED , false => MR3IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3IR :: DISABLED } } # [ doc = "Possible values of the field `MR3R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3RR :: ENABLED => true , MR3RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3RR { match value { true => MR3RR :: ENABLED , false => MR3RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3RR :: DISABLED } } # [ doc = "Possible values of the field `MR3S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3SR :: ENABLED => true , MR3SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3SR { match value { true => MR3SR :: ENABLED , false => MR3SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3SR :: DISABLED } } # [ doc = "Values that can be written to the field `MR0I`" ] pub enum MR0IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0IW :: ENABLED => true , MR0IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0IW < 'a > { w : & 'a mut W , } impl < 'a > _MR0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0R`" ] pub enum MR0RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0RW :: ENABLED => true , MR0RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0RW < 'a > { w : & 'a mut W , } impl < 'a > _MR0RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0S`" ] pub enum MR0SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0SW :: ENABLED => true , MR0SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0SW < 'a > { w : & 'a mut W , } impl < 'a > _MR0SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1I`" ] pub enum MR1IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1IW :: ENABLED => true , MR1IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1IW < 'a > { w : & 'a mut W , } impl < 'a > _MR1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1R`" ] pub enum MR1RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1RW :: ENABLED => true , MR1RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1RW < 'a > { w : & 'a mut W , } impl < 'a > _MR1RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1S`" ] pub enum MR1SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1SW :: ENABLED => true , MR1SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1SW < 'a > { w : & 'a mut W , } impl < 'a > _MR1SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2I`" ] pub enum MR2IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2IW :: ENABLED => true , MR2IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2IW < 'a > { w : & 'a mut W , } impl < 'a > _MR2IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2R`" ] pub enum MR2RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2RW :: ENABLED => true , MR2RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2RW < 'a > { w : & 'a mut W , } impl < 'a > _MR2RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2S`" ] pub enum MR2SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2SW :: ENABLED => true , MR2SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2SW < 'a > { w : & 'a mut W , } impl < 'a > _MR2SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3I`" ] pub enum MR3IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3IW :: ENABLED => true , MR3IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3IW < 'a > { w : & 'a mut W , } impl < 'a > _MR3IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3R`" ] pub enum MR3RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3RW :: ENABLED => true , MR3RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3RW < 'a > { w : & 'a mut W , } impl < 'a > _MR3RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3S`" ] pub enum MR3SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3SW :: ENABLED => true , MR3SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3SW < 'a > { w : & 'a mut W , } impl < 'a > _MR3SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & self ) -> MR0IR { MR0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & self ) -> MR0RR { MR0RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & self ) -> MR0SR { MR0SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & self ) -> MR1IR { MR1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & self ) -> MR1RR { MR1RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & self ) -> MR1SR { MR1SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & self ) -> MR2IR { MR2IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & self ) -> MR2RR { MR2RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & self ) -> MR2SR { MR2SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & self ) -> MR3IR { MR3IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & self ) -> MR3RR { MR3RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & self ) -> MR3SR { MR3SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & mut self ) -> _MR0IW { _MR0IW { w : self } } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & mut self ) -> _MR0RW { _MR0RW { w : self } } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & mut self ) -> _MR0SW { _MR0SW { w : self } } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & mut self ) -> _MR1IW { _MR1IW { w : self } } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & mut self ) -> _MR1RW { _MR1RW { w : self } } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & mut self ) -> _MR1SW { _MR1SW { w : self } } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & mut self ) -> _MR2IW { _MR2IW { w : self } } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & mut self ) -> _MR2RW { _MR2RW { w : self } } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & mut self ) -> _MR2SW { _MR2SW { w : self } } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & mut self ) -> _MR3IW { _MR3IW { w : self } } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & mut self ) -> _MR3RW { _MR3RW { w : self } } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & mut self ) -> _MR3SW { _MR3SW { w : self } } } } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub struct MR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mod mr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MATCHR { bits : u32 , } impl MATCHR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _MATCHW < 'a > { w : & 'a mut W , } impl < 'a > _MATCHW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter match value." ] # [ inline ] pub fn match_ ( & self ) -> MATCHR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; MATCHR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Timer counter match value." ] # [ inline ] pub fn match_ ( & mut self ) -> _MATCHW { _MATCHW { w : self } } } } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub struct CCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub mod ccr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CAP0RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0RER :: ENABLED_ => true , CAP0RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0RER { match value { true => CAP0RER :: ENABLED_ , false => CAP0RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0FER :: ENABLED_ => true , CAP0FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0FER { match value { true => CAP0FER :: ENABLED_ , false => CAP0FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0IR :: ENABLED_ => true , CAP0IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0IR { match value { true => CAP0IR :: ENABLED_ , false => CAP0IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0IR :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1RER :: ENABLED_ => true , CAP1RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1RER { match value { true => CAP1RER :: ENABLED_ , false => CAP1RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1FER :: ENABLED_ => true , CAP1FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1FER { match value { true => CAP1FER :: ENABLED_ , false => CAP1FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1IR :: ENABLED_ => true , CAP1IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1IR { match value { true => CAP1IR :: ENABLED_ , false => CAP1IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1IR :: DISABLED_ } } # [ doc = "Values that can be written to the field `CAP0RE`" ] pub enum CAP0REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0REW :: ENABLED_ => true , CAP0REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0FE`" ] pub enum CAP0FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0FEW :: ENABLED_ => true , CAP0FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0I`" ] pub enum CAP0IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0IW :: ENABLED_ => true , CAP0IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1RE`" ] pub enum CAP1REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1REW :: ENABLED_ => true , CAP1REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1FE`" ] pub enum CAP1FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1FEW :: ENABLED_ => true , CAP1FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1I`" ] pub enum CAP1IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1IW :: ENABLED_ => true , CAP1IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Capture on CT32B0_CAP0 rising edge: a sequence of 0 then 1 on CT32B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & self ) -> CAP0RER { CAP0RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Capture on CT32B0_CAP0 falling edge: a sequence of 1 then 0 on CT32B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & self ) -> CAP0FER { CAP0FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Interrupt on CT32B0_CAP0 event: a CR0 load due to a CT32B0_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & self ) -> CAP0IR { CAP0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Capture on CT32B0_CAP1 rising edge: a sequence of 0 then 1 on CT32B0_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1re ( & self ) -> CAP1RER { CAP1RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Capture on CT32B0_CAP1 falling edge: a sequence of 1 then 0 on CT32B0_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1fe ( & self ) -> CAP1FER { CAP1FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Interrupt on CT32B0_CAP1 event: a CR1 load due to a CT32B0_CAP1 event will generate an interrupt." ] # [ inline ] pub fn cap1i ( & self ) -> CAP1IR { CAP1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Capture on CT32B0_CAP0 rising edge: a sequence of 0 then 1 on CT32B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & mut self ) -> _CAP0REW { _CAP0REW { w : self } } # [ doc = "Bit 1 - Capture on CT32B0_CAP0 falling edge: a sequence of 1 then 0 on CT32B0_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & mut self ) -> _CAP0FEW { _CAP0FEW { w : self } } # [ doc = "Bit 2 - Interrupt on CT32B0_CAP0 event: a CR0 load due to a CT32B0_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & mut self ) -> _CAP0IW { _CAP0IW { w : self } } # [ doc = "Bit 6 - Capture on CT32B0_CAP1 rising edge: a sequence of 0 then 1 on CT32B0_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1re ( & mut self ) -> _CAP1REW { _CAP1REW { w : self } } # [ doc = "Bit 7 - Capture on CT32B0_CAP1 falling edge: a sequence of 1 then 0 on CT32B0_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1fe ( & mut self ) -> _CAP1FEW { _CAP1FEW { w : self } } # [ doc = "Bit 8 - Interrupt on CT32B0_CAP1 event: a CR1 load due to a CT32B0_CAP1 event will generate an interrupt." ] # [ inline ] pub fn cap1i ( & mut self ) -> _CAP1IW { _CAP1IW { w : self } } } } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input." ] pub struct CR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input." ] pub mod cr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: CR0 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u32 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; CAPR { bits } } } } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT32B0_CAP1 input." ] pub struct CR1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT32B0_CAP1 input." ] pub mod cr1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CR1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u32 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _CAPW < 'a > { w : & 'a mut W , } impl < 'a > _CAPW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; CAPR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Timer counter capture value." ] # [ inline ] pub fn cap ( & mut self ) -> _CAPW { _CAPW { w : self } } } } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT\\[3:0\\]." ] pub struct EMR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT\\[3:0\\]." ] pub mod emr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EMR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EM0R { bits : bool , } impl EM0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM1R { bits : bool , } impl EM1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM2R { bits : bool , } impl EM2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM3R { bits : bool , } impl EM3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `EMC0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC0R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC0R :: DO_NOTHING_ => 0 , EMC0R :: CLEAR_THE_CORRESPOND => 0x01 , EMC0R :: SET_THE_CORRESPONDIN => 0x02 , EMC0R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC0R { match value { 0 => EMC0R :: DO_NOTHING_ , 1 => EMC0R :: CLEAR_THE_CORRESPOND , 2 => EMC0R :: SET_THE_CORRESPONDIN , 3 => EMC0R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC0R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC0R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC0R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC0R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC1R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC1R :: DO_NOTHING_ => 0 , EMC1R :: CLEAR_THE_CORRESPOND => 0x01 , EMC1R :: SET_THE_CORRESPONDIN => 0x02 , EMC1R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC1R { match value { 0 => EMC1R :: DO_NOTHING_ , 1 => EMC1R :: CLEAR_THE_CORRESPOND , 2 => EMC1R :: SET_THE_CORRESPONDIN , 3 => EMC1R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC1R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC1R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC1R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC1R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC2R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC2R :: DO_NOTHING_ => 0 , EMC2R :: CLEAR_THE_CORRESPOND => 0x01 , EMC2R :: SET_THE_CORRESPONDIN => 0x02 , EMC2R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC2R { match value { 0 => EMC2R :: DO_NOTHING_ , 1 => EMC2R :: CLEAR_THE_CORRESPOND , 2 => EMC2R :: SET_THE_CORRESPONDIN , 3 => EMC2R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC2R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC2R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC2R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC2R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC3R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC3R :: DO_NOTHING_ => 0 , EMC3R :: CLEAR_THE_CORRESPOND => 0x01 , EMC3R :: SET_THE_CORRESPONDIN => 0x02 , EMC3R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC3R { match value { 0 => EMC3R :: DO_NOTHING_ , 1 => EMC3R :: CLEAR_THE_CORRESPOND , 2 => EMC3R :: SET_THE_CORRESPONDIN , 3 => EMC3R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC3R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC3R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC3R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC3R :: TOGGLE_THE_CORRESPON } } # [ doc = r" Proxy" ] pub struct _EM0W < 'a > { w : & 'a mut W , } impl < 'a > _EM0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM1W < 'a > { w : & 'a mut W , } impl < 'a > _EM1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM2W < 'a > { w : & 'a mut W , } impl < 'a > _EM2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM3W < 'a > { w : & 'a mut W , } impl < 'a > _EM3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC0`" ] pub enum EMC0W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC0W :: DO_NOTHING_ => 0 , EMC0W :: CLEAR_THE_CORRESPOND => 1 , EMC0W :: SET_THE_CORRESPONDIN => 2 , EMC0W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC0W < 'a > { w : & 'a mut W , } impl < 'a > _EMC0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC0W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC0W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC0W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC0W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC0W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC1`" ] pub enum EMC1W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC1W :: DO_NOTHING_ => 0 , EMC1W :: CLEAR_THE_CORRESPOND => 1 , EMC1W :: SET_THE_CORRESPONDIN => 2 , EMC1W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC1W < 'a > { w : & 'a mut W , } impl < 'a > _EMC1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC1W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC1W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT1 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC1W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT1 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC1W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC1W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC2`" ] pub enum EMC2W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC2W :: DO_NOTHING_ => 0 , EMC2W :: CLEAR_THE_CORRESPOND => 1 , EMC2W :: SET_THE_CORRESPONDIN => 2 , EMC2W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC2W < 'a > { w : & 'a mut W , } impl < 'a > _EMC2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC2W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC2W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT2 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC2W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT2 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC2W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC2W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC3`" ] pub enum EMC3W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC3W :: DO_NOTHING_ => 0 , EMC3W :: CLEAR_THE_CORRESPOND => 1 , EMC3W :: SET_THE_CORRESPONDIN => 2 , EMC3W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC3W < 'a > { w : & 'a mut W , } impl < 'a > _EMC3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC3W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC3W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT3 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC3W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT3 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC3W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC3W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT32B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & self ) -> EM0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM0R { bits } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT32B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & self ) -> EM1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM1R { bits } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT32B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em2 ( & self ) -> EM2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM2R { bits } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output. This bit is driven to the CT32B3_MAT0/CT32B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em3 ( & self ) -> EM3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM3R { bits } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0." ] # [ inline ] pub fn emc0 ( & self ) -> EMC0R { EMC0R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & self ) -> EMC1R { EMC1R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & self ) -> EMC2R { EMC2R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & self ) -> EMC3R { EMC3R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT32B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & mut self ) -> _EM0W { _EM0W { w : self } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT32B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & mut self ) -> _EM1W { _EM1W { w : self } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT32B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em2 ( & mut self ) -> _EM2W { _EM2W { w : self } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output. This bit is driven to the CT32B3_MAT0/CT32B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em3 ( & mut self ) -> _EM3W { _EM3W { w : self } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0." ] # [ inline ] pub fn emc0 ( & mut self ) -> _EMC0W { _EMC0W { w : self } } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & mut self ) -> _EMC1W { _EMC1W { w : self } } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & mut self ) -> _EMC2W { _EMC2W { w : self } } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & mut self ) -> _EMC3W { _EMC3W { w : self } } } } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub struct CTCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub mod ctcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CTCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CTM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CTMR { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CTMR :: TIMER_MODE_EVERY_RI => 0 , CTMR :: COUNTER_MODE_TC_IS_RISING => 0x01 , CTMR :: COUNTER_MODE_TC_IS_FALLING => 0x02 , CTMR :: COUNTER_MODE_TC_IS_BOTH => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CTMR { match value { 0 => CTMR :: TIMER_MODE_EVERY_RI , 1 => CTMR :: COUNTER_MODE_TC_IS_RISING , 2 => CTMR :: COUNTER_MODE_TC_IS_FALLING , 3 => CTMR :: COUNTER_MODE_TC_IS_BOTH , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `TIMER_MODE_EVERY_RI`" ] # [ inline ] pub fn is_timer_mode_every_ri ( & self ) -> bool { * self == CTMR :: TIMER_MODE_EVERY_RI } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_RISING`" ] # [ inline ] pub fn is_counter_mode_tc_is_rising ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_RISING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_FALLING`" ] # [ inline ] pub fn is_counter_mode_tc_is_falling ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_FALLING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_BOTH`" ] # [ inline ] pub fn is_counter_mode_tc_is_both ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_BOTH } } # [ doc = "Possible values of the field `CIS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CISR { # [ doc = "CT32B0_CAP0" ] CT32B0_CAP0 , # [ doc = "Reserved." ] RESERVED_1 , # [ doc = "CT32B0_CAP1" ] CT32B0_CAP1 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl CISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CISR :: CT32B0_CAP0 => 0 , CISR :: RESERVED_1 => 0x01 , CISR :: CT32B0_CAP1 => 0x02 , CISR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CISR { match value { 0 => CISR :: CT32B0_CAP0 , 1 => CISR :: RESERVED_1 , 2 => CISR :: CT32B0_CAP1 , i => CISR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `CT32B0_CAP0`" ] # [ inline ] pub fn is_ct32b0_cap0 ( & self ) -> bool { * self == CISR :: CT32B0_CAP0 } # [ doc = "Checks if the value of the field is `RESERVED_1`" ] # [ inline ] pub fn is_reserved_1 ( & self ) -> bool { * self == CISR :: RESERVED_1 } # [ doc = "Checks if the value of the field is `CT32B0_CAP1`" ] # [ inline ] pub fn is_ct32b0_cap1 ( & self ) -> bool { * self == CISR :: CT32B0_CAP1 } } # [ doc = r" Value of the field" ] pub struct ENCCR { bits : bool , } impl ENCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `SElCC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELCCR { # [ doc = "Rising Edge of CT32B0_CAP0 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP0 , # [ doc = "Falling Edge of CT32B0_CAP0 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP0 , # [ doc = "Reserved," ] RESERVED_2 , # [ doc = "Reserved." ] RESERVED_3 , # [ doc = "Rising Edge of CT32B0_CAP1 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP1 , # [ doc = "Falling Edge of CT32B0_CAP1 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP1 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SELCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELCCR :: RISING_EDGE_OF_CT32B_CAP0 => 0 , SELCCR :: FALLING_EDGE_OF_CT32_CAP0 => 0x01 , SELCCR :: RESERVED_2 => 0x02 , SELCCR :: RESERVED_3 => 0x03 , SELCCR :: RISING_EDGE_OF_CT32B_CAP1 => 0x04 , SELCCR :: FALLING_EDGE_OF_CT32_CAP1 => 0x05 , SELCCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELCCR { match value { 0 => SELCCR :: RISING_EDGE_OF_CT32B_CAP0 , 1 => SELCCR :: FALLING_EDGE_OF_CT32_CAP0 , 2 => SELCCR :: RESERVED_2 , 3 => SELCCR :: RESERVED_3 , 4 => SELCCR :: RISING_EDGE_OF_CT32B_CAP1 , 5 => SELCCR :: FALLING_EDGE_OF_CT32_CAP1 , i => SELCCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT32B_CAP0`" ] # [ inline ] pub fn is_rising_edge_of_ct32b_cap0 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT32B_CAP0 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT32_CAP0`" ] # [ inline ] pub fn is_falling_edge_of_ct32_cap0 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT32_CAP0 } # [ doc = "Checks if the value of the field is `RESERVED_2`" ] # [ inline ] pub fn is_reserved_2 ( & self ) -> bool { * self == SELCCR :: RESERVED_2 } # [ doc = "Checks if the value of the field is `RESERVED_3`" ] # [ inline ] pub fn is_reserved_3 ( & self ) -> bool { * self == SELCCR :: RESERVED_3 } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT32B_CAP1`" ] # [ inline ] pub fn is_rising_edge_of_ct32b_cap1 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT32B_CAP1 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT32_CAP1`" ] # [ inline ] pub fn is_falling_edge_of_ct32_cap1 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT32_CAP1 } } # [ doc = "Values that can be written to the field `CTM`" ] pub enum CTMW { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CTMW :: TIMER_MODE_EVERY_RI => 0 , CTMW :: COUNTER_MODE_TC_IS_RISING => 1 , CTMW :: COUNTER_MODE_TC_IS_FALLING => 2 , CTMW :: COUNTER_MODE_TC_IS_BOTH => 3 } } } # [ doc = r" Proxy" ] pub struct _CTMW < 'a > { w : & 'a mut W , } impl < 'a > _CTMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CTMW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Timer Mode: every rising PCLK edge" ] # [ inline ] pub fn timer_mode_every_ri ( self ) -> & 'a mut W { self . variant ( CTMW :: TIMER_MODE_EVERY_RI ) } # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_rising ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_RISING ) } # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_falling ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_FALLING ) } # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_both ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_BOTH ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CIS`" ] pub enum CISW { # [ doc = "CT32B0_CAP0" ] CT32B0_CAP0 , # [ doc = "Reserved." ] RESERVED_1 , # [ doc = "CT32B0_CAP1" ] CT32B0_CAP1 } impl CISW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CISW :: CT32B0_CAP0 => 0 , CISW :: RESERVED_1 => 1 , CISW :: CT32B0_CAP1 => 2 } } } # [ doc = r" Proxy" ] pub struct _CISW < 'a > { w : & 'a mut W , } impl < 'a > _CISW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CISW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CT32B0_CAP0" ] # [ inline ] pub fn ct32b0_cap0 ( self ) -> & 'a mut W { self . variant ( CISW :: CT32B0_CAP0 ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_1 ( self ) -> & 'a mut W { self . variant ( CISW :: RESERVED_1 ) } # [ doc = "CT32B0_CAP1" ] # [ inline ] pub fn ct32b0_cap1 ( self ) -> & 'a mut W { self . variant ( CISW :: CT32B0_CAP1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENCCW < 'a > { w : & 'a mut W , } impl < 'a > _ENCCW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SElCC`" ] pub enum SELCCW { # [ doc = "Rising Edge of CT32B0_CAP0 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP0 , # [ doc = "Falling Edge of CT32B0_CAP0 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP0 , # [ doc = "Reserved," ] RESERVED_2 , # [ doc = "Reserved." ] RESERVED_3 , # [ doc = "Rising Edge of CT32B0_CAP1 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP1 , # [ doc = "Falling Edge of CT32B0_CAP1 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP1 } impl SELCCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELCCW :: RISING_EDGE_OF_CT32B_CAP0 => 0 , SELCCW :: FALLING_EDGE_OF_CT32_CAP0 => 1 , SELCCW :: RESERVED_2 => 2 , SELCCW :: RESERVED_3 => 3 , SELCCW :: RISING_EDGE_OF_CT32B_CAP1 => 4 , SELCCW :: FALLING_EDGE_OF_CT32_CAP1 => 5 } } } # [ doc = r" Proxy" ] pub struct _SELCCW < 'a > { w : & 'a mut W , } impl < 'a > _SELCCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELCCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Rising Edge of CT32B0_CAP0 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn rising_edge_of_ct32b_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT32B_CAP0 ) } # [ doc = "Falling Edge of CT32B0_CAP0 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn falling_edge_of_ct32_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT32_CAP0 ) } # [ doc = "Reserved," ] # [ inline ] pub fn reserved_2 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RESERVED_2 ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_3 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RESERVED_3 ) } # [ doc = "Rising Edge of CT32B0_CAP1 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn rising_edge_of_ct32b_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT32B_CAP1 ) } # [ doc = "Falling Edge of CT32B0_CAP1 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn falling_edge_of_ct32_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT32_CAP1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & self ) -> CTMR { CTMR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. If Counter mode is selected in the CTCR, the 3 bits for that input in the Capture Control Register (CCR) must be programmed as 000. Values 0x1 and0x3 are reserved." ] # [ inline ] pub fn cis ( & self ) -> CISR { CISR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & self ) -> ENCCR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENCCR { bits } } # [ doc = "Bits 5:7 - When bit 4 is a 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved." ] # [ inline ] pub fn sel_cc ( & self ) -> SELCCR { SELCCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & mut self ) -> _CTMW { _CTMW { w : self } } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. If Counter mode is selected in the CTCR, the 3 bits for that input in the Capture Control Register (CCR) must be programmed as 000. Values 0x1 and0x3 are reserved." ] # [ inline ] pub fn cis ( & mut self ) -> _CISW { _CISW { w : self } } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & mut self ) -> _ENCCW { _ENCCW { w : self } } # [ doc = "Bits 5:7 - When bit 4 is a 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved." ] # [ inline ] pub fn sel_cc ( & mut self ) -> _SELCCW { _SELCCW { w : self } } } } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT\\[3:0\\]." ] pub struct PWMC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT\\[3:0\\]." ] pub mod pwmc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PWMC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PWMEN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN0R { # [ doc = "CT32Bn_MAT0 is controlled by EM0." ] CT32BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN0R :: CT32BN_MAT0_IS_CONTR => false , PWMEN0R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN0R { match value { false => PWMEN0R :: CT32BN_MAT0_IS_CONTR , true => PWMEN0R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT0_IS_CONTR`" ] # [ inline ] pub fn is_ct32bn_mat0_is_contr ( & self ) -> bool { * self == PWMEN0R :: CT32BN_MAT0_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN0R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN1R { # [ doc = "CT32Bn_MAT01 is controlled by EM1." ] CT32BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT32Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN1R :: CT32BN_MAT01_IS_CONT => false , PWMEN1R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN1R { match value { false => PWMEN1R :: CT32BN_MAT01_IS_CONT , true => PWMEN1R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT01_IS_CONT`" ] # [ inline ] pub fn is_ct32bn_mat01_is_cont ( & self ) -> bool { * self == PWMEN1R :: CT32BN_MAT01_IS_CONT } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN1R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN2R { # [ doc = "CT32Bn_MAT2 is controlled by EM2." ] CT32BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN2R :: CT32BN_MAT2_IS_CONTR => false , PWMEN2R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN2R { match value { false => PWMEN2R :: CT32BN_MAT2_IS_CONTR , true => PWMEN2R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT2_IS_CONTR`" ] # [ inline ] pub fn is_ct32bn_mat2_is_contr ( & self ) -> bool { * self == PWMEN2R :: CT32BN_MAT2_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN2R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN3R { # [ doc = "CT32Bn_MAT3 is controlled by EM3." ] CT32BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT132Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN3R :: CT32BN_MAT3_IS_CONTR => false , PWMEN3R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN3R { match value { false => PWMEN3R :: CT32BN_MAT3_IS_CONTR , true => PWMEN3R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT3_IS_CONTR`" ] # [ inline ] pub fn is_ct32bn_mat3_is_contr ( & self ) -> bool { * self == PWMEN3R :: CT32BN_MAT3_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN3R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Values that can be written to the field `PWMEN0`" ] pub enum PWMEN0W { # [ doc = "CT32Bn_MAT0 is controlled by EM0." ] CT32BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN0W :: CT32BN_MAT0_IS_CONTR => false , PWMEN0W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN0W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT0 is controlled by EM0." ] # [ inline ] pub fn ct32bn_mat0_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: CT32BN_MAT0_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT32Bn_MAT0." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN1`" ] pub enum PWMEN1W { # [ doc = "CT32Bn_MAT01 is controlled by EM1." ] CT32BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT32Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN1W :: CT32BN_MAT01_IS_CONT => false , PWMEN1W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN1W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT01 is controlled by EM1." ] # [ inline ] pub fn ct32bn_mat01_is_cont ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: CT32BN_MAT01_IS_CONT ) } # [ doc = "PWM mode is enabled for CT32Bn_MAT1." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN2`" ] pub enum PWMEN2W { # [ doc = "CT32Bn_MAT2 is controlled by EM2." ] CT32BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN2W :: CT32BN_MAT2_IS_CONTR => false , PWMEN2W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN2W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT2 is controlled by EM2." ] # [ inline ] pub fn ct32bn_mat2_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: CT32BN_MAT2_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT32Bn_MAT2." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN3`" ] pub enum PWMEN3W { # [ doc = "CT32Bn_MAT3 is controlled by EM3." ] CT32BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT132Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN3W :: CT32BN_MAT3_IS_CONTR => false , PWMEN3W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN3W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT3 is controlled by EM3." ] # [ inline ] pub fn ct32bn_mat3_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: CT32BN_MAT3_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT132Bn_MAT3." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & self ) -> PWMEN0R { PWMEN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & self ) -> PWMEN1R { PWMEN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & self ) -> PWMEN2R { PWMEN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle." ] # [ inline ] pub fn pwmen3 ( & self ) -> PWMEN3R { PWMEN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & mut self ) -> _PWMEN0W { _PWMEN0W { w : self } } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & mut self ) -> _PWMEN1W { _PWMEN1W { w : self } } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & mut self ) -> _PWMEN2W { _PWMEN2W { w : self } } # [ doc = "Bit 3 - PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle." ] # [ inline ] pub fn pwmen3 ( & mut self ) -> _PWMEN3W { _PWMEN3W { w : self } } } } } # [ doc = "32-bit counter/timers CT32B1" ] pub struct CT32B1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for CT32B1 { } impl CT32B1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ct32b1 :: RegisterBlock { 0x4001_8000 as * const _ } } impl Deref for CT32B1 { type Target = ct32b1 :: RegisterBlock ; fn deref ( & self ) -> & ct32b1 :: RegisterBlock { unsafe { & * CT32B1 :: ptr ( ) } } } # [ doc = "32-bit counter/timers CT32B1" ] pub mod ct32b1 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub ir : IR , # [ doc = "0x04 - Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub tcr : TCR , # [ doc = "0x08 - Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub tc : TC , # [ doc = "0x0c - Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub pr : PR , # [ doc = "0x10 - Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub pc : PC , # [ doc = "0x14 - Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mcr : MCR , # [ doc = "0x18 - Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mr : [ MR ; 4 ] , # [ doc = "0x28 - Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub ccr : CCR , # [ doc = "0x2c - Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input." ] pub cr0 : CR0 , # [ doc = "0x30 - Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT32B1_CAP1 input." ] pub cr1 : CR1 , _reserved0 : [ u8 ; 8usize ] , # [ doc = "0x3c - External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT\\[3:0\\]." ] pub emr : EMR , _reserved1 : [ u8 ; 48usize ] , # [ doc = "0x70 - Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub ctcr : CTCR , # [ doc = "0x74 - PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT\\[3:0\\]." ] pub pwmc : PWMC , } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub struct IR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending." ] pub mod ir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MR0INTR { bits : bool , } impl MR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR1INTR { bits : bool , } impl MR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR2INTR { bits : bool , } impl MR2INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MR3INTR { bits : bool , } impl MR3INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR0INTR { bits : bool , } impl CR0INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct CR1INTR { bits : bool , } impl CR1INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _MR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR2INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR2INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MR3INTW < 'a > { w : & 'a mut W , } impl < 'a > _MR3INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR0INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR0INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CR1INTW < 'a > { w : & 'a mut W , } impl < 'a > _CR1INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & self ) -> MR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR0INTR { bits } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & self ) -> MR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR1INTR { bits } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & self ) -> MR2INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR2INTR { bits } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & self ) -> MR3INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MR3INTR { bits } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & self ) -> CR0INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR0INTR { bits } } # [ doc = "Bit 5 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & self ) -> CR1INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; CR1INTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt flag for match channel 0." ] # [ inline ] pub fn mr0int ( & mut self ) -> _MR0INTW { _MR0INTW { w : self } } # [ doc = "Bit 1 - Interrupt flag for match channel 1." ] # [ inline ] pub fn mr1int ( & mut self ) -> _MR1INTW { _MR1INTW { w : self } } # [ doc = "Bit 2 - Interrupt flag for match channel 2." ] # [ inline ] pub fn mr2int ( & mut self ) -> _MR2INTW { _MR2INTW { w : self } } # [ doc = "Bit 3 - Interrupt flag for match channel 3." ] # [ inline ] pub fn mr3int ( & mut self ) -> _MR3INTW { _MR3INTW { w : self } } # [ doc = "Bit 4 - Interrupt flag for capture channel 0 event." ] # [ inline ] pub fn cr0int ( & mut self ) -> _CR0INTW { _CR0INTW { w : self } } # [ doc = "Bit 5 - Interrupt flag for capture channel 1 event." ] # [ inline ] pub fn cr1int ( & mut self ) -> _CR1INTW { _CR1INTW { w : self } } } } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub struct TCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR." ] pub mod tcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CENR { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CENR :: THE_COUNTERS_ARE_DIS => false , CENR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CENR { match value { false => CENR :: THE_COUNTERS_ARE_DIS , true => CENR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `THE_COUNTERS_ARE_DIS`" ] # [ inline ] pub fn is_the_counters_are_dis ( & self ) -> bool { * self == CENR :: THE_COUNTERS_ARE_DIS } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CENR :: THE_TIMER_COUNTER_AN } } # [ doc = "Possible values of the field `CRST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRSTR { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CRSTR :: DO_NOTHING_ => false , CRSTR :: THE_TIMER_COUNTER_AN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CRSTR { match value { false => CRSTR :: DO_NOTHING_ , true => CRSTR :: THE_TIMER_COUNTER_AN , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == CRSTR :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `THE_TIMER_COUNTER_AN`" ] # [ inline ] pub fn is_the_timer_counter_an ( & self ) -> bool { * self == CRSTR :: THE_TIMER_COUNTER_AN } } # [ doc = "Values that can be written to the field `CEN`" ] pub enum CENW { # [ doc = "The counters are disabled." ] THE_COUNTERS_ARE_DIS , # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] THE_TIMER_COUNTER_AN } impl CENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CENW :: THE_COUNTERS_ARE_DIS => false , CENW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CENW < 'a > { w : & 'a mut W , } impl < 'a > _CENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The counters are disabled." ] # [ inline ] pub fn the_counters_are_dis ( self ) -> & 'a mut W { self . variant ( CENW :: THE_COUNTERS_ARE_DIS ) } # [ doc = "The Timer Counter and Prescale Counter are enabled for counting." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CENW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CRST`" ] pub enum CRSTW { # [ doc = "Do nothing." ] DO_NOTHING_ , # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] THE_TIMER_COUNTER_AN } impl CRSTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CRSTW :: DO_NOTHING_ => false , CRSTW :: THE_TIMER_COUNTER_AN => true } } } # [ doc = r" Proxy" ] pub struct _CRSTW < 'a > { w : & 'a mut W , } impl < 'a > _CRSTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CRSTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Do nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( CRSTW :: DO_NOTHING_ ) } # [ doc = "The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR\\[1\\] is returned to zero." ] # [ inline ] pub fn the_timer_counter_an ( self ) -> & 'a mut W { self . variant ( CRSTW :: THE_TIMER_COUNTER_AN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & self ) -> CENR { CENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & self ) -> CRSTR { CRSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Counter enable." ] # [ inline ] pub fn cen ( & mut self ) -> _CENW { _CENW { w : self } } # [ doc = "Bit 1 - Counter reset." ] # [ inline ] pub fn crst ( & mut self ) -> _CRSTW { _CRSTW { w : self } } } } # [ doc = "Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub struct TC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR." ] pub mod tc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TCR { bits : u32 , } impl TCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _TCW < 'a > { w : & 'a mut W , } impl < 'a > _TCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter value." ] # [ inline ] pub fn tc ( & self ) -> TCR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; TCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Timer counter value." ] # [ inline ] pub fn tc ( & mut self ) -> _TCW { _TCW { w : self } } } } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub struct PR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC." ] pub mod pr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCVALR { bits : u32 , } impl PCVALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCVALW < 'a > { w : & 'a mut W , } impl < 'a > _PCVALW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Prescaler value." ] # [ inline ] pub fn pcval ( & self ) -> PCVALR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PCVALR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Prescaler value." ] # [ inline ] pub fn pcval ( & mut self ) -> _PCVALW { _PCVALW { w : self } } } } # [ doc = "Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub struct PC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface." ] pub mod pc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PCR { bits : u32 , } impl PCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _PCW < 'a > { w : & 'a mut W , } impl < 'a > _PCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Prescale counter value." ] # [ inline ] pub fn pc ( & self ) -> PCR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Prescale counter value." ] # [ inline ] pub fn pc ( & mut self ) -> _PCW { _PCW { w : self } } } } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub struct MCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs." ] pub mod mcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MR0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0IR :: ENABLED => true , MR0IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0IR { match value { true => MR0IR :: ENABLED , false => MR0IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0IR :: DISABLED } } # [ doc = "Possible values of the field `MR0R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0RR :: ENABLED => true , MR0RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0RR { match value { true => MR0RR :: ENABLED , false => MR0RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0RR :: DISABLED } } # [ doc = "Possible values of the field `MR0S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR0SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR0SR :: ENABLED => true , MR0SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR0SR { match value { true => MR0SR :: ENABLED , false => MR0SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR0SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR0SR :: DISABLED } } # [ doc = "Possible values of the field `MR1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1IR :: ENABLED => true , MR1IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1IR { match value { true => MR1IR :: ENABLED , false => MR1IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1IR :: DISABLED } } # [ doc = "Possible values of the field `MR1R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1RR :: ENABLED => true , MR1RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1RR { match value { true => MR1RR :: ENABLED , false => MR1RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1RR :: DISABLED } } # [ doc = "Possible values of the field `MR1S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR1SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR1SR :: ENABLED => true , MR1SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR1SR { match value { true => MR1SR :: ENABLED , false => MR1SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR1SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR1SR :: DISABLED } } # [ doc = "Possible values of the field `MR2I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2IR :: ENABLED => true , MR2IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2IR { match value { true => MR2IR :: ENABLED , false => MR2IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2IR :: DISABLED } } # [ doc = "Possible values of the field `MR2R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2RR :: ENABLED => true , MR2RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2RR { match value { true => MR2RR :: ENABLED , false => MR2RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2RR :: DISABLED } } # [ doc = "Possible values of the field `MR2S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR2SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR2SR :: ENABLED => true , MR2SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR2SR { match value { true => MR2SR :: ENABLED , false => MR2SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR2SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR2SR :: DISABLED } } # [ doc = "Possible values of the field `MR3I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3IR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3IR :: ENABLED => true , MR3IR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3IR { match value { true => MR3IR :: ENABLED , false => MR3IR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3IR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3IR :: DISABLED } } # [ doc = "Possible values of the field `MR3R`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3RR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3RR :: ENABLED => true , MR3RR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3RR { match value { true => MR3RR :: ENABLED , false => MR3RR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3RR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3RR :: DISABLED } } # [ doc = "Possible values of the field `MR3S`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MR3SR { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MR3SR :: ENABLED => true , MR3SR :: DISABLED => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MR3SR { match value { true => MR3SR :: ENABLED , false => MR3SR :: DISABLED , } } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == MR3SR :: ENABLED } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MR3SR :: DISABLED } } # [ doc = "Values that can be written to the field `MR0I`" ] pub enum MR0IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0IW :: ENABLED => true , MR0IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0IW < 'a > { w : & 'a mut W , } impl < 'a > _MR0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0R`" ] pub enum MR0RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0RW :: ENABLED => true , MR0RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0RW < 'a > { w : & 'a mut W , } impl < 'a > _MR0RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR0S`" ] pub enum MR0SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR0SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR0SW :: ENABLED => true , MR0SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR0SW < 'a > { w : & 'a mut W , } impl < 'a > _MR0SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR0SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR0SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1I`" ] pub enum MR1IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1IW :: ENABLED => true , MR1IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1IW < 'a > { w : & 'a mut W , } impl < 'a > _MR1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1R`" ] pub enum MR1RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1RW :: ENABLED => true , MR1RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1RW < 'a > { w : & 'a mut W , } impl < 'a > _MR1RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR1S`" ] pub enum MR1SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR1SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR1SW :: ENABLED => true , MR1SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR1SW < 'a > { w : & 'a mut W , } impl < 'a > _MR1SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR1SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR1SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2I`" ] pub enum MR2IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2IW :: ENABLED => true , MR2IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2IW < 'a > { w : & 'a mut W , } impl < 'a > _MR2IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2R`" ] pub enum MR2RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2RW :: ENABLED => true , MR2RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2RW < 'a > { w : & 'a mut W , } impl < 'a > _MR2RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR2S`" ] pub enum MR2SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR2SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR2SW :: ENABLED => true , MR2SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR2SW < 'a > { w : & 'a mut W , } impl < 'a > _MR2SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR2SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR2SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3I`" ] pub enum MR3IW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3IW :: ENABLED => true , MR3IW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3IW < 'a > { w : & 'a mut W , } impl < 'a > _MR3IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3IW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3R`" ] pub enum MR3RW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3RW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3RW :: ENABLED => true , MR3RW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3RW < 'a > { w : & 'a mut W , } impl < 'a > _MR3RW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3RW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3RW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MR3S`" ] pub enum MR3SW { # [ doc = "Enabled" ] ENABLED , # [ doc = "Disabled" ] DISABLED } impl MR3SW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MR3SW :: ENABLED => true , MR3SW :: DISABLED => false } } } # [ doc = r" Proxy" ] pub struct _MR3SW < 'a > { w : & 'a mut W , } impl < 'a > _MR3SW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MR3SW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: ENABLED ) } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MR3SW :: DISABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & self ) -> MR0IR { MR0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & self ) -> MR0RR { MR0RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & self ) -> MR0SR { MR0SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & self ) -> MR1IR { MR1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & self ) -> MR1RR { MR1RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & self ) -> MR1SR { MR1SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & self ) -> MR2IR { MR2IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & self ) -> MR2RR { MR2RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & self ) -> MR2SR { MR2SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & self ) -> MR3IR { MR3IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & self ) -> MR3RR { MR3RR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & self ) -> MR3SR { MR3SR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC." ] # [ inline ] pub fn mr0i ( & mut self ) -> _MR0IW { _MR0IW { w : self } } # [ doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it." ] # [ inline ] pub fn mr0r ( & mut self ) -> _MR0RW { _MR0RW { w : self } } # [ doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR0 matches the TC." ] # [ inline ] pub fn mr0s ( & mut self ) -> _MR0SW { _MR0SW { w : self } } # [ doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC." ] # [ inline ] pub fn mr1i ( & mut self ) -> _MR1IW { _MR1IW { w : self } } # [ doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it." ] # [ inline ] pub fn mr1r ( & mut self ) -> _MR1RW { _MR1RW { w : self } } # [ doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR1 matches the TC." ] # [ inline ] pub fn mr1s ( & mut self ) -> _MR1SW { _MR1SW { w : self } } # [ doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC." ] # [ inline ] pub fn mr2i ( & mut self ) -> _MR2IW { _MR2IW { w : self } } # [ doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it." ] # [ inline ] pub fn mr2r ( & mut self ) -> _MR2RW { _MR2RW { w : self } } # [ doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR2 matches the TC." ] # [ inline ] pub fn mr2s ( & mut self ) -> _MR2SW { _MR2SW { w : self } } # [ doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC." ] # [ inline ] pub fn mr3i ( & mut self ) -> _MR3IW { _MR3IW { w : self } } # [ doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it." ] # [ inline ] pub fn mr3r ( & mut self ) -> _MR3RW { _MR3RW { w : self } } # [ doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR\\[0\\] will be set to 0 if MR3 matches the TC." ] # [ inline ] pub fn mr3s ( & mut self ) -> _MR3SW { _MR3SW { w : self } } } } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub struct MR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC." ] pub mod mr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MATCHR { bits : u32 , } impl MATCHR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _MATCHW < 'a > { w : & 'a mut W , } impl < 'a > _MATCHW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter match value." ] # [ inline ] pub fn match_ ( & self ) -> MATCHR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; MATCHR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Timer counter match value." ] # [ inline ] pub fn match_ ( & mut self ) -> _MATCHW { _MATCHW { w : self } } } } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub struct CCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place." ] pub mod ccr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CAP0RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0RER :: ENABLED_ => true , CAP0RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0RER { match value { true => CAP0RER :: ENABLED_ , false => CAP0RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0FER :: ENABLED_ => true , CAP0FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0FER { match value { true => CAP0FER :: ENABLED_ , false => CAP0FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP0I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP0IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP0IR :: ENABLED_ => true , CAP0IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP0IR { match value { true => CAP0IR :: ENABLED_ , false => CAP0IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP0IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP0IR :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1RE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1RER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1RER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1RER :: ENABLED_ => true , CAP1RER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1RER { match value { true => CAP1RER :: ENABLED_ , false => CAP1RER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1RER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1RER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1FE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1FER { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1FER :: ENABLED_ => true , CAP1FER :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1FER { match value { true => CAP1FER :: ENABLED_ , false => CAP1FER :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1FER :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1FER :: DISABLED_ } } # [ doc = "Possible values of the field `CAP1I`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP1IR { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CAP1IR :: ENABLED_ => true , CAP1IR :: DISABLED_ => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CAP1IR { match value { true => CAP1IR :: ENABLED_ , false => CAP1IR :: DISABLED_ , } } # [ doc = "Checks if the value of the field is `ENABLED_`" ] # [ inline ] pub fn is_enabled_ ( & self ) -> bool { * self == CAP1IR :: ENABLED_ } # [ doc = "Checks if the value of the field is `DISABLED_`" ] # [ inline ] pub fn is_disabled_ ( & self ) -> bool { * self == CAP1IR :: DISABLED_ } } # [ doc = "Values that can be written to the field `CAP0RE`" ] pub enum CAP0REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0REW :: ENABLED_ => true , CAP0REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0FE`" ] pub enum CAP0FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0FEW :: ENABLED_ => true , CAP0FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP0I`" ] pub enum CAP0IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP0IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP0IW :: ENABLED_ => true , CAP0IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP0IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP0IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP0IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP0IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1RE`" ] pub enum CAP1REW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1REW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1REW :: ENABLED_ => true , CAP1REW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1REW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1REW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1REW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1REW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1FE`" ] pub enum CAP1FEW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1FEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1FEW :: ENABLED_ => true , CAP1FEW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1FEW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1FEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1FEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1FEW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CAP1I`" ] pub enum CAP1IW { # [ doc = "Enabled." ] ENABLED_ , # [ doc = "Disabled." ] DISABLED_ } impl CAP1IW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CAP1IW :: ENABLED_ => true , CAP1IW :: DISABLED_ => false } } } # [ doc = r" Proxy" ] pub struct _CAP1IW < 'a > { w : & 'a mut W , } impl < 'a > _CAP1IW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CAP1IW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enabled." ] # [ inline ] pub fn enabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: ENABLED_ ) } # [ doc = "Disabled." ] # [ inline ] pub fn disabled_ ( self ) -> & 'a mut W { self . variant ( CAP1IW :: DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Capture on CT32B1_CAP0 rising edge: a sequence of 0 then 1 on CT32B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & self ) -> CAP0RER { CAP0RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Capture on CT32B1_CAP0 falling edge: a sequence of 1 then 0 on CT32B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & self ) -> CAP0FER { CAP0FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Interrupt on CT32B1_CAP0 event: a CR0 load due to a CT32B1_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & self ) -> CAP0IR { CAP0IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Capture on CT32B1_CAP1 rising edge: a sequence of 0 then 1 on CT32B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1re ( & self ) -> CAP1RER { CAP1RER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Capture on CT32B1_CAP1 falling edge: a sequence of 1 then 0 on CT32B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1fe ( & self ) -> CAP1FER { CAP1FER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Interrupt on CT32B1_CAP1 event: a CR1 load due to a CT32B1_CAP1 event will generate an interrupt." ] # [ inline ] pub fn cap1i ( & self ) -> CAP1IR { CAP1IR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Capture on CT32B1_CAP0 rising edge: a sequence of 0 then 1 on CT32B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0re ( & mut self ) -> _CAP0REW { _CAP0REW { w : self } } # [ doc = "Bit 1 - Capture on CT32B1_CAP0 falling edge: a sequence of 1 then 0 on CT32B1_CAP0 will cause CR0 to be loaded with the contents of TC." ] # [ inline ] pub fn cap0fe ( & mut self ) -> _CAP0FEW { _CAP0FEW { w : self } } # [ doc = "Bit 2 - Interrupt on CT32B1_CAP0 event: a CR0 load due to a CT32B1_CAP0 event will generate an interrupt." ] # [ inline ] pub fn cap0i ( & mut self ) -> _CAP0IW { _CAP0IW { w : self } } # [ doc = "Bit 3 - Capture on CT32B1_CAP1 rising edge: a sequence of 0 then 1 on CT32B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1re ( & mut self ) -> _CAP1REW { _CAP1REW { w : self } } # [ doc = "Bit 4 - Capture on CT32B1_CAP1 falling edge: a sequence of 1 then 0 on CT32B1_CAP1 will cause CR1 to be loaded with the contents of TC." ] # [ inline ] pub fn cap1fe ( & mut self ) -> _CAP1FEW { _CAP1FEW { w : self } } # [ doc = "Bit 5 - Interrupt on CT32B1_CAP1 event: a CR1 load due to a CT32B1_CAP1 event will generate an interrupt." ] # [ inline ] pub fn cap1i ( & mut self ) -> _CAP1IW { _CAP1IW { w : self } } } } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input." ] pub struct CR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input." ] pub mod cr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: CR0 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u32 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; CAPR { bits } } } } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT32B1_CAP1 input." ] pub struct CR1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Register 1. CR1 is loaded with the value of TC when there is an event on the CT32B1_CAP1 input." ] pub mod cr1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CR1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct CAPR { bits : u32 , } impl CAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _CAPW < 'a > { w : & 'a mut W , } impl < 'a > _CAPW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Timer counter capture value." ] # [ inline ] pub fn cap ( & self ) -> CAPR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; CAPR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Timer counter capture value." ] # [ inline ] pub fn cap ( & mut self ) -> _CAPW { _CAPW { w : self } } } } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT\\[3:0\\]." ] pub struct EMR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT\\[3:0\\]." ] pub mod emr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EMR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EM0R { bits : bool , } impl EM0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM1R { bits : bool , } impl EM1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM2R { bits : bool , } impl EM2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EM3R { bits : bool , } impl EM3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `EMC0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC0R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC0R :: DO_NOTHING_ => 0 , EMC0R :: CLEAR_THE_CORRESPOND => 0x01 , EMC0R :: SET_THE_CORRESPONDIN => 0x02 , EMC0R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC0R { match value { 0 => EMC0R :: DO_NOTHING_ , 1 => EMC0R :: CLEAR_THE_CORRESPOND , 2 => EMC0R :: SET_THE_CORRESPONDIN , 3 => EMC0R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC0R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC0R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC0R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC0R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC1R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC1R :: DO_NOTHING_ => 0 , EMC1R :: CLEAR_THE_CORRESPOND => 0x01 , EMC1R :: SET_THE_CORRESPONDIN => 0x02 , EMC1R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC1R { match value { 0 => EMC1R :: DO_NOTHING_ , 1 => EMC1R :: CLEAR_THE_CORRESPOND , 2 => EMC1R :: SET_THE_CORRESPONDIN , 3 => EMC1R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC1R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC1R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC1R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC1R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC2R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC2R :: DO_NOTHING_ => 0 , EMC2R :: CLEAR_THE_CORRESPOND => 0x01 , EMC2R :: SET_THE_CORRESPONDIN => 0x02 , EMC2R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC2R { match value { 0 => EMC2R :: DO_NOTHING_ , 1 => EMC2R :: CLEAR_THE_CORRESPOND , 2 => EMC2R :: SET_THE_CORRESPONDIN , 3 => EMC2R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC2R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC2R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC2R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC2R :: TOGGLE_THE_CORRESPON } } # [ doc = "Possible values of the field `EMC3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EMC3R { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EMC3R :: DO_NOTHING_ => 0 , EMC3R :: CLEAR_THE_CORRESPOND => 0x01 , EMC3R :: SET_THE_CORRESPONDIN => 0x02 , EMC3R :: TOGGLE_THE_CORRESPON => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EMC3R { match value { 0 => EMC3R :: DO_NOTHING_ , 1 => EMC3R :: CLEAR_THE_CORRESPOND , 2 => EMC3R :: SET_THE_CORRESPONDIN , 3 => EMC3R :: TOGGLE_THE_CORRESPON , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DO_NOTHING_`" ] # [ inline ] pub fn is_do_nothing_ ( & self ) -> bool { * self == EMC3R :: DO_NOTHING_ } # [ doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`" ] # [ inline ] pub fn is_clear_the_correspond ( & self ) -> bool { * self == EMC3R :: CLEAR_THE_CORRESPOND } # [ doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`" ] # [ inline ] pub fn is_set_the_correspondin ( & self ) -> bool { * self == EMC3R :: SET_THE_CORRESPONDIN } # [ doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`" ] # [ inline ] pub fn is_toggle_the_correspon ( & self ) -> bool { * self == EMC3R :: TOGGLE_THE_CORRESPON } } # [ doc = r" Proxy" ] pub struct _EM0W < 'a > { w : & 'a mut W , } impl < 'a > _EM0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM1W < 'a > { w : & 'a mut W , } impl < 'a > _EM1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM2W < 'a > { w : & 'a mut W , } impl < 'a > _EM2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EM3W < 'a > { w : & 'a mut W , } impl < 'a > _EM3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC0`" ] pub enum EMC0W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC0W :: DO_NOTHING_ => 0 , EMC0W :: CLEAR_THE_CORRESPOND => 1 , EMC0W :: SET_THE_CORRESPONDIN => 2 , EMC0W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC0W < 'a > { w : & 'a mut W , } impl < 'a > _EMC0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC0W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC0W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC0W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC0W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC0W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC1`" ] pub enum EMC1W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT1 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT1 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC1W :: DO_NOTHING_ => 0 , EMC1W :: CLEAR_THE_CORRESPOND => 1 , EMC1W :: SET_THE_CORRESPONDIN => 2 , EMC1W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC1W < 'a > { w : & 'a mut W , } impl < 'a > _EMC1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC1W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC1W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT1 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC1W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT1 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC1W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC1W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC2`" ] pub enum EMC2W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT2 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT2 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC2W :: DO_NOTHING_ => 0 , EMC2W :: CLEAR_THE_CORRESPOND => 1 , EMC2W :: SET_THE_CORRESPONDIN => 2 , EMC2W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC2W < 'a > { w : & 'a mut W , } impl < 'a > _EMC2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC2W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC2W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT2 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC2W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT2 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC2W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC2W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EMC3`" ] pub enum EMC3W { # [ doc = "Do Nothing." ] DO_NOTHING_ , # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT3 pin is LOW if pinned out)." ] CLEAR_THE_CORRESPOND , # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT3 pin is HIGH if pinned out)." ] SET_THE_CORRESPONDIN , # [ doc = "Toggle the corresponding External Match bit/output." ] TOGGLE_THE_CORRESPON } impl EMC3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EMC3W :: DO_NOTHING_ => 0 , EMC3W :: CLEAR_THE_CORRESPOND => 1 , EMC3W :: SET_THE_CORRESPONDIN => 2 , EMC3W :: TOGGLE_THE_CORRESPON => 3 } } } # [ doc = r" Proxy" ] pub struct _EMC3W < 'a > { w : & 'a mut W , } impl < 'a > _EMC3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EMC3W ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Do Nothing." ] # [ inline ] pub fn do_nothing_ ( self ) -> & 'a mut W { self . variant ( EMC3W :: DO_NOTHING_ ) } # [ doc = "Clear the corresponding External Match bit/output to 0 (CT32Bi_MAT3 pin is LOW if pinned out)." ] # [ inline ] pub fn clear_the_correspond ( self ) -> & 'a mut W { self . variant ( EMC3W :: CLEAR_THE_CORRESPOND ) } # [ doc = "Set the corresponding External Match bit/output to 1 (CT32Bi_MAT3 pin is HIGH if pinned out)." ] # [ inline ] pub fn set_the_correspondin ( self ) -> & 'a mut W { self . variant ( EMC3W :: SET_THE_CORRESPONDIN ) } # [ doc = "Toggle the corresponding External Match bit/output." ] # [ inline ] pub fn toggle_the_correspon ( self ) -> & 'a mut W { self . variant ( EMC3W :: TOGGLE_THE_CORRESPON ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT32B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & self ) -> EM0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM0R { bits } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT32B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & self ) -> EM1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM1R { bits } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT32B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em2 ( & self ) -> EM2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM2R { bits } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output. This bit is driven to the CT32B3_MAT0/CT32B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em3 ( & self ) -> EM3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EM3R { bits } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0." ] # [ inline ] pub fn emc0 ( & self ) -> EMC0R { EMC0R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & self ) -> EMC1R { EMC1R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & self ) -> EMC2R { EMC2R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & self ) -> EMC3R { EMC3R :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[5:4\\] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT32B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em0 ( & mut self ) -> _EM0W { _EM0W { w : self } } # [ doc = "Bit 1 - External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[7:6\\] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT32B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em1 ( & mut self ) -> _EM1W { _EM1W { w : self } } # [ doc = "Bit 2 - External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[9:8\\] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT32B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em2 ( & mut self ) -> _EM2W { _EM2W { w : self } } # [ doc = "Bit 3 - External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR\\[11:10\\] control the functionality of this output. This bit is driven to the CT32B3_MAT0/CT32B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)." ] # [ inline ] pub fn em3 ( & mut self ) -> _EM3W { _EM3W { w : self } } # [ doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0." ] # [ inline ] pub fn emc0 ( & mut self ) -> _EMC0W { _EMC0W { w : self } } # [ doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1." ] # [ inline ] pub fn emc1 ( & mut self ) -> _EMC1W { _EMC1W { w : self } } # [ doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2." ] # [ inline ] pub fn emc2 ( & mut self ) -> _EMC2W { _EMC2W { w : self } } # [ doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3." ] # [ inline ] pub fn emc3 ( & mut self ) -> _EMC3W { _EMC3W { w : self } } } } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub struct CTCR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting." ] pub mod ctcr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CTCR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CTM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CTMR { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CTMR :: TIMER_MODE_EVERY_RI => 0 , CTMR :: COUNTER_MODE_TC_IS_RISING => 0x01 , CTMR :: COUNTER_MODE_TC_IS_FALLING => 0x02 , CTMR :: COUNTER_MODE_TC_IS_BOTH => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CTMR { match value { 0 => CTMR :: TIMER_MODE_EVERY_RI , 1 => CTMR :: COUNTER_MODE_TC_IS_RISING , 2 => CTMR :: COUNTER_MODE_TC_IS_FALLING , 3 => CTMR :: COUNTER_MODE_TC_IS_BOTH , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `TIMER_MODE_EVERY_RI`" ] # [ inline ] pub fn is_timer_mode_every_ri ( & self ) -> bool { * self == CTMR :: TIMER_MODE_EVERY_RI } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_RISING`" ] # [ inline ] pub fn is_counter_mode_tc_is_rising ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_RISING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_FALLING`" ] # [ inline ] pub fn is_counter_mode_tc_is_falling ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_FALLING } # [ doc = "Checks if the value of the field is `COUNTER_MODE_TC_IS_BOTH`" ] # [ inline ] pub fn is_counter_mode_tc_is_both ( & self ) -> bool { * self == CTMR :: COUNTER_MODE_TC_IS_BOTH } } # [ doc = "Possible values of the field `CIS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CISR { # [ doc = "CT32B1_CAP0" ] CT32B1_CAP0 , # [ doc = "CT32B1_CAP1" ] CT32B1_CAP1 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl CISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CISR :: CT32B1_CAP0 => 0 , CISR :: CT32B1_CAP1 => 0x01 , CISR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CISR { match value { 0 => CISR :: CT32B1_CAP0 , 1 => CISR :: CT32B1_CAP1 , i => CISR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `CT32B1_CAP0`" ] # [ inline ] pub fn is_ct32b1_cap0 ( & self ) -> bool { * self == CISR :: CT32B1_CAP0 } # [ doc = "Checks if the value of the field is `CT32B1_CAP1`" ] # [ inline ] pub fn is_ct32b1_cap1 ( & self ) -> bool { * self == CISR :: CT32B1_CAP1 } } # [ doc = r" Value of the field" ] pub struct ENCCR { bits : bool , } impl ENCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `SElCC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELCCR { # [ doc = "Rising Edge of CT32B1_CAP0 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP0 , # [ doc = "Falling Edge of CT32B1_CAP0 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP0 , # [ doc = "Rising Edge of CT32B1_CAP1 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP1 , # [ doc = "Falling Edge of CT32B1_CAP1 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP1 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SELCCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELCCR :: RISING_EDGE_OF_CT32B_CAP0 => 0 , SELCCR :: FALLING_EDGE_OF_CT32_CAP0 => 0x01 , SELCCR :: RISING_EDGE_OF_CT32B_CAP1 => 0x02 , SELCCR :: FALLING_EDGE_OF_CT32_CAP1 => 0x03 , SELCCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELCCR { match value { 0 => SELCCR :: RISING_EDGE_OF_CT32B_CAP0 , 1 => SELCCR :: FALLING_EDGE_OF_CT32_CAP0 , 2 => SELCCR :: RISING_EDGE_OF_CT32B_CAP1 , 3 => SELCCR :: FALLING_EDGE_OF_CT32_CAP1 , i => SELCCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT32B_CAP0`" ] # [ inline ] pub fn is_rising_edge_of_ct32b_cap0 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT32B_CAP0 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT32_CAP0`" ] # [ inline ] pub fn is_falling_edge_of_ct32_cap0 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT32_CAP0 } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_CT32B_CAP1`" ] # [ inline ] pub fn is_rising_edge_of_ct32b_cap1 ( & self ) -> bool { * self == SELCCR :: RISING_EDGE_OF_CT32B_CAP1 } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_CT32_CAP1`" ] # [ inline ] pub fn is_falling_edge_of_ct32_cap1 ( & self ) -> bool { * self == SELCCR :: FALLING_EDGE_OF_CT32_CAP1 } } # [ doc = "Values that can be written to the field `CTM`" ] pub enum CTMW { # [ doc = "Timer Mode: every rising PCLK edge" ] TIMER_MODE_EVERY_RI , # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_RISING , # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_FALLING , # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] COUNTER_MODE_TC_IS_BOTH } impl CTMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CTMW :: TIMER_MODE_EVERY_RI => 0 , CTMW :: COUNTER_MODE_TC_IS_RISING => 1 , CTMW :: COUNTER_MODE_TC_IS_FALLING => 2 , CTMW :: COUNTER_MODE_TC_IS_BOTH => 3 } } } # [ doc = r" Proxy" ] pub struct _CTMW < 'a > { w : & 'a mut W , } impl < 'a > _CTMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CTMW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Timer Mode: every rising PCLK edge" ] # [ inline ] pub fn timer_mode_every_ri ( self ) -> & 'a mut W { self . variant ( CTMW :: TIMER_MODE_EVERY_RI ) } # [ doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_rising ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_RISING ) } # [ doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_falling ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_FALLING ) } # [ doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2." ] # [ inline ] pub fn counter_mode_tc_is_both ( self ) -> & 'a mut W { self . variant ( CTMW :: COUNTER_MODE_TC_IS_BOTH ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CIS`" ] pub enum CISW { # [ doc = "CT32B1_CAP0" ] CT32B1_CAP0 , # [ doc = "CT32B1_CAP1" ] CT32B1_CAP1 } impl CISW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CISW :: CT32B1_CAP0 => 0 , CISW :: CT32B1_CAP1 => 1 } } } # [ doc = r" Proxy" ] pub struct _CISW < 'a > { w : & 'a mut W , } impl < 'a > _CISW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CISW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CT32B1_CAP0" ] # [ inline ] pub fn ct32b1_cap0 ( self ) -> & 'a mut W { self . variant ( CISW :: CT32B1_CAP0 ) } # [ doc = "CT32B1_CAP1" ] # [ inline ] pub fn ct32b1_cap1 ( self ) -> & 'a mut W { self . variant ( CISW :: CT32B1_CAP1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENCCW < 'a > { w : & 'a mut W , } impl < 'a > _ENCCW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SElCC`" ] pub enum SELCCW { # [ doc = "Rising Edge of CT32B1_CAP0 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP0 , # [ doc = "Falling Edge of CT32B1_CAP0 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP0 , # [ doc = "Rising Edge of CT32B1_CAP1 clears the timer (if bit 4 is set)" ] RISING_EDGE_OF_CT32B_CAP1 , # [ doc = "Falling Edge of CT32B1_CAP1 clears the timer (if bit 4 is set)" ] FALLING_EDGE_OF_CT32_CAP1 } impl SELCCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELCCW :: RISING_EDGE_OF_CT32B_CAP0 => 0 , SELCCW :: FALLING_EDGE_OF_CT32_CAP0 => 1 , SELCCW :: RISING_EDGE_OF_CT32B_CAP1 => 2 , SELCCW :: FALLING_EDGE_OF_CT32_CAP1 => 3 } } } # [ doc = r" Proxy" ] pub struct _SELCCW < 'a > { w : & 'a mut W , } impl < 'a > _SELCCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELCCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Rising Edge of CT32B1_CAP0 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn rising_edge_of_ct32b_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT32B_CAP0 ) } # [ doc = "Falling Edge of CT32B1_CAP0 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn falling_edge_of_ct32_cap0 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT32_CAP0 ) } # [ doc = "Rising Edge of CT32B1_CAP1 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn rising_edge_of_ct32b_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: RISING_EDGE_OF_CT32B_CAP1 ) } # [ doc = "Falling Edge of CT32B1_CAP1 clears the timer (if bit 4 is set)" ] # [ inline ] pub fn falling_edge_of_ct32_cap1 ( self ) -> & 'a mut W { self . variant ( SELCCW :: FALLING_EDGE_OF_CT32_CAP1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & self ) -> CTMR { CTMR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. If Counter mode is selected in the CTCR, the 3 bits for that input in the Capture Control Register (CCR) must be programmed as 000. Values 0x2 to 0x3 are reserved." ] # [ inline ] pub fn cis ( & self ) -> CISR { CISR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & self ) -> ENCCR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENCCR { bits } } # [ doc = "Bits 5:7 - When bit 4 is a 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn sel_cc ( & self ) -> SELCCR { SELCCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000." ] # [ inline ] pub fn ctm ( & mut self ) -> _CTMW { _CTMW { w : self } } # [ doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin or comparator output is sampled for clocking. If Counter mode is selected in the CTCR, the 3 bits for that input in the Capture Control Register (CCR) must be programmed as 000. Values 0x2 to 0x3 are reserved." ] # [ inline ] pub fn cis ( & mut self ) -> _CISW { _CISW { w : self } } # [ doc = "Bit 4 - Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs." ] # [ inline ] pub fn encc ( & mut self ) -> _ENCCW { _ENCCW { w : self } } # [ doc = "Bits 5:7 - When bit 4 is a 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn sel_cc ( & mut self ) -> _SELCCW { _SELCCW { w : self } } } } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT\\[3:0\\]." ] pub struct PWMC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT\\[3:0\\]." ] pub mod pwmc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PWMC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PWMEN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN0R { # [ doc = "CT32Bn_MAT0 is controlled by EM0." ] CT32BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN0R :: CT32BN_MAT0_IS_CONTR => false , PWMEN0R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN0R { match value { false => PWMEN0R :: CT32BN_MAT0_IS_CONTR , true => PWMEN0R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT0_IS_CONTR`" ] # [ inline ] pub fn is_ct32bn_mat0_is_contr ( & self ) -> bool { * self == PWMEN0R :: CT32BN_MAT0_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN0R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN1R { # [ doc = "CT32Bn_MAT01 is controlled by EM1." ] CT32BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT32Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN1R :: CT32BN_MAT01_IS_CONT => false , PWMEN1R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN1R { match value { false => PWMEN1R :: CT32BN_MAT01_IS_CONT , true => PWMEN1R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT01_IS_CONT`" ] # [ inline ] pub fn is_ct32bn_mat01_is_cont ( & self ) -> bool { * self == PWMEN1R :: CT32BN_MAT01_IS_CONT } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN1R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN2R { # [ doc = "CT32Bn_MAT2 is controlled by EM2." ] CT32BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN2R :: CT32BN_MAT2_IS_CONTR => false , PWMEN2R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN2R { match value { false => PWMEN2R :: CT32BN_MAT2_IS_CONTR , true => PWMEN2R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT2_IS_CONTR`" ] # [ inline ] pub fn is_ct32bn_mat2_is_contr ( & self ) -> bool { * self == PWMEN2R :: CT32BN_MAT2_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN2R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Possible values of the field `PWMEN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PWMEN3R { # [ doc = "CT32Bn_MAT3 is controlled by EM3." ] CT32BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT132Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PWMEN3R :: CT32BN_MAT3_IS_CONTR => false , PWMEN3R :: PWM_MODE_IS_ENABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PWMEN3R { match value { false => PWMEN3R :: CT32BN_MAT3_IS_CONTR , true => PWMEN3R :: PWM_MODE_IS_ENABLED_ , } } # [ doc = "Checks if the value of the field is `CT32BN_MAT3_IS_CONTR`" ] # [ inline ] pub fn is_ct32bn_mat3_is_contr ( & self ) -> bool { * self == PWMEN3R :: CT32BN_MAT3_IS_CONTR } # [ doc = "Checks if the value of the field is `PWM_MODE_IS_ENABLED_`" ] # [ inline ] pub fn is_pwm_mode_is_enabled_ ( & self ) -> bool { * self == PWMEN3R :: PWM_MODE_IS_ENABLED_ } } # [ doc = "Values that can be written to the field `PWMEN0`" ] pub enum PWMEN0W { # [ doc = "CT32Bn_MAT0 is controlled by EM0." ] CT32BN_MAT0_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT0." ] PWM_MODE_IS_ENABLED_ } impl PWMEN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN0W :: CT32BN_MAT0_IS_CONTR => false , PWMEN0W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN0W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT0 is controlled by EM0." ] # [ inline ] pub fn ct32bn_mat0_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: CT32BN_MAT0_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT32Bn_MAT0." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN0W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN1`" ] pub enum PWMEN1W { # [ doc = "CT32Bn_MAT01 is controlled by EM1." ] CT32BN_MAT01_IS_CONT , # [ doc = "PWM mode is enabled for CT32Bn_MAT1." ] PWM_MODE_IS_ENABLED_ } impl PWMEN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN1W :: CT32BN_MAT01_IS_CONT => false , PWMEN1W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN1W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT01 is controlled by EM1." ] # [ inline ] pub fn ct32bn_mat01_is_cont ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: CT32BN_MAT01_IS_CONT ) } # [ doc = "PWM mode is enabled for CT32Bn_MAT1." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN1W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN2`" ] pub enum PWMEN2W { # [ doc = "CT32Bn_MAT2 is controlled by EM2." ] CT32BN_MAT2_IS_CONTR , # [ doc = "PWM mode is enabled for CT32Bn_MAT2." ] PWM_MODE_IS_ENABLED_ } impl PWMEN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN2W :: CT32BN_MAT2_IS_CONTR => false , PWMEN2W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN2W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT2 is controlled by EM2." ] # [ inline ] pub fn ct32bn_mat2_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: CT32BN_MAT2_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT32Bn_MAT2." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN2W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PWMEN3`" ] pub enum PWMEN3W { # [ doc = "CT32Bn_MAT3 is controlled by EM3." ] CT32BN_MAT3_IS_CONTR , # [ doc = "PWM mode is enabled for CT132Bn_MAT3." ] PWM_MODE_IS_ENABLED_ } impl PWMEN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PWMEN3W :: CT32BN_MAT3_IS_CONTR => false , PWMEN3W :: PWM_MODE_IS_ENABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _PWMEN3W < 'a > { w : & 'a mut W , } impl < 'a > _PWMEN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PWMEN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CT32Bn_MAT3 is controlled by EM3." ] # [ inline ] pub fn ct32bn_mat3_is_contr ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: CT32BN_MAT3_IS_CONTR ) } # [ doc = "PWM mode is enabled for CT132Bn_MAT3." ] # [ inline ] pub fn pwm_mode_is_enabled_ ( self ) -> & 'a mut W { self . variant ( PWMEN3W :: PWM_MODE_IS_ENABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & self ) -> PWMEN0R { PWMEN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & self ) -> PWMEN1R { PWMEN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & self ) -> PWMEN2R { PWMEN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle." ] # [ inline ] pub fn pwmen3 ( & self ) -> PWMEN3R { PWMEN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - PWM mode enable for channel0." ] # [ inline ] pub fn pwmen0 ( & mut self ) -> _PWMEN0W { _PWMEN0W { w : self } } # [ doc = "Bit 1 - PWM mode enable for channel1." ] # [ inline ] pub fn pwmen1 ( & mut self ) -> _PWMEN1W { _PWMEN1W { w : self } } # [ doc = "Bit 2 - PWM mode enable for channel2." ] # [ inline ] pub fn pwmen2 ( & mut self ) -> _PWMEN2W { _PWMEN2W { w : self } } # [ doc = "Bit 3 - PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle." ] # [ inline ] pub fn pwmen3 ( & mut self ) -> _PWMEN3W { _PWMEN3W { w : self } } } } } # [ doc = "ADC" ] pub struct ADC { _marker : PhantomData < * const ( ) > } unsafe impl Send for ADC { } impl ADC { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const adc :: RegisterBlock { 0x4001_c000 as * const _ } } impl Deref for ADC { type Target = adc :: RegisterBlock ; fn deref ( & self ) -> & adc :: RegisterBlock { unsafe { & * ADC :: ptr ( ) } } } # [ doc = "ADC" ] pub mod adc { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - A/D Control Register. The CR register must be written to select the operating mode before A/D conversion can occur." ] pub cr : CR , # [ doc = "0x04 - A/D Global Data Register. Contains the result of the most recent A/D conversion." ] pub gdr : GDR , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0x0c - A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt." ] pub inten : INTEN , # [ doc = "0x10 - A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel N" ] pub dr : [ DR ; 8 ] , # [ doc = "0x30 - A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag." ] pub stat : STAT , } # [ doc = "A/D Control Register. The CR register must be written to select the operating mode before A/D conversion can occur." ] pub struct CR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "A/D Control Register. The CR register must be written to select the operating mode before A/D conversion can occur." ] pub mod cr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct SELR { bits : u8 , } impl SELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct CLKDIVR { bits : u8 , } impl CLKDIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Possible values of the field `BURST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BURSTR { # [ doc = "Software-controlled mode: Conversions are software-controlled and require 11 clocks." ] SOFTWARE_CONTROLLED_ , # [ doc = "Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher  bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start." ] HARDWARE_SCAN_MODE_ } impl BURSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BURSTR :: SOFTWARE_CONTROLLED_ => false , BURSTR :: HARDWARE_SCAN_MODE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BURSTR { match value { false => BURSTR :: SOFTWARE_CONTROLLED_ , true => BURSTR :: HARDWARE_SCAN_MODE_ , } } # [ doc = "Checks if the value of the field is `SOFTWARE_CONTROLLED_`" ] # [ inline ] pub fn is_software_controlled_ ( & self ) -> bool { * self == BURSTR :: SOFTWARE_CONTROLLED_ } # [ doc = "Checks if the value of the field is `HARDWARE_SCAN_MODE_`" ] # [ inline ] pub fn is_hardware_scan_mode_ ( & self ) -> bool { * self == BURSTR :: HARDWARE_SCAN_MODE_ } } # [ doc = "Possible values of the field `CLKS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CLKSR { # [ doc = "11 clocks / 10 bits" ] _11_CLOCKS , # [ doc = "10 clocks / 9 bits" ] _10_CLOCKS , # [ doc = "9 clocks / 8 bits" ] _9_CLOCKS , # [ doc = "8 clocks / 7 bits" ] _8_CLOCKS , # [ doc = "7 clocks / 6 bits" ] _7_CLOCKS , # [ doc = "6 clocks / 5 bits" ] _6_CLOCKS , # [ doc = "5 clocks / 4 bits" ] _5_CLOCKS , # [ doc = "4 clocks / 3 bits" ] _4_CLOCKS } impl CLKSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { CLKSR :: _11_CLOCKS => 0 , CLKSR :: _10_CLOCKS => 0x01 , CLKSR :: _9_CLOCKS => 0x02 , CLKSR :: _8_CLOCKS => 0x03 , CLKSR :: _7_CLOCKS => 0x04 , CLKSR :: _6_CLOCKS => 0x05 , CLKSR :: _5_CLOCKS => 0x06 , CLKSR :: _4_CLOCKS => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> CLKSR { match value { 0 => CLKSR :: _11_CLOCKS , 1 => CLKSR :: _10_CLOCKS , 2 => CLKSR :: _9_CLOCKS , 3 => CLKSR :: _8_CLOCKS , 4 => CLKSR :: _7_CLOCKS , 5 => CLKSR :: _6_CLOCKS , 6 => CLKSR :: _5_CLOCKS , 7 => CLKSR :: _4_CLOCKS , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `_11_CLOCKS`" ] # [ inline ] pub fn is_11_clocks ( & self ) -> bool { * self == CLKSR :: _11_CLOCKS } # [ doc = "Checks if the value of the field is `_10_CLOCKS`" ] # [ inline ] pub fn is_10_clocks ( & self ) -> bool { * self == CLKSR :: _10_CLOCKS } # [ doc = "Checks if the value of the field is `_9_CLOCKS`" ] # [ inline ] pub fn is_9_clocks ( & self ) -> bool { * self == CLKSR :: _9_CLOCKS } # [ doc = "Checks if the value of the field is `_8_CLOCKS`" ] # [ inline ] pub fn is_8_clocks ( & self ) -> bool { * self == CLKSR :: _8_CLOCKS } # [ doc = "Checks if the value of the field is `_7_CLOCKS`" ] # [ inline ] pub fn is_7_clocks ( & self ) -> bool { * self == CLKSR :: _7_CLOCKS } # [ doc = "Checks if the value of the field is `_6_CLOCKS`" ] # [ inline ] pub fn is_6_clocks ( & self ) -> bool { * self == CLKSR :: _6_CLOCKS } # [ doc = "Checks if the value of the field is `_5_CLOCKS`" ] # [ inline ] pub fn is_5_clocks ( & self ) -> bool { * self == CLKSR :: _5_CLOCKS } # [ doc = "Checks if the value of the field is `_4_CLOCKS`" ] # [ inline ] pub fn is_4_clocks ( & self ) -> bool { * self == CLKSR :: _4_CLOCKS } } # [ doc = "Possible values of the field `START`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STARTR { # [ doc = "No start (this value should be used when clearing PDN to 0)." ] NO_START_THIS_VALUE , # [ doc = "Start conversion now." ] START_CONVERSION_NOW , # [ doc = "Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0." ] PIO0_2 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0." ] PIO1_5 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0\\[1\\]." ] CT32B0_MAT0 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1\\[1\\]." ] CT32B0_MAT1 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0\\[1\\]." ] CT16B0_MAT0 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1\\[1\\]." ] CT16B0_MAT1 } impl STARTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { STARTR :: NO_START_THIS_VALUE => 0 , STARTR :: START_CONVERSION_NOW => 0x01 , STARTR :: PIO0_2 => 0x02 , STARTR :: PIO1_5 => 0x03 , STARTR :: CT32B0_MAT0 => 0x04 , STARTR :: CT32B0_MAT1 => 0x05 , STARTR :: CT16B0_MAT0 => 0x06 , STARTR :: CT16B0_MAT1 => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> STARTR { match value { 0 => STARTR :: NO_START_THIS_VALUE , 1 => STARTR :: START_CONVERSION_NOW , 2 => STARTR :: PIO0_2 , 3 => STARTR :: PIO1_5 , 4 => STARTR :: CT32B0_MAT0 , 5 => STARTR :: CT32B0_MAT1 , 6 => STARTR :: CT16B0_MAT0 , 7 => STARTR :: CT16B0_MAT1 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `NO_START_THIS_VALUE`" ] # [ inline ] pub fn is_no_start_this_value ( & self ) -> bool { * self == STARTR :: NO_START_THIS_VALUE } # [ doc = "Checks if the value of the field is `START_CONVERSION_NOW`" ] # [ inline ] pub fn is_start_conversion_now ( & self ) -> bool { * self == STARTR :: START_CONVERSION_NOW } # [ doc = "Checks if the value of the field is `PIO0_2`" ] # [ inline ] pub fn is_pio0_2 ( & self ) -> bool { * self == STARTR :: PIO0_2 } # [ doc = "Checks if the value of the field is `PIO1_5`" ] # [ inline ] pub fn is_pio1_5 ( & self ) -> bool { * self == STARTR :: PIO1_5 } # [ doc = "Checks if the value of the field is `CT32B0_MAT0`" ] # [ inline ] pub fn is_ct32b0_mat0 ( & self ) -> bool { * self == STARTR :: CT32B0_MAT0 } # [ doc = "Checks if the value of the field is `CT32B0_MAT1`" ] # [ inline ] pub fn is_ct32b0_mat1 ( & self ) -> bool { * self == STARTR :: CT32B0_MAT1 } # [ doc = "Checks if the value of the field is `CT16B0_MAT0`" ] # [ inline ] pub fn is_ct16b0_mat0 ( & self ) -> bool { * self == STARTR :: CT16B0_MAT0 } # [ doc = "Checks if the value of the field is `CT16B0_MAT1`" ] # [ inline ] pub fn is_ct16b0_mat1 ( & self ) -> bool { * self == STARTR :: CT16B0_MAT1 } } # [ doc = "Possible values of the field `EDGE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EDGER { # [ doc = "Start conversion on a rising edge on the selected CAP/MAT signal." ] RISING , # [ doc = "Start conversion on a falling edge on the selected CAP/MAT signal." ] FALLING } impl EDGER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { EDGER :: RISING => false , EDGER :: FALLING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> EDGER { match value { false => EDGER :: RISING , true => EDGER :: FALLING , } } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ] pub fn is_rising ( & self ) -> bool { * self == EDGER :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ] pub fn is_falling ( & self ) -> bool { * self == EDGER :: FALLING } } # [ doc = r" Proxy" ] pub struct _SELW < 'a > { w : & 'a mut W , } impl < 'a > _SELW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLKDIVW < 'a > { w : & 'a mut W , } impl < 'a > _CLKDIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BURST`" ] pub enum BURSTW { # [ doc = "Software-controlled mode: Conversions are software-controlled and require 11 clocks." ] SOFTWARE_CONTROLLED_ , # [ doc = "Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher  bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start." ] HARDWARE_SCAN_MODE_ } impl BURSTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BURSTW :: SOFTWARE_CONTROLLED_ => false , BURSTW :: HARDWARE_SCAN_MODE_ => true } } } # [ doc = r" Proxy" ] pub struct _BURSTW < 'a > { w : & 'a mut W , } impl < 'a > _BURSTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BURSTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Software-controlled mode: Conversions are software-controlled and require 11 clocks." ] # [ inline ] pub fn software_controlled_ ( self ) -> & 'a mut W { self . variant ( BURSTW :: SOFTWARE_CONTROLLED_ ) } # [ doc = "Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start." ] # [ inline ] pub fn hardware_scan_mode_ ( self ) -> & 'a mut W { self . variant ( BURSTW :: HARDWARE_SCAN_MODE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CLKS`" ] pub enum CLKSW { # [ doc = "11 clocks / 10 bits" ] _11_CLOCKS , # [ doc = "10 clocks / 9 bits" ] _10_CLOCKS , # [ doc = "9 clocks / 8 bits" ] _9_CLOCKS , # [ doc = "8 clocks / 7 bits" ] _8_CLOCKS , # [ doc = "7 clocks / 6 bits" ] _7_CLOCKS , # [ doc = "6 clocks / 5 bits" ] _6_CLOCKS , # [ doc = "5 clocks / 4 bits" ] _5_CLOCKS , # [ doc = "4 clocks / 3 bits" ] _4_CLOCKS } impl CLKSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { CLKSW :: _11_CLOCKS => 0 , CLKSW :: _10_CLOCKS => 1 , CLKSW :: _9_CLOCKS => 2 , CLKSW :: _8_CLOCKS => 3 , CLKSW :: _7_CLOCKS => 4 , CLKSW :: _6_CLOCKS => 5 , CLKSW :: _5_CLOCKS => 6 , CLKSW :: _4_CLOCKS => 7 } } } # [ doc = r" Proxy" ] pub struct _CLKSW < 'a > { w : & 'a mut W , } impl < 'a > _CLKSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CLKSW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "11 clocks / 10 bits" ] # [ inline ] pub fn _11_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _11_CLOCKS ) } # [ doc = "10 clocks / 9 bits" ] # [ inline ] pub fn _10_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _10_CLOCKS ) } # [ doc = "9 clocks / 8 bits" ] # [ inline ] pub fn _9_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _9_CLOCKS ) } # [ doc = "8 clocks / 7 bits" ] # [ inline ] pub fn _8_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _8_CLOCKS ) } # [ doc = "7 clocks / 6 bits" ] # [ inline ] pub fn _7_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _7_CLOCKS ) } # [ doc = "6 clocks / 5 bits" ] # [ inline ] pub fn _6_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _6_CLOCKS ) } # [ doc = "5 clocks / 4 bits" ] # [ inline ] pub fn _5_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _5_CLOCKS ) } # [ doc = "4 clocks / 3 bits" ] # [ inline ] pub fn _4_clocks ( self ) -> & 'a mut W { self . variant ( CLKSW :: _4_CLOCKS ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `START`" ] pub enum STARTW { # [ doc = "No start (this value should be used when clearing PDN to 0)." ] NO_START_THIS_VALUE , # [ doc = "Start conversion now." ] START_CONVERSION_NOW , # [ doc = "Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0." ] PIO0_2 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0." ] PIO1_5 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0\\[1\\]." ] CT32B0_MAT0 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1\\[1\\]." ] CT32B0_MAT1 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0\\[1\\]." ] CT16B0_MAT0 , # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1\\[1\\]." ] CT16B0_MAT1 } impl STARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { STARTW :: NO_START_THIS_VALUE => 0 , STARTW :: START_CONVERSION_NOW => 1 , STARTW :: PIO0_2 => 2 , STARTW :: PIO1_5 => 3 , STARTW :: CT32B0_MAT0 => 4 , STARTW :: CT32B0_MAT1 => 5 , STARTW :: CT16B0_MAT0 => 6 , STARTW :: CT16B0_MAT1 => 7 } } } # [ doc = r" Proxy" ] pub struct _STARTW < 'a > { w : & 'a mut W , } impl < 'a > _STARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : STARTW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "No start (this value should be used when clearing PDN to 0)." ] # [ inline ] pub fn no_start_this_value ( self ) -> & 'a mut W { self . variant ( STARTW :: NO_START_THIS_VALUE ) } # [ doc = "Start conversion now." ] # [ inline ] pub fn start_conversion_now ( self ) -> & 'a mut W { self . variant ( STARTW :: START_CONVERSION_NOW ) } # [ doc = "Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0." ] # [ inline ] pub fn pio0_2 ( self ) -> & 'a mut W { self . variant ( STARTW :: PIO0_2 ) } # [ doc = "Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0." ] # [ inline ] pub fn pio1_5 ( self ) -> & 'a mut W { self . variant ( STARTW :: PIO1_5 ) } # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0\\[1\\]." ] # [ inline ] pub fn ct32b0_mat0 ( self ) -> & 'a mut W { self . variant ( STARTW :: CT32B0_MAT0 ) } # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1\\[1\\]." ] # [ inline ] pub fn ct32b0_mat1 ( self ) -> & 'a mut W { self . variant ( STARTW :: CT32B0_MAT1 ) } # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0\\[1\\]." ] # [ inline ] pub fn ct16b0_mat0 ( self ) -> & 'a mut W { self . variant ( STARTW :: CT16B0_MAT0 ) } # [ doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1\\[1\\]." ] # [ inline ] pub fn ct16b0_mat1 ( self ) -> & 'a mut W { self . variant ( STARTW :: CT16B0_MAT1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EDGE`" ] pub enum EDGEW { # [ doc = "Start conversion on a rising edge on the selected CAP/MAT signal." ] RISING , # [ doc = "Start conversion on a falling edge on the selected CAP/MAT signal." ] FALLING } impl EDGEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { EDGEW :: RISING => false , EDGEW :: FALLING => true } } } # [ doc = r" Proxy" ] pub struct _EDGEW < 'a > { w : & 'a mut W , } impl < 'a > _EDGEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EDGEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Start conversion on a rising edge on the selected CAP/MAT signal." ] # [ inline ] pub fn rising ( self ) -> & 'a mut W { self . variant ( EDGEW :: RISING ) } # [ doc = "Start conversion on a falling edge on the selected CAP/MAT signal." ] # [ inline ] pub fn falling ( self ) -> & 'a mut W { self . variant ( EDGEW :: FALLING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Selects which of the AD7:0 pins is (are) to be sampled and converted. Bit 0 selects Pin AD0, bit 1 selects pin AD1,..., and bit 7 selects pin AD7. In software-controlled mode (BURST = 0), only one channel can be selected, i.e. only one of these bits should be 1. In hardware scan mode (BURST = 1), any numbers of channels can be selected, i.e any or all bits can be set to 1. If all bits are set to 0, channel 0 is selected automatically (SEL = 0x01)." ] # [ inline ] pub fn sel ( & self ) -> SELR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; SELR { bits } } # [ doc = "Bits 8:15 - The APB clock (PCLK) is divided by CLKDIV +1 to produce the clock for the ADC, which should be less than or equal to 4.5 MHz. Typically, software should program the smallest value in this field that yields a clock of 4.5 MHz or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable." ] # [ inline ] pub fn clkdiv ( & self ) -> CLKDIVR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; CLKDIVR { bits } } # [ doc = "Bit 16 - Burst mode If BURST is set to 1, the ADGINTEN bit in the INTEN register (Table 276) must be set to 0." ] # [ inline ] pub fn burst ( & self ) -> BURSTR { BURSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 17:19 - This field selects the number of clocks used for each conversion in Burst mode, and the number of bits of accuracy of the result in the LS bits of ADDR, between 11 clocks (10 bits) and 4 clocks (3 bits)." ] # [ inline ] pub fn clks ( & self ) -> CLKSR { CLKSR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 24:26 - When the BURST bit is 0, these bits control whether and when an A/D conversion is started:" ] # [ inline ] pub fn start ( & self ) -> STARTR { STARTR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 27 - This bit is significant only when the START field contains 010-111. In these cases:" ] # [ inline ] pub fn edge ( & self ) -> EDGER { EDGER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Selects which of the AD7:0 pins is (are) to be sampled and converted. Bit 0 selects Pin AD0, bit 1 selects pin AD1,..., and bit 7 selects pin AD7. In software-controlled mode (BURST = 0), only one channel can be selected, i.e. only one of these bits should be 1. In hardware scan mode (BURST = 1), any numbers of channels can be selected, i.e any or all bits can be set to 1. If all bits are set to 0, channel 0 is selected automatically (SEL = 0x01)." ] # [ inline ] pub fn sel ( & mut self ) -> _SELW { _SELW { w : self } } # [ doc = "Bits 8:15 - The APB clock (PCLK) is divided by CLKDIV +1 to produce the clock for the ADC, which should be less than or equal to 4.5 MHz. Typically, software should program the smallest value in this field that yields a clock of 4.5 MHz or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable." ] # [ inline ] pub fn clkdiv ( & mut self ) -> _CLKDIVW { _CLKDIVW { w : self } } # [ doc = "Bit 16 - Burst mode If BURST is set to 1, the ADGINTEN bit in the INTEN register (Table 276) must be set to 0." ] # [ inline ] pub fn burst ( & mut self ) -> _BURSTW { _BURSTW { w : self } } # [ doc = "Bits 17:19 - This field selects the number of clocks used for each conversion in Burst mode, and the number of bits of accuracy of the result in the LS bits of ADDR, between 11 clocks (10 bits) and 4 clocks (3 bits)." ] # [ inline ] pub fn clks ( & mut self ) -> _CLKSW { _CLKSW { w : self } } # [ doc = "Bits 24:26 - When the BURST bit is 0, these bits control whether and when an A/D conversion is started:" ] # [ inline ] pub fn start ( & mut self ) -> _STARTW { _STARTW { w : self } } # [ doc = "Bit 27 - This bit is significant only when the START field contains 010-111. In these cases:" ] # [ inline ] pub fn edge ( & mut self ) -> _EDGEW { _EDGEW { w : self } } } } # [ doc = "A/D Global Data Register. Contains the result of the most recent A/D conversion." ] pub struct GDR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "A/D Global Data Register. Contains the result of the most recent A/D conversion." ] pub mod gdr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: GDR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct V_VREFR { bits : u16 , } impl V_VREFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct CHNR { bits : u8 , } impl CHNR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct OVERRUNR { bits : bool , } impl OVERRUNR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DONER { bits : bool , } impl DONER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _V_VREFW < 'a > { w : & 'a mut W , } impl < 'a > _V_VREFW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CHNW < 'a > { w : & 'a mut W , } impl < 'a > _CHNW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _OVERRUNW < 'a > { w : & 'a mut W , } impl < 'a > _OVERRUNW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DONEW < 'a > { w : & 'a mut W , } impl < 'a > _DONEW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 6:15 - When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin selected by the SEL field, divided by the voltage on the VDD pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VSS, while 0x3FF indicates that the voltage on ADn was close to, equal to, or greater than that on VREF." ] # [ inline ] pub fn v_vref ( & self ) -> V_VREFR { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; V_VREFR { bits } } # [ doc = "Bits 24:26 - These bits contain the channel from which the result bits V_VREF were converted." ] # [ inline ] pub fn chn ( & self ) -> CHNR { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; CHNR { bits } } # [ doc = "Bit 30 - This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits." ] # [ inline ] pub fn overrun ( & self ) -> OVERRUNR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; OVERRUNR { bits } } # [ doc = "Bit 31 - This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read and when the ADCR is written. If the ADCR is written while a conversion is still in progress, this bit is set and a new conversion is started." ] # [ inline ] pub fn done ( & self ) -> DONER { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DONER { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 6:15 - When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin selected by the SEL field, divided by the voltage on the VDD pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VSS, while 0x3FF indicates that the voltage on ADn was close to, equal to, or greater than that on VREF." ] # [ inline ] pub fn v_vref ( & mut self ) -> _V_VREFW { _V_VREFW { w : self } } # [ doc = "Bits 24:26 - These bits contain the channel from which the result bits V_VREF were converted." ] # [ inline ] pub fn chn ( & mut self ) -> _CHNW { _CHNW { w : self } } # [ doc = "Bit 30 - This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits." ] # [ inline ] pub fn overrun ( & mut self ) -> _OVERRUNW { _OVERRUNW { w : self } } # [ doc = "Bit 31 - This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read and when the ADCR is written. If the ADCR is written while a conversion is still in progress, this bit is set and a new conversion is started." ] # [ inline ] pub fn done ( & mut self ) -> _DONEW { _DONEW { w : self } } } } # [ doc = "A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt." ] pub struct INTEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt." ] pub mod inten { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ADINTENR { bits : u8 , } impl ADINTENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct ADGINTENR { bits : bool , } impl ADGINTENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _ADINTENW < 'a > { w : & 'a mut W , } impl < 'a > _ADINTENW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ADGINTENW < 'a > { w : & 'a mut W , } impl < 'a > _ADGINTENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc." ] # [ inline ] pub fn adinten ( & self ) -> ADINTENR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ADINTENR { bits } } # [ doc = "Bit 8 - When 1, enables the global DONE flag in ADDR to generate an interrupt. When 0, only the individual A/D channels enabled by ADINTEN 7:0 will generate interrupts. This bit must be set to 0 in burst mode (BURST = 1 in the CR register)." ] # [ inline ] pub fn adginten ( & self ) -> ADGINTENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ADGINTENR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x0100 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc." ] # [ inline ] pub fn adinten ( & mut self ) -> _ADINTENW { _ADINTENW { w : self } } # [ doc = "Bit 8 - When 1, enables the global DONE flag in ADDR to generate an interrupt. When 0, only the individual A/D channels enabled by ADINTEN 7:0 will generate interrupts. This bit must be set to 0 in burst mode (BURST = 1 in the CR register)." ] # [ inline ] pub fn adginten ( & mut self ) -> _ADGINTENW { _ADGINTENW { w : self } } } } # [ doc = "A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel N" ] pub struct DR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel N" ] pub mod dr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: DR { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct V_VREFR { bits : u16 , } impl V_VREFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct OVERRUNR { bits : bool , } impl OVERRUNR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DONER { bits : bool , } impl DONER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 6:15 - When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF." ] # [ inline ] pub fn v_vref ( & self ) -> V_VREFR { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; V_VREFR { bits } } # [ doc = "Bit 30 - This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register." ] # [ inline ] pub fn overrun ( & self ) -> OVERRUNR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; OVERRUNR { bits } } # [ doc = "Bit 31 - This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read." ] # [ inline ] pub fn done ( & self ) -> DONER { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DONER { bits } } } } # [ doc = "A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag." ] pub struct STAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag." ] pub mod stat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: STAT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct DONER { bits : u8 , } impl DONER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct OVERRUNR { bits : u8 , } impl OVERRUNR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct ADINTR { bits : bool , } impl ADINTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - These bits mirror the DONE status flags that appear in the result register for each A/D channel n." ] # [ inline ] pub fn done ( & self ) -> DONER { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DONER { bits } } # [ doc = "Bits 8:15 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel n. Reading ADSTAT allows checking the status of all A/D channels simultaneously." ] # [ inline ] pub fn overrun ( & self ) -> OVERRUNR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; OVERRUNR { bits } } # [ doc = "Bit 16 - This bit is the A/D interrupt flag. It is one when any of the individual A/D channel Done flags is asserted and enabled to contribute to the A/D interrupt via the ADINTEN register." ] # [ inline ] pub fn adint ( & self ) -> ADINTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ADINTR { bits } } } } } # [ doc = "Power Management Unit (PMU)" ] pub struct PMU { _marker : PhantomData < * const ( ) > } unsafe impl Send for PMU { } impl PMU { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const pmu :: RegisterBlock { 0x4003_8000 as * const _ } } impl Deref for PMU { type Target = pmu :: RegisterBlock ; fn deref ( & self ) -> & pmu :: RegisterBlock { unsafe { & * PMU :: ptr ( ) } } } # [ doc = "Power Management Unit (PMU)" ] pub mod pmu { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Power control register" ] pub pcon : PCON , # [ doc = "0x04 - General purpose register 0" ] pub gpreg : [ GPREG ; 4 ] , # [ doc = "0x14 - General purpose register 4" ] pub gpreg4 : GPREG4 , } # [ doc = "Power control register" ] pub struct PCON { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Power control register" ] pub mod pcon { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PCON { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMR { # [ doc = "Default. The part is in active or sleep mode." ] DEFAULT , # [ doc = "ARM WFI will enter Deep-sleep mode." ] DEEPSLEEP , # [ doc = "ARM WFI will enter Power-down mode." ] POWERDOWN , # [ doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down)." ] DEEPPOWERDOWN , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl PMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PMR :: DEFAULT => 0 , PMR :: DEEPSLEEP => 0x01 , PMR :: POWERDOWN => 0x02 , PMR :: DEEPPOWERDOWN => 0x03 , PMR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PMR { match value { 0 => PMR :: DEFAULT , 1 => PMR :: DEEPSLEEP , 2 => PMR :: POWERDOWN , 3 => PMR :: DEEPPOWERDOWN , i => PMR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ] pub fn is_default ( & self ) -> bool { * self == PMR :: DEFAULT } # [ doc = "Checks if the value of the field is `DEEPSLEEP`" ] # [ inline ] pub fn is_deepsleep ( & self ) -> bool { * self == PMR :: DEEPSLEEP } # [ doc = "Checks if the value of the field is `POWERDOWN`" ] # [ inline ] pub fn is_powerdown ( & self ) -> bool { * self == PMR :: POWERDOWN } # [ doc = "Checks if the value of the field is `DEEPPOWERDOWN`" ] # [ inline ] pub fn is_deeppowerdown ( & self ) -> bool { * self == PMR :: DEEPPOWERDOWN } } # [ doc = r" Value of the field" ] pub struct NODPDR { bits : bool , } impl NODPDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `SLEEPFLAG`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SLEEPFLAGR { # [ doc = "Read: No power-down mode entered. LPC11U1x is in Active mode. Write: No effect." ] NOPOWERDOWN , # [ doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0." ] POWERDOWN } impl SLEEPFLAGR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SLEEPFLAGR :: NOPOWERDOWN => false , SLEEPFLAGR :: POWERDOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SLEEPFLAGR { match value { false => SLEEPFLAGR :: NOPOWERDOWN , true => SLEEPFLAGR :: POWERDOWN , } } # [ doc = "Checks if the value of the field is `NOPOWERDOWN`" ] # [ inline ] pub fn is_nopowerdown ( & self ) -> bool { * self == SLEEPFLAGR :: NOPOWERDOWN } # [ doc = "Checks if the value of the field is `POWERDOWN`" ] # [ inline ] pub fn is_powerdown ( & self ) -> bool { * self == SLEEPFLAGR :: POWERDOWN } } # [ doc = "Possible values of the field `DPDFLAG`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DPDFLAGR { # [ doc = "Read: Deep power-down mode  not entered. Write: No effect." ] DPNOTENTERED , # [ doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag." ] DPENTERED } impl DPDFLAGR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DPDFLAGR :: DPNOTENTERED => false , DPDFLAGR :: DPENTERED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DPDFLAGR { match value { false => DPDFLAGR :: DPNOTENTERED , true => DPDFLAGR :: DPENTERED , } } # [ doc = "Checks if the value of the field is `DPNOTENTERED`" ] # [ inline ] pub fn is_dpnotentered ( & self ) -> bool { * self == DPDFLAGR :: DPNOTENTERED } # [ doc = "Checks if the value of the field is `DPENTERED`" ] # [ inline ] pub fn is_dpentered ( & self ) -> bool { * self == DPDFLAGR :: DPENTERED } } # [ doc = "Values that can be written to the field `PM`" ] pub enum PMW { # [ doc = "Default. The part is in active or sleep mode." ] DEFAULT , # [ doc = "ARM WFI will enter Deep-sleep mode." ] DEEPSLEEP , # [ doc = "ARM WFI will enter Power-down mode." ] POWERDOWN , # [ doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down)." ] DEEPPOWERDOWN } impl PMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PMW :: DEFAULT => 0 , PMW :: DEEPSLEEP => 1 , PMW :: POWERDOWN => 2 , PMW :: DEEPPOWERDOWN => 3 } } } # [ doc = r" Proxy" ] pub struct _PMW < 'a > { w : & 'a mut W , } impl < 'a > _PMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PMW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default. The part is in active or sleep mode." ] # [ inline ] pub fn default ( self ) -> & 'a mut W { self . variant ( PMW :: DEFAULT ) } # [ doc = "ARM WFI will enter Deep-sleep mode." ] # [ inline ] pub fn deepsleep ( self ) -> & 'a mut W { self . variant ( PMW :: DEEPSLEEP ) } # [ doc = "ARM WFI will enter Power-down mode." ] # [ inline ] pub fn powerdown ( self ) -> & 'a mut W { self . variant ( PMW :: POWERDOWN ) } # [ doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down)." ] # [ inline ] pub fn deeppowerdown ( self ) -> & 'a mut W { self . variant ( PMW :: DEEPPOWERDOWN ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NODPDW < 'a > { w : & 'a mut W , } impl < 'a > _NODPDW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SLEEPFLAG`" ] pub enum SLEEPFLAGW { # [ doc = "Read: No power-down mode entered. LPC11U1x is in Active mode. Write: No effect." ] NOPOWERDOWN , # [ doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0." ] POWERDOWN } impl SLEEPFLAGW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SLEEPFLAGW :: NOPOWERDOWN => false , SLEEPFLAGW :: POWERDOWN => true } } } # [ doc = r" Proxy" ] pub struct _SLEEPFLAGW < 'a > { w : & 'a mut W , } impl < 'a > _SLEEPFLAGW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SLEEPFLAGW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Read: No power-down mode entered. LPC11U1x is in Active mode. Write: No effect." ] # [ inline ] pub fn nopowerdown ( self ) -> & 'a mut W { self . variant ( SLEEPFLAGW :: NOPOWERDOWN ) } # [ doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0." ] # [ inline ] pub fn powerdown ( self ) -> & 'a mut W { self . variant ( SLEEPFLAGW :: POWERDOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DPDFLAG`" ] pub enum DPDFLAGW { # [ doc = "Read: Deep power-down mode  not entered. Write: No effect." ] DPNOTENTERED , # [ doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag." ] DPENTERED } impl DPDFLAGW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DPDFLAGW :: DPNOTENTERED => false , DPDFLAGW :: DPENTERED => true } } } # [ doc = r" Proxy" ] pub struct _DPDFLAGW < 'a > { w : & 'a mut W , } impl < 'a > _DPDFLAGW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DPDFLAGW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Read: Deep power-down mode not entered. Write: No effect." ] # [ inline ] pub fn dpnotentered ( self ) -> & 'a mut W { self . variant ( DPDFLAGW :: DPNOTENTERED ) } # [ doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag." ] # [ inline ] pub fn dpentered ( self ) -> & 'a mut W { self . variant ( DPDFLAGW :: DPENTERED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Power mode" ] # [ inline ] pub fn pm ( & self ) -> PMR { PMR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 3 - A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed. Execution continues after the WFI if this bit is 1. This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked." ] # [ inline ] pub fn nodpd ( & self ) -> NODPDR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; NODPDR { bits } } # [ doc = "Bit 8 - Sleep mode flag" ] # [ inline ] pub fn sleepflag ( & self ) -> SLEEPFLAGR { SLEEPFLAGR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Deep power-down flag" ] # [ inline ] pub fn dpdflag ( & self ) -> DPDFLAGR { DPDFLAGR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Power mode" ] # [ inline ] pub fn pm ( & mut self ) -> _PMW { _PMW { w : self } } # [ doc = "Bit 3 - A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed. Execution continues after the WFI if this bit is 1. This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked." ] # [ inline ] pub fn nodpd ( & mut self ) -> _NODPDW { _NODPDW { w : self } } # [ doc = "Bit 8 - Sleep mode flag" ] # [ inline ] pub fn sleepflag ( & mut self ) -> _SLEEPFLAGW { _SLEEPFLAGW { w : self } } # [ doc = "Bit 11 - Deep power-down flag" ] # [ inline ] pub fn dpdflag ( & mut self ) -> _DPDFLAGW { _DPDFLAGW { w : self } } } } # [ doc = "General purpose register 0" ] pub struct GPREG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "General purpose register 0" ] pub mod gpreg { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: GPREG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct GPDATAR { bits : u32 , } impl GPDATAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _GPDATAW < 'a > { w : & 'a mut W , } impl < 'a > _GPDATAW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Data retained during Deep power-down mode." ] # [ inline ] pub fn gpdata ( & self ) -> GPDATAR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; GPDATAR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Data retained during Deep power-down mode." ] # [ inline ] pub fn gpdata ( & mut self ) -> _GPDATAW { _GPDATAW { w : self } } } } # [ doc = "General purpose register 4" ] pub struct GPREG4 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "General purpose register 4" ] pub mod gpreg4 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: GPREG4 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `WAKEUPHYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WAKEUPHYSR { # [ doc = "Hysteresis for WAKEUP pin disabled." ] DISABLED , # [ doc = "Hysteresis for WAKEUP pin enabled." ] ENABLED } impl WAKEUPHYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WAKEUPHYSR :: DISABLED => false , WAKEUPHYSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WAKEUPHYSR { match value { false => WAKEUPHYSR :: DISABLED , true => WAKEUPHYSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == WAKEUPHYSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == WAKEUPHYSR :: ENABLED } } # [ doc = r" Value of the field" ] pub struct GPDATAR { bits : u32 , } impl GPDATAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = "Values that can be written to the field `WAKEUPHYS`" ] pub enum WAKEUPHYSW { # [ doc = "Hysteresis for WAKEUP pin disabled." ] DISABLED , # [ doc = "Hysteresis for WAKEUP pin enabled." ] ENABLED } impl WAKEUPHYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WAKEUPHYSW :: DISABLED => false , WAKEUPHYSW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _WAKEUPHYSW < 'a > { w : & 'a mut W , } impl < 'a > _WAKEUPHYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WAKEUPHYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Hysteresis for WAKEUP pin disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( WAKEUPHYSW :: DISABLED ) } # [ doc = "Hysteresis for WAKEUP pin enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( WAKEUPHYSW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _GPDATAW < 'a > { w : & 'a mut W , } impl < 'a > _GPDATAW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x001f_ffff ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 10 - WAKEUP pin hysteresis enable" ] # [ inline ] pub fn wakeuphys ( & self ) -> WAKEUPHYSR { WAKEUPHYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 11:31 - Data retained during Deep power-down mode." ] # [ inline ] pub fn gpdata ( & self ) -> GPDATAR { let bits = { const MASK : u32 = 0x001f_ffff ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; GPDATAR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 10 - WAKEUP pin hysteresis enable" ] # [ inline ] pub fn wakeuphys ( & mut self ) -> _WAKEUPHYSW { _WAKEUPHYSW { w : self } } # [ doc = "Bits 11:31 - Data retained during Deep power-down mode." ] # [ inline ] pub fn gpdata ( & mut self ) -> _GPDATAW { _GPDATAW { w : self } } } } } # [ doc = "Flash controller" ] pub struct FLASHCTRL { _marker : PhantomData < * const ( ) > } unsafe impl Send for FLASHCTRL { } impl FLASHCTRL { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const flashctrl :: RegisterBlock { 0x4003_c000 as * const _ } } impl Deref for FLASHCTRL { type Target = flashctrl :: RegisterBlock ; fn deref ( & self ) -> & flashctrl :: RegisterBlock { unsafe { & * FLASHCTRL :: ptr ( ) } } } # [ doc = "Flash controller" ] pub mod flashctrl { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 16usize ] , # [ doc = "0x10 - Flash memory access time configuration register" ] pub flashcfg : FLASHCFG , _reserved1 : [ u8 ; 12usize ] , # [ doc = "0x20 - Signature start address register" ] pub fmsstart : FMSSTART , # [ doc = "0x24 - Signature stop-address register" ] pub fmsstop : FMSSTOP , _reserved2 : [ u8 ; 4usize ] , # [ doc = "0x2c - Word 0 \\[31:0\\]" ] pub fmsw0 : FMSW0 , # [ doc = "0x30 - Word 1 \\[63:32\\]" ] pub fmsw1 : FMSW1 , # [ doc = "0x34 - Word 2 \\[95:64\\]" ] pub fmsw2 : FMSW2 , # [ doc = "0x38 - Word 3 \\[127:96\\]" ] pub fmsw3 : FMSW3 , _reserved3 : [ u8 ; 96usize ] , # [ doc = "0x9c - EEPROM BIST start address register" ] pub eemsstart : EEMSSTART , # [ doc = "0xa0 - EEPROM BIST stop address register" ] pub eemsstop : EEMSSTOP , # [ doc = "0xa4 - EEPROM 24-bit BIST signature register" ] pub eemssig : EEMSSIG , _reserved4 : [ u8 ; 3896usize ] , # [ doc = "0xfe0 - Signature generation status register" ] pub fmstat : FMSTAT , _reserved5 : [ u8 ; 4usize ] , # [ doc = "0xfe8 - Signature generation status clear register" ] pub fmstatclr : FMSTATCLR , } # [ doc = "EEPROM BIST start address register" ] pub struct EEMSSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "EEPROM BIST start address register" ] pub mod eemsstart { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EEMSSTART { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct STARTAR { bits : u16 , } impl STARTAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _STARTAW < 'a > { w : & 'a mut W , } impl < 'a > _STARTAW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x3fff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:13 - BIST start address: Bit 0 is fixed zero since only even addresses are allowed." ] # [ inline ] pub fn starta ( & self ) -> STARTAR { let bits = { const MASK : u16 = 0x3fff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; STARTAR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:13 - BIST start address: Bit 0 is fixed zero since only even addresses are allowed." ] # [ inline ] pub fn starta ( & mut self ) -> _STARTAW { _STARTAW { w : self } } } } # [ doc = "EEPROM BIST stop address register" ] pub struct EEMSSTOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "EEPROM BIST stop address register" ] pub mod eemsstop { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EEMSSTOP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct STOPAR { bits : u16 , } impl STOPAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct DEVSELR { bits : bool , } impl DEVSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct STRTBISTR { bits : bool , } impl STRTBISTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _STOPAW < 'a > { w : & 'a mut W , } impl < 'a > _STOPAW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x3fff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DEVSELW < 'a > { w : & 'a mut W , } impl < 'a > _DEVSELW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _STRTBISTW < 'a > { w : & 'a mut W , } impl < 'a > _STRTBISTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:13 - BIST stop address: Bit 0 is fixed zero since only even addresses are allowed." ] # [ inline ] pub fn stopa ( & self ) -> STOPAR { let bits = { const MASK : u16 = 0x3fff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; STOPAR { bits } } # [ doc = "Bit 30 - BIST device select bit 0: the BIST signature is generated over the total memory space. Singe pages are interleaved over the EEPROM devices when multiple devices are used, the signature is generated over memory of multiple devices. 1: the BIST signature is generated only over a memory range located on a single EEPROM device. Therefore the internal address generation is done such that the address' CS bits are kept stable to select only the same device. The address' MSB and LSB bits are used to step through the memory range specified by the start and stop address fields. Note: if this bit is set the start and stop address fields must be programmed such that they both address the same EEPROM device. Therefore the address' CS bits in both the start and stop address must be the same." ] # [ inline ] pub fn devsel ( & self ) -> DEVSELR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DEVSELR { bits } } # [ doc = "Bit 31 - BIST start bit Setting this bit will start the BIST. This bit is self-clearing." ] # [ inline ] pub fn strtbist ( & self ) -> STRTBISTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; STRTBISTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:13 - BIST stop address: Bit 0 is fixed zero since only even addresses are allowed." ] # [ inline ] pub fn stopa ( & mut self ) -> _STOPAW { _STOPAW { w : self } } # [ doc = "Bit 30 - BIST device select bit 0: the BIST signature is generated over the total memory space. Singe pages are interleaved over the EEPROM devices when multiple devices are used, the signature is generated over memory of multiple devices. 1: the BIST signature is generated only over a memory range located on a single EEPROM device. Therefore the internal address generation is done such that the address' CS bits are kept stable to select only the same device. The address' MSB and LSB bits are used to step through the memory range specified by the start and stop address fields. Note: if this bit is set the start and stop address fields must be programmed such that they both address the same EEPROM device. Therefore the address' CS bits in both the start and stop address must be the same." ] # [ inline ] pub fn devsel ( & mut self ) -> _DEVSELW { _DEVSELW { w : self } } # [ doc = "Bit 31 - BIST start bit Setting this bit will start the BIST. This bit is self-clearing." ] # [ inline ] pub fn strtbist ( & mut self ) -> _STRTBISTW { _STRTBISTW { w : self } } } } # [ doc = "EEPROM 24-bit BIST signature register" ] pub struct EEMSSIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "EEPROM 24-bit BIST signature register" ] pub mod eemssig { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: EEMSSIG { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct DATA_SIGR { bits : u16 , } impl DATA_SIGR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct PARITY_SIGR { bits : u16 , } impl PARITY_SIGR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - BIST 16-bit signature calculated from only the data bytes" ] # [ inline ] pub fn data_sig ( & self ) -> DATA_SIGR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; DATA_SIGR { bits } } # [ doc = "Bits 16:31 - BIST 16-bit signature calculated from only the parity bits of the data bytes" ] # [ inline ] pub fn parity_sig ( & self ) -> PARITY_SIGR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; PARITY_SIGR { bits } } } } # [ doc = "Flash memory access time configuration register" ] pub struct FLASHCFG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Flash memory access time configuration register" ] pub mod flashcfg { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FLASHCFG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FLASHTIM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLASHTIMR { # [ doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)." ] _1_SYSTEM_CLOCK_FLASH , # [ doc = "2 system clocks flash access time (for system clock frequencies of up to 40 MHz)." ] _2_SYSTEM_CLOCKS_FLAS , # [ doc = "3 system clocks flash access time (for system clock frequencies of up to 50 MHz)." ] _3_SYSTEM_CLOCKS_FLAS , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FLASHTIMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FLASHTIMR :: _1_SYSTEM_CLOCK_FLASH => 0 , FLASHTIMR :: _2_SYSTEM_CLOCKS_FLAS => 0x01 , FLASHTIMR :: _3_SYSTEM_CLOCKS_FLAS => 0x02 , FLASHTIMR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FLASHTIMR { match value { 0 => FLASHTIMR :: _1_SYSTEM_CLOCK_FLASH , 1 => FLASHTIMR :: _2_SYSTEM_CLOCKS_FLAS , 2 => FLASHTIMR :: _3_SYSTEM_CLOCKS_FLAS , i => FLASHTIMR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `_1_SYSTEM_CLOCK_FLASH`" ] # [ inline ] pub fn is_1_system_clock_flash ( & self ) -> bool { * self == FLASHTIMR :: _1_SYSTEM_CLOCK_FLASH } # [ doc = "Checks if the value of the field is `_2_SYSTEM_CLOCKS_FLAS`" ] # [ inline ] pub fn is_2_system_clocks_flas ( & self ) -> bool { * self == FLASHTIMR :: _2_SYSTEM_CLOCKS_FLAS } # [ doc = "Checks if the value of the field is `_3_SYSTEM_CLOCKS_FLAS`" ] # [ inline ] pub fn is_3_system_clocks_flas ( & self ) -> bool { * self == FLASHTIMR :: _3_SYSTEM_CLOCKS_FLAS } } # [ doc = "Values that can be written to the field `FLASHTIM`" ] pub enum FLASHTIMW { # [ doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)." ] _1_SYSTEM_CLOCK_FLASH , # [ doc = "2 system clocks flash access time (for system clock frequencies of up to 40 MHz)." ] _2_SYSTEM_CLOCKS_FLAS , # [ doc = "3 system clocks flash access time (for system clock frequencies of up to 50 MHz)." ] _3_SYSTEM_CLOCKS_FLAS } impl FLASHTIMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FLASHTIMW :: _1_SYSTEM_CLOCK_FLASH => 0 , FLASHTIMW :: _2_SYSTEM_CLOCKS_FLAS => 1 , FLASHTIMW :: _3_SYSTEM_CLOCKS_FLAS => 2 } } } # [ doc = r" Proxy" ] pub struct _FLASHTIMW < 'a > { w : & 'a mut W , } impl < 'a > _FLASHTIMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FLASHTIMW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)." ] # [ inline ] pub fn _1_system_clock_flash ( self ) -> & 'a mut W { self . variant ( FLASHTIMW :: _1_SYSTEM_CLOCK_FLASH ) } # [ doc = "2 system clocks flash access time (for system clock frequencies of up to 40 MHz)." ] # [ inline ] pub fn _2_system_clocks_flas ( self ) -> & 'a mut W { self . variant ( FLASHTIMW :: _2_SYSTEM_CLOCKS_FLAS ) } # [ doc = "3 system clocks flash access time (for system clock frequencies of up to 50 MHz)." ] # [ inline ] pub fn _3_system_clocks_flas ( self ) -> & 'a mut W { self . variant ( FLASHTIMW :: _3_SYSTEM_CLOCKS_FLAS ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access." ] # [ inline ] pub fn flashtim ( & self ) -> FLASHTIMR { FLASHTIMR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access." ] # [ inline ] pub fn flashtim ( & mut self ) -> _FLASHTIMW { _FLASHTIMW { w : self } } } } # [ doc = "Signature start address register" ] pub struct FMSSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Signature start address register" ] pub mod fmsstart { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FMSSTART { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct STARTR { bits : u32 , } impl STARTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _STARTW < 'a > { w : & 'a mut W , } impl < 'a > _STARTW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x0001_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits\\[20:4\\])." ] # [ inline ] pub fn start ( & self ) -> STARTR { let bits = { const MASK : u32 = 0x0001_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; STARTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits\\[20:4\\])." ] # [ inline ] pub fn start ( & mut self ) -> _STARTW { _STARTW { w : self } } } } # [ doc = "Signature stop-address register" ] pub struct FMSSTOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Signature stop-address register" ] pub mod fmsstop { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FMSSTOP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct STOPR { bits : u32 , } impl STOPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = "Possible values of the field `SIG_START`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SIG_STARTR { # [ doc = "Signature generation is stopped" ] SIGNATURE_GENERATION , # [ doc = "Initiate signature generation" ] INITIATE_SIGNATURE_G } impl SIG_STARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SIG_STARTR :: SIGNATURE_GENERATION => false , SIG_STARTR :: INITIATE_SIGNATURE_G => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SIG_STARTR { match value { false => SIG_STARTR :: SIGNATURE_GENERATION , true => SIG_STARTR :: INITIATE_SIGNATURE_G , } } # [ doc = "Checks if the value of the field is `SIGNATURE_GENERATION`" ] # [ inline ] pub fn is_signature_generation ( & self ) -> bool { * self == SIG_STARTR :: SIGNATURE_GENERATION } # [ doc = "Checks if the value of the field is `INITIATE_SIGNATURE_G`" ] # [ inline ] pub fn is_initiate_signature_g ( & self ) -> bool { * self == SIG_STARTR :: INITIATE_SIGNATURE_G } } # [ doc = r" Proxy" ] pub struct _STOPW < 'a > { w : & 'a mut W , } impl < 'a > _STOPW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x0001_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SIG_START`" ] pub enum SIG_STARTW { # [ doc = "Signature generation is stopped" ] SIGNATURE_GENERATION , # [ doc = "Initiate signature generation" ] INITIATE_SIGNATURE_G } impl SIG_STARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SIG_STARTW :: SIGNATURE_GENERATION => false , SIG_STARTW :: INITIATE_SIGNATURE_G => true } } } # [ doc = r" Proxy" ] pub struct _SIG_STARTW < 'a > { w : & 'a mut W , } impl < 'a > _SIG_STARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SIG_STARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Signature generation is stopped" ] # [ inline ] pub fn signature_generation ( self ) -> & 'a mut W { self . variant ( SIG_STARTW :: SIGNATURE_GENERATION ) } # [ doc = "Initiate signature generation" ] # [ inline ] pub fn initiate_signature_g ( self ) -> & 'a mut W { self . variant ( SIG_STARTW :: INITIATE_SIGNATURE_G ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:16 - BIST stop address divided by 16 (corresponds to AHB byte address \\[20:4\\])." ] # [ inline ] pub fn stop ( & self ) -> STOPR { let bits = { const MASK : u32 = 0x0001_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; STOPR { bits } } # [ doc = "Bit 17 - Start control bit for signature generation." ] # [ inline ] pub fn sig_start ( & self ) -> SIG_STARTR { SIG_STARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:16 - BIST stop address divided by 16 (corresponds to AHB byte address \\[20:4\\])." ] # [ inline ] pub fn stop ( & mut self ) -> _STOPW { _STOPW { w : self } } # [ doc = "Bit 17 - Start control bit for signature generation." ] # [ inline ] pub fn sig_start ( & mut self ) -> _SIG_STARTW { _SIG_STARTW { w : self } } } } # [ doc = "Word 0 \\[31:0\\]" ] pub struct FMSW0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Word 0 \\[31:0\\]" ] pub mod fmsw0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: FMSW0 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct SW0_31_0R { bits : u32 , } impl SW0_31_0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Word 0 of 128-bit signature (bits 31 to 0)." ] # [ inline ] pub fn sw0_31_0 ( & self ) -> SW0_31_0R { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; SW0_31_0R { bits } } } } # [ doc = "Word 1 \\[63:32\\]" ] pub struct FMSW1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Word 1 \\[63:32\\]" ] pub mod fmsw1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: FMSW1 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct SW1_63_32R { bits : u32 , } impl SW1_63_32R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Word 1 of 128-bit signature (bits 63 to 32)." ] # [ inline ] pub fn sw1_63_32 ( & self ) -> SW1_63_32R { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; SW1_63_32R { bits } } } } # [ doc = "Word 2 \\[95:64\\]" ] pub struct FMSW2 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Word 2 \\[95:64\\]" ] pub mod fmsw2 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: FMSW2 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct SW2_95_64R { bits : u32 , } impl SW2_95_64R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Word 2 of 128-bit signature (bits 95 to 64)." ] # [ inline ] pub fn sw2_95_64 ( & self ) -> SW2_95_64R { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; SW2_95_64R { bits } } } } # [ doc = "Word 3 \\[127:96\\]" ] pub struct FMSW3 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Word 3 \\[127:96\\]" ] pub mod fmsw3 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: FMSW3 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct SW3_127_96R { bits : u32 , } impl SW3_127_96R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Word 3 of 128-bit signature (bits 127 to 96)." ] # [ inline ] pub fn sw3_127_96 ( & self ) -> SW3_127_96R { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; SW3_127_96R { bits } } } } # [ doc = "Signature generation status register" ] pub struct FMSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Signature generation status register" ] pub mod fmstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: FMSTAT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct SIG_DONER { bits : bool , } impl SIG_DONER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - When 1, a previously started signature generation has completed. See FMSTATCLR register description for clearing this flag." ] # [ inline ] pub fn sig_done ( & self ) -> SIG_DONER { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SIG_DONER { bits } } } } # [ doc = "Signature generation status clear register" ] pub struct FMSTATCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Signature generation status clear register" ] pub mod fmstatclr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FMSTATCLR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _SIG_DONE_CLRW < 'a > { w : & 'a mut W , } impl < 'a > _SIG_DONE_CLRW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Writing a 1 to this bits clears the signature generation completion flag (SIG_DONE) in the FMSTAT register." ] # [ inline ] pub fn sig_done_clr ( & mut self ) -> _SIG_DONE_CLRW { _SIG_DONE_CLRW { w : self } } } } } # [ doc = "SSP/SPI" ] pub struct SSP0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SSP0 { } impl SSP0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ssp0 :: RegisterBlock { 0x4004_0000 as * const _ } } impl Deref for SSP0 { type Target = ssp0 :: RegisterBlock ; fn deref ( & self ) -> & ssp0 :: RegisterBlock { unsafe { & * SSP0 :: ptr ( ) } } } # [ doc = "SSP/SPI" ] pub mod ssp0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control Register 0. Selects the serial clock rate, bus type, and data size." ] pub cr0 : CR0 , # [ doc = "0x04 - Control Register 1. Selects master/slave and other modes." ] pub cr1 : CR1 , # [ doc = "0x08 - Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO." ] pub dr : DR , # [ doc = "0x0c - Status Register" ] pub sr : SR , # [ doc = "0x10 - Clock Prescale Register" ] pub cpsr : CPSR , # [ doc = "0x14 - Interrupt Mask Set and Clear Register" ] pub imsc : IMSC , # [ doc = "0x18 - Raw Interrupt Status Register" ] pub ris : RIS , # [ doc = "0x1c - Masked Interrupt Status Register" ] pub mis : MIS , # [ doc = "0x20 - SSPICR Interrupt Clear Register" ] pub icr : ICR , } # [ doc = "Control Register 0. Selects the serial clock rate, bus type, and data size." ] pub struct CR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Control Register 0. Selects the serial clock rate, bus type, and data size." ] pub mod cr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CR0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DSS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DSSR { # [ doc = "4-bit transfer" ] _4_BIT_TRANSFER , # [ doc = "5-bit transfer" ] _5_BIT_TRANSFER , # [ doc = "6-bit transfer" ] _6_BIT_TRANSFER , # [ doc = "7-bit transfer" ] _7_BIT_TRANSFER , # [ doc = "8-bit transfer" ] _8_BIT_TRANSFER , # [ doc = "9-bit transfer" ] _9_BIT_TRANSFER , # [ doc = "10-bit transfer" ] _10_BIT_TRANSFER , # [ doc = "11-bit transfer" ] _11_BIT_TRANSFER , # [ doc = "12-bit transfer" ] _12_BIT_TRANSFER , # [ doc = "13-bit transfer" ] _13_BIT_TRANSFER , # [ doc = "14-bit transfer" ] _14_BIT_TRANSFER , # [ doc = "15-bit transfer" ] _15_BIT_TRANSFER , # [ doc = "16-bit transfer" ] _16_BIT_TRANSFER , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl DSSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { DSSR :: _4_BIT_TRANSFER => 0x03 , DSSR :: _5_BIT_TRANSFER => 0x04 , DSSR :: _6_BIT_TRANSFER => 0x05 , DSSR :: _7_BIT_TRANSFER => 0x06 , DSSR :: _8_BIT_TRANSFER => 0x07 , DSSR :: _9_BIT_TRANSFER => 0x08 , DSSR :: _10_BIT_TRANSFER => 0x09 , DSSR :: _11_BIT_TRANSFER => 0x0a , DSSR :: _12_BIT_TRANSFER => 0x0b , DSSR :: _13_BIT_TRANSFER => 0x0c , DSSR :: _14_BIT_TRANSFER => 0x0d , DSSR :: _15_BIT_TRANSFER => 0x0e , DSSR :: _16_BIT_TRANSFER => 0x0f , DSSR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> DSSR { match value { 3 => DSSR :: _4_BIT_TRANSFER , 4 => DSSR :: _5_BIT_TRANSFER , 5 => DSSR :: _6_BIT_TRANSFER , 6 => DSSR :: _7_BIT_TRANSFER , 7 => DSSR :: _8_BIT_TRANSFER , 8 => DSSR :: _9_BIT_TRANSFER , 9 => DSSR :: _10_BIT_TRANSFER , 10 => DSSR :: _11_BIT_TRANSFER , 11 => DSSR :: _12_BIT_TRANSFER , 12 => DSSR :: _13_BIT_TRANSFER , 13 => DSSR :: _14_BIT_TRANSFER , 14 => DSSR :: _15_BIT_TRANSFER , 15 => DSSR :: _16_BIT_TRANSFER , i => DSSR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `_4_BIT_TRANSFER`" ] # [ inline ] pub fn is_4_bit_transfer ( & self ) -> bool { * self == DSSR :: _4_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_5_BIT_TRANSFER`" ] # [ inline ] pub fn is_5_bit_transfer ( & self ) -> bool { * self == DSSR :: _5_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_6_BIT_TRANSFER`" ] # [ inline ] pub fn is_6_bit_transfer ( & self ) -> bool { * self == DSSR :: _6_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_7_BIT_TRANSFER`" ] # [ inline ] pub fn is_7_bit_transfer ( & self ) -> bool { * self == DSSR :: _7_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_8_BIT_TRANSFER`" ] # [ inline ] pub fn is_8_bit_transfer ( & self ) -> bool { * self == DSSR :: _8_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_9_BIT_TRANSFER`" ] # [ inline ] pub fn is_9_bit_transfer ( & self ) -> bool { * self == DSSR :: _9_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_10_BIT_TRANSFER`" ] # [ inline ] pub fn is_10_bit_transfer ( & self ) -> bool { * self == DSSR :: _10_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_11_BIT_TRANSFER`" ] # [ inline ] pub fn is_11_bit_transfer ( & self ) -> bool { * self == DSSR :: _11_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_12_BIT_TRANSFER`" ] # [ inline ] pub fn is_12_bit_transfer ( & self ) -> bool { * self == DSSR :: _12_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_13_BIT_TRANSFER`" ] # [ inline ] pub fn is_13_bit_transfer ( & self ) -> bool { * self == DSSR :: _13_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_14_BIT_TRANSFER`" ] # [ inline ] pub fn is_14_bit_transfer ( & self ) -> bool { * self == DSSR :: _14_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_15_BIT_TRANSFER`" ] # [ inline ] pub fn is_15_bit_transfer ( & self ) -> bool { * self == DSSR :: _15_BIT_TRANSFER } # [ doc = "Checks if the value of the field is `_16_BIT_TRANSFER`" ] # [ inline ] pub fn is_16_bit_transfer ( & self ) -> bool { * self == DSSR :: _16_BIT_TRANSFER } } # [ doc = "Possible values of the field `FRF`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FRFR { # [ doc = "SPI" ] SPI , # [ doc = "TI" ] TI , # [ doc = "Microwire" ] MICROWIRE } impl FRFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FRFR :: SPI => 0 , FRFR :: TI => 0x01 , FRFR :: MICROWIRE => 0x02 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FRFR { match value { 0 => FRFR :: SPI , 1 => FRFR :: TI , 2 => FRFR :: MICROWIRE , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `SPI`" ] # [ inline ] pub fn is_spi ( & self ) -> bool { * self == FRFR :: SPI } # [ doc = "Checks if the value of the field is `TI`" ] # [ inline ] pub fn is_ti ( & self ) -> bool { * self == FRFR :: TI } # [ doc = "Checks if the value of the field is `MICROWIRE`" ] # [ inline ] pub fn is_microwire ( & self ) -> bool { * self == FRFR :: MICROWIRE } } # [ doc = "Possible values of the field `CPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPOLR { # [ doc = "SPI controller maintains the bus clock low between frames." ] LOW , # [ doc = "SPI controller maintains the bus clock high between frames." ] HIGH } impl CPOLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CPOLR :: LOW => false , CPOLR :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CPOLR { match value { false => CPOLR :: LOW , true => CPOLR :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == CPOLR :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == CPOLR :: HIGH } } # [ doc = "Possible values of the field `CPHA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPHAR { # [ doc = "SPI controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line." ] FIRSTCLOCK , # [ doc = "SPI controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line." ] SECONDCLOCK } impl CPHAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CPHAR :: FIRSTCLOCK => false , CPHAR :: SECONDCLOCK => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CPHAR { match value { false => CPHAR :: FIRSTCLOCK , true => CPHAR :: SECONDCLOCK , } } # [ doc = "Checks if the value of the field is `FIRSTCLOCK`" ] # [ inline ] pub fn is_firstclock ( & self ) -> bool { * self == CPHAR :: FIRSTCLOCK } # [ doc = "Checks if the value of the field is `SECONDCLOCK`" ] # [ inline ] pub fn is_secondclock ( & self ) -> bool { * self == CPHAR :: SECONDCLOCK } } # [ doc = r" Value of the field" ] pub struct SCRR { bits : u8 , } impl SCRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Values that can be written to the field `DSS`" ] pub enum DSSW { # [ doc = "4-bit transfer" ] _4_BIT_TRANSFER , # [ doc = "5-bit transfer" ] _5_BIT_TRANSFER , # [ doc = "6-bit transfer" ] _6_BIT_TRANSFER , # [ doc = "7-bit transfer" ] _7_BIT_TRANSFER , # [ doc = "8-bit transfer" ] _8_BIT_TRANSFER , # [ doc = "9-bit transfer" ] _9_BIT_TRANSFER , # [ doc = "10-bit transfer" ] _10_BIT_TRANSFER , # [ doc = "11-bit transfer" ] _11_BIT_TRANSFER , # [ doc = "12-bit transfer" ] _12_BIT_TRANSFER , # [ doc = "13-bit transfer" ] _13_BIT_TRANSFER , # [ doc = "14-bit transfer" ] _14_BIT_TRANSFER , # [ doc = "15-bit transfer" ] _15_BIT_TRANSFER , # [ doc = "16-bit transfer" ] _16_BIT_TRANSFER } impl DSSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { DSSW :: _4_BIT_TRANSFER => 3 , DSSW :: _5_BIT_TRANSFER => 4 , DSSW :: _6_BIT_TRANSFER => 5 , DSSW :: _7_BIT_TRANSFER => 6 , DSSW :: _8_BIT_TRANSFER => 7 , DSSW :: _9_BIT_TRANSFER => 8 , DSSW :: _10_BIT_TRANSFER => 9 , DSSW :: _11_BIT_TRANSFER => 10 , DSSW :: _12_BIT_TRANSFER => 11 , DSSW :: _13_BIT_TRANSFER => 12 , DSSW :: _14_BIT_TRANSFER => 13 , DSSW :: _15_BIT_TRANSFER => 14 , DSSW :: _16_BIT_TRANSFER => 15 } } } # [ doc = r" Proxy" ] pub struct _DSSW < 'a > { w : & 'a mut W , } impl < 'a > _DSSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DSSW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "4-bit transfer" ] # [ inline ] pub fn _4_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _4_BIT_TRANSFER ) } # [ doc = "5-bit transfer" ] # [ inline ] pub fn _5_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _5_BIT_TRANSFER ) } # [ doc = "6-bit transfer" ] # [ inline ] pub fn _6_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _6_BIT_TRANSFER ) } # [ doc = "7-bit transfer" ] # [ inline ] pub fn _7_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _7_BIT_TRANSFER ) } # [ doc = "8-bit transfer" ] # [ inline ] pub fn _8_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _8_BIT_TRANSFER ) } # [ doc = "9-bit transfer" ] # [ inline ] pub fn _9_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _9_BIT_TRANSFER ) } # [ doc = "10-bit transfer" ] # [ inline ] pub fn _10_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _10_BIT_TRANSFER ) } # [ doc = "11-bit transfer" ] # [ inline ] pub fn _11_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _11_BIT_TRANSFER ) } # [ doc = "12-bit transfer" ] # [ inline ] pub fn _12_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _12_BIT_TRANSFER ) } # [ doc = "13-bit transfer" ] # [ inline ] pub fn _13_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _13_BIT_TRANSFER ) } # [ doc = "14-bit transfer" ] # [ inline ] pub fn _14_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _14_BIT_TRANSFER ) } # [ doc = "15-bit transfer" ] # [ inline ] pub fn _15_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _15_BIT_TRANSFER ) } # [ doc = "16-bit transfer" ] # [ inline ] pub fn _16_bit_transfer ( self ) -> & 'a mut W { self . variant ( DSSW :: _16_BIT_TRANSFER ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FRF`" ] pub enum FRFW { # [ doc = "SPI" ] SPI , # [ doc = "TI" ] TI , # [ doc = "Microwire" ] MICROWIRE } impl FRFW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FRFW :: SPI => 0 , FRFW :: TI => 1 , FRFW :: MICROWIRE => 2 } } } # [ doc = r" Proxy" ] pub struct _FRFW < 'a > { w : & 'a mut W , } impl < 'a > _FRFW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FRFW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SPI" ] # [ inline ] pub fn spi ( self ) -> & 'a mut W { self . variant ( FRFW :: SPI ) } # [ doc = "TI" ] # [ inline ] pub fn ti ( self ) -> & 'a mut W { self . variant ( FRFW :: TI ) } # [ doc = "Microwire" ] # [ inline ] pub fn microwire ( self ) -> & 'a mut W { self . variant ( FRFW :: MICROWIRE ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CPOL`" ] pub enum CPOLW { # [ doc = "SPI controller maintains the bus clock low between frames." ] LOW , # [ doc = "SPI controller maintains the bus clock high between frames." ] HIGH } impl CPOLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CPOLW :: LOW => false , CPOLW :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _CPOLW < 'a > { w : & 'a mut W , } impl < 'a > _CPOLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CPOLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "SPI controller maintains the bus clock low between frames." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( CPOLW :: LOW ) } # [ doc = "SPI controller maintains the bus clock high between frames." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( CPOLW :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CPHA`" ] pub enum CPHAW { # [ doc = "SPI controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line." ] FIRSTCLOCK , # [ doc = "SPI controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line." ] SECONDCLOCK } impl CPHAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CPHAW :: FIRSTCLOCK => false , CPHAW :: SECONDCLOCK => true } } } # [ doc = r" Proxy" ] pub struct _CPHAW < 'a > { w : & 'a mut W , } impl < 'a > _CPHAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CPHAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "SPI controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line." ] # [ inline ] pub fn firstclock ( self ) -> & 'a mut W { self . variant ( CPHAW :: FIRSTCLOCK ) } # [ doc = "SPI controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line." ] # [ inline ] pub fn secondclock ( self ) -> & 'a mut W { self . variant ( CPHAW :: SECONDCLOCK ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SCRW < 'a > { w : & 'a mut W , } impl < 'a > _SCRW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used." ] # [ inline ] pub fn dss ( & self ) -> DSSR { DSSR :: _from ( { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 4:5 - Frame Format." ] # [ inline ] pub fn frf ( & self ) -> FRFR { FRFR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 6 - Clock Out Polarity. This bit is only used in SPI mode." ] # [ inline ] pub fn cpol ( & self ) -> CPOLR { CPOLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Clock Out Phase. This bit is only used in SPI mode." ] # [ inline ] pub fn cpha ( & self ) -> CPHAR { CPHAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 8:15 - Serial Clock Rate. The number of prescaler output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X \\[SCR+1\\])." ] # [ inline ] pub fn scr ( & self ) -> SCRR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; SCRR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:3 - Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used." ] # [ inline ] pub fn dss ( & mut self ) -> _DSSW { _DSSW { w : self } } # [ doc = "Bits 4:5 - Frame Format." ] # [ inline ] pub fn frf ( & mut self ) -> _FRFW { _FRFW { w : self } } # [ doc = "Bit 6 - Clock Out Polarity. This bit is only used in SPI mode." ] # [ inline ] pub fn cpol ( & mut self ) -> _CPOLW { _CPOLW { w : self } } # [ doc = "Bit 7 - Clock Out Phase. This bit is only used in SPI mode." ] # [ inline ] pub fn cpha ( & mut self ) -> _CPHAW { _CPHAW { w : self } } # [ doc = "Bits 8:15 - Serial Clock Rate. The number of prescaler output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X \\[SCR+1\\])." ] # [ inline ] pub fn scr ( & mut self ) -> _SCRW { _SCRW { w : self } } } } # [ doc = "Control Register 1. Selects master/slave and other modes." ] pub struct CR1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Control Register 1. Selects master/slave and other modes." ] pub mod cr1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CR1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `LBM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LBMR { # [ doc = "During normal operation." ] DURING_NORMAL_OPERAT , # [ doc = "Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively)." ] SERIAL_INPUT_IS_TAKE } impl LBMR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LBMR :: DURING_NORMAL_OPERAT => false , LBMR :: SERIAL_INPUT_IS_TAKE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LBMR { match value { false => LBMR :: DURING_NORMAL_OPERAT , true => LBMR :: SERIAL_INPUT_IS_TAKE , } } # [ doc = "Checks if the value of the field is `DURING_NORMAL_OPERAT`" ] # [ inline ] pub fn is_during_normal_operat ( & self ) -> bool { * self == LBMR :: DURING_NORMAL_OPERAT } # [ doc = "Checks if the value of the field is `SERIAL_INPUT_IS_TAKE`" ] # [ inline ] pub fn is_serial_input_is_take ( & self ) -> bool { * self == LBMR :: SERIAL_INPUT_IS_TAKE } } # [ doc = "Possible values of the field `SSE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SSER { # [ doc = "The SPI controller is disabled." ] DISABLED , # [ doc = "The SPI controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP/SPI registers and interrupt controller registers, before setting this bit." ] ENABLED } impl SSER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SSER :: DISABLED => false , SSER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SSER { match value { false => SSER :: DISABLED , true => SSER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == SSER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == SSER :: ENABLED } } # [ doc = "Possible values of the field `MS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MSR { # [ doc = "The SPI controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line." ] MASTER , # [ doc = "The SPI controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines." ] SLAVE } impl MSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MSR :: MASTER => false , MSR :: SLAVE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MSR { match value { false => MSR :: MASTER , true => MSR :: SLAVE , } } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ] pub fn is_master ( & self ) -> bool { * self == MSR :: MASTER } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ] pub fn is_slave ( & self ) -> bool { * self == MSR :: SLAVE } } # [ doc = r" Value of the field" ] pub struct SODR { bits : bool , } impl SODR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Values that can be written to the field `LBM`" ] pub enum LBMW { # [ doc = "During normal operation." ] DURING_NORMAL_OPERAT , # [ doc = "Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively)." ] SERIAL_INPUT_IS_TAKE } impl LBMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { LBMW :: DURING_NORMAL_OPERAT => false , LBMW :: SERIAL_INPUT_IS_TAKE => true } } } # [ doc = r" Proxy" ] pub struct _LBMW < 'a > { w : & 'a mut W , } impl < 'a > _LBMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : LBMW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "During normal operation." ] # [ inline ] pub fn during_normal_operat ( self ) -> & 'a mut W { self . variant ( LBMW :: DURING_NORMAL_OPERAT ) } # [ doc = "Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively)." ] # [ inline ] pub fn serial_input_is_take ( self ) -> & 'a mut W { self . variant ( LBMW :: SERIAL_INPUT_IS_TAKE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SSE`" ] pub enum SSEW { # [ doc = "The SPI controller is disabled." ] DISABLED , # [ doc = "The SPI controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP/SPI registers and interrupt controller registers, before setting this bit." ] ENABLED } impl SSEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SSEW :: DISABLED => false , SSEW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _SSEW < 'a > { w : & 'a mut W , } impl < 'a > _SSEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SSEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The SPI controller is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( SSEW :: DISABLED ) } # [ doc = "The SPI controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP/SPI registers and interrupt controller registers, before setting this bit." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( SSEW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MS`" ] pub enum MSW { # [ doc = "The SPI controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line." ] MASTER , # [ doc = "The SPI controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines." ] SLAVE } impl MSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MSW :: MASTER => false , MSW :: SLAVE => true } } } # [ doc = r" Proxy" ] pub struct _MSW < 'a > { w : & 'a mut W , } impl < 'a > _MSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "The SPI controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line." ] # [ inline ] pub fn master ( self ) -> & 'a mut W { self . variant ( MSW :: MASTER ) } # [ doc = "The SPI controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines." ] # [ inline ] pub fn slave ( self ) -> & 'a mut W { self . variant ( MSW :: SLAVE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SODW < 'a > { w : & 'a mut W , } impl < 'a > _SODW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Loop Back Mode." ] # [ inline ] pub fn lbm ( & self ) -> LBMR { LBMR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - SPI Enable." ] # [ inline ] pub fn sse ( & self ) -> SSER { SSER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Master/Slave Mode.This bit can only be written when the SSE bit is 0." ] # [ inline ] pub fn ms ( & self ) -> MSR { MSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SPI controller from driving the transmit data line (MISO)." ] # [ inline ] pub fn sod ( & self ) -> SODR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SODR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Loop Back Mode." ] # [ inline ] pub fn lbm ( & mut self ) -> _LBMW { _LBMW { w : self } } # [ doc = "Bit 1 - SPI Enable." ] # [ inline ] pub fn sse ( & mut self ) -> _SSEW { _SSEW { w : self } } # [ doc = "Bit 2 - Master/Slave Mode.This bit can only be written when the SSE bit is 0." ] # [ inline ] pub fn ms ( & mut self ) -> _MSW { _MSW { w : self } } # [ doc = "Bit 3 - Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SPI controller from driving the transmit data line (MISO)." ] # [ inline ] pub fn sod ( & mut self ) -> _SODW { _SODW { w : self } } } } # [ doc = "Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO." ] pub struct DR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO." ] pub mod dr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DATAR { bits : u16 , } impl DATAR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _DATAW < 'a > { w : & 'a mut W , } impl < 'a > _DATAW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SPI controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bit, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SPI controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bit, the data is right-justified in this field with higher order bits filled with 0s." ] # [ inline ] pub fn data ( & self ) -> DATAR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; DATAR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SPI controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bit, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SPI controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bit, the data is right-justified in this field with higher order bits filled with 0s." ] # [ inline ] pub fn data ( & mut self ) -> _DATAW { _DATAW { w : self } } } } # [ doc = "Status Register" ] pub struct SR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Status Register" ] pub mod sr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: SR { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct TFER { bits : bool , } impl TFER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TNFR { bits : bool , } impl TNFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RNER { bits : bool , } impl RNER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RFFR { bits : bool , } impl RFFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct BSYR { bits : bool , } impl BSYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not." ] # [ inline ] pub fn tfe ( & self ) -> TFER { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TFER { bits } } # [ doc = "Bit 1 - Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not." ] # [ inline ] pub fn tnf ( & self ) -> TNFR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TNFR { bits } } # [ doc = "Bit 2 - Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not." ] # [ inline ] pub fn rne ( & self ) -> RNER { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RNER { bits } } # [ doc = "Bit 3 - Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not." ] # [ inline ] pub fn rff ( & self ) -> RFFR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RFFR { bits } } # [ doc = "Bit 4 - Busy. This bit is 0 if the SPI controller is idle, 1 if it is currently sending/receiving a frame and/or the Tx FIFO is not empty." ] # [ inline ] pub fn bsy ( & self ) -> BSYR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; BSYR { bits } } } } # [ doc = "Clock Prescale Register" ] pub struct CPSR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clock Prescale Register" ] pub mod cpsr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CPSR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct CPSDVSRR { bits : u8 , } impl CPSDVSRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _CPSDVSRW < 'a > { w : & 'a mut W , } impl < 'a > _CPSDVSRW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - This even value between 2 and 254, by which SPI_PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0." ] # [ inline ] pub fn cpsdvsr ( & self ) -> CPSDVSRR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; CPSDVSRR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - This even value between 2 and 254, by which SPI_PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0." ] # [ inline ] pub fn cpsdvsr ( & mut self ) -> _CPSDVSRW { _CPSDVSRW { w : self } } } } # [ doc = "Interrupt Mask Set and Clear Register" ] pub struct IMSC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt Mask Set and Clear Register" ] pub mod imsc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IMSC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct RORIMR { bits : bool , } impl RORIMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RTIMR { bits : bool , } impl RTIMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RXIMR { bits : bool , } impl RXIMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXIMR { bits : bool , } impl TXIMR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _RORIMW < 'a > { w : & 'a mut W , } impl < 'a > _RORIMW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RTIMW < 'a > { w : & 'a mut W , } impl < 'a > _RTIMW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RXIMW < 'a > { w : & 'a mut W , } impl < 'a > _RXIMW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXIMW < 'a > { w : & 'a mut W , } impl < 'a > _TXIMW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs." ] # [ inline ] pub fn rorim ( & self ) -> RORIMR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RORIMR { bits } } # [ doc = "Bit 1 - Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X \\[SCR+1\\])." ] # [ inline ] pub fn rtim ( & self ) -> RTIMR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RTIMR { bits } } # [ doc = "Bit 2 - Software should set this bit to enable interrupt when the Rx FIFO is at least half full." ] # [ inline ] pub fn rxim ( & self ) -> RXIMR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RXIMR { bits } } # [ doc = "Bit 3 - Software should set this bit to enable interrupt when the Tx FIFO is at least half empty." ] # [ inline ] pub fn txim ( & self ) -> TXIMR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXIMR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs." ] # [ inline ] pub fn rorim ( & mut self ) -> _RORIMW { _RORIMW { w : self } } # [ doc = "Bit 1 - Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X \\[SCR+1\\])." ] # [ inline ] pub fn rtim ( & mut self ) -> _RTIMW { _RTIMW { w : self } } # [ doc = "Bit 2 - Software should set this bit to enable interrupt when the Rx FIFO is at least half full." ] # [ inline ] pub fn rxim ( & mut self ) -> _RXIMW { _RXIMW { w : self } } # [ doc = "Bit 3 - Software should set this bit to enable interrupt when the Tx FIFO is at least half empty." ] # [ inline ] pub fn txim ( & mut self ) -> _TXIMW { _TXIMW { w : self } } } } # [ doc = "Raw Interrupt Status Register" ] pub struct RIS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Raw Interrupt Status Register" ] pub mod ris { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RIS { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct RORRISR { bits : bool , } impl RORRISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RTRISR { bits : bool , } impl RTRISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RXRISR { bits : bool , } impl RXRISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXRISR { bits : bool , } impl TXRISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - This bit is 1 if another frame was completely received while the RxFIFO was full. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs." ] # [ inline ] pub fn rorris ( & self ) -> RORRISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RORRISR { bits } } # [ doc = "Bit 1 - This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X \\[SCR+1\\])." ] # [ inline ] pub fn rtris ( & self ) -> RTRISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RTRISR { bits } } # [ doc = "Bit 2 - This bit is 1 if the Rx FIFO is at least half full." ] # [ inline ] pub fn rxris ( & self ) -> RXRISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RXRISR { bits } } # [ doc = "Bit 3 - This bit is 1 if the Tx FIFO is at least half empty." ] # [ inline ] pub fn txris ( & self ) -> TXRISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXRISR { bits } } } } # [ doc = "Masked Interrupt Status Register" ] pub struct MIS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Masked Interrupt Status Register" ] pub mod mis { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: MIS { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct RORMISR { bits : bool , } impl RORMISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RTMISR { bits : bool , } impl RTMISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RXMISR { bits : bool , } impl RXMISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXMISR { bits : bool , } impl TXMISR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - This bit is 1 if another frame was completely received while the RxFIFO was full, and this interrupt is enabled." ] # [ inline ] pub fn rormis ( & self ) -> RORMISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RORMISR { bits } } # [ doc = "Bit 1 - This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out period, and this interrupt is enabled. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X \\[SCR+1\\])." ] # [ inline ] pub fn rtmis ( & self ) -> RTMISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RTMISR { bits } } # [ doc = "Bit 2 - This bit is 1 if the Rx FIFO is at least half full, and this interrupt is enabled." ] # [ inline ] pub fn rxmis ( & self ) -> RXMISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RXMISR { bits } } # [ doc = "Bit 3 - This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is enabled." ] # [ inline ] pub fn txmis ( & self ) -> TXMISR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXMISR { bits } } } } # [ doc = "SSPICR Interrupt Clear Register" ] pub struct ICR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "SSPICR Interrupt Clear Register" ] pub mod icr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ICR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _RORICW < 'a > { w : & 'a mut W , } impl < 'a > _RORICW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RTICW < 'a > { w : & 'a mut W , } impl < 'a > _RTICW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Writing a 1 to this bit clears the frame was received when RxFIFO was full interrupt." ] # [ inline ] pub fn roric ( & mut self ) -> _RORICW { _RORICW { w : self } } # [ doc = "Bit 1 - Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read for a timeout period interrupt. The timeout period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X \\[SCR+1\\])." ] # [ inline ] pub fn rtic ( & mut self ) -> _RTICW { _RTICW { w : self } } } } } # [ doc = "I/O configuration Modification" ] pub struct IOCON { _marker : PhantomData < * const ( ) > } unsafe impl Send for IOCON { } impl IOCON { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const iocon :: RegisterBlock { 0x4004_4000 as * const _ } } impl Deref for IOCON { type Target = iocon :: RegisterBlock ; fn deref ( & self ) -> & iocon :: RegisterBlock { unsafe { & * IOCON :: ptr ( ) } } } # [ doc = "I/O configuration Modification" ] pub mod iocon { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - I/O configuration for pin RESET/PIO0_0" ] pub reset_pio0_0 : RESET_PIO0_0 , # [ doc = "0x04 - I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2/USB_FTOGGLE" ] pub pio0_1 : PIO0_1 , # [ doc = "0x08 - I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0" ] pub pio0_2 : PIO0_2 , # [ doc = "0x0c - I/O configuration for pin PIO0_3/USB_VBUS" ] pub pio0_3 : PIO0_3 , # [ doc = "0x10 - I/O configuration for pin PIO0_4/SCL" ] pub pio0_4 : PIO0_4 , # [ doc = "0x14 - I/O configuration for pin PIO0_5/SDA" ] pub pio0_5 : PIO0_5 , # [ doc = "0x18 - I/O configuration for pin PIO0_6/USB_CONNECT/SCK0" ] pub pio0_6 : PIO0_6 , # [ doc = "0x1c - I/O configuration for pin PIO0_7/CTS" ] pub pio0_7 : PIO0_7 , # [ doc = "0x20 - I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0" ] pub pio0_8 : PIO0_8 , # [ doc = "0x24 - I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1" ] pub pio0_9 : PIO0_9 , # [ doc = "0x28 - I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2" ] pub swclk_pio0_10 : SWCLK_PIO0_10 , # [ doc = "0x2c - I/O configuration for pin TDI/PIO0_11/AD0/CT32B0_MAT3" ] pub tdi_pio0_11 : TDI_PIO0_11 , # [ doc = "0x30 - I/O configuration for pin TMS/PIO0_12/AD1/CT32B1_CAP0" ] pub tms_pio0_12 : TMS_PIO0_12 , # [ doc = "0x34 - I/O configuration for pin TDO/PIO0_13/AD2/CT32B1_MAT0" ] pub tdo_pio0_13 : TDO_PIO0_13 , # [ doc = "0x38 - I/O configuration for pin TRST/PIO0_14/AD3/CT32B1_MAT1" ] pub trst_pio0_14 : TRST_PIO0_14 , # [ doc = "0x3c - I/O configuration for pin SWDIO/PIO0_15/AD4/CT32B1_MAT2" ] pub swdio_pio0_15 : SWDIO_PIO0_15 , # [ doc = "0x40 - I/O configuration for pin PIO0_16/AD5/CT32B1_MAT3/ WAKEUP" ] pub pio0_16 : PIO0_16 , # [ doc = "0x44 - I/O configuration for pin PIO0_17/RTS/CT32B0_CAP0/SCLK" ] pub pio0_17 : PIO0_17 , # [ doc = "0x48 - I/O configuration for pin PIO0_18/RXD/CT32B0_MAT0" ] pub pio0_18 : PIO0_18 , # [ doc = "0x4c - I/O configuration for pin PIO0_19/TXD/CT32B0_MAT1" ] pub pio0_19 : PIO0_19 , # [ doc = "0x50 - I/O configuration for pin PIO0_20/CT16B1_CAP0" ] pub pio0_20 : PIO0_20 , # [ doc = "0x54 - I/O configuration for pin PIO0_21/CT16B1_MAT0/MOSI1" ] pub pio0_21 : PIO0_21 , # [ doc = "0x58 - I/O configuration for pin PIO0_22/AD6/CT16B1_MAT1/MISO1" ] pub pio0_22 : PIO0_22 , # [ doc = "0x5c - I/O configuration for pin PIO0_23/AD7" ] pub pio0_23 : PIO0_23 , # [ doc = "0x60 - I/O configuration for pin PIO1_0/CT32B1_MAT0" ] pub pio1_0 : PIO1_0 , # [ doc = "0x64 - I/O configuration for pin PIO1_1/CT32B1_MAT1" ] pub pio1_1 : PIO1_1 , # [ doc = "0x68 - I/O configuration for pin PIO1_2/CT32B1_MAT2" ] pub pio1_2 : PIO1_2 , # [ doc = "0x6c - I/O configuration for pin PIO1_3/CT32B1_MAT3" ] pub pio1_3 : PIO1_3 , # [ doc = "0x70 - I/O configuration for pin PIO1_4/CT32B1_CAP0" ] pub pio1_4 : PIO1_4 , # [ doc = "0x74 - I/O configuration for pin PIO1_5/CT32B1_CAP1" ] pub pio1_5 : PIO1_5 , # [ doc = "0x78 - I/O configuration for pin PIO1_6" ] pub pio1_6 : PIO1_6 , # [ doc = "0x7c - I/O configuration for pin PIO1_7" ] pub pio1_7 : PIO1_7 , # [ doc = "0x80 - I/O configuration for pin PIO1_8" ] pub pio1_8 : PIO1_8 , # [ doc = "0x84 - I/O configuration for pin PIO1_9" ] pub pio1_9 : PIO1_9 , # [ doc = "0x88 - I/O configuration for pin PIO1_10" ] pub pio1_10 : PIO1_10 , # [ doc = "0x8c - I/O configuration for pin PIO1_11" ] pub pio1_11 : PIO1_11 , # [ doc = "0x90 - I/O configuration for pin PIO1_12" ] pub pio1_12 : PIO1_12 , # [ doc = "0x94 - I/O configuration for pin PIO1_13/DTR/CT16B0_MAT0/TXD" ] pub pio1_13 : PIO1_13 , # [ doc = "0x98 - I/O configuration for pin PIO1_14/DSR/CT16B0_MAT1/RXD" ] pub pio1_14 : PIO1_14 , # [ doc = "0x9c - I/O configuration for pin PIO1_15/DCD/ CT16B0_MAT2/SCK1" ] pub pio1_15 : PIO1_15 , # [ doc = "0xa0 - I/O configuration for pin PIO1_16/RI/CT16B0_CAP0" ] pub pio1_16 : PIO1_16 , # [ doc = "0xa4 - I/O configuration for PIO1_17/CT16B0_CAP1/RXD" ] pub pio1_17 : PIO1_17 , # [ doc = "0xa8 - I/O configuration for PIO1_18/CT16B1_CAP1/TXD" ] pub pio1_18 : PIO1_18 , # [ doc = "0xac - I/O configuration for pin PIO1_19/DTR/SSEL1" ] pub pio1_19 : PIO1_19 , # [ doc = "0xb0 - I/O configuration for pin PIO1_20/DSR/SCK1" ] pub pio1_20 : PIO1_20 , # [ doc = "0xb4 - I/O configuration for pin PIO1_21/DCD/MISO1" ] pub pio1_21 : PIO1_21 , # [ doc = "0xb8 - I/O configuration for pin PIO1_22/RI/MOSI1" ] pub pio1_22 : PIO1_22 , # [ doc = "0xbc - I/O configuration for pin PIO1_23/CT16B1_MAT1/SSEL1" ] pub pio1_23 : PIO1_23 , # [ doc = "0xc0 - I/O configuration for pin PIO1_24/ CT32B0_MAT0" ] pub pio1_24 : PIO1_24 , # [ doc = "0xc4 - I/O configuration for pin PIO1_25/CT32B0_MAT1" ] pub pio1_25 : PIO1_25 , # [ doc = "0xc8 - I/O configuration for pin PIO1_26/CT32B0_MAT2/ RXD" ] pub pio1_26 : PIO1_26 , # [ doc = "0xcc - I/O configuration for pin PIO1_27/CT32B0_MAT3/ TXD" ] pub pio1_27 : PIO1_27 , # [ doc = "0xd0 - I/O configuration for pin PIO1_28/CT32B0_CAP0/ SCLK" ] pub pio1_28 : PIO1_28 , # [ doc = "0xd4 - I/O configuration for pin PIO1_29/SCK0/ CT32B0_CAP1" ] pub pio1_29 : PIO1_29 , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0xdc - I/O configuration for pin PIO1_31" ] pub pio1_31 : PIO1_31 , } # [ doc = "I/O configuration for pin RESET/PIO0_0" ] pub struct RESET_PIO0_0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin RESET/PIO0_0" ] pub mod reset_pio0_0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RESET_PIO0_0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "RESET." ] RESET_ , # [ doc = "PIO0_0." ] PIO0_0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: RESET_ => 0 , FUNCR :: PIO0_0_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: RESET_ , 1 => FUNCR :: PIO0_0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `RESET_`" ] # [ inline ] pub fn is_reset_ ( & self ) -> bool { * self == FUNCR :: RESET_ } # [ doc = "Checks if the value of the field is `PIO0_0_`" ] # [ inline ] pub fn is_pio0_0_ ( & self ) -> bool { * self == FUNCR :: PIO0_0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "RESET." ] RESET_ , # [ doc = "PIO0_0." ] PIO0_0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: RESET_ => 0 , FUNCW :: PIO0_0_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "RESET." ] # [ inline ] pub fn reset_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: RESET_ ) } # [ doc = "PIO0_0." ] # [ inline ] pub fn pio0_0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2/USB_FTOGGLE" ] pub struct PIO0_1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2/USB_FTOGGLE" ] pub mod pio0_1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_1." ] PIO0_1_ , # [ doc = "CLKOUT." ] CLKOUT_ , # [ doc = "CT32B0_MAT2." ] CT32B0_MAT2_ , # [ doc = "USB_FTOGGLE." ] USB_FTOGGLE_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_1_ => 0 , FUNCR :: CLKOUT_ => 0x01 , FUNCR :: CT32B0_MAT2_ => 0x02 , FUNCR :: USB_FTOGGLE_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_1_ , 1 => FUNCR :: CLKOUT_ , 2 => FUNCR :: CT32B0_MAT2_ , 3 => FUNCR :: USB_FTOGGLE_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_1_`" ] # [ inline ] pub fn is_pio0_1_ ( & self ) -> bool { * self == FUNCR :: PIO0_1_ } # [ doc = "Checks if the value of the field is `CLKOUT_`" ] # [ inline ] pub fn is_clkout_ ( & self ) -> bool { * self == FUNCR :: CLKOUT_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT2_`" ] # [ inline ] pub fn is_ct32b0_mat2_ ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT2_ } # [ doc = "Checks if the value of the field is `USB_FTOGGLE_`" ] # [ inline ] pub fn is_usb_ftoggle_ ( & self ) -> bool { * self == FUNCR :: USB_FTOGGLE_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_1." ] PIO0_1_ , # [ doc = "CLKOUT." ] CLKOUT_ , # [ doc = "CT32B0_MAT2." ] CT32B0_MAT2_ , # [ doc = "USB_FTOGGLE." ] USB_FTOGGLE_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_1_ => 0 , FUNCW :: CLKOUT_ => 1 , FUNCW :: CT32B0_MAT2_ => 2 , FUNCW :: USB_FTOGGLE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_1." ] # [ inline ] pub fn pio0_1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_1_ ) } # [ doc = "CLKOUT." ] # [ inline ] pub fn clkout_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CLKOUT_ ) } # [ doc = "CT32B0_MAT2." ] # [ inline ] pub fn ct32b0_mat2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT2_ ) } # [ doc = "USB_FTOGGLE." ] # [ inline ] pub fn usb_ftoggle_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: USB_FTOGGLE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0" ] pub struct PIO0_2 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0" ] pub mod pio0_2 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_2 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_2." ] PIO0_2_ , # [ doc = "SSEL0." ] SSEL0_ , # [ doc = "CT16B0_CAP0." ] CT16B0_CAP0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_2_ => 0 , FUNCR :: SSEL0_ => 0x01 , FUNCR :: CT16B0_CAP0_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_2_ , 1 => FUNCR :: SSEL0_ , 2 => FUNCR :: CT16B0_CAP0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_2_`" ] # [ inline ] pub fn is_pio0_2_ ( & self ) -> bool { * self == FUNCR :: PIO0_2_ } # [ doc = "Checks if the value of the field is `SSEL0_`" ] # [ inline ] pub fn is_ssel0_ ( & self ) -> bool { * self == FUNCR :: SSEL0_ } # [ doc = "Checks if the value of the field is `CT16B0_CAP0_`" ] # [ inline ] pub fn is_ct16b0_cap0_ ( & self ) -> bool { * self == FUNCR :: CT16B0_CAP0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_2." ] PIO0_2_ , # [ doc = "SSEL0." ] SSEL0_ , # [ doc = "CT16B0_CAP0." ] CT16B0_CAP0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_2_ => 0 , FUNCW :: SSEL0_ => 1 , FUNCW :: CT16B0_CAP0_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_2." ] # [ inline ] pub fn pio0_2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_2_ ) } # [ doc = "SSEL0." ] # [ inline ] pub fn ssel0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SSEL0_ ) } # [ doc = "CT16B0_CAP0." ] # [ inline ] pub fn ct16b0_cap0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_CAP0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_3/USB_VBUS" ] pub struct PIO0_3 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_3/USB_VBUS" ] pub mod pio0_3 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_3 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_3." ] PIO0_3_ , # [ doc = "USB_VBUS." ] USB_VBUS_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_3_ => 0 , FUNCR :: USB_VBUS_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_3_ , 1 => FUNCR :: USB_VBUS_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_3_`" ] # [ inline ] pub fn is_pio0_3_ ( & self ) -> bool { * self == FUNCR :: PIO0_3_ } # [ doc = "Checks if the value of the field is `USB_VBUS_`" ] # [ inline ] pub fn is_usb_vbus_ ( & self ) -> bool { * self == FUNCR :: USB_VBUS_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_3." ] PIO0_3_ , # [ doc = "USB_VBUS." ] USB_VBUS_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_3_ => 0 , FUNCW :: USB_VBUS_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_3." ] # [ inline ] pub fn pio0_3_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_3_ ) } # [ doc = "USB_VBUS." ] # [ inline ] pub fn usb_vbus_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: USB_VBUS_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_4/SCL" ] pub struct PIO0_4 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_4/SCL" ] pub mod pio0_4 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_4 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_4 (open-drain pin)." ] PIO0_4_OPEN_DRAIN_P , # [ doc = "I2C SCL (open-drain pin)." ] I2C_SCL_OPEN_DRAIN_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_4_OPEN_DRAIN_P => 0 , FUNCR :: I2C_SCL_OPEN_DRAIN_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_4_OPEN_DRAIN_P , 1 => FUNCR :: I2C_SCL_OPEN_DRAIN_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_4_OPEN_DRAIN_P`" ] # [ inline ] pub fn is_pio0_4_open_drain_p ( & self ) -> bool { * self == FUNCR :: PIO0_4_OPEN_DRAIN_P } # [ doc = "Checks if the value of the field is `I2C_SCL_OPEN_DRAIN_`" ] # [ inline ] pub fn is_i2c_scl_open_drain_ ( & self ) -> bool { * self == FUNCR :: I2C_SCL_OPEN_DRAIN_ } } # [ doc = "Possible values of the field `I2CMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum I2CMODER { # [ doc = "Standard mode/ Fast-mode I2C." ] STANDARD_MODE_FAST_ , # [ doc = "Standard I/O functionality" ] STANDARD_IO_FUNCTIO , # [ doc = "Fast-mode Plus I2C" ] FAST_MODE_PLUS_I2C , # [ doc = "Reserved." ] RESERVED_3 } impl I2CMODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { I2CMODER :: STANDARD_MODE_FAST_ => 0 , I2CMODER :: STANDARD_IO_FUNCTIO => 0x01 , I2CMODER :: FAST_MODE_PLUS_I2C => 0x02 , I2CMODER :: RESERVED_3 => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> I2CMODER { match value { 0 => I2CMODER :: STANDARD_MODE_FAST_ , 1 => I2CMODER :: STANDARD_IO_FUNCTIO , 2 => I2CMODER :: FAST_MODE_PLUS_I2C , 3 => I2CMODER :: RESERVED_3 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `STANDARD_MODE_FAST_`" ] # [ inline ] pub fn is_standard_mode_fast_ ( & self ) -> bool { * self == I2CMODER :: STANDARD_MODE_FAST_ } # [ doc = "Checks if the value of the field is `STANDARD_IO_FUNCTIO`" ] # [ inline ] pub fn is_standard_io_functio ( & self ) -> bool { * self == I2CMODER :: STANDARD_IO_FUNCTIO } # [ doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`" ] # [ inline ] pub fn is_fast_mode_plus_i2c ( & self ) -> bool { * self == I2CMODER :: FAST_MODE_PLUS_I2C } # [ doc = "Checks if the value of the field is `RESERVED_3`" ] # [ inline ] pub fn is_reserved_3 ( & self ) -> bool { * self == I2CMODER :: RESERVED_3 } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_4 (open-drain pin)." ] PIO0_4_OPEN_DRAIN_P , # [ doc = "I2C SCL (open-drain pin)." ] I2C_SCL_OPEN_DRAIN_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_4_OPEN_DRAIN_P => 0 , FUNCW :: I2C_SCL_OPEN_DRAIN_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_4 (open-drain pin)." ] # [ inline ] pub fn pio0_4_open_drain_p ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_4_OPEN_DRAIN_P ) } # [ doc = "I2C SCL (open-drain pin)." ] # [ inline ] pub fn i2c_scl_open_drain_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: I2C_SCL_OPEN_DRAIN_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `I2CMODE`" ] pub enum I2CMODEW { # [ doc = "Standard mode/ Fast-mode I2C." ] STANDARD_MODE_FAST_ , # [ doc = "Standard I/O functionality" ] STANDARD_IO_FUNCTIO , # [ doc = "Fast-mode Plus I2C" ] FAST_MODE_PLUS_I2C , # [ doc = "Reserved." ] RESERVED_3 } impl I2CMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { I2CMODEW :: STANDARD_MODE_FAST_ => 0 , I2CMODEW :: STANDARD_IO_FUNCTIO => 1 , I2CMODEW :: FAST_MODE_PLUS_I2C => 2 , I2CMODEW :: RESERVED_3 => 3 } } } # [ doc = r" Proxy" ] pub struct _I2CMODEW < 'a > { w : & 'a mut W , } impl < 'a > _I2CMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : I2CMODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Standard mode/ Fast-mode I2C." ] # [ inline ] pub fn standard_mode_fast_ ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: STANDARD_MODE_FAST_ ) } # [ doc = "Standard I/O functionality" ] # [ inline ] pub fn standard_io_functio ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: STANDARD_IO_FUNCTIO ) } # [ doc = "Fast-mode Plus I2C" ] # [ inline ] pub fn fast_mode_plus_i2c ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: FAST_MODE_PLUS_I2C ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_3 ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: RESERVED_3 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:9 - Selects I2C mode (see Section 7.3.8). Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)." ] # [ inline ] pub fn i2cmode ( & self ) -> I2CMODER { I2CMODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x80 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 8:9 - Selects I2C mode (see Section 7.3.8). Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)." ] # [ inline ] pub fn i2cmode ( & mut self ) -> _I2CMODEW { _I2CMODEW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_5/SDA" ] pub struct PIO0_5 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_5/SDA" ] pub mod pio0_5 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_5 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_5 (open-drain pin)." ] PIO0_5_OPEN_DRAIN_P , # [ doc = "I2C SDA (open-drain pin)." ] I2C_SDA_OPEN_DRAIN_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_5_OPEN_DRAIN_P => 0 , FUNCR :: I2C_SDA_OPEN_DRAIN_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_5_OPEN_DRAIN_P , 1 => FUNCR :: I2C_SDA_OPEN_DRAIN_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_5_OPEN_DRAIN_P`" ] # [ inline ] pub fn is_pio0_5_open_drain_p ( & self ) -> bool { * self == FUNCR :: PIO0_5_OPEN_DRAIN_P } # [ doc = "Checks if the value of the field is `I2C_SDA_OPEN_DRAIN_`" ] # [ inline ] pub fn is_i2c_sda_open_drain_ ( & self ) -> bool { * self == FUNCR :: I2C_SDA_OPEN_DRAIN_ } } # [ doc = "Possible values of the field `I2CMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum I2CMODER { # [ doc = "Standard mode/ Fast-mode I2C." ] STANDARD_MODE_FAST_ , # [ doc = "Standard I/O functionality" ] STANDARD_IO_FUNCTIO , # [ doc = "Fast-mode Plus I2C" ] FAST_MODE_PLUS_I2C , # [ doc = "Reserved." ] RESERVED_3 } impl I2CMODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { I2CMODER :: STANDARD_MODE_FAST_ => 0 , I2CMODER :: STANDARD_IO_FUNCTIO => 0x01 , I2CMODER :: FAST_MODE_PLUS_I2C => 0x02 , I2CMODER :: RESERVED_3 => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> I2CMODER { match value { 0 => I2CMODER :: STANDARD_MODE_FAST_ , 1 => I2CMODER :: STANDARD_IO_FUNCTIO , 2 => I2CMODER :: FAST_MODE_PLUS_I2C , 3 => I2CMODER :: RESERVED_3 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `STANDARD_MODE_FAST_`" ] # [ inline ] pub fn is_standard_mode_fast_ ( & self ) -> bool { * self == I2CMODER :: STANDARD_MODE_FAST_ } # [ doc = "Checks if the value of the field is `STANDARD_IO_FUNCTIO`" ] # [ inline ] pub fn is_standard_io_functio ( & self ) -> bool { * self == I2CMODER :: STANDARD_IO_FUNCTIO } # [ doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`" ] # [ inline ] pub fn is_fast_mode_plus_i2c ( & self ) -> bool { * self == I2CMODER :: FAST_MODE_PLUS_I2C } # [ doc = "Checks if the value of the field is `RESERVED_3`" ] # [ inline ] pub fn is_reserved_3 ( & self ) -> bool { * self == I2CMODER :: RESERVED_3 } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_5 (open-drain pin)." ] PIO0_5_OPEN_DRAIN_P , # [ doc = "I2C SDA (open-drain pin)." ] I2C_SDA_OPEN_DRAIN_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_5_OPEN_DRAIN_P => 0 , FUNCW :: I2C_SDA_OPEN_DRAIN_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_5 (open-drain pin)." ] # [ inline ] pub fn pio0_5_open_drain_p ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_5_OPEN_DRAIN_P ) } # [ doc = "I2C SDA (open-drain pin)." ] # [ inline ] pub fn i2c_sda_open_drain_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: I2C_SDA_OPEN_DRAIN_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `I2CMODE`" ] pub enum I2CMODEW { # [ doc = "Standard mode/ Fast-mode I2C." ] STANDARD_MODE_FAST_ , # [ doc = "Standard I/O functionality" ] STANDARD_IO_FUNCTIO , # [ doc = "Fast-mode Plus I2C" ] FAST_MODE_PLUS_I2C , # [ doc = "Reserved." ] RESERVED_3 } impl I2CMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { I2CMODEW :: STANDARD_MODE_FAST_ => 0 , I2CMODEW :: STANDARD_IO_FUNCTIO => 1 , I2CMODEW :: FAST_MODE_PLUS_I2C => 2 , I2CMODEW :: RESERVED_3 => 3 } } } # [ doc = r" Proxy" ] pub struct _I2CMODEW < 'a > { w : & 'a mut W , } impl < 'a > _I2CMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : I2CMODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Standard mode/ Fast-mode I2C." ] # [ inline ] pub fn standard_mode_fast_ ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: STANDARD_MODE_FAST_ ) } # [ doc = "Standard I/O functionality" ] # [ inline ] pub fn standard_io_functio ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: STANDARD_IO_FUNCTIO ) } # [ doc = "Fast-mode Plus I2C" ] # [ inline ] pub fn fast_mode_plus_i2c ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: FAST_MODE_PLUS_I2C ) } # [ doc = "Reserved." ] # [ inline ] pub fn reserved_3 ( self ) -> & 'a mut W { self . variant ( I2CMODEW :: RESERVED_3 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:9 - Selects I2C mode (see Section 7.3.8). Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)." ] # [ inline ] pub fn i2cmode ( & self ) -> I2CMODER { I2CMODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x80 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 8:9 - Selects I2C mode (see Section 7.3.8). Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)." ] # [ inline ] pub fn i2cmode ( & mut self ) -> _I2CMODEW { _I2CMODEW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_6/USB_CONNECT/SCK0" ] pub struct PIO0_6 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_6/USB_CONNECT/SCK0" ] pub mod pio0_6 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_6 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_6." ] PIO0_6_ , # [ doc = "USB_CONNECT." ] USB_CONNECT_ , # [ doc = "SCK0." ] SCK0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_6_ => 0 , FUNCR :: USB_CONNECT_ => 0x01 , FUNCR :: SCK0_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_6_ , 1 => FUNCR :: USB_CONNECT_ , 2 => FUNCR :: SCK0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_6_`" ] # [ inline ] pub fn is_pio0_6_ ( & self ) -> bool { * self == FUNCR :: PIO0_6_ } # [ doc = "Checks if the value of the field is `USB_CONNECT_`" ] # [ inline ] pub fn is_usb_connect_ ( & self ) -> bool { * self == FUNCR :: USB_CONNECT_ } # [ doc = "Checks if the value of the field is `SCK0_`" ] # [ inline ] pub fn is_sck0_ ( & self ) -> bool { * self == FUNCR :: SCK0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_6." ] PIO0_6_ , # [ doc = "USB_CONNECT." ] USB_CONNECT_ , # [ doc = "SCK0." ] SCK0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_6_ => 0 , FUNCW :: USB_CONNECT_ => 1 , FUNCW :: SCK0_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_6." ] # [ inline ] pub fn pio0_6_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_6_ ) } # [ doc = "USB_CONNECT." ] # [ inline ] pub fn usb_connect_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: USB_CONNECT_ ) } # [ doc = "SCK0." ] # [ inline ] pub fn sck0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SCK0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_7/CTS" ] pub struct PIO0_7 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_7/CTS" ] pub mod pio0_7 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_7 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_7." ] PIO0_7_ , # [ doc = "CTS." ] CTS_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_7_ => 0 , FUNCR :: CTS_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_7_ , 1 => FUNCR :: CTS_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_7_`" ] # [ inline ] pub fn is_pio0_7_ ( & self ) -> bool { * self == FUNCR :: PIO0_7_ } # [ doc = "Checks if the value of the field is `CTS_`" ] # [ inline ] pub fn is_cts_ ( & self ) -> bool { * self == FUNCR :: CTS_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_7." ] PIO0_7_ , # [ doc = "CTS." ] CTS_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_7_ => 0 , FUNCW :: CTS_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_7." ] # [ inline ] pub fn pio0_7_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_7_ ) } # [ doc = "CTS." ] # [ inline ] pub fn cts_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CTS_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0" ] pub struct PIO0_8 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0" ] pub mod pio0_8 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_8 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_8." ] PIO0_8_ , # [ doc = "MISO0." ] MISO0_ , # [ doc = "CT16B0_MAT0." ] CT16B0_MAT0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_8_ => 0 , FUNCR :: MISO0_ => 0x01 , FUNCR :: CT16B0_MAT0_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_8_ , 1 => FUNCR :: MISO0_ , 2 => FUNCR :: CT16B0_MAT0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_8_`" ] # [ inline ] pub fn is_pio0_8_ ( & self ) -> bool { * self == FUNCR :: PIO0_8_ } # [ doc = "Checks if the value of the field is `MISO0_`" ] # [ inline ] pub fn is_miso0_ ( & self ) -> bool { * self == FUNCR :: MISO0_ } # [ doc = "Checks if the value of the field is `CT16B0_MAT0_`" ] # [ inline ] pub fn is_ct16b0_mat0_ ( & self ) -> bool { * self == FUNCR :: CT16B0_MAT0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_8." ] PIO0_8_ , # [ doc = "MISO0." ] MISO0_ , # [ doc = "CT16B0_MAT0." ] CT16B0_MAT0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_8_ => 0 , FUNCW :: MISO0_ => 1 , FUNCW :: CT16B0_MAT0_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_8." ] # [ inline ] pub fn pio0_8_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_8_ ) } # [ doc = "MISO0." ] # [ inline ] pub fn miso0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: MISO0_ ) } # [ doc = "CT16B0_MAT0." ] # [ inline ] pub fn ct16b0_mat0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_MAT0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1" ] pub struct PIO0_9 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1" ] pub mod pio0_9 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_9 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_9." ] PIO0_9_ , # [ doc = "MOSI0." ] MOSI0_ , # [ doc = "CT16B0_MAT1." ] CT16B0_MAT1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_9_ => 0 , FUNCR :: MOSI0_ => 0x01 , FUNCR :: CT16B0_MAT1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_9_ , 1 => FUNCR :: MOSI0_ , 2 => FUNCR :: CT16B0_MAT1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_9_`" ] # [ inline ] pub fn is_pio0_9_ ( & self ) -> bool { * self == FUNCR :: PIO0_9_ } # [ doc = "Checks if the value of the field is `MOSI0_`" ] # [ inline ] pub fn is_mosi0_ ( & self ) -> bool { * self == FUNCR :: MOSI0_ } # [ doc = "Checks if the value of the field is `CT16B0_MAT1_`" ] # [ inline ] pub fn is_ct16b0_mat1_ ( & self ) -> bool { * self == FUNCR :: CT16B0_MAT1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_9." ] PIO0_9_ , # [ doc = "MOSI0." ] MOSI0_ , # [ doc = "CT16B0_MAT1." ] CT16B0_MAT1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_9_ => 0 , FUNCW :: MOSI0_ => 1 , FUNCW :: CT16B0_MAT1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_9." ] # [ inline ] pub fn pio0_9_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_9_ ) } # [ doc = "MOSI0." ] # [ inline ] pub fn mosi0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: MOSI0_ ) } # [ doc = "CT16B0_MAT1." ] # [ inline ] pub fn ct16b0_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_MAT1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2" ] pub struct SWCLK_PIO0_10 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2" ] pub mod swclk_pio0_10 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SWCLK_PIO0_10 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "SWCLK." ] SWCLK_ , # [ doc = "PIO0_10." ] PIO0_10_ , # [ doc = "SCK0." ] SCK0_ , # [ doc = "CT16B0_MAT2." ] CT16B0_MAT2_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: SWCLK_ => 0 , FUNCR :: PIO0_10_ => 0x01 , FUNCR :: SCK0_ => 0x02 , FUNCR :: CT16B0_MAT2_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: SWCLK_ , 1 => FUNCR :: PIO0_10_ , 2 => FUNCR :: SCK0_ , 3 => FUNCR :: CT16B0_MAT2_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `SWCLK_`" ] # [ inline ] pub fn is_swclk_ ( & self ) -> bool { * self == FUNCR :: SWCLK_ } # [ doc = "Checks if the value of the field is `PIO0_10_`" ] # [ inline ] pub fn is_pio0_10_ ( & self ) -> bool { * self == FUNCR :: PIO0_10_ } # [ doc = "Checks if the value of the field is `SCK0_`" ] # [ inline ] pub fn is_sck0_ ( & self ) -> bool { * self == FUNCR :: SCK0_ } # [ doc = "Checks if the value of the field is `CT16B0_MAT2_`" ] # [ inline ] pub fn is_ct16b0_mat2_ ( & self ) -> bool { * self == FUNCR :: CT16B0_MAT2_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "SWCLK." ] SWCLK_ , # [ doc = "PIO0_10." ] PIO0_10_ , # [ doc = "SCK0." ] SCK0_ , # [ doc = "CT16B0_MAT2." ] CT16B0_MAT2_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: SWCLK_ => 0 , FUNCW :: PIO0_10_ => 1 , FUNCW :: SCK0_ => 2 , FUNCW :: CT16B0_MAT2_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SWCLK." ] # [ inline ] pub fn swclk_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SWCLK_ ) } # [ doc = "PIO0_10." ] # [ inline ] pub fn pio0_10_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_10_ ) } # [ doc = "SCK0." ] # [ inline ] pub fn sck0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SCK0_ ) } # [ doc = "CT16B0_MAT2." ] # [ inline ] pub fn ct16b0_mat2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_MAT2_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin TDI/PIO0_11/AD0/CT32B0_MAT3" ] pub struct TDI_PIO0_11 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin TDI/PIO0_11/AD0/CT32B0_MAT3" ] pub mod tdi_pio0_11 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TDI_PIO0_11 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "TDI." ] TDI_ , # [ doc = "PIO0_11." ] PIO0_11_ , # [ doc = "AD0." ] AD0_ , # [ doc = "CT32B0_MAT3." ] CT32B0_MAT3_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: TDI_ => 0 , FUNCR :: PIO0_11_ => 0x01 , FUNCR :: AD0_ => 0x02 , FUNCR :: CT32B0_MAT3_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: TDI_ , 1 => FUNCR :: PIO0_11_ , 2 => FUNCR :: AD0_ , 3 => FUNCR :: CT32B0_MAT3_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `TDI_`" ] # [ inline ] pub fn is_tdi_ ( & self ) -> bool { * self == FUNCR :: TDI_ } # [ doc = "Checks if the value of the field is `PIO0_11_`" ] # [ inline ] pub fn is_pio0_11_ ( & self ) -> bool { * self == FUNCR :: PIO0_11_ } # [ doc = "Checks if the value of the field is `AD0_`" ] # [ inline ] pub fn is_ad0_ ( & self ) -> bool { * self == FUNCR :: AD0_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT3_`" ] # [ inline ] pub fn is_ct32b0_mat3_ ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT3_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "TDI." ] TDI_ , # [ doc = "PIO0_11." ] PIO0_11_ , # [ doc = "AD0." ] AD0_ , # [ doc = "CT32B0_MAT3." ] CT32B0_MAT3_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: TDI_ => 0 , FUNCW :: PIO0_11_ => 1 , FUNCW :: AD0_ => 2 , FUNCW :: CT32B0_MAT3_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "TDI." ] # [ inline ] pub fn tdi_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: TDI_ ) } # [ doc = "PIO0_11." ] # [ inline ] pub fn pio0_11_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_11_ ) } # [ doc = "AD0." ] # [ inline ] pub fn ad0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD0_ ) } # [ doc = "CT32B0_MAT3." ] # [ inline ] pub fn ct32b0_mat3_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT3_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin TMS/PIO0_12/AD1/CT32B1_CAP0" ] pub struct TMS_PIO0_12 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin TMS/PIO0_12/AD1/CT32B1_CAP0" ] pub mod tms_pio0_12 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TMS_PIO0_12 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "TMS." ] TMS_ , # [ doc = "PIO0_12." ] PIO0_12_ , # [ doc = "AD1." ] AD1_ , # [ doc = "CT32B1_CAP0." ] CT32B1_CAP0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: TMS_ => 0 , FUNCR :: PIO0_12_ => 0x01 , FUNCR :: AD1_ => 0x02 , FUNCR :: CT32B1_CAP0_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: TMS_ , 1 => FUNCR :: PIO0_12_ , 2 => FUNCR :: AD1_ , 3 => FUNCR :: CT32B1_CAP0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `TMS_`" ] # [ inline ] pub fn is_tms_ ( & self ) -> bool { * self == FUNCR :: TMS_ } # [ doc = "Checks if the value of the field is `PIO0_12_`" ] # [ inline ] pub fn is_pio0_12_ ( & self ) -> bool { * self == FUNCR :: PIO0_12_ } # [ doc = "Checks if the value of the field is `AD1_`" ] # [ inline ] pub fn is_ad1_ ( & self ) -> bool { * self == FUNCR :: AD1_ } # [ doc = "Checks if the value of the field is `CT32B1_CAP0_`" ] # [ inline ] pub fn is_ct32b1_cap0_ ( & self ) -> bool { * self == FUNCR :: CT32B1_CAP0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "TMS." ] TMS_ , # [ doc = "PIO0_12." ] PIO0_12_ , # [ doc = "AD1." ] AD1_ , # [ doc = "CT32B1_CAP0." ] CT32B1_CAP0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: TMS_ => 0 , FUNCW :: PIO0_12_ => 1 , FUNCW :: AD1_ => 2 , FUNCW :: CT32B1_CAP0_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "TMS." ] # [ inline ] pub fn tms_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: TMS_ ) } # [ doc = "PIO0_12." ] # [ inline ] pub fn pio0_12_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_12_ ) } # [ doc = "AD1." ] # [ inline ] pub fn ad1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD1_ ) } # [ doc = "CT32B1_CAP0." ] # [ inline ] pub fn ct32b1_cap0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_CAP0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin TDO/PIO0_13/AD2/CT32B1_MAT0" ] pub struct TDO_PIO0_13 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin TDO/PIO0_13/AD2/CT32B1_MAT0" ] pub mod tdo_pio0_13 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TDO_PIO0_13 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "TDO." ] TDO_ , # [ doc = "PIO0_13." ] PIO0_13_ , # [ doc = "AD2." ] AD2_ , # [ doc = "CT32B1_MAT0." ] CT32B1_MAT0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: TDO_ => 0 , FUNCR :: PIO0_13_ => 0x01 , FUNCR :: AD2_ => 0x02 , FUNCR :: CT32B1_MAT0_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: TDO_ , 1 => FUNCR :: PIO0_13_ , 2 => FUNCR :: AD2_ , 3 => FUNCR :: CT32B1_MAT0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `TDO_`" ] # [ inline ] pub fn is_tdo_ ( & self ) -> bool { * self == FUNCR :: TDO_ } # [ doc = "Checks if the value of the field is `PIO0_13_`" ] # [ inline ] pub fn is_pio0_13_ ( & self ) -> bool { * self == FUNCR :: PIO0_13_ } # [ doc = "Checks if the value of the field is `AD2_`" ] # [ inline ] pub fn is_ad2_ ( & self ) -> bool { * self == FUNCR :: AD2_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT0_`" ] # [ inline ] pub fn is_ct32b1_mat0_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "TDO." ] TDO_ , # [ doc = "PIO0_13." ] PIO0_13_ , # [ doc = "AD2." ] AD2_ , # [ doc = "CT32B1_MAT0." ] CT32B1_MAT0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: TDO_ => 0 , FUNCW :: PIO0_13_ => 1 , FUNCW :: AD2_ => 2 , FUNCW :: CT32B1_MAT0_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "TDO." ] # [ inline ] pub fn tdo_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: TDO_ ) } # [ doc = "PIO0_13." ] # [ inline ] pub fn pio0_13_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_13_ ) } # [ doc = "AD2." ] # [ inline ] pub fn ad2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD2_ ) } # [ doc = "CT32B1_MAT0." ] # [ inline ] pub fn ct32b1_mat0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin TRST/PIO0_14/AD3/CT32B1_MAT1" ] pub struct TRST_PIO0_14 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin TRST/PIO0_14/AD3/CT32B1_MAT1" ] pub mod trst_pio0_14 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TRST_PIO0_14 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "TRST." ] TRST_ , # [ doc = "PIO0_14." ] PIO0_14_ , # [ doc = "AD3." ] AD3_ , # [ doc = "CT32B1_MAT1." ] CT32B1_MAT1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: TRST_ => 0 , FUNCR :: PIO0_14_ => 0x01 , FUNCR :: AD3_ => 0x02 , FUNCR :: CT32B1_MAT1_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: TRST_ , 1 => FUNCR :: PIO0_14_ , 2 => FUNCR :: AD3_ , 3 => FUNCR :: CT32B1_MAT1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `TRST_`" ] # [ inline ] pub fn is_trst_ ( & self ) -> bool { * self == FUNCR :: TRST_ } # [ doc = "Checks if the value of the field is `PIO0_14_`" ] # [ inline ] pub fn is_pio0_14_ ( & self ) -> bool { * self == FUNCR :: PIO0_14_ } # [ doc = "Checks if the value of the field is `AD3_`" ] # [ inline ] pub fn is_ad3_ ( & self ) -> bool { * self == FUNCR :: AD3_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT1_`" ] # [ inline ] pub fn is_ct32b1_mat1_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "TRST." ] TRST_ , # [ doc = "PIO0_14." ] PIO0_14_ , # [ doc = "AD3." ] AD3_ , # [ doc = "CT32B1_MAT1." ] CT32B1_MAT1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: TRST_ => 0 , FUNCW :: PIO0_14_ => 1 , FUNCW :: AD3_ => 2 , FUNCW :: CT32B1_MAT1_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "TRST." ] # [ inline ] pub fn trst_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: TRST_ ) } # [ doc = "PIO0_14." ] # [ inline ] pub fn pio0_14_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_14_ ) } # [ doc = "AD3." ] # [ inline ] pub fn ad3_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD3_ ) } # [ doc = "CT32B1_MAT1." ] # [ inline ] pub fn ct32b1_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin SWDIO/PIO0_15/AD4/CT32B1_MAT2" ] pub struct SWDIO_PIO0_15 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin SWDIO/PIO0_15/AD4/CT32B1_MAT2" ] pub mod swdio_pio0_15 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SWDIO_PIO0_15 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "SWDIO." ] SWDIO_ , # [ doc = "PIO0_15." ] PIO0_15_ , # [ doc = "AD4." ] AD4_ , # [ doc = "CT32B1_MAT2." ] CT32B1_MAT2_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: SWDIO_ => 0 , FUNCR :: PIO0_15_ => 0x01 , FUNCR :: AD4_ => 0x02 , FUNCR :: CT32B1_MAT2_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: SWDIO_ , 1 => FUNCR :: PIO0_15_ , 2 => FUNCR :: AD4_ , 3 => FUNCR :: CT32B1_MAT2_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `SWDIO_`" ] # [ inline ] pub fn is_swdio_ ( & self ) -> bool { * self == FUNCR :: SWDIO_ } # [ doc = "Checks if the value of the field is `PIO0_15_`" ] # [ inline ] pub fn is_pio0_15_ ( & self ) -> bool { * self == FUNCR :: PIO0_15_ } # [ doc = "Checks if the value of the field is `AD4_`" ] # [ inline ] pub fn is_ad4_ ( & self ) -> bool { * self == FUNCR :: AD4_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT2_`" ] # [ inline ] pub fn is_ct32b1_mat2_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT2_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "SWDIO." ] SWDIO_ , # [ doc = "PIO0_15." ] PIO0_15_ , # [ doc = "AD4." ] AD4_ , # [ doc = "CT32B1_MAT2." ] CT32B1_MAT2_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: SWDIO_ => 0 , FUNCW :: PIO0_15_ => 1 , FUNCW :: AD4_ => 2 , FUNCW :: CT32B1_MAT2_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SWDIO." ] # [ inline ] pub fn swdio_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SWDIO_ ) } # [ doc = "PIO0_15." ] # [ inline ] pub fn pio0_15_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_15_ ) } # [ doc = "AD4." ] # [ inline ] pub fn ad4_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD4_ ) } # [ doc = "CT32B1_MAT2." ] # [ inline ] pub fn ct32b1_mat2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT2_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_16/AD5/CT32B1_MAT3/ WAKEUP" ] pub struct PIO0_16 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_16/AD5/CT32B1_MAT3/ WAKEUP" ] pub mod pio0_16 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_16 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_16." ] PIO0_16_ , # [ doc = "AD5." ] AD5_ , # [ doc = "CT32B1_MAT3." ] CT32B1_MAT3_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_16_ => 0 , FUNCR :: AD5_ => 0x01 , FUNCR :: CT32B1_MAT3_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_16_ , 1 => FUNCR :: AD5_ , 2 => FUNCR :: CT32B1_MAT3_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_16_`" ] # [ inline ] pub fn is_pio0_16_ ( & self ) -> bool { * self == FUNCR :: PIO0_16_ } # [ doc = "Checks if the value of the field is `AD5_`" ] # [ inline ] pub fn is_ad5_ ( & self ) -> bool { * self == FUNCR :: AD5_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT3_`" ] # [ inline ] pub fn is_ct32b1_mat3_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT3_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_16." ] PIO0_16_ , # [ doc = "AD5." ] AD5_ , # [ doc = "CT32B1_MAT3." ] CT32B1_MAT3_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_16_ => 0 , FUNCW :: AD5_ => 1 , FUNCW :: CT32B1_MAT3_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_16." ] # [ inline ] pub fn pio0_16_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_16_ ) } # [ doc = "AD5." ] # [ inline ] pub fn ad5_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD5_ ) } # [ doc = "CT32B1_MAT3." ] # [ inline ] pub fn ct32b1_mat3_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT3_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. This pin functions as WAKEUP pin if the LPC11Uxx is in Deep power-down mode regardless of the value of FUNC. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. This pin functions as WAKEUP pin if the LPC11Uxx is in Deep power-down mode regardless of the value of FUNC. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_17/RTS/CT32B0_CAP0/SCLK" ] pub struct PIO0_17 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_17/RTS/CT32B0_CAP0/SCLK" ] pub mod pio0_17 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_17 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_17." ] PIO0_17_ , # [ doc = "RTS." ] RTS_ , # [ doc = "CT32B0_CAP0." ] CT32B0_CAP0_ , # [ doc = "SCLK (UART synchronous clock)." ] SCLK_UART_SYNCHRONO , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_17_ => 0 , FUNCR :: RTS_ => 0x01 , FUNCR :: CT32B0_CAP0_ => 0x02 , FUNCR :: SCLK_UART_SYNCHRONO => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_17_ , 1 => FUNCR :: RTS_ , 2 => FUNCR :: CT32B0_CAP0_ , 3 => FUNCR :: SCLK_UART_SYNCHRONO , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_17_`" ] # [ inline ] pub fn is_pio0_17_ ( & self ) -> bool { * self == FUNCR :: PIO0_17_ } # [ doc = "Checks if the value of the field is `RTS_`" ] # [ inline ] pub fn is_rts_ ( & self ) -> bool { * self == FUNCR :: RTS_ } # [ doc = "Checks if the value of the field is `CT32B0_CAP0_`" ] # [ inline ] pub fn is_ct32b0_cap0_ ( & self ) -> bool { * self == FUNCR :: CT32B0_CAP0_ } # [ doc = "Checks if the value of the field is `SCLK_UART_SYNCHRONO`" ] # [ inline ] pub fn is_sclk_uart_synchrono ( & self ) -> bool { * self == FUNCR :: SCLK_UART_SYNCHRONO } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_17." ] PIO0_17_ , # [ doc = "RTS." ] RTS_ , # [ doc = "CT32B0_CAP0." ] CT32B0_CAP0_ , # [ doc = "SCLK (UART synchronous clock)." ] SCLK_UART_SYNCHRONO } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_17_ => 0 , FUNCW :: RTS_ => 1 , FUNCW :: CT32B0_CAP0_ => 2 , FUNCW :: SCLK_UART_SYNCHRONO => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_17." ] # [ inline ] pub fn pio0_17_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_17_ ) } # [ doc = "RTS." ] # [ inline ] pub fn rts_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: RTS_ ) } # [ doc = "CT32B0_CAP0." ] # [ inline ] pub fn ct32b0_cap0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_CAP0_ ) } # [ doc = "SCLK (UART synchronous clock)." ] # [ inline ] pub fn sclk_uart_synchrono ( self ) -> & 'a mut W { self . variant ( FUNCW :: SCLK_UART_SYNCHRONO ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_18/RXD/CT32B0_MAT0" ] pub struct PIO0_18 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_18/RXD/CT32B0_MAT0" ] pub mod pio0_18 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_18 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_18." ] PIO0_18_ , # [ doc = "RXD." ] RXD_ , # [ doc = "CT32B0_MAT0." ] CT32B0_MAT0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_18_ => 0 , FUNCR :: RXD_ => 0x01 , FUNCR :: CT32B0_MAT0_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_18_ , 1 => FUNCR :: RXD_ , 2 => FUNCR :: CT32B0_MAT0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_18_`" ] # [ inline ] pub fn is_pio0_18_ ( & self ) -> bool { * self == FUNCR :: PIO0_18_ } # [ doc = "Checks if the value of the field is `RXD_`" ] # [ inline ] pub fn is_rxd_ ( & self ) -> bool { * self == FUNCR :: RXD_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT0_`" ] # [ inline ] pub fn is_ct32b0_mat0_ ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_18." ] PIO0_18_ , # [ doc = "RXD." ] RXD_ , # [ doc = "CT32B0_MAT0." ] CT32B0_MAT0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_18_ => 0 , FUNCW :: RXD_ => 1 , FUNCW :: CT32B0_MAT0_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_18." ] # [ inline ] pub fn pio0_18_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_18_ ) } # [ doc = "RXD." ] # [ inline ] pub fn rxd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: RXD_ ) } # [ doc = "CT32B0_MAT0." ] # [ inline ] pub fn ct32b0_mat0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_19/TXD/CT32B0_MAT1" ] pub struct PIO0_19 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_19/TXD/CT32B0_MAT1" ] pub mod pio0_19 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_19 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_19." ] PIO0_19_ , # [ doc = "TXD." ] TXD_ , # [ doc = "CT32B0_MAT1." ] CT32B0_MAT1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_19_ => 0 , FUNCR :: TXD_ => 0x01 , FUNCR :: CT32B0_MAT1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_19_ , 1 => FUNCR :: TXD_ , 2 => FUNCR :: CT32B0_MAT1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_19_`" ] # [ inline ] pub fn is_pio0_19_ ( & self ) -> bool { * self == FUNCR :: PIO0_19_ } # [ doc = "Checks if the value of the field is `TXD_`" ] # [ inline ] pub fn is_txd_ ( & self ) -> bool { * self == FUNCR :: TXD_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT1_`" ] # [ inline ] pub fn is_ct32b0_mat1_ ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_19." ] PIO0_19_ , # [ doc = "TXD." ] TXD_ , # [ doc = "CT32B0_MAT1." ] CT32B0_MAT1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_19_ => 0 , FUNCW :: TXD_ => 1 , FUNCW :: CT32B0_MAT1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_19." ] # [ inline ] pub fn pio0_19_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_19_ ) } # [ doc = "TXD." ] # [ inline ] pub fn txd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: TXD_ ) } # [ doc = "CT32B0_MAT1." ] # [ inline ] pub fn ct32b0_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_20/CT16B1_CAP0" ] pub struct PIO0_20 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_20/CT16B1_CAP0" ] pub mod pio0_20 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_20 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_20." ] PIO0_20_ , # [ doc = "CT16B1_CAP0." ] CT16B1_CAP0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_20_ => 0 , FUNCR :: CT16B1_CAP0_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_20_ , 1 => FUNCR :: CT16B1_CAP0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_20_`" ] # [ inline ] pub fn is_pio0_20_ ( & self ) -> bool { * self == FUNCR :: PIO0_20_ } # [ doc = "Checks if the value of the field is `CT16B1_CAP0_`" ] # [ inline ] pub fn is_ct16b1_cap0_ ( & self ) -> bool { * self == FUNCR :: CT16B1_CAP0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_20." ] PIO0_20_ , # [ doc = "CT16B1_CAP0." ] CT16B1_CAP0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_20_ => 0 , FUNCW :: CT16B1_CAP0_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_20." ] # [ inline ] pub fn pio0_20_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_20_ ) } # [ doc = "CT16B1_CAP0." ] # [ inline ] pub fn ct16b1_cap0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B1_CAP0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_21/CT16B1_MAT0/MOSI1" ] pub struct PIO0_21 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_21/CT16B1_MAT0/MOSI1" ] pub mod pio0_21 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_21 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_21." ] PIO0_21_ , # [ doc = "CT16B1_MAT0." ] CT16B1_MAT0_ , # [ doc = "MOSI1." ] MOSI1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_21_ => 0 , FUNCR :: CT16B1_MAT0_ => 0x01 , FUNCR :: MOSI1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_21_ , 1 => FUNCR :: CT16B1_MAT0_ , 2 => FUNCR :: MOSI1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_21_`" ] # [ inline ] pub fn is_pio0_21_ ( & self ) -> bool { * self == FUNCR :: PIO0_21_ } # [ doc = "Checks if the value of the field is `CT16B1_MAT0_`" ] # [ inline ] pub fn is_ct16b1_mat0_ ( & self ) -> bool { * self == FUNCR :: CT16B1_MAT0_ } # [ doc = "Checks if the value of the field is `MOSI1_`" ] # [ inline ] pub fn is_mosi1_ ( & self ) -> bool { * self == FUNCR :: MOSI1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_21." ] PIO0_21_ , # [ doc = "CT16B1_MAT0." ] CT16B1_MAT0_ , # [ doc = "MOSI1." ] MOSI1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_21_ => 0 , FUNCW :: CT16B1_MAT0_ => 1 , FUNCW :: MOSI1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_21." ] # [ inline ] pub fn pio0_21_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_21_ ) } # [ doc = "CT16B1_MAT0." ] # [ inline ] pub fn ct16b1_mat0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B1_MAT0_ ) } # [ doc = "MOSI1." ] # [ inline ] pub fn mosi1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: MOSI1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_22/AD6/CT16B1_MAT1/MISO1" ] pub struct PIO0_22 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_22/AD6/CT16B1_MAT1/MISO1" ] pub mod pio0_22 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_22 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_22." ] PIO0_22_ , # [ doc = "AD6." ] AD6_ , # [ doc = "CT16B1_MAT1." ] CT16B1_MAT1_ , # [ doc = "MISO1." ] MISO1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_22_ => 0 , FUNCR :: AD6_ => 0x01 , FUNCR :: CT16B1_MAT1_ => 0x02 , FUNCR :: MISO1_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_22_ , 1 => FUNCR :: AD6_ , 2 => FUNCR :: CT16B1_MAT1_ , 3 => FUNCR :: MISO1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_22_`" ] # [ inline ] pub fn is_pio0_22_ ( & self ) -> bool { * self == FUNCR :: PIO0_22_ } # [ doc = "Checks if the value of the field is `AD6_`" ] # [ inline ] pub fn is_ad6_ ( & self ) -> bool { * self == FUNCR :: AD6_ } # [ doc = "Checks if the value of the field is `CT16B1_MAT1_`" ] # [ inline ] pub fn is_ct16b1_mat1_ ( & self ) -> bool { * self == FUNCR :: CT16B1_MAT1_ } # [ doc = "Checks if the value of the field is `MISO1_`" ] # [ inline ] pub fn is_miso1_ ( & self ) -> bool { * self == FUNCR :: MISO1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_22." ] PIO0_22_ , # [ doc = "AD6." ] AD6_ , # [ doc = "CT16B1_MAT1." ] CT16B1_MAT1_ , # [ doc = "MISO1." ] MISO1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_22_ => 0 , FUNCW :: AD6_ => 1 , FUNCW :: CT16B1_MAT1_ => 2 , FUNCW :: MISO1_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_22." ] # [ inline ] pub fn pio0_22_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_22_ ) } # [ doc = "AD6." ] # [ inline ] pub fn ad6_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD6_ ) } # [ doc = "CT16B1_MAT1." ] # [ inline ] pub fn ct16b1_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B1_MAT1_ ) } # [ doc = "MISO1." ] # [ inline ] pub fn miso1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: MISO1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO0_23/AD7" ] pub struct PIO0_23 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO0_23/AD7" ] pub mod pio0_23 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO0_23 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO0_23." ] PIO0_23_ , # [ doc = "AD7." ] AD7_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO0_23_ => 0 , FUNCR :: AD7_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO0_23_ , 1 => FUNCR :: AD7_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO0_23_`" ] # [ inline ] pub fn is_pio0_23_ ( & self ) -> bool { * self == FUNCR :: PIO0_23_ } # [ doc = "Checks if the value of the field is `AD7_`" ] # [ inline ] pub fn is_ad7_ ( & self ) -> bool { * self == FUNCR :: AD7_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `ADMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADMODER { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADMODER :: ANALOG_INPUT_MODE_ => false , ADMODER :: DIGITAL_FUNCTIONAL_M => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADMODER { match value { false => ADMODER :: ANALOG_INPUT_MODE_ , true => ADMODER :: DIGITAL_FUNCTIONAL_M , } } # [ doc = "Checks if the value of the field is `ANALOG_INPUT_MODE_`" ] # [ inline ] pub fn is_analog_input_mode_ ( & self ) -> bool { * self == ADMODER :: ANALOG_INPUT_MODE_ } # [ doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`" ] # [ inline ] pub fn is_digital_functional_m ( & self ) -> bool { * self == ADMODER :: DIGITAL_FUNCTIONAL_M } } # [ doc = "Possible values of the field `FILTR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTRR { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FILTRR :: FILTER_ENABLED_ => false , FILTRR :: FILTER_DISABLED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FILTRR { match value { false => FILTRR :: FILTER_ENABLED_ , true => FILTRR :: FILTER_DISABLED_ , } } # [ doc = "Checks if the value of the field is `FILTER_ENABLED_`" ] # [ inline ] pub fn is_filter_enabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_ENABLED_ } # [ doc = "Checks if the value of the field is `FILTER_DISABLED_`" ] # [ inline ] pub fn is_filter_disabled_ ( & self ) -> bool { * self == FILTRR :: FILTER_DISABLED_ } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO0_23." ] PIO0_23_ , # [ doc = "AD7." ] AD7_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO0_23_ => 0 , FUNCW :: AD7_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO0_23." ] # [ inline ] pub fn pio0_23_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO0_23_ ) } # [ doc = "AD7." ] # [ inline ] pub fn ad7_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: AD7_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADMODE`" ] pub enum ADMODEW { # [ doc = "Analog input mode." ] ANALOG_INPUT_MODE_ , # [ doc = "Digital functional mode." ] DIGITAL_FUNCTIONAL_M } impl ADMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADMODEW :: ANALOG_INPUT_MODE_ => false , ADMODEW :: DIGITAL_FUNCTIONAL_M => true } } } # [ doc = r" Proxy" ] pub struct _ADMODEW < 'a > { w : & 'a mut W , } impl < 'a > _ADMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADMODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Analog input mode." ] # [ inline ] pub fn analog_input_mode_ ( self ) -> & 'a mut W { self . variant ( ADMODEW :: ANALOG_INPUT_MODE_ ) } # [ doc = "Digital functional mode." ] # [ inline ] pub fn digital_functional_m ( self ) -> & 'a mut W { self . variant ( ADMODEW :: DIGITAL_FUNCTIONAL_M ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FILTR`" ] pub enum FILTRW { # [ doc = "Filter enabled." ] FILTER_ENABLED_ , # [ doc = "Filter disabled." ] FILTER_DISABLED_ } impl FILTRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FILTRW :: FILTER_ENABLED_ => false , FILTRW :: FILTER_DISABLED_ => true } } } # [ doc = r" Proxy" ] pub struct _FILTRW < 'a > { w : & 'a mut W , } impl < 'a > _FILTRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FILTRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Filter enabled." ] # [ inline ] pub fn filter_enabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_ENABLED_ ) } # [ doc = "Filter disabled." ] # [ inline ] pub fn filter_disabled_ ( self ) -> & 'a mut W { self . variant ( FILTRW :: FILTER_DISABLED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & self ) -> ADMODER { ADMODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & self ) -> FILTRR { FILTRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 7 - Selects Analog/Digital mode." ] # [ inline ] pub fn admode ( & mut self ) -> _ADMODEW { _ADMODEW { w : self } } # [ doc = "Bit 8 - Selects 10 ns input glitch filter." ] # [ inline ] pub fn filtr ( & mut self ) -> _FILTRW { _FILTRW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_0/CT32B1_MAT0" ] pub struct PIO1_0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_0/CT32B1_MAT0" ] pub mod pio1_0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_0." ] PIO1_0_ , # [ doc = "CT32B1_MAT1." ] CT32B1_MAT1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_0_ => 0 , FUNCR :: CT32B1_MAT1_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_0_ , 1 => FUNCR :: CT32B1_MAT1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_0_`" ] # [ inline ] pub fn is_pio1_0_ ( & self ) -> bool { * self == FUNCR :: PIO1_0_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT1_`" ] # [ inline ] pub fn is_ct32b1_mat1_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_0." ] PIO1_0_ , # [ doc = "CT32B1_MAT1." ] CT32B1_MAT1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_0_ => 0 , FUNCW :: CT32B1_MAT1_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_0." ] # [ inline ] pub fn pio1_0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_0_ ) } # [ doc = "CT32B1_MAT1." ] # [ inline ] pub fn ct32b1_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_1/CT32B1_MAT1" ] pub struct PIO1_1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_1/CT32B1_MAT1" ] pub mod pio1_1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_1." ] PIO1_1_ , # [ doc = "CT32B1_MAT1." ] CT32B1_MAT1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_1_ => 0 , FUNCR :: CT32B1_MAT1_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_1_ , 1 => FUNCR :: CT32B1_MAT1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_1_`" ] # [ inline ] pub fn is_pio1_1_ ( & self ) -> bool { * self == FUNCR :: PIO1_1_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT1_`" ] # [ inline ] pub fn is_ct32b1_mat1_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_1." ] PIO1_1_ , # [ doc = "CT32B1_MAT1." ] CT32B1_MAT1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_1_ => 0 , FUNCW :: CT32B1_MAT1_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_1." ] # [ inline ] pub fn pio1_1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_1_ ) } # [ doc = "CT32B1_MAT1." ] # [ inline ] pub fn ct32b1_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_2/CT32B1_MAT2" ] pub struct PIO1_2 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_2/CT32B1_MAT2" ] pub mod pio1_2 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_2 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_2." ] PIO1_2_ , # [ doc = "CT32B1_MAT2." ] CT32B1_MAT2_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_2_ => 0 , FUNCR :: CT32B1_MAT2_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_2_ , 1 => FUNCR :: CT32B1_MAT2_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_2_`" ] # [ inline ] pub fn is_pio1_2_ ( & self ) -> bool { * self == FUNCR :: PIO1_2_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT2_`" ] # [ inline ] pub fn is_ct32b1_mat2_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT2_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_2." ] PIO1_2_ , # [ doc = "CT32B1_MAT2." ] CT32B1_MAT2_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_2_ => 0 , FUNCW :: CT32B1_MAT2_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_2." ] # [ inline ] pub fn pio1_2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_2_ ) } # [ doc = "CT32B1_MAT2." ] # [ inline ] pub fn ct32b1_mat2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT2_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_3/CT32B1_MAT3" ] pub struct PIO1_3 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_3/CT32B1_MAT3" ] pub mod pio1_3 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_3 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_3." ] PIO1_3_ , # [ doc = "CT32B1_MAT3." ] CT32B1_MAT3_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_3_ => 0 , FUNCR :: CT32B1_MAT3_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_3_ , 1 => FUNCR :: CT32B1_MAT3_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_3_`" ] # [ inline ] pub fn is_pio1_3_ ( & self ) -> bool { * self == FUNCR :: PIO1_3_ } # [ doc = "Checks if the value of the field is `CT32B1_MAT3_`" ] # [ inline ] pub fn is_ct32b1_mat3_ ( & self ) -> bool { * self == FUNCR :: CT32B1_MAT3_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_3." ] PIO1_3_ , # [ doc = "CT32B1_MAT3." ] CT32B1_MAT3_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_3_ => 0 , FUNCW :: CT32B1_MAT3_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_3." ] # [ inline ] pub fn pio1_3_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_3_ ) } # [ doc = "CT32B1_MAT3." ] # [ inline ] pub fn ct32b1_mat3_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_MAT3_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_4/CT32B1_CAP0" ] pub struct PIO1_4 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_4/CT32B1_CAP0" ] pub mod pio1_4 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_4 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_4." ] PIO1_4_ , # [ doc = "CT32B1_CAP0." ] CT32B1_CAP0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_4_ => 0 , FUNCR :: CT32B1_CAP0_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_4_ , 1 => FUNCR :: CT32B1_CAP0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_4_`" ] # [ inline ] pub fn is_pio1_4_ ( & self ) -> bool { * self == FUNCR :: PIO1_4_ } # [ doc = "Checks if the value of the field is `CT32B1_CAP0_`" ] # [ inline ] pub fn is_ct32b1_cap0_ ( & self ) -> bool { * self == FUNCR :: CT32B1_CAP0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_4." ] PIO1_4_ , # [ doc = "CT32B1_CAP0." ] CT32B1_CAP0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_4_ => 0 , FUNCW :: CT32B1_CAP0_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_4." ] # [ inline ] pub fn pio1_4_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_4_ ) } # [ doc = "CT32B1_CAP0." ] # [ inline ] pub fn ct32b1_cap0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_CAP0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_5/CT32B1_CAP1" ] pub struct PIO1_5 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_5/CT32B1_CAP1" ] pub mod pio1_5 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_5 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_5." ] PIO1_5_ , # [ doc = "CT32B1_CAP1." ] CT32B1_CAP1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_5_ => 0 , FUNCR :: CT32B1_CAP1_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_5_ , 1 => FUNCR :: CT32B1_CAP1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_5_`" ] # [ inline ] pub fn is_pio1_5_ ( & self ) -> bool { * self == FUNCR :: PIO1_5_ } # [ doc = "Checks if the value of the field is `CT32B1_CAP1_`" ] # [ inline ] pub fn is_ct32b1_cap1_ ( & self ) -> bool { * self == FUNCR :: CT32B1_CAP1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_5." ] PIO1_5_ , # [ doc = "CT32B1_CAP1." ] CT32B1_CAP1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_5_ => 0 , FUNCW :: CT32B1_CAP1_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_5." ] # [ inline ] pub fn pio1_5_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_5_ ) } # [ doc = "CT32B1_CAP1." ] # [ inline ] pub fn ct32b1_cap1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B1_CAP1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_6" ] pub struct PIO1_6 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_6" ] pub mod pio1_6 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_6 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_6." ] PIO1_6_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_6_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_6_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_6_`" ] # [ inline ] pub fn is_pio1_6_ ( & self ) -> bool { * self == FUNCR :: PIO1_6_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_6." ] PIO1_6_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_6_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_6." ] # [ inline ] pub fn pio1_6_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_6_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_7" ] pub struct PIO1_7 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_7" ] pub mod pio1_7 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_7 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_7." ] PIO1_7_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_7_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_7_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_7_`" ] # [ inline ] pub fn is_pio1_7_ ( & self ) -> bool { * self == FUNCR :: PIO1_7_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_7." ] PIO1_7_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_7_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_7." ] # [ inline ] pub fn pio1_7_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_7_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_8" ] pub struct PIO1_8 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_8" ] pub mod pio1_8 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_8 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_8." ] PIO1_8_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_8_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_8_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_8_`" ] # [ inline ] pub fn is_pio1_8_ ( & self ) -> bool { * self == FUNCR :: PIO1_8_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_8." ] PIO1_8_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_8_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_8." ] # [ inline ] pub fn pio1_8_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_8_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_9" ] pub struct PIO1_9 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_9" ] pub mod pio1_9 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_9 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_9." ] PIO1_9_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_9_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_9_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_9_`" ] # [ inline ] pub fn is_pio1_9_ ( & self ) -> bool { * self == FUNCR :: PIO1_9_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_9." ] PIO1_9_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_9_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_9." ] # [ inline ] pub fn pio1_9_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_9_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_10" ] pub struct PIO1_10 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_10" ] pub mod pio1_10 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_10 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_10." ] PIO1_10_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_10_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_10_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_10_`" ] # [ inline ] pub fn is_pio1_10_ ( & self ) -> bool { * self == FUNCR :: PIO1_10_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_10." ] PIO1_10_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_10_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_10." ] # [ inline ] pub fn pio1_10_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_10_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_11" ] pub struct PIO1_11 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_11" ] pub mod pio1_11 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_11 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_11." ] PIO1_11_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_11_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_11_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_11_`" ] # [ inline ] pub fn is_pio1_11_ ( & self ) -> bool { * self == FUNCR :: PIO1_11_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_11." ] PIO1_11_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_11_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_11." ] # [ inline ] pub fn pio1_11_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_11_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_12" ] pub struct PIO1_12 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_12" ] pub mod pio1_12 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_12 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_12." ] PIO1_12_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_12_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_12_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_12_`" ] # [ inline ] pub fn is_pio1_12_ ( & self ) -> bool { * self == FUNCR :: PIO1_12_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_12." ] PIO1_12_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_12_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_12." ] # [ inline ] pub fn pio1_12_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_12_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_13/DTR/CT16B0_MAT0/TXD" ] pub struct PIO1_13 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_13/DTR/CT16B0_MAT0/TXD" ] pub mod pio1_13 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_13 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_13." ] PIO1_13_ , # [ doc = "DTR." ] DTR_ , # [ doc = "CT16B0_MAT0." ] CT16B0_MAT0_ , # [ doc = "TXD." ] TXD_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_13_ => 0 , FUNCR :: DTR_ => 0x01 , FUNCR :: CT16B0_MAT0_ => 0x02 , FUNCR :: TXD_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_13_ , 1 => FUNCR :: DTR_ , 2 => FUNCR :: CT16B0_MAT0_ , 3 => FUNCR :: TXD_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_13_`" ] # [ inline ] pub fn is_pio1_13_ ( & self ) -> bool { * self == FUNCR :: PIO1_13_ } # [ doc = "Checks if the value of the field is `DTR_`" ] # [ inline ] pub fn is_dtr_ ( & self ) -> bool { * self == FUNCR :: DTR_ } # [ doc = "Checks if the value of the field is `CT16B0_MAT0_`" ] # [ inline ] pub fn is_ct16b0_mat0_ ( & self ) -> bool { * self == FUNCR :: CT16B0_MAT0_ } # [ doc = "Checks if the value of the field is `TXD_`" ] # [ inline ] pub fn is_txd_ ( & self ) -> bool { * self == FUNCR :: TXD_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_13." ] PIO1_13_ , # [ doc = "DTR." ] DTR_ , # [ doc = "CT16B0_MAT0." ] CT16B0_MAT0_ , # [ doc = "TXD." ] TXD_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_13_ => 0 , FUNCW :: DTR_ => 1 , FUNCW :: CT16B0_MAT0_ => 2 , FUNCW :: TXD_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_13." ] # [ inline ] pub fn pio1_13_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_13_ ) } # [ doc = "DTR." ] # [ inline ] pub fn dtr_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: DTR_ ) } # [ doc = "CT16B0_MAT0." ] # [ inline ] pub fn ct16b0_mat0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_MAT0_ ) } # [ doc = "TXD." ] # [ inline ] pub fn txd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: TXD_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_14/DSR/CT16B0_MAT1/RXD" ] pub struct PIO1_14 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_14/DSR/CT16B0_MAT1/RXD" ] pub mod pio1_14 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_14 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_14." ] PIO1_14_ , # [ doc = "DSR." ] DSR_ , # [ doc = "CT16B0_MAT1." ] CT16B0_MAT1_ , # [ doc = "RXD." ] RXD_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_14_ => 0 , FUNCR :: DSR_ => 0x01 , FUNCR :: CT16B0_MAT1_ => 0x02 , FUNCR :: RXD_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_14_ , 1 => FUNCR :: DSR_ , 2 => FUNCR :: CT16B0_MAT1_ , 3 => FUNCR :: RXD_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_14_`" ] # [ inline ] pub fn is_pio1_14_ ( & self ) -> bool { * self == FUNCR :: PIO1_14_ } # [ doc = "Checks if the value of the field is `DSR_`" ] # [ inline ] pub fn is_dsr_ ( & self ) -> bool { * self == FUNCR :: DSR_ } # [ doc = "Checks if the value of the field is `CT16B0_MAT1_`" ] # [ inline ] pub fn is_ct16b0_mat1_ ( & self ) -> bool { * self == FUNCR :: CT16B0_MAT1_ } # [ doc = "Checks if the value of the field is `RXD_`" ] # [ inline ] pub fn is_rxd_ ( & self ) -> bool { * self == FUNCR :: RXD_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_14." ] PIO1_14_ , # [ doc = "DSR." ] DSR_ , # [ doc = "CT16B0_MAT1." ] CT16B0_MAT1_ , # [ doc = "RXD." ] RXD_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_14_ => 0 , FUNCW :: DSR_ => 1 , FUNCW :: CT16B0_MAT1_ => 2 , FUNCW :: RXD_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_14." ] # [ inline ] pub fn pio1_14_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_14_ ) } # [ doc = "DSR." ] # [ inline ] pub fn dsr_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: DSR_ ) } # [ doc = "CT16B0_MAT1." ] # [ inline ] pub fn ct16b0_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_MAT1_ ) } # [ doc = "RXD." ] # [ inline ] pub fn rxd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: RXD_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_15/DCD/ CT16B0_MAT2/SCK1" ] pub struct PIO1_15 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_15/DCD/ CT16B0_MAT2/SCK1" ] pub mod pio1_15 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_15 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_15." ] PIO1_15_ , # [ doc = "DCD." ] DCD_ , # [ doc = "CT16B0_MAT2." ] CT16B0_MAT2_ , # [ doc = "SCK1." ] SCK1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_15_ => 0 , FUNCR :: DCD_ => 0x01 , FUNCR :: CT16B0_MAT2_ => 0x02 , FUNCR :: SCK1_ => 0x03 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_15_ , 1 => FUNCR :: DCD_ , 2 => FUNCR :: CT16B0_MAT2_ , 3 => FUNCR :: SCK1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_15_`" ] # [ inline ] pub fn is_pio1_15_ ( & self ) -> bool { * self == FUNCR :: PIO1_15_ } # [ doc = "Checks if the value of the field is `DCD_`" ] # [ inline ] pub fn is_dcd_ ( & self ) -> bool { * self == FUNCR :: DCD_ } # [ doc = "Checks if the value of the field is `CT16B0_MAT2_`" ] # [ inline ] pub fn is_ct16b0_mat2_ ( & self ) -> bool { * self == FUNCR :: CT16B0_MAT2_ } # [ doc = "Checks if the value of the field is `SCK1_`" ] # [ inline ] pub fn is_sck1_ ( & self ) -> bool { * self == FUNCR :: SCK1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_15." ] PIO1_15_ , # [ doc = "DCD." ] DCD_ , # [ doc = "CT16B0_MAT2." ] CT16B0_MAT2_ , # [ doc = "SCK1." ] SCK1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_15_ => 0 , FUNCW :: DCD_ => 1 , FUNCW :: CT16B0_MAT2_ => 2 , FUNCW :: SCK1_ => 3 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_15." ] # [ inline ] pub fn pio1_15_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_15_ ) } # [ doc = "DCD." ] # [ inline ] pub fn dcd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: DCD_ ) } # [ doc = "CT16B0_MAT2." ] # [ inline ] pub fn ct16b0_mat2_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_MAT2_ ) } # [ doc = "SCK1." ] # [ inline ] pub fn sck1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SCK1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x4 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_16/RI/CT16B0_CAP0" ] pub struct PIO1_16 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_16/RI/CT16B0_CAP0" ] pub mod pio1_16 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_16 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_16." ] PIO1_16_ , # [ doc = "RI." ] RI_ , # [ doc = "CT16B0_CAP0." ] CT16B0_CAP0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_16_ => 0 , FUNCR :: RI_ => 0x01 , FUNCR :: CT16B0_CAP0_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_16_ , 1 => FUNCR :: RI_ , 2 => FUNCR :: CT16B0_CAP0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_16_`" ] # [ inline ] pub fn is_pio1_16_ ( & self ) -> bool { * self == FUNCR :: PIO1_16_ } # [ doc = "Checks if the value of the field is `RI_`" ] # [ inline ] pub fn is_ri_ ( & self ) -> bool { * self == FUNCR :: RI_ } # [ doc = "Checks if the value of the field is `CT16B0_CAP0_`" ] # [ inline ] pub fn is_ct16b0_cap0_ ( & self ) -> bool { * self == FUNCR :: CT16B0_CAP0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_16." ] PIO1_16_ , # [ doc = "RI." ] RI_ , # [ doc = "CT16B0_CAP0." ] CT16B0_CAP0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_16_ => 0 , FUNCW :: RI_ => 1 , FUNCW :: CT16B0_CAP0_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_16." ] # [ inline ] pub fn pio1_16_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_16_ ) } # [ doc = "RI." ] # [ inline ] pub fn ri_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: RI_ ) } # [ doc = "CT16B0_CAP0." ] # [ inline ] pub fn ct16b0_cap0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_CAP0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for PIO1_17/CT16B0_CAP1/RXD" ] pub struct PIO1_17 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for PIO1_17/CT16B0_CAP1/RXD" ] pub mod pio1_17 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_17 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_17." ] PIO1_17_ , # [ doc = "CT16B0_CAP1" ] CT16B0_CAP1 , # [ doc = "RXD" ] RXD , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_17_ => 0 , FUNCR :: CT16B0_CAP1 => 0x01 , FUNCR :: RXD => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_17_ , 1 => FUNCR :: CT16B0_CAP1 , 2 => FUNCR :: RXD , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_17_`" ] # [ inline ] pub fn is_pio1_17_ ( & self ) -> bool { * self == FUNCR :: PIO1_17_ } # [ doc = "Checks if the value of the field is `CT16B0_CAP1`" ] # [ inline ] pub fn is_ct16b0_cap1 ( & self ) -> bool { * self == FUNCR :: CT16B0_CAP1 } # [ doc = "Checks if the value of the field is `RXD`" ] # [ inline ] pub fn is_rxd ( & self ) -> bool { * self == FUNCR :: RXD } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_17." ] PIO1_17_ , # [ doc = "CT16B0_CAP1" ] CT16B0_CAP1 , # [ doc = "RXD" ] RXD } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_17_ => 0 , FUNCW :: CT16B0_CAP1 => 1 , FUNCW :: RXD => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_17." ] # [ inline ] pub fn pio1_17_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_17_ ) } # [ doc = "CT16B0_CAP1" ] # [ inline ] pub fn ct16b0_cap1 ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B0_CAP1 ) } # [ doc = "RXD" ] # [ inline ] pub fn rxd ( self ) -> & 'a mut W { self . variant ( FUNCW :: RXD ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for PIO1_18/CT16B1_CAP1/TXD" ] pub struct PIO1_18 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for PIO1_18/CT16B1_CAP1/TXD" ] pub mod pio1_18 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_18 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_18" ] PIO1_18 , # [ doc = "CT16B1_CAP1" ] CT16B1_CAP1 , # [ doc = "TXD" ] TXD , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_18 => 0 , FUNCR :: CT16B1_CAP1 => 0x01 , FUNCR :: TXD => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_18 , 1 => FUNCR :: CT16B1_CAP1 , 2 => FUNCR :: TXD , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_18`" ] # [ inline ] pub fn is_pio1_18 ( & self ) -> bool { * self == FUNCR :: PIO1_18 } # [ doc = "Checks if the value of the field is `CT16B1_CAP1`" ] # [ inline ] pub fn is_ct16b1_cap1 ( & self ) -> bool { * self == FUNCR :: CT16B1_CAP1 } # [ doc = "Checks if the value of the field is `TXD`" ] # [ inline ] pub fn is_txd ( & self ) -> bool { * self == FUNCR :: TXD } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_18" ] PIO1_18 , # [ doc = "CT16B1_CAP1" ] CT16B1_CAP1 , # [ doc = "TXD" ] TXD } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_18 => 0 , FUNCW :: CT16B1_CAP1 => 1 , FUNCW :: TXD => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_18" ] # [ inline ] pub fn pio1_18 ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_18 ) } # [ doc = "CT16B1_CAP1" ] # [ inline ] pub fn ct16b1_cap1 ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B1_CAP1 ) } # [ doc = "TXD" ] # [ inline ] pub fn txd ( self ) -> & 'a mut W { self . variant ( FUNCW :: TXD ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_19/DTR/SSEL1" ] pub struct PIO1_19 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_19/DTR/SSEL1" ] pub mod pio1_19 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_19 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_19." ] PIO1_19_ , # [ doc = "DTR." ] DTR_ , # [ doc = "SSEL1." ] SSEL1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_19_ => 0 , FUNCR :: DTR_ => 0x01 , FUNCR :: SSEL1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_19_ , 1 => FUNCR :: DTR_ , 2 => FUNCR :: SSEL1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_19_`" ] # [ inline ] pub fn is_pio1_19_ ( & self ) -> bool { * self == FUNCR :: PIO1_19_ } # [ doc = "Checks if the value of the field is `DTR_`" ] # [ inline ] pub fn is_dtr_ ( & self ) -> bool { * self == FUNCR :: DTR_ } # [ doc = "Checks if the value of the field is `SSEL1_`" ] # [ inline ] pub fn is_ssel1_ ( & self ) -> bool { * self == FUNCR :: SSEL1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_19." ] PIO1_19_ , # [ doc = "DTR." ] DTR_ , # [ doc = "SSEL1." ] SSEL1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_19_ => 0 , FUNCW :: DTR_ => 1 , FUNCW :: SSEL1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_19." ] # [ inline ] pub fn pio1_19_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_19_ ) } # [ doc = "DTR." ] # [ inline ] pub fn dtr_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: DTR_ ) } # [ doc = "SSEL1." ] # [ inline ] pub fn ssel1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SSEL1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_20/DSR/SCK1" ] pub struct PIO1_20 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_20/DSR/SCK1" ] pub mod pio1_20 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_20 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_20." ] PIO1_20_ , # [ doc = "DSR." ] DSR_ , # [ doc = "SCK1." ] SCK1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_20_ => 0 , FUNCR :: DSR_ => 0x01 , FUNCR :: SCK1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_20_ , 1 => FUNCR :: DSR_ , 2 => FUNCR :: SCK1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_20_`" ] # [ inline ] pub fn is_pio1_20_ ( & self ) -> bool { * self == FUNCR :: PIO1_20_ } # [ doc = "Checks if the value of the field is `DSR_`" ] # [ inline ] pub fn is_dsr_ ( & self ) -> bool { * self == FUNCR :: DSR_ } # [ doc = "Checks if the value of the field is `SCK1_`" ] # [ inline ] pub fn is_sck1_ ( & self ) -> bool { * self == FUNCR :: SCK1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_20." ] PIO1_20_ , # [ doc = "DSR." ] DSR_ , # [ doc = "SCK1." ] SCK1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_20_ => 0 , FUNCW :: DSR_ => 1 , FUNCW :: SCK1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_20." ] # [ inline ] pub fn pio1_20_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_20_ ) } # [ doc = "DSR." ] # [ inline ] pub fn dsr_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: DSR_ ) } # [ doc = "SCK1." ] # [ inline ] pub fn sck1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SCK1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_21/DCD/MISO1" ] pub struct PIO1_21 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_21/DCD/MISO1" ] pub mod pio1_21 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_21 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_21." ] PIO1_21_ , # [ doc = "DCD." ] DCD_ , # [ doc = "MISO1." ] MISO1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_21_ => 0 , FUNCR :: DCD_ => 0x01 , FUNCR :: MISO1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_21_ , 1 => FUNCR :: DCD_ , 2 => FUNCR :: MISO1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_21_`" ] # [ inline ] pub fn is_pio1_21_ ( & self ) -> bool { * self == FUNCR :: PIO1_21_ } # [ doc = "Checks if the value of the field is `DCD_`" ] # [ inline ] pub fn is_dcd_ ( & self ) -> bool { * self == FUNCR :: DCD_ } # [ doc = "Checks if the value of the field is `MISO1_`" ] # [ inline ] pub fn is_miso1_ ( & self ) -> bool { * self == FUNCR :: MISO1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_21." ] PIO1_21_ , # [ doc = "DCD." ] DCD_ , # [ doc = "MISO1." ] MISO1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_21_ => 0 , FUNCW :: DCD_ => 1 , FUNCW :: MISO1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_21." ] # [ inline ] pub fn pio1_21_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_21_ ) } # [ doc = "DCD." ] # [ inline ] pub fn dcd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: DCD_ ) } # [ doc = "MISO1." ] # [ inline ] pub fn miso1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: MISO1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_22/RI/MOSI1" ] pub struct PIO1_22 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_22/RI/MOSI1" ] pub mod pio1_22 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_22 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_22." ] PIO1_22_ , # [ doc = "RI." ] RI_ , # [ doc = "MOSI1." ] MOSI1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_22_ => 0 , FUNCR :: RI_ => 0x01 , FUNCR :: MOSI1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_22_ , 1 => FUNCR :: RI_ , 2 => FUNCR :: MOSI1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_22_`" ] # [ inline ] pub fn is_pio1_22_ ( & self ) -> bool { * self == FUNCR :: PIO1_22_ } # [ doc = "Checks if the value of the field is `RI_`" ] # [ inline ] pub fn is_ri_ ( & self ) -> bool { * self == FUNCR :: RI_ } # [ doc = "Checks if the value of the field is `MOSI1_`" ] # [ inline ] pub fn is_mosi1_ ( & self ) -> bool { * self == FUNCR :: MOSI1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_22." ] PIO1_22_ , # [ doc = "RI." ] RI_ , # [ doc = "MOSI1." ] MOSI1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_22_ => 0 , FUNCW :: RI_ => 1 , FUNCW :: MOSI1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_22." ] # [ inline ] pub fn pio1_22_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_22_ ) } # [ doc = "RI." ] # [ inline ] pub fn ri_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: RI_ ) } # [ doc = "MOSI1." ] # [ inline ] pub fn mosi1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: MOSI1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_23/CT16B1_MAT1/SSEL1" ] pub struct PIO1_23 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_23/CT16B1_MAT1/SSEL1" ] pub mod pio1_23 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_23 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_23." ] PIO1_23_ , # [ doc = "CT16B1_MAT1." ] CT16B1_MAT1_ , # [ doc = "SSEL1." ] SSEL1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_23_ => 0 , FUNCR :: CT16B1_MAT1_ => 0x01 , FUNCR :: SSEL1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_23_ , 1 => FUNCR :: CT16B1_MAT1_ , 2 => FUNCR :: SSEL1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_23_`" ] # [ inline ] pub fn is_pio1_23_ ( & self ) -> bool { * self == FUNCR :: PIO1_23_ } # [ doc = "Checks if the value of the field is `CT16B1_MAT1_`" ] # [ inline ] pub fn is_ct16b1_mat1_ ( & self ) -> bool { * self == FUNCR :: CT16B1_MAT1_ } # [ doc = "Checks if the value of the field is `SSEL1_`" ] # [ inline ] pub fn is_ssel1_ ( & self ) -> bool { * self == FUNCR :: SSEL1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_23." ] PIO1_23_ , # [ doc = "CT16B1_MAT1." ] CT16B1_MAT1_ , # [ doc = "SSEL1." ] SSEL1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_23_ => 0 , FUNCW :: CT16B1_MAT1_ => 1 , FUNCW :: SSEL1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_23." ] # [ inline ] pub fn pio1_23_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_23_ ) } # [ doc = "CT16B1_MAT1." ] # [ inline ] pub fn ct16b1_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT16B1_MAT1_ ) } # [ doc = "SSEL1." ] # [ inline ] pub fn ssel1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SSEL1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_24/ CT32B0_MAT0" ] pub struct PIO1_24 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_24/ CT32B0_MAT0" ] pub mod pio1_24 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_24 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_24." ] PIO1_24_ , # [ doc = "CT32B0_MAT0." ] CT32B0_MAT0_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_24_ => 0 , FUNCR :: CT32B0_MAT0_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_24_ , 1 => FUNCR :: CT32B0_MAT0_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_24_`" ] # [ inline ] pub fn is_pio1_24_ ( & self ) -> bool { * self == FUNCR :: PIO1_24_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT0_`" ] # [ inline ] pub fn is_ct32b0_mat0_ ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT0_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_24." ] PIO1_24_ , # [ doc = "CT32B0_MAT0." ] CT32B0_MAT0_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_24_ => 0 , FUNCW :: CT32B0_MAT0_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_24." ] # [ inline ] pub fn pio1_24_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_24_ ) } # [ doc = "CT32B0_MAT0." ] # [ inline ] pub fn ct32b0_mat0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT0_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_25/CT32B0_MAT1" ] pub struct PIO1_25 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_25/CT32B0_MAT1" ] pub mod pio1_25 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_25 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_25." ] PIO1_25_ , # [ doc = "CT32B0_MAT1." ] CT32B0_MAT1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_25_ => 0 , FUNCR :: CT32B0_MAT1_ => 0x01 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_25_ , 1 => FUNCR :: CT32B0_MAT1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_25_`" ] # [ inline ] pub fn is_pio1_25_ ( & self ) -> bool { * self == FUNCR :: PIO1_25_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT1_`" ] # [ inline ] pub fn is_ct32b0_mat1_ ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_25." ] PIO1_25_ , # [ doc = "CT32B0_MAT1." ] CT32B0_MAT1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_25_ => 0 , FUNCW :: CT32B0_MAT1_ => 1 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_25." ] # [ inline ] pub fn pio1_25_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_25_ ) } # [ doc = "CT32B0_MAT1." ] # [ inline ] pub fn ct32b0_mat1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x2 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_26/CT32B0_MAT2/ RXD" ] pub struct PIO1_26 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_26/CT32B0_MAT2/ RXD" ] pub mod pio1_26 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_26 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_26." ] PIO1_26_ , # [ doc = "CT32B0_MAT2" ] CT32B0_MAT2 , # [ doc = "RXD." ] RXD_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_26_ => 0 , FUNCR :: CT32B0_MAT2 => 0x01 , FUNCR :: RXD_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_26_ , 1 => FUNCR :: CT32B0_MAT2 , 2 => FUNCR :: RXD_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_26_`" ] # [ inline ] pub fn is_pio1_26_ ( & self ) -> bool { * self == FUNCR :: PIO1_26_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT2`" ] # [ inline ] pub fn is_ct32b0_mat2 ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT2 } # [ doc = "Checks if the value of the field is `RXD_`" ] # [ inline ] pub fn is_rxd_ ( & self ) -> bool { * self == FUNCR :: RXD_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_26." ] PIO1_26_ , # [ doc = "CT32B0_MAT2" ] CT32B0_MAT2 , # [ doc = "RXD." ] RXD_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_26_ => 0 , FUNCW :: CT32B0_MAT2 => 1 , FUNCW :: RXD_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_26." ] # [ inline ] pub fn pio1_26_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_26_ ) } # [ doc = "CT32B0_MAT2" ] # [ inline ] pub fn ct32b0_mat2 ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT2 ) } # [ doc = "RXD." ] # [ inline ] pub fn rxd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: RXD_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_27/CT32B0_MAT3/ TXD" ] pub struct PIO1_27 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_27/CT32B0_MAT3/ TXD" ] pub mod pio1_27 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_27 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_27." ] PIO1_27_ , # [ doc = "CT32B0_MAT3." ] CT32B0_MAT3_ , # [ doc = "TXD." ] TXD_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_27_ => 0 , FUNCR :: CT32B0_MAT3_ => 0x01 , FUNCR :: TXD_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_27_ , 1 => FUNCR :: CT32B0_MAT3_ , 2 => FUNCR :: TXD_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_27_`" ] # [ inline ] pub fn is_pio1_27_ ( & self ) -> bool { * self == FUNCR :: PIO1_27_ } # [ doc = "Checks if the value of the field is `CT32B0_MAT3_`" ] # [ inline ] pub fn is_ct32b0_mat3_ ( & self ) -> bool { * self == FUNCR :: CT32B0_MAT3_ } # [ doc = "Checks if the value of the field is `TXD_`" ] # [ inline ] pub fn is_txd_ ( & self ) -> bool { * self == FUNCR :: TXD_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_27." ] PIO1_27_ , # [ doc = "CT32B0_MAT3." ] CT32B0_MAT3_ , # [ doc = "TXD." ] TXD_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_27_ => 0 , FUNCW :: CT32B0_MAT3_ => 1 , FUNCW :: TXD_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_27." ] # [ inline ] pub fn pio1_27_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_27_ ) } # [ doc = "CT32B0_MAT3." ] # [ inline ] pub fn ct32b0_mat3_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_MAT3_ ) } # [ doc = "TXD." ] # [ inline ] pub fn txd_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: TXD_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_28/CT32B0_CAP0/ SCLK" ] pub struct PIO1_28 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_28/CT32B0_CAP0/ SCLK" ] pub mod pio1_28 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_28 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_28." ] PIO1_28_ , # [ doc = "CT32B0_CAP0." ] CT32B0_CAP0_ , # [ doc = "SCLK." ] SCLK_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_28_ => 0 , FUNCR :: CT32B0_CAP0_ => 0x01 , FUNCR :: SCLK_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_28_ , 1 => FUNCR :: CT32B0_CAP0_ , 2 => FUNCR :: SCLK_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_28_`" ] # [ inline ] pub fn is_pio1_28_ ( & self ) -> bool { * self == FUNCR :: PIO1_28_ } # [ doc = "Checks if the value of the field is `CT32B0_CAP0_`" ] # [ inline ] pub fn is_ct32b0_cap0_ ( & self ) -> bool { * self == FUNCR :: CT32B0_CAP0_ } # [ doc = "Checks if the value of the field is `SCLK_`" ] # [ inline ] pub fn is_sclk_ ( & self ) -> bool { * self == FUNCR :: SCLK_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_28." ] PIO1_28_ , # [ doc = "CT32B0_CAP0." ] CT32B0_CAP0_ , # [ doc = "SCLK." ] SCLK_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_28_ => 0 , FUNCW :: CT32B0_CAP0_ => 1 , FUNCW :: SCLK_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_28." ] # [ inline ] pub fn pio1_28_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_28_ ) } # [ doc = "CT32B0_CAP0." ] # [ inline ] pub fn ct32b0_cap0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_CAP0_ ) } # [ doc = "SCLK." ] # [ inline ] pub fn sclk_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SCLK_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_29/SCK0/ CT32B0_CAP1" ] pub struct PIO1_29 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_29/SCK0/ CT32B0_CAP1" ] pub mod pio1_29 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_29 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_29." ] PIO1_29_ , # [ doc = "SCK0." ] SCK0_ , # [ doc = "CT32B0_CAP1." ] CT32B0_CAP1_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_29_ => 0 , FUNCR :: SCK0_ => 0x01 , FUNCR :: CT32B0_CAP1_ => 0x02 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_29_ , 1 => FUNCR :: SCK0_ , 2 => FUNCR :: CT32B0_CAP1_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_29_`" ] # [ inline ] pub fn is_pio1_29_ ( & self ) -> bool { * self == FUNCR :: PIO1_29_ } # [ doc = "Checks if the value of the field is `SCK0_`" ] # [ inline ] pub fn is_sck0_ ( & self ) -> bool { * self == FUNCR :: SCK0_ } # [ doc = "Checks if the value of the field is `CT32B0_CAP1_`" ] # [ inline ] pub fn is_ct32b0_cap1_ ( & self ) -> bool { * self == FUNCR :: CT32B0_CAP1_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_29." ] PIO1_29_ , # [ doc = "SCK0." ] SCK0_ , # [ doc = "CT32B0_CAP1." ] CT32B0_CAP1_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_29_ => 0 , FUNCW :: SCK0_ => 1 , FUNCW :: CT32B0_CAP1_ => 2 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_29." ] # [ inline ] pub fn pio1_29_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_29_ ) } # [ doc = "SCK0." ] # [ inline ] pub fn sck0_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: SCK0_ ) } # [ doc = "CT32B0_CAP1." ] # [ inline ] pub fn ct32b0_cap1_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: CT32B0_CAP1_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x3 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } # [ doc = "I/O configuration for pin PIO1_31" ] pub struct PIO1_31 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "I/O configuration for pin PIO1_31" ] pub mod pio1_31 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIO1_31 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FUNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FUNCR { # [ doc = "PIO1_31." ] PIO1_31_ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FUNCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FUNCR :: PIO1_31_ => 0 , FUNCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FUNCR { match value { 0 => FUNCR :: PIO1_31_ , i => FUNCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `PIO1_31_`" ] # [ inline ] pub fn is_pio1_31_ ( & self ) -> bool { * self == FUNCR :: PIO1_31_ } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: INACTIVE_NO_PULL_DO => 0 , MODER :: PULL_DOWN_RESISTOR_E => 0x01 , MODER :: PULL_UP_RESISTOR_ENA => 0x02 , MODER :: REPEATER_MODE_ => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: INACTIVE_NO_PULL_DO , 1 => MODER :: PULL_DOWN_RESISTOR_E , 2 => MODER :: PULL_UP_RESISTOR_ENA , 3 => MODER :: REPEATER_MODE_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`" ] # [ inline ] pub fn is_inactive_no_pull_do ( & self ) -> bool { * self == MODER :: INACTIVE_NO_PULL_DO } # [ doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`" ] # [ inline ] pub fn is_pull_down_resistor_e ( & self ) -> bool { * self == MODER :: PULL_DOWN_RESISTOR_E } # [ doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`" ] # [ inline ] pub fn is_pull_up_resistor_ena ( & self ) -> bool { * self == MODER :: PULL_UP_RESISTOR_ENA } # [ doc = "Checks if the value of the field is `REPEATER_MODE_`" ] # [ inline ] pub fn is_repeater_mode_ ( & self ) -> bool { * self == MODER :: REPEATER_MODE_ } } # [ doc = "Possible values of the field `HYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HYSR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HYSR :: DISABLE_ => false , HYSR :: ENABLE_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HYSR { match value { false => HYSR :: DISABLE_ , true => HYSR :: ENABLE_ , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == HYSR :: DISABLE_ } # [ doc = "Checks if the value of the field is `ENABLE_`" ] # [ inline ] pub fn is_enable_ ( & self ) -> bool { * self == HYSR :: ENABLE_ } } # [ doc = "Possible values of the field `INV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INVR { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INVR :: INPUT_NOT_INVERTED_ => false , INVR :: INPUT_INVERTED_HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INVR { match value { false => INVR :: INPUT_NOT_INVERTED_ , true => INVR :: INPUT_INVERTED_HIGH , } } # [ doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`" ] # [ inline ] pub fn is_input_not_inverted_ ( & self ) -> bool { * self == INVR :: INPUT_NOT_INVERTED_ } # [ doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`" ] # [ inline ] pub fn is_input_inverted_high ( & self ) -> bool { * self == INVR :: INPUT_INVERTED_HIGH } } # [ doc = "Possible values of the field `OD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ODR { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ODR :: DISABLE_ => false , ODR :: OPEN_DRAIN_MODE_ENAB => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ODR { match value { false => ODR :: DISABLE_ , true => ODR :: OPEN_DRAIN_MODE_ENAB , } } # [ doc = "Checks if the value of the field is `DISABLE_`" ] # [ inline ] pub fn is_disable_ ( & self ) -> bool { * self == ODR :: DISABLE_ } # [ doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`" ] # [ inline ] pub fn is_open_drain_mode_enab ( & self ) -> bool { * self == ODR :: OPEN_DRAIN_MODE_ENAB } } # [ doc = "Values that can be written to the field `FUNC`" ] pub enum FUNCW { # [ doc = "PIO1_31." ] PIO1_31_ } impl FUNCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FUNCW :: PIO1_31_ => 0 } } } # [ doc = r" Proxy" ] pub struct _FUNCW < 'a > { w : & 'a mut W , } impl < 'a > _FUNCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FUNCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "PIO1_31." ] # [ inline ] pub fn pio1_31_ ( self ) -> & 'a mut W { self . variant ( FUNCW :: PIO1_31_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] INACTIVE_NO_PULL_DO , # [ doc = "Pull-down resistor enabled." ] PULL_DOWN_RESISTOR_E , # [ doc = "Pull-up resistor enabled." ] PULL_UP_RESISTOR_ENA , # [ doc = "Repeater mode." ] REPEATER_MODE_ } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: INACTIVE_NO_PULL_DO => 0 , MODEW :: PULL_DOWN_RESISTOR_E => 1 , MODEW :: PULL_UP_RESISTOR_ENA => 2 , MODEW :: REPEATER_MODE_ => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Inactive (no pull-down/pull-up resistor enabled)." ] # [ inline ] pub fn inactive_no_pull_do ( self ) -> & 'a mut W { self . variant ( MODEW :: INACTIVE_NO_PULL_DO ) } # [ doc = "Pull-down resistor enabled." ] # [ inline ] pub fn pull_down_resistor_e ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_DOWN_RESISTOR_E ) } # [ doc = "Pull-up resistor enabled." ] # [ inline ] pub fn pull_up_resistor_ena ( self ) -> & 'a mut W { self . variant ( MODEW :: PULL_UP_RESISTOR_ENA ) } # [ doc = "Repeater mode." ] # [ inline ] pub fn repeater_mode_ ( self ) -> & 'a mut W { self . variant ( MODEW :: REPEATER_MODE_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HYS`" ] pub enum HYSW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Enable." ] ENABLE_ } impl HYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HYSW :: DISABLE_ => false , HYSW :: ENABLE_ => true } } } # [ doc = r" Proxy" ] pub struct _HYSW < 'a > { w : & 'a mut W , } impl < 'a > _HYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: DISABLE_ ) } # [ doc = "Enable." ] # [ inline ] pub fn enable_ ( self ) -> & 'a mut W { self . variant ( HYSW :: ENABLE_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INV`" ] pub enum INVW { # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] INPUT_NOT_INVERTED_ , # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] INPUT_INVERTED_HIGH } impl INVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INVW :: INPUT_NOT_INVERTED_ => false , INVW :: INPUT_INVERTED_HIGH => true } } } # [ doc = r" Proxy" ] pub struct _INVW < 'a > { w : & 'a mut W , } impl < 'a > _INVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INVW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0)." ] # [ inline ] pub fn input_not_inverted_ ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_NOT_INVERTED_ ) } # [ doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)." ] # [ inline ] pub fn input_inverted_high ( self ) -> & 'a mut W { self . variant ( INVW :: INPUT_INVERTED_HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OD`" ] pub enum ODW { # [ doc = "Disable." ] DISABLE_ , # [ doc = "Open-drain mode enabled.  This is not a true open-drain mode." ] OPEN_DRAIN_MODE_ENAB } impl ODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ODW :: DISABLE_ => false , ODW :: OPEN_DRAIN_MODE_ENAB => true } } } # [ doc = r" Proxy" ] pub struct _ODW < 'a > { w : & 'a mut W , } impl < 'a > _ODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable." ] # [ inline ] pub fn disable_ ( self ) -> & 'a mut W { self . variant ( ODW :: DISABLE_ ) } # [ doc = "Open-drain mode enabled. This is not a true open-drain mode." ] # [ inline ] pub fn open_drain_mode_enab ( self ) -> & 'a mut W { self . variant ( ODW :: OPEN_DRAIN_MODE_ENAB ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & self ) -> FUNCR { FUNCR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & self ) -> HYSR { HYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & self ) -> INVR { INVR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & self ) -> ODR { ODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x90 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Selects pin function. Values 0x1 to 0x7 are reserved." ] # [ inline ] pub fn func ( & mut self ) -> _FUNCW { _FUNCW { w : self } } # [ doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bit 5 - Hysteresis." ] # [ inline ] pub fn hys ( & mut self ) -> _HYSW { _HYSW { w : self } } # [ doc = "Bit 6 - Invert input" ] # [ inline ] pub fn inv ( & mut self ) -> _INVW { _INVW { w : self } } # [ doc = "Bit 10 - Open-drain mode." ] # [ inline ] pub fn od ( & mut self ) -> _ODW { _ODW { w : self } } } } } # [ doc = "System control block" ] pub struct SYSCON { _marker : PhantomData < * const ( ) > } unsafe impl Send for SYSCON { } impl SYSCON { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const syscon :: RegisterBlock { 0x4004_8000 as * const _ } } impl Deref for SYSCON { type Target = syscon :: RegisterBlock ; fn deref ( & self ) -> & syscon :: RegisterBlock { unsafe { & * SYSCON :: ptr ( ) } } } # [ doc = "System control block" ] pub mod syscon { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - System memory remap" ] pub sysmemremap : SYSMEMREMAP , # [ doc = "0x04 - Peripheral reset control" ] pub presetctrl : PRESETCTRL , # [ doc = "0x08 - System PLL control" ] pub syspllctrl : SYSPLLCTRL , # [ doc = "0x0c - System PLL status" ] pub syspllstat : SYSPLLSTAT , # [ doc = "0x10 - USB PLL control" ] pub usbpllctrl : USBPLLCTRL , # [ doc = "0x14 - USB PLL status" ] pub usbpllstat : USBPLLSTAT , _reserved0 : [ u8 ; 8usize ] , # [ doc = "0x20 - System oscillator control" ] pub sysoscctrl : SYSOSCCTRL , # [ doc = "0x24 - Watchdog oscillator control" ] pub wdtoscctrl : WDTOSCCTRL , _reserved1 : [ u8 ; 8usize ] , # [ doc = "0x30 - System reset status register" ] pub sysrststat : SYSRSTSTAT , _reserved2 : [ u8 ; 12usize ] , # [ doc = "0x40 - System PLL clock source select" ] pub syspllclksel : SYSPLLCLKSEL , # [ doc = "0x44 - System PLL clock source update enable" ] pub syspllclkuen : SYSPLLCLKUEN , # [ doc = "0x48 - USB PLL clock source select" ] pub usbpllclksel : USBPLLCLKSEL , # [ doc = "0x4c - USB PLL clock source update enable" ] pub usbpllclkuen : USBPLLCLKUEN , _reserved3 : [ u8 ; 32usize ] , # [ doc = "0x70 - Main clock source select" ] pub mainclksel : MAINCLKSEL , # [ doc = "0x74 - Main clock source update enable" ] pub mainclkuen : MAINCLKUEN , # [ doc = "0x78 - System clock divider" ] pub sysahbclkdiv : SYSAHBCLKDIV , _reserved4 : [ u8 ; 4usize ] , # [ doc = "0x80 - System clock control" ] pub sysahbclkctrl : SYSAHBCLKCTRL , _reserved5 : [ u8 ; 16usize ] , # [ doc = "0x94 - SSP0 clock divider" ] pub ssp0clkdiv : SSP0CLKDIV , # [ doc = "0x98 - UART clock divider" ] pub uartclkdiv : UARTCLKDIV , # [ doc = "0x9c - SSP1 clock divider" ] pub ssp1clkdiv : SSP1CLKDIV , _reserved6 : [ u8 ; 32usize ] , # [ doc = "0xc0 - USB clock source select" ] pub usbclksel : USBCLKSEL , # [ doc = "0xc4 - USB clock source update enable" ] pub usbclkuen : USBCLKUEN , # [ doc = "0xc8 - USB clock source divider" ] pub usbclkdiv : USBCLKDIV , _reserved7 : [ u8 ; 20usize ] , # [ doc = "0xe0 - CLKOUT clock source select" ] pub clkoutsel : CLKOUTSEL , # [ doc = "0xe4 - CLKOUT clock source update enable" ] pub clkoutuen : CLKOUTUEN , # [ doc = "0xe8 - CLKOUT clock divider" ] pub clkoutdiv : CLKOUTDIV , _reserved8 : [ u8 ; 20usize ] , # [ doc = "0x100 - POR captured PIO status 0" ] pub pioporcap0 : PIOPORCAP0 , # [ doc = "0x104 - POR captured PIO status 1" ] pub pioporcap1 : PIOPORCAP1 , _reserved9 : [ u8 ; 72usize ] , # [ doc = "0x150 - Brown-Out Detect" ] pub bodctrl : BODCTRL , # [ doc = "0x154 - System tick counter calibration" ] pub systckcal : SYSTCKCAL , _reserved10 : [ u8 ; 24usize ] , # [ doc = "0x170 - IQR delay. Allows trade-off between interrupt latency and determinism." ] pub irqlatency : IRQLATENCY , # [ doc = "0x174 - NMI Source Control" ] pub nmisrc : NMISRC , # [ doc = "0x178 - GPIO Pin Interrupt Select register 0" ] pub pintsel : [ PINTSEL ; 8 ] , # [ doc = "0x198 - USB clock control" ] pub usbclkctrl : USBCLKCTRL , # [ doc = "0x19c - USB clock status" ] pub usbclkst : USBCLKST , _reserved11 : [ u8 ; 100usize ] , # [ doc = "0x204 - Start logic 0 interrupt wake-up enable register 0" ] pub starterp0 : STARTERP0 , _reserved12 : [ u8 ; 12usize ] , # [ doc = "0x214 - Start logic 1 interrupt wake-up enable register 1" ] pub starterp1 : STARTERP1 , _reserved13 : [ u8 ; 24usize ] , # [ doc = "0x230 - Power-down states in deep-sleep mode" ] pub pdsleepcfg : PDSLEEPCFG , # [ doc = "0x234 - Power-down states for wake-up from deep-sleep" ] pub pdawakecfg : PDAWAKECFG , # [ doc = "0x238 - Power configuration register" ] pub pdruncfg : PDRUNCFG , _reserved14 : [ u8 ; 440usize ] , # [ doc = "0x3f4 - Device ID" ] pub device_id : DEVICE_ID , } # [ doc = "System memory remap" ] pub struct SYSMEMREMAP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System memory remap" ] pub mod sysmemremap { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSMEMREMAP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MAP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MAPR { # [ doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM." ] BOOT_LOADER_MODE_IN , # [ doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM." ] USER_RAM_MODE_INTER , # [ doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash." ] USER_FLASH_MODE_INT , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl MAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MAPR :: BOOT_LOADER_MODE_IN => 0 , MAPR :: USER_RAM_MODE_INTER => 0x01 , MAPR :: USER_FLASH_MODE_INT => 0x02 , MAPR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MAPR { match value { 0 => MAPR :: BOOT_LOADER_MODE_IN , 1 => MAPR :: USER_RAM_MODE_INTER , 2 => MAPR :: USER_FLASH_MODE_INT , i => MAPR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `BOOT_LOADER_MODE_IN`" ] # [ inline ] pub fn is_boot_loader_mode_in ( & self ) -> bool { * self == MAPR :: BOOT_LOADER_MODE_IN } # [ doc = "Checks if the value of the field is `USER_RAM_MODE_INTER`" ] # [ inline ] pub fn is_user_ram_mode_inter ( & self ) -> bool { * self == MAPR :: USER_RAM_MODE_INTER } # [ doc = "Checks if the value of the field is `USER_FLASH_MODE_INT`" ] # [ inline ] pub fn is_user_flash_mode_int ( & self ) -> bool { * self == MAPR :: USER_FLASH_MODE_INT } } # [ doc = "Values that can be written to the field `MAP`" ] pub enum MAPW { # [ doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM." ] BOOT_LOADER_MODE_IN , # [ doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM." ] USER_RAM_MODE_INTER , # [ doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash." ] USER_FLASH_MODE_INT } impl MAPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MAPW :: BOOT_LOADER_MODE_IN => 0 , MAPW :: USER_RAM_MODE_INTER => 1 , MAPW :: USER_FLASH_MODE_INT => 2 } } } # [ doc = r" Proxy" ] pub struct _MAPW < 'a > { w : & 'a mut W , } impl < 'a > _MAPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MAPW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM." ] # [ inline ] pub fn boot_loader_mode_in ( self ) -> & 'a mut W { self . variant ( MAPW :: BOOT_LOADER_MODE_IN ) } # [ doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM." ] # [ inline ] pub fn user_ram_mode_inter ( self ) -> & 'a mut W { self . variant ( MAPW :: USER_RAM_MODE_INTER ) } # [ doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash." ] # [ inline ] pub fn user_flash_mode_int ( self ) -> & 'a mut W { self . variant ( MAPW :: USER_FLASH_MODE_INT ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - System memory remap. Value 0x3 is reserved." ] # [ inline ] pub fn map ( & self ) -> MAPR { MAPR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x02 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - System memory remap. Value 0x3 is reserved." ] # [ inline ] pub fn map ( & mut self ) -> _MAPW { _MAPW { w : self } } } } # [ doc = "Peripheral reset control" ] pub struct PRESETCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Peripheral reset control" ] pub mod presetctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PRESETCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SSP0_RST_N`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SSP0_RST_NR { # [ doc = "Resets the SSP0 peripheral." ] RESETS_THE_SSP0_PERI , # [ doc = "SSP0 reset de-asserted." ] SSP0_RESET_DE_ASSERT } impl SSP0_RST_NR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SSP0_RST_NR :: RESETS_THE_SSP0_PERI => false , SSP0_RST_NR :: SSP0_RESET_DE_ASSERT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SSP0_RST_NR { match value { false => SSP0_RST_NR :: RESETS_THE_SSP0_PERI , true => SSP0_RST_NR :: SSP0_RESET_DE_ASSERT , } } # [ doc = "Checks if the value of the field is `RESETS_THE_SSP0_PERI`" ] # [ inline ] pub fn is_resets_the_ssp0_peri ( & self ) -> bool { * self == SSP0_RST_NR :: RESETS_THE_SSP0_PERI } # [ doc = "Checks if the value of the field is `SSP0_RESET_DE_ASSERT`" ] # [ inline ] pub fn is_ssp0_reset_de_assert ( & self ) -> bool { * self == SSP0_RST_NR :: SSP0_RESET_DE_ASSERT } } # [ doc = "Possible values of the field `I2C_RST_N`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum I2C_RST_NR { # [ doc = "Resets the I2C peripheral." ] RESETS_THE_I2C_PERIP , # [ doc = "I2C reset de-asserted." ] I2C_RESET_DE_ASSERTE } impl I2C_RST_NR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { I2C_RST_NR :: RESETS_THE_I2C_PERIP => false , I2C_RST_NR :: I2C_RESET_DE_ASSERTE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> I2C_RST_NR { match value { false => I2C_RST_NR :: RESETS_THE_I2C_PERIP , true => I2C_RST_NR :: I2C_RESET_DE_ASSERTE , } } # [ doc = "Checks if the value of the field is `RESETS_THE_I2C_PERIP`" ] # [ inline ] pub fn is_resets_the_i2c_perip ( & self ) -> bool { * self == I2C_RST_NR :: RESETS_THE_I2C_PERIP } # [ doc = "Checks if the value of the field is `I2C_RESET_DE_ASSERTE`" ] # [ inline ] pub fn is_i2c_reset_de_asserte ( & self ) -> bool { * self == I2C_RST_NR :: I2C_RESET_DE_ASSERTE } } # [ doc = "Possible values of the field `SSP1_RST_N`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SSP1_RST_NR { # [ doc = "Resets the SSP1 peripheral." ] RESETS_THE_SSP1_PERI , # [ doc = "SSP1 reset de-asserted." ] SSP1_RESET_DE_ASSERT } impl SSP1_RST_NR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SSP1_RST_NR :: RESETS_THE_SSP1_PERI => false , SSP1_RST_NR :: SSP1_RESET_DE_ASSERT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SSP1_RST_NR { match value { false => SSP1_RST_NR :: RESETS_THE_SSP1_PERI , true => SSP1_RST_NR :: SSP1_RESET_DE_ASSERT , } } # [ doc = "Checks if the value of the field is `RESETS_THE_SSP1_PERI`" ] # [ inline ] pub fn is_resets_the_ssp1_peri ( & self ) -> bool { * self == SSP1_RST_NR :: RESETS_THE_SSP1_PERI } # [ doc = "Checks if the value of the field is `SSP1_RESET_DE_ASSERT`" ] # [ inline ] pub fn is_ssp1_reset_de_assert ( & self ) -> bool { * self == SSP1_RST_NR :: SSP1_RESET_DE_ASSERT } } # [ doc = "Values that can be written to the field `SSP0_RST_N`" ] pub enum SSP0_RST_NW { # [ doc = "Resets the SSP0 peripheral." ] RESETS_THE_SSP0_PERI , # [ doc = "SSP0 reset de-asserted." ] SSP0_RESET_DE_ASSERT } impl SSP0_RST_NW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SSP0_RST_NW :: RESETS_THE_SSP0_PERI => false , SSP0_RST_NW :: SSP0_RESET_DE_ASSERT => true } } } # [ doc = r" Proxy" ] pub struct _SSP0_RST_NW < 'a > { w : & 'a mut W , } impl < 'a > _SSP0_RST_NW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SSP0_RST_NW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Resets the SSP0 peripheral." ] # [ inline ] pub fn resets_the_ssp0_peri ( self ) -> & 'a mut W { self . variant ( SSP0_RST_NW :: RESETS_THE_SSP0_PERI ) } # [ doc = "SSP0 reset de-asserted." ] # [ inline ] pub fn ssp0_reset_de_assert ( self ) -> & 'a mut W { self . variant ( SSP0_RST_NW :: SSP0_RESET_DE_ASSERT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `I2C_RST_N`" ] pub enum I2C_RST_NW { # [ doc = "Resets the I2C peripheral." ] RESETS_THE_I2C_PERIP , # [ doc = "I2C reset de-asserted." ] I2C_RESET_DE_ASSERTE } impl I2C_RST_NW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { I2C_RST_NW :: RESETS_THE_I2C_PERIP => false , I2C_RST_NW :: I2C_RESET_DE_ASSERTE => true } } } # [ doc = r" Proxy" ] pub struct _I2C_RST_NW < 'a > { w : & 'a mut W , } impl < 'a > _I2C_RST_NW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : I2C_RST_NW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Resets the I2C peripheral." ] # [ inline ] pub fn resets_the_i2c_perip ( self ) -> & 'a mut W { self . variant ( I2C_RST_NW :: RESETS_THE_I2C_PERIP ) } # [ doc = "I2C reset de-asserted." ] # [ inline ] pub fn i2c_reset_de_asserte ( self ) -> & 'a mut W { self . variant ( I2C_RST_NW :: I2C_RESET_DE_ASSERTE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SSP1_RST_N`" ] pub enum SSP1_RST_NW { # [ doc = "Resets the SSP1 peripheral." ] RESETS_THE_SSP1_PERI , # [ doc = "SSP1 reset de-asserted." ] SSP1_RESET_DE_ASSERT } impl SSP1_RST_NW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SSP1_RST_NW :: RESETS_THE_SSP1_PERI => false , SSP1_RST_NW :: SSP1_RESET_DE_ASSERT => true } } } # [ doc = r" Proxy" ] pub struct _SSP1_RST_NW < 'a > { w : & 'a mut W , } impl < 'a > _SSP1_RST_NW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SSP1_RST_NW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Resets the SSP1 peripheral." ] # [ inline ] pub fn resets_the_ssp1_peri ( self ) -> & 'a mut W { self . variant ( SSP1_RST_NW :: RESETS_THE_SSP1_PERI ) } # [ doc = "SSP1 reset de-asserted." ] # [ inline ] pub fn ssp1_reset_de_assert ( self ) -> & 'a mut W { self . variant ( SSP1_RST_NW :: SSP1_RESET_DE_ASSERT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - SSP0 reset control" ] # [ inline ] pub fn ssp0_rst_n ( & self ) -> SSP0_RST_NR { SSP0_RST_NR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - I2C reset control" ] # [ inline ] pub fn i2c_rst_n ( & self ) -> I2C_RST_NR { I2C_RST_NR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - SSP1 reset control" ] # [ inline ] pub fn ssp1_rst_n ( & self ) -> SSP1_RST_NR { SSP1_RST_NR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - SSP0 reset control" ] # [ inline ] pub fn ssp0_rst_n ( & mut self ) -> _SSP0_RST_NW { _SSP0_RST_NW { w : self } } # [ doc = "Bit 1 - I2C reset control" ] # [ inline ] pub fn i2c_rst_n ( & mut self ) -> _I2C_RST_NW { _I2C_RST_NW { w : self } } # [ doc = "Bit 2 - SSP1 reset control" ] # [ inline ] pub fn ssp1_rst_n ( & mut self ) -> _SSP1_RST_NW { _SSP1_RST_NW { w : self } } } } # [ doc = "System PLL control" ] pub struct SYSPLLCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System PLL control" ] pub mod syspllctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSPLLCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MSELR { bits : u8 , } impl MSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Possible values of the field `PSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSELR { # [ doc = "P = 1" ] P_EQ_1 , # [ doc = "P = 2" ] P_EQ_2 , # [ doc = "P = 4" ] P_EQ_4 , # [ doc = "P = 8" ] P_EQ_8 } impl PSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PSELR :: P_EQ_1 => 0 , PSELR :: P_EQ_2 => 0x01 , PSELR :: P_EQ_4 => 0x02 , PSELR :: P_EQ_8 => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PSELR { match value { 0 => PSELR :: P_EQ_1 , 1 => PSELR :: P_EQ_2 , 2 => PSELR :: P_EQ_4 , 3 => PSELR :: P_EQ_8 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `P_EQ_1`" ] # [ inline ] pub fn is_p_eq_1 ( & self ) -> bool { * self == PSELR :: P_EQ_1 } # [ doc = "Checks if the value of the field is `P_EQ_2`" ] # [ inline ] pub fn is_p_eq_2 ( & self ) -> bool { * self == PSELR :: P_EQ_2 } # [ doc = "Checks if the value of the field is `P_EQ_4`" ] # [ inline ] pub fn is_p_eq_4 ( & self ) -> bool { * self == PSELR :: P_EQ_4 } # [ doc = "Checks if the value of the field is `P_EQ_8`" ] # [ inline ] pub fn is_p_eq_8 ( & self ) -> bool { * self == PSELR :: P_EQ_8 } } # [ doc = r" Proxy" ] pub struct _MSELW < 'a > { w : & 'a mut W , } impl < 'a > _MSELW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PSEL`" ] pub enum PSELW { # [ doc = "P = 1" ] P_EQ_1 , # [ doc = "P = 2" ] P_EQ_2 , # [ doc = "P = 4" ] P_EQ_4 , # [ doc = "P = 8" ] P_EQ_8 } impl PSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PSELW :: P_EQ_1 => 0 , PSELW :: P_EQ_2 => 1 , PSELW :: P_EQ_4 => 2 , PSELW :: P_EQ_8 => 3 } } } # [ doc = r" Proxy" ] pub struct _PSELW < 'a > { w : & 'a mut W , } impl < 'a > _PSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PSELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "P = 1" ] # [ inline ] pub fn p_eq_1 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_1 ) } # [ doc = "P = 2" ] # [ inline ] pub fn p_eq_2 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_2 ) } # [ doc = "P = 4" ] # [ inline ] pub fn p_eq_4 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_4 ) } # [ doc = "P = 8" ] # [ inline ] pub fn p_eq_8 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_8 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32" ] # [ inline ] pub fn msel ( & self ) -> MSELR { let bits = { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; MSELR { bits } } # [ doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P." ] # [ inline ] pub fn psel ( & self ) -> PSELR { PSELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32" ] # [ inline ] pub fn msel ( & mut self ) -> _MSELW { _MSELW { w : self } } # [ doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P." ] # [ inline ] pub fn psel ( & mut self ) -> _PSELW { _PSELW { w : self } } } } # [ doc = "System PLL status" ] pub struct SYSPLLSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System PLL status" ] pub mod syspllstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: SYSPLLSTAT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `LOCK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LOCKR { # [ doc = "PLL not locked" ] PLL_NOT_LOCKED , # [ doc = "PLL locked" ] PLL_LOCKED } impl LOCKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LOCKR :: PLL_NOT_LOCKED => false , LOCKR :: PLL_LOCKED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LOCKR { match value { false => LOCKR :: PLL_NOT_LOCKED , true => LOCKR :: PLL_LOCKED , } } # [ doc = "Checks if the value of the field is `PLL_NOT_LOCKED`" ] # [ inline ] pub fn is_pll_not_locked ( & self ) -> bool { * self == LOCKR :: PLL_NOT_LOCKED } # [ doc = "Checks if the value of the field is `PLL_LOCKED`" ] # [ inline ] pub fn is_pll_locked ( & self ) -> bool { * self == LOCKR :: PLL_LOCKED } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - PLL lock status" ] # [ inline ] pub fn lock ( & self ) -> LOCKR { LOCKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "USB PLL control" ] pub struct USBPLLCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB PLL control" ] pub mod usbpllctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: USBPLLCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MSELR { bits : u8 , } impl MSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Possible values of the field `PSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSELR { # [ doc = "P = 1" ] P_EQ_1 , # [ doc = "P = 2" ] P_EQ_2 , # [ doc = "P = 4" ] P_EQ_4 , # [ doc = "P = 8" ] P_EQ_8 } impl PSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PSELR :: P_EQ_1 => 0 , PSELR :: P_EQ_2 => 0x01 , PSELR :: P_EQ_4 => 0x02 , PSELR :: P_EQ_8 => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PSELR { match value { 0 => PSELR :: P_EQ_1 , 1 => PSELR :: P_EQ_2 , 2 => PSELR :: P_EQ_4 , 3 => PSELR :: P_EQ_8 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `P_EQ_1`" ] # [ inline ] pub fn is_p_eq_1 ( & self ) -> bool { * self == PSELR :: P_EQ_1 } # [ doc = "Checks if the value of the field is `P_EQ_2`" ] # [ inline ] pub fn is_p_eq_2 ( & self ) -> bool { * self == PSELR :: P_EQ_2 } # [ doc = "Checks if the value of the field is `P_EQ_4`" ] # [ inline ] pub fn is_p_eq_4 ( & self ) -> bool { * self == PSELR :: P_EQ_4 } # [ doc = "Checks if the value of the field is `P_EQ_8`" ] # [ inline ] pub fn is_p_eq_8 ( & self ) -> bool { * self == PSELR :: P_EQ_8 } } # [ doc = r" Proxy" ] pub struct _MSELW < 'a > { w : & 'a mut W , } impl < 'a > _MSELW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PSEL`" ] pub enum PSELW { # [ doc = "P = 1" ] P_EQ_1 , # [ doc = "P = 2" ] P_EQ_2 , # [ doc = "P = 4" ] P_EQ_4 , # [ doc = "P = 8" ] P_EQ_8 } impl PSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PSELW :: P_EQ_1 => 0 , PSELW :: P_EQ_2 => 1 , PSELW :: P_EQ_4 => 2 , PSELW :: P_EQ_8 => 3 } } } # [ doc = r" Proxy" ] pub struct _PSELW < 'a > { w : & 'a mut W , } impl < 'a > _PSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PSELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "P = 1" ] # [ inline ] pub fn p_eq_1 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_1 ) } # [ doc = "P = 2" ] # [ inline ] pub fn p_eq_2 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_2 ) } # [ doc = "P = 4" ] # [ inline ] pub fn p_eq_4 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_4 ) } # [ doc = "P = 8" ] # [ inline ] pub fn p_eq_8 ( self ) -> & 'a mut W { self . variant ( PSELW :: P_EQ_8 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32" ] # [ inline ] pub fn msel ( & self ) -> MSELR { let bits = { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; MSELR { bits } } # [ doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P." ] # [ inline ] pub fn psel ( & self ) -> PSELR { PSELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32" ] # [ inline ] pub fn msel ( & mut self ) -> _MSELW { _MSELW { w : self } } # [ doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P." ] # [ inline ] pub fn psel ( & mut self ) -> _PSELW { _PSELW { w : self } } } } # [ doc = "USB PLL status" ] pub struct USBPLLSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB PLL status" ] pub mod usbpllstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: USBPLLSTAT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `LOCK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LOCKR { # [ doc = "PLL not locked" ] PLL_NOT_LOCKED , # [ doc = "PLL locked" ] PLL_LOCKED } impl LOCKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LOCKR :: PLL_NOT_LOCKED => false , LOCKR :: PLL_LOCKED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LOCKR { match value { false => LOCKR :: PLL_NOT_LOCKED , true => LOCKR :: PLL_LOCKED , } } # [ doc = "Checks if the value of the field is `PLL_NOT_LOCKED`" ] # [ inline ] pub fn is_pll_not_locked ( & self ) -> bool { * self == LOCKR :: PLL_NOT_LOCKED } # [ doc = "Checks if the value of the field is `PLL_LOCKED`" ] # [ inline ] pub fn is_pll_locked ( & self ) -> bool { * self == LOCKR :: PLL_LOCKED } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - PLL lock status" ] # [ inline ] pub fn lock ( & self ) -> LOCKR { LOCKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "System oscillator control" ] pub struct SYSOSCCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System oscillator control" ] pub mod sysoscctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSOSCCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `BYPASS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BYPASSR { # [ doc = "Oscillator is not bypassed." ] OSCILLATOR_IS_NOT_BY , # [ doc = "Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator." ] BYPASS_ENABLED_PLL_ } impl BYPASSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BYPASSR :: OSCILLATOR_IS_NOT_BY => false , BYPASSR :: BYPASS_ENABLED_PLL_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BYPASSR { match value { false => BYPASSR :: OSCILLATOR_IS_NOT_BY , true => BYPASSR :: BYPASS_ENABLED_PLL_ , } } # [ doc = "Checks if the value of the field is `OSCILLATOR_IS_NOT_BY`" ] # [ inline ] pub fn is_oscillator_is_not_by ( & self ) -> bool { * self == BYPASSR :: OSCILLATOR_IS_NOT_BY } # [ doc = "Checks if the value of the field is `BYPASS_ENABLED_PLL_`" ] # [ inline ] pub fn is_bypass_enabled_pll_ ( & self ) -> bool { * self == BYPASSR :: BYPASS_ENABLED_PLL_ } } # [ doc = "Possible values of the field `FREQRANGE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FREQRANGER { # [ doc = "1 - 20 MHz frequency range." ] _1_20_MHZ_FREQUENCY , # [ doc = "15 - 25 MHz frequency range" ] _15_25_MHZ_FREQUENC } impl FREQRANGER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FREQRANGER :: _1_20_MHZ_FREQUENCY => false , FREQRANGER :: _15_25_MHZ_FREQUENC => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FREQRANGER { match value { false => FREQRANGER :: _1_20_MHZ_FREQUENCY , true => FREQRANGER :: _15_25_MHZ_FREQUENC , } } # [ doc = "Checks if the value of the field is `_1_20_MHZ_FREQUENCY`" ] # [ inline ] pub fn is_1_20_mhz_frequency ( & self ) -> bool { * self == FREQRANGER :: _1_20_MHZ_FREQUENCY } # [ doc = "Checks if the value of the field is `_15_25_MHZ_FREQUENC`" ] # [ inline ] pub fn is_15_25_mhz_frequenc ( & self ) -> bool { * self == FREQRANGER :: _15_25_MHZ_FREQUENC } } # [ doc = "Values that can be written to the field `BYPASS`" ] pub enum BYPASSW { # [ doc = "Oscillator is not bypassed." ] OSCILLATOR_IS_NOT_BY , # [ doc = "Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator." ] BYPASS_ENABLED_PLL_ } impl BYPASSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BYPASSW :: OSCILLATOR_IS_NOT_BY => false , BYPASSW :: BYPASS_ENABLED_PLL_ => true } } } # [ doc = r" Proxy" ] pub struct _BYPASSW < 'a > { w : & 'a mut W , } impl < 'a > _BYPASSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BYPASSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Oscillator is not bypassed." ] # [ inline ] pub fn oscillator_is_not_by ( self ) -> & 'a mut W { self . variant ( BYPASSW :: OSCILLATOR_IS_NOT_BY ) } # [ doc = "Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator." ] # [ inline ] pub fn bypass_enabled_pll_ ( self ) -> & 'a mut W { self . variant ( BYPASSW :: BYPASS_ENABLED_PLL_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FREQRANGE`" ] pub enum FREQRANGEW { # [ doc = "1 - 20 MHz frequency range." ] _1_20_MHZ_FREQUENCY , # [ doc = "15 - 25 MHz frequency range" ] _15_25_MHZ_FREQUENC } impl FREQRANGEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FREQRANGEW :: _1_20_MHZ_FREQUENCY => false , FREQRANGEW :: _15_25_MHZ_FREQUENC => true } } } # [ doc = r" Proxy" ] pub struct _FREQRANGEW < 'a > { w : & 'a mut W , } impl < 'a > _FREQRANGEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FREQRANGEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "1 - 20 MHz frequency range." ] # [ inline ] pub fn _1_20_mhz_frequency ( self ) -> & 'a mut W { self . variant ( FREQRANGEW :: _1_20_MHZ_FREQUENCY ) } # [ doc = "15 - 25 MHz frequency range" ] # [ inline ] pub fn _15_25_mhz_frequenc ( self ) -> & 'a mut W { self . variant ( FREQRANGEW :: _15_25_MHZ_FREQUENC ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Bypass system oscillator" ] # [ inline ] pub fn bypass ( & self ) -> BYPASSR { BYPASSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Determines frequency range for Low-power oscillator." ] # [ inline ] pub fn freqrange ( & self ) -> FREQRANGER { FREQRANGER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Bypass system oscillator" ] # [ inline ] pub fn bypass ( & mut self ) -> _BYPASSW { _BYPASSW { w : self } } # [ doc = "Bit 1 - Determines frequency range for Low-power oscillator." ] # [ inline ] pub fn freqrange ( & mut self ) -> _FREQRANGEW { _FREQRANGEW { w : self } } } } # [ doc = "Watchdog oscillator control" ] pub struct WDTOSCCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog oscillator control" ] pub mod wdtoscctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: WDTOSCCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVSELR { bits : u8 , } impl DIVSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Possible values of the field `FREQSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FREQSELR { # [ doc = "0.6 MHz" ] _0_6_MHZ , # [ doc = "1.05 MHz" ] _1_05_MHZ , # [ doc = "1.4 MHz" ] _1_4_MHZ , # [ doc = "1.75 MHz" ] _1_75_MHZ , # [ doc = "2.1 MHz" ] _2_1_MHZ , # [ doc = "2.4 MHz" ] _2_4_MHZ , # [ doc = "2.7 MHz" ] _2_7_MHZ , # [ doc = "3.0 MHz" ] _3_0_MHZ , # [ doc = "3.25 MHz" ] _3_25_MHZ , # [ doc = "3.5 MHz" ] _3_5_MHZ , # [ doc = "3.75 MHz" ] _3_75_MHZ , # [ doc = "4.0 MHz" ] _4_0_MHZ , # [ doc = "4.2 MHz" ] _4_2_MHZ , # [ doc = "4.4 MHz" ] _4_4_MHZ , # [ doc = "4.6 MHz" ] _4_6_MHZ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl FREQSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { FREQSELR :: _0_6_MHZ => 0x01 , FREQSELR :: _1_05_MHZ => 0x02 , FREQSELR :: _1_4_MHZ => 0x03 , FREQSELR :: _1_75_MHZ => 0x04 , FREQSELR :: _2_1_MHZ => 0x05 , FREQSELR :: _2_4_MHZ => 0x06 , FREQSELR :: _2_7_MHZ => 0x07 , FREQSELR :: _3_0_MHZ => 0x08 , FREQSELR :: _3_25_MHZ => 0x09 , FREQSELR :: _3_5_MHZ => 0x0a , FREQSELR :: _3_75_MHZ => 0x0b , FREQSELR :: _4_0_MHZ => 0x0c , FREQSELR :: _4_2_MHZ => 0x0d , FREQSELR :: _4_4_MHZ => 0x0e , FREQSELR :: _4_6_MHZ => 0x0f , FREQSELR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> FREQSELR { match value { 1 => FREQSELR :: _0_6_MHZ , 2 => FREQSELR :: _1_05_MHZ , 3 => FREQSELR :: _1_4_MHZ , 4 => FREQSELR :: _1_75_MHZ , 5 => FREQSELR :: _2_1_MHZ , 6 => FREQSELR :: _2_4_MHZ , 7 => FREQSELR :: _2_7_MHZ , 8 => FREQSELR :: _3_0_MHZ , 9 => FREQSELR :: _3_25_MHZ , 10 => FREQSELR :: _3_5_MHZ , 11 => FREQSELR :: _3_75_MHZ , 12 => FREQSELR :: _4_0_MHZ , 13 => FREQSELR :: _4_2_MHZ , 14 => FREQSELR :: _4_4_MHZ , 15 => FREQSELR :: _4_6_MHZ , i => FREQSELR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `_0_6_MHZ`" ] # [ inline ] pub fn is_0_6_mhz ( & self ) -> bool { * self == FREQSELR :: _0_6_MHZ } # [ doc = "Checks if the value of the field is `_1_05_MHZ`" ] # [ inline ] pub fn is_1_05_mhz ( & self ) -> bool { * self == FREQSELR :: _1_05_MHZ } # [ doc = "Checks if the value of the field is `_1_4_MHZ`" ] # [ inline ] pub fn is_1_4_mhz ( & self ) -> bool { * self == FREQSELR :: _1_4_MHZ } # [ doc = "Checks if the value of the field is `_1_75_MHZ`" ] # [ inline ] pub fn is_1_75_mhz ( & self ) -> bool { * self == FREQSELR :: _1_75_MHZ } # [ doc = "Checks if the value of the field is `_2_1_MHZ`" ] # [ inline ] pub fn is_2_1_mhz ( & self ) -> bool { * self == FREQSELR :: _2_1_MHZ } # [ doc = "Checks if the value of the field is `_2_4_MHZ`" ] # [ inline ] pub fn is_2_4_mhz ( & self ) -> bool { * self == FREQSELR :: _2_4_MHZ } # [ doc = "Checks if the value of the field is `_2_7_MHZ`" ] # [ inline ] pub fn is_2_7_mhz ( & self ) -> bool { * self == FREQSELR :: _2_7_MHZ } # [ doc = "Checks if the value of the field is `_3_0_MHZ`" ] # [ inline ] pub fn is_3_0_mhz ( & self ) -> bool { * self == FREQSELR :: _3_0_MHZ } # [ doc = "Checks if the value of the field is `_3_25_MHZ`" ] # [ inline ] pub fn is_3_25_mhz ( & self ) -> bool { * self == FREQSELR :: _3_25_MHZ } # [ doc = "Checks if the value of the field is `_3_5_MHZ`" ] # [ inline ] pub fn is_3_5_mhz ( & self ) -> bool { * self == FREQSELR :: _3_5_MHZ } # [ doc = "Checks if the value of the field is `_3_75_MHZ`" ] # [ inline ] pub fn is_3_75_mhz ( & self ) -> bool { * self == FREQSELR :: _3_75_MHZ } # [ doc = "Checks if the value of the field is `_4_0_MHZ`" ] # [ inline ] pub fn is_4_0_mhz ( & self ) -> bool { * self == FREQSELR :: _4_0_MHZ } # [ doc = "Checks if the value of the field is `_4_2_MHZ`" ] # [ inline ] pub fn is_4_2_mhz ( & self ) -> bool { * self == FREQSELR :: _4_2_MHZ } # [ doc = "Checks if the value of the field is `_4_4_MHZ`" ] # [ inline ] pub fn is_4_4_mhz ( & self ) -> bool { * self == FREQSELR :: _4_4_MHZ } # [ doc = "Checks if the value of the field is `_4_6_MHZ`" ] # [ inline ] pub fn is_4_6_mhz ( & self ) -> bool { * self == FREQSELR :: _4_6_MHZ } } # [ doc = r" Proxy" ] pub struct _DIVSELW < 'a > { w : & 'a mut W , } impl < 'a > _DIVSELW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FREQSEL`" ] pub enum FREQSELW { # [ doc = "0.6 MHz" ] _0_6_MHZ , # [ doc = "1.05 MHz" ] _1_05_MHZ , # [ doc = "1.4 MHz" ] _1_4_MHZ , # [ doc = "1.75 MHz" ] _1_75_MHZ , # [ doc = "2.1 MHz" ] _2_1_MHZ , # [ doc = "2.4 MHz" ] _2_4_MHZ , # [ doc = "2.7 MHz" ] _2_7_MHZ , # [ doc = "3.0 MHz" ] _3_0_MHZ , # [ doc = "3.25 MHz" ] _3_25_MHZ , # [ doc = "3.5 MHz" ] _3_5_MHZ , # [ doc = "3.75 MHz" ] _3_75_MHZ , # [ doc = "4.0 MHz" ] _4_0_MHZ , # [ doc = "4.2 MHz" ] _4_2_MHZ , # [ doc = "4.4 MHz" ] _4_4_MHZ , # [ doc = "4.6 MHz" ] _4_6_MHZ } impl FREQSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { FREQSELW :: _0_6_MHZ => 1 , FREQSELW :: _1_05_MHZ => 2 , FREQSELW :: _1_4_MHZ => 3 , FREQSELW :: _1_75_MHZ => 4 , FREQSELW :: _2_1_MHZ => 5 , FREQSELW :: _2_4_MHZ => 6 , FREQSELW :: _2_7_MHZ => 7 , FREQSELW :: _3_0_MHZ => 8 , FREQSELW :: _3_25_MHZ => 9 , FREQSELW :: _3_5_MHZ => 10 , FREQSELW :: _3_75_MHZ => 11 , FREQSELW :: _4_0_MHZ => 12 , FREQSELW :: _4_2_MHZ => 13 , FREQSELW :: _4_4_MHZ => 14 , FREQSELW :: _4_6_MHZ => 15 } } } # [ doc = r" Proxy" ] pub struct _FREQSELW < 'a > { w : & 'a mut W , } impl < 'a > _FREQSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FREQSELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "0.6 MHz" ] # [ inline ] pub fn _0_6_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _0_6_MHZ ) } # [ doc = "1.05 MHz" ] # [ inline ] pub fn _1_05_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _1_05_MHZ ) } # [ doc = "1.4 MHz" ] # [ inline ] pub fn _1_4_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _1_4_MHZ ) } # [ doc = "1.75 MHz" ] # [ inline ] pub fn _1_75_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _1_75_MHZ ) } # [ doc = "2.1 MHz" ] # [ inline ] pub fn _2_1_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _2_1_MHZ ) } # [ doc = "2.4 MHz" ] # [ inline ] pub fn _2_4_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _2_4_MHZ ) } # [ doc = "2.7 MHz" ] # [ inline ] pub fn _2_7_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _2_7_MHZ ) } # [ doc = "3.0 MHz" ] # [ inline ] pub fn _3_0_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _3_0_MHZ ) } # [ doc = "3.25 MHz" ] # [ inline ] pub fn _3_25_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _3_25_MHZ ) } # [ doc = "3.5 MHz" ] # [ inline ] pub fn _3_5_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _3_5_MHZ ) } # [ doc = "3.75 MHz" ] # [ inline ] pub fn _3_75_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _3_75_MHZ ) } # [ doc = "4.0 MHz" ] # [ inline ] pub fn _4_0_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _4_0_MHZ ) } # [ doc = "4.2 MHz" ] # [ inline ] pub fn _4_2_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _4_2_MHZ ) } # [ doc = "4.4 MHz" ] # [ inline ] pub fn _4_4_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _4_4_MHZ ) } # [ doc = "4.6 MHz" ] # [ inline ] pub fn _4_6_mhz ( self ) -> & 'a mut W { self . variant ( FREQSELW :: _4_6_MHZ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64" ] # [ inline ] pub fn divsel ( & self ) -> DIVSELR { let bits = { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVSELR { bits } } # [ doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)." ] # [ inline ] pub fn freqsel ( & self ) -> FREQSELR { FREQSELR :: _from ( { const MASK : u8 = 0x0f ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64" ] # [ inline ] pub fn divsel ( & mut self ) -> _DIVSELW { _DIVSELW { w : self } } # [ doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)." ] # [ inline ] pub fn freqsel ( & mut self ) -> _FREQSELW { _FREQSELW { w : self } } } } # [ doc = "System reset status register" ] pub struct SYSRSTSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System reset status register" ] pub mod sysrststat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSRSTSTAT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `POR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PORR { # [ doc = "No POR detected" ] NO_POR_DETECTED , # [ doc = "POR detected. Writing a one clears this reset." ] POR_DETECTED_WRITIN } impl PORR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PORR :: NO_POR_DETECTED => false , PORR :: POR_DETECTED_WRITIN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PORR { match value { false => PORR :: NO_POR_DETECTED , true => PORR :: POR_DETECTED_WRITIN , } } # [ doc = "Checks if the value of the field is `NO_POR_DETECTED`" ] # [ inline ] pub fn is_no_por_detected ( & self ) -> bool { * self == PORR :: NO_POR_DETECTED } # [ doc = "Checks if the value of the field is `POR_DETECTED_WRITIN`" ] # [ inline ] pub fn is_por_detected_writin ( & self ) -> bool { * self == PORR :: POR_DETECTED_WRITIN } } # [ doc = "Possible values of the field `EXTRST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EXTRSTR { # [ doc = "No reset event detected." ] NO_RESET_EVENT_DETEC , # [ doc = "Reset detected. Writing a one clears this reset." ] RESET_DETECTED_WRIT } impl EXTRSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { EXTRSTR :: NO_RESET_EVENT_DETEC => false , EXTRSTR :: RESET_DETECTED_WRIT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> EXTRSTR { match value { false => EXTRSTR :: NO_RESET_EVENT_DETEC , true => EXTRSTR :: RESET_DETECTED_WRIT , } } # [ doc = "Checks if the value of the field is `NO_RESET_EVENT_DETEC`" ] # [ inline ] pub fn is_no_reset_event_detec ( & self ) -> bool { * self == EXTRSTR :: NO_RESET_EVENT_DETEC } # [ doc = "Checks if the value of the field is `RESET_DETECTED_WRIT`" ] # [ inline ] pub fn is_reset_detected_writ ( & self ) -> bool { * self == EXTRSTR :: RESET_DETECTED_WRIT } } # [ doc = "Possible values of the field `WDT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTR { # [ doc = "No WDT reset detected" ] NO_WDT_RESET_DETECTE , # [ doc = "WDT reset detected. Writing a one clears this reset." ] WDT_RESET_DETECTED_ } impl WDTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WDTR :: NO_WDT_RESET_DETECTE => false , WDTR :: WDT_RESET_DETECTED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WDTR { match value { false => WDTR :: NO_WDT_RESET_DETECTE , true => WDTR :: WDT_RESET_DETECTED_ , } } # [ doc = "Checks if the value of the field is `NO_WDT_RESET_DETECTE`" ] # [ inline ] pub fn is_no_wdt_reset_detecte ( & self ) -> bool { * self == WDTR :: NO_WDT_RESET_DETECTE } # [ doc = "Checks if the value of the field is `WDT_RESET_DETECTED_`" ] # [ inline ] pub fn is_wdt_reset_detected_ ( & self ) -> bool { * self == WDTR :: WDT_RESET_DETECTED_ } } # [ doc = "Possible values of the field `BOD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BODR { # [ doc = "No BOD reset detected" ] NO_BOD_RESET_DETECTE , # [ doc = "BOD reset detected. Writing a one clears this reset." ] BOD_RESET_DETECTED_ } impl BODR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BODR :: NO_BOD_RESET_DETECTE => false , BODR :: BOD_RESET_DETECTED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BODR { match value { false => BODR :: NO_BOD_RESET_DETECTE , true => BODR :: BOD_RESET_DETECTED_ , } } # [ doc = "Checks if the value of the field is `NO_BOD_RESET_DETECTE`" ] # [ inline ] pub fn is_no_bod_reset_detecte ( & self ) -> bool { * self == BODR :: NO_BOD_RESET_DETECTE } # [ doc = "Checks if the value of the field is `BOD_RESET_DETECTED_`" ] # [ inline ] pub fn is_bod_reset_detected_ ( & self ) -> bool { * self == BODR :: BOD_RESET_DETECTED_ } } # [ doc = "Possible values of the field `SYSRST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSRSTR { # [ doc = "No System reset detected" ] NO_SYSTEM_RESET_DETE , # [ doc = "System reset detected. Writing a one clears this reset." ] SYSTEM_RESET_DETECTE } impl SYSRSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SYSRSTR :: NO_SYSTEM_RESET_DETE => false , SYSRSTR :: SYSTEM_RESET_DETECTE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SYSRSTR { match value { false => SYSRSTR :: NO_SYSTEM_RESET_DETE , true => SYSRSTR :: SYSTEM_RESET_DETECTE , } } # [ doc = "Checks if the value of the field is `NO_SYSTEM_RESET_DETE`" ] # [ inline ] pub fn is_no_system_reset_dete ( & self ) -> bool { * self == SYSRSTR :: NO_SYSTEM_RESET_DETE } # [ doc = "Checks if the value of the field is `SYSTEM_RESET_DETECTE`" ] # [ inline ] pub fn is_system_reset_detecte ( & self ) -> bool { * self == SYSRSTR :: SYSTEM_RESET_DETECTE } } # [ doc = "Values that can be written to the field `POR`" ] pub enum PORW { # [ doc = "No POR detected" ] NO_POR_DETECTED , # [ doc = "POR detected. Writing a one clears this reset." ] POR_DETECTED_WRITIN } impl PORW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PORW :: NO_POR_DETECTED => false , PORW :: POR_DETECTED_WRITIN => true } } } # [ doc = r" Proxy" ] pub struct _PORW < 'a > { w : & 'a mut W , } impl < 'a > _PORW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PORW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No POR detected" ] # [ inline ] pub fn no_por_detected ( self ) -> & 'a mut W { self . variant ( PORW :: NO_POR_DETECTED ) } # [ doc = "POR detected. Writing a one clears this reset." ] # [ inline ] pub fn por_detected_writin ( self ) -> & 'a mut W { self . variant ( PORW :: POR_DETECTED_WRITIN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EXTRST`" ] pub enum EXTRSTW { # [ doc = "No reset event detected." ] NO_RESET_EVENT_DETEC , # [ doc = "Reset detected. Writing a one clears this reset." ] RESET_DETECTED_WRIT } impl EXTRSTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { EXTRSTW :: NO_RESET_EVENT_DETEC => false , EXTRSTW :: RESET_DETECTED_WRIT => true } } } # [ doc = r" Proxy" ] pub struct _EXTRSTW < 'a > { w : & 'a mut W , } impl < 'a > _EXTRSTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EXTRSTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No reset event detected." ] # [ inline ] pub fn no_reset_event_detec ( self ) -> & 'a mut W { self . variant ( EXTRSTW :: NO_RESET_EVENT_DETEC ) } # [ doc = "Reset detected. Writing a one clears this reset." ] # [ inline ] pub fn reset_detected_writ ( self ) -> & 'a mut W { self . variant ( EXTRSTW :: RESET_DETECTED_WRIT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WDT`" ] pub enum WDTW { # [ doc = "No WDT reset detected" ] NO_WDT_RESET_DETECTE , # [ doc = "WDT reset detected. Writing a one clears this reset." ] WDT_RESET_DETECTED_ } impl WDTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WDTW :: NO_WDT_RESET_DETECTE => false , WDTW :: WDT_RESET_DETECTED_ => true } } } # [ doc = r" Proxy" ] pub struct _WDTW < 'a > { w : & 'a mut W , } impl < 'a > _WDTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WDTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No WDT reset detected" ] # [ inline ] pub fn no_wdt_reset_detecte ( self ) -> & 'a mut W { self . variant ( WDTW :: NO_WDT_RESET_DETECTE ) } # [ doc = "WDT reset detected. Writing a one clears this reset." ] # [ inline ] pub fn wdt_reset_detected_ ( self ) -> & 'a mut W { self . variant ( WDTW :: WDT_RESET_DETECTED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BOD`" ] pub enum BODW { # [ doc = "No BOD reset detected" ] NO_BOD_RESET_DETECTE , # [ doc = "BOD reset detected. Writing a one clears this reset." ] BOD_RESET_DETECTED_ } impl BODW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BODW :: NO_BOD_RESET_DETECTE => false , BODW :: BOD_RESET_DETECTED_ => true } } } # [ doc = r" Proxy" ] pub struct _BODW < 'a > { w : & 'a mut W , } impl < 'a > _BODW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BODW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No BOD reset detected" ] # [ inline ] pub fn no_bod_reset_detecte ( self ) -> & 'a mut W { self . variant ( BODW :: NO_BOD_RESET_DETECTE ) } # [ doc = "BOD reset detected. Writing a one clears this reset." ] # [ inline ] pub fn bod_reset_detected_ ( self ) -> & 'a mut W { self . variant ( BODW :: BOD_RESET_DETECTED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SYSRST`" ] pub enum SYSRSTW { # [ doc = "No System reset detected" ] NO_SYSTEM_RESET_DETE , # [ doc = "System reset detected. Writing a one clears this reset." ] SYSTEM_RESET_DETECTE } impl SYSRSTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYSRSTW :: NO_SYSTEM_RESET_DETE => false , SYSRSTW :: SYSTEM_RESET_DETECTE => true } } } # [ doc = r" Proxy" ] pub struct _SYSRSTW < 'a > { w : & 'a mut W , } impl < 'a > _SYSRSTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYSRSTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No System reset detected" ] # [ inline ] pub fn no_system_reset_dete ( self ) -> & 'a mut W { self . variant ( SYSRSTW :: NO_SYSTEM_RESET_DETE ) } # [ doc = "System reset detected. Writing a one clears this reset." ] # [ inline ] pub fn system_reset_detecte ( self ) -> & 'a mut W { self . variant ( SYSRSTW :: SYSTEM_RESET_DETECTE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - POR reset status" ] # [ inline ] pub fn por ( & self ) -> PORR { PORR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - External reset status" ] # [ inline ] pub fn extrst ( & self ) -> EXTRSTR { EXTRSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Status of the Watchdog reset" ] # [ inline ] pub fn wdt ( & self ) -> WDTR { WDTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Status of the Brown-out detect reset" ] # [ inline ] pub fn bod ( & self ) -> BODR { BODR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Status of the software system reset" ] # [ inline ] pub fn sysrst ( & self ) -> SYSRSTR { SYSRSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x03 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - POR reset status" ] # [ inline ] pub fn por ( & mut self ) -> _PORW { _PORW { w : self } } # [ doc = "Bit 1 - External reset status" ] # [ inline ] pub fn extrst ( & mut self ) -> _EXTRSTW { _EXTRSTW { w : self } } # [ doc = "Bit 2 - Status of the Watchdog reset" ] # [ inline ] pub fn wdt ( & mut self ) -> _WDTW { _WDTW { w : self } } # [ doc = "Bit 3 - Status of the Brown-out detect reset" ] # [ inline ] pub fn bod ( & mut self ) -> _BODW { _BODW { w : self } } # [ doc = "Bit 4 - Status of the software system reset" ] # [ inline ] pub fn sysrst ( & mut self ) -> _SYSRSTW { _SYSRSTW { w : self } } } } # [ doc = "System PLL clock source select" ] pub struct SYSPLLCLKSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System PLL clock source select" ] pub mod syspllclksel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSPLLCLKSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELR { # [ doc = "IRC" ] IRC , # [ doc = "Crystal Oscillator (SYSOSC)" ] CRYSTAL_OSCILLATOR_ } impl SELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELR :: IRC => 0 , SELR :: CRYSTAL_OSCILLATOR_ => 0x01 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELR { match value { 0 => SELR :: IRC , 1 => SELR :: CRYSTAL_OSCILLATOR_ , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `IRC`" ] # [ inline ] pub fn is_irc ( & self ) -> bool { * self == SELR :: IRC } # [ doc = "Checks if the value of the field is `CRYSTAL_OSCILLATOR_`" ] # [ inline ] pub fn is_crystal_oscillator_ ( & self ) -> bool { * self == SELR :: CRYSTAL_OSCILLATOR_ } } # [ doc = "Values that can be written to the field `SEL`" ] pub enum SELW { # [ doc = "IRC" ] IRC , # [ doc = "Crystal Oscillator (SYSOSC)" ] CRYSTAL_OSCILLATOR_ } impl SELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELW :: IRC => 0 , SELW :: CRYSTAL_OSCILLATOR_ => 1 } } } # [ doc = r" Proxy" ] pub struct _SELW < 'a > { w : & 'a mut W , } impl < 'a > _SELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "IRC" ] # [ inline ] pub fn irc ( self ) -> & 'a mut W { self . variant ( SELW :: IRC ) } # [ doc = "Crystal Oscillator (SYSOSC)" ] # [ inline ] pub fn crystal_oscillator_ ( self ) -> & 'a mut W { self . variant ( SELW :: CRYSTAL_OSCILLATOR_ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - System PLL clock source" ] # [ inline ] pub fn sel ( & self ) -> SELR { SELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - System PLL clock source" ] # [ inline ] pub fn sel ( & mut self ) -> _SELW { _SELW { w : self } } } } # [ doc = "System PLL clock source update enable" ] pub struct SYSPLLCLKUEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System PLL clock source update enable" ] pub mod syspllclkuen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSPLLCLKUEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENAR { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENAR :: NO_CHANGE => false , ENAR :: UPDATE_CLOCK_SOURCE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENAR { match value { false => ENAR :: NO_CHANGE , true => ENAR :: UPDATE_CLOCK_SOURCE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE`" ] # [ inline ] pub fn is_no_change ( & self ) -> bool { * self == ENAR :: NO_CHANGE } # [ doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`" ] # [ inline ] pub fn is_update_clock_source ( & self ) -> bool { * self == ENAR :: UPDATE_CLOCK_SOURCE } } # [ doc = "Values that can be written to the field `ENA`" ] pub enum ENAW { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENAW :: NO_CHANGE => false , ENAW :: UPDATE_CLOCK_SOURCE => true } } } # [ doc = r" Proxy" ] pub struct _ENAW < 'a > { w : & 'a mut W , } impl < 'a > _ENAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No change" ] # [ inline ] pub fn no_change ( self ) -> & 'a mut W { self . variant ( ENAW :: NO_CHANGE ) } # [ doc = "Update clock source" ] # [ inline ] pub fn update_clock_source ( self ) -> & 'a mut W { self . variant ( ENAW :: UPDATE_CLOCK_SOURCE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable system PLL clock source update" ] # [ inline ] pub fn ena ( & self ) -> ENAR { ENAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable system PLL clock source update" ] # [ inline ] pub fn ena ( & mut self ) -> _ENAW { _ENAW { w : self } } } } # [ doc = "USB PLL clock source select" ] pub struct USBPLLCLKSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB PLL clock source select" ] pub mod usbpllclksel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: USBPLLCLKSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELR { # [ doc = "IRC. The USB PLL clock source must be switched to system oscillator for correct full-speed USB operation. The IRC is suitable for low-speed USB operation." ] IRC_THE_USB_PLL_CLO , # [ doc = "System oscillator" ] SYSTEM_OSCILLATOR } impl SELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELR :: IRC_THE_USB_PLL_CLO => 0 , SELR :: SYSTEM_OSCILLATOR => 0x01 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELR { match value { 0 => SELR :: IRC_THE_USB_PLL_CLO , 1 => SELR :: SYSTEM_OSCILLATOR , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `IRC_THE_USB_PLL_CLO`" ] # [ inline ] pub fn is_irc_the_usb_pll_clo ( & self ) -> bool { * self == SELR :: IRC_THE_USB_PLL_CLO } # [ doc = "Checks if the value of the field is `SYSTEM_OSCILLATOR`" ] # [ inline ] pub fn is_system_oscillator ( & self ) -> bool { * self == SELR :: SYSTEM_OSCILLATOR } } # [ doc = "Values that can be written to the field `SEL`" ] pub enum SELW { # [ doc = "IRC. The USB PLL clock source must be switched to system oscillator for correct full-speed USB operation. The IRC is suitable for low-speed USB operation." ] IRC_THE_USB_PLL_CLO , # [ doc = "System oscillator" ] SYSTEM_OSCILLATOR } impl SELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELW :: IRC_THE_USB_PLL_CLO => 0 , SELW :: SYSTEM_OSCILLATOR => 1 } } } # [ doc = r" Proxy" ] pub struct _SELW < 'a > { w : & 'a mut W , } impl < 'a > _SELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "IRC. The USB PLL clock source must be switched to system oscillator for correct full-speed USB operation. The IRC is suitable for low-speed USB operation." ] # [ inline ] pub fn irc_the_usb_pll_clo ( self ) -> & 'a mut W { self . variant ( SELW :: IRC_THE_USB_PLL_CLO ) } # [ doc = "System oscillator" ] # [ inline ] pub fn system_oscillator ( self ) -> & 'a mut W { self . variant ( SELW :: SYSTEM_OSCILLATOR ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - USB PLL clock source" ] # [ inline ] pub fn sel ( & self ) -> SELR { SELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - USB PLL clock source" ] # [ inline ] pub fn sel ( & mut self ) -> _SELW { _SELW { w : self } } } } # [ doc = "USB PLL clock source update enable" ] pub struct USBPLLCLKUEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB PLL clock source update enable" ] pub mod usbpllclkuen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: USBPLLCLKUEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENAR { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENAR :: NO_CHANGE => false , ENAR :: UPDATE_CLOCK_SOURCE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENAR { match value { false => ENAR :: NO_CHANGE , true => ENAR :: UPDATE_CLOCK_SOURCE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE`" ] # [ inline ] pub fn is_no_change ( & self ) -> bool { * self == ENAR :: NO_CHANGE } # [ doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`" ] # [ inline ] pub fn is_update_clock_source ( & self ) -> bool { * self == ENAR :: UPDATE_CLOCK_SOURCE } } # [ doc = "Values that can be written to the field `ENA`" ] pub enum ENAW { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENAW :: NO_CHANGE => false , ENAW :: UPDATE_CLOCK_SOURCE => true } } } # [ doc = r" Proxy" ] pub struct _ENAW < 'a > { w : & 'a mut W , } impl < 'a > _ENAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No change" ] # [ inline ] pub fn no_change ( self ) -> & 'a mut W { self . variant ( ENAW :: NO_CHANGE ) } # [ doc = "Update clock source" ] # [ inline ] pub fn update_clock_source ( self ) -> & 'a mut W { self . variant ( ENAW :: UPDATE_CLOCK_SOURCE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable USB PLL clock source update" ] # [ inline ] pub fn ena ( & self ) -> ENAR { ENAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable USB PLL clock source update" ] # [ inline ] pub fn ena ( & mut self ) -> _ENAW { _ENAW { w : self } } } } # [ doc = "Main clock source select" ] pub struct MAINCLKSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Main clock source select" ] pub mod mainclksel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MAINCLKSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELR { # [ doc = "IRC Oscillator" ] IRC_OSCILLATOR , # [ doc = "PLL input" ] PLL_INPUT , # [ doc = "Watchdog oscillator" ] WATCHDOG_OSCILLATOR , # [ doc = "PLL output" ] PLL_OUTPUT } impl SELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELR :: IRC_OSCILLATOR => 0 , SELR :: PLL_INPUT => 0x01 , SELR :: WATCHDOG_OSCILLATOR => 0x02 , SELR :: PLL_OUTPUT => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELR { match value { 0 => SELR :: IRC_OSCILLATOR , 1 => SELR :: PLL_INPUT , 2 => SELR :: WATCHDOG_OSCILLATOR , 3 => SELR :: PLL_OUTPUT , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `IRC_OSCILLATOR`" ] # [ inline ] pub fn is_irc_oscillator ( & self ) -> bool { * self == SELR :: IRC_OSCILLATOR } # [ doc = "Checks if the value of the field is `PLL_INPUT`" ] # [ inline ] pub fn is_pll_input ( & self ) -> bool { * self == SELR :: PLL_INPUT } # [ doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR`" ] # [ inline ] pub fn is_watchdog_oscillator ( & self ) -> bool { * self == SELR :: WATCHDOG_OSCILLATOR } # [ doc = "Checks if the value of the field is `PLL_OUTPUT`" ] # [ inline ] pub fn is_pll_output ( & self ) -> bool { * self == SELR :: PLL_OUTPUT } } # [ doc = "Values that can be written to the field `SEL`" ] pub enum SELW { # [ doc = "IRC Oscillator" ] IRC_OSCILLATOR , # [ doc = "PLL input" ] PLL_INPUT , # [ doc = "Watchdog oscillator" ] WATCHDOG_OSCILLATOR , # [ doc = "PLL output" ] PLL_OUTPUT } impl SELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELW :: IRC_OSCILLATOR => 0 , SELW :: PLL_INPUT => 1 , SELW :: WATCHDOG_OSCILLATOR => 2 , SELW :: PLL_OUTPUT => 3 } } } # [ doc = r" Proxy" ] pub struct _SELW < 'a > { w : & 'a mut W , } impl < 'a > _SELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "IRC Oscillator" ] # [ inline ] pub fn irc_oscillator ( self ) -> & 'a mut W { self . variant ( SELW :: IRC_OSCILLATOR ) } # [ doc = "PLL input" ] # [ inline ] pub fn pll_input ( self ) -> & 'a mut W { self . variant ( SELW :: PLL_INPUT ) } # [ doc = "Watchdog oscillator" ] # [ inline ] pub fn watchdog_oscillator ( self ) -> & 'a mut W { self . variant ( SELW :: WATCHDOG_OSCILLATOR ) } # [ doc = "PLL output" ] # [ inline ] pub fn pll_output ( self ) -> & 'a mut W { self . variant ( SELW :: PLL_OUTPUT ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Clock source for main clock" ] # [ inline ] pub fn sel ( & self ) -> SELR { SELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Clock source for main clock" ] # [ inline ] pub fn sel ( & mut self ) -> _SELW { _SELW { w : self } } } } # [ doc = "Main clock source update enable" ] pub struct MAINCLKUEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Main clock source update enable" ] pub mod mainclkuen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MAINCLKUEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENAR { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENAR :: NO_CHANGE => false , ENAR :: UPDATE_CLOCK_SOURCE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENAR { match value { false => ENAR :: NO_CHANGE , true => ENAR :: UPDATE_CLOCK_SOURCE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE`" ] # [ inline ] pub fn is_no_change ( & self ) -> bool { * self == ENAR :: NO_CHANGE } # [ doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`" ] # [ inline ] pub fn is_update_clock_source ( & self ) -> bool { * self == ENAR :: UPDATE_CLOCK_SOURCE } } # [ doc = "Values that can be written to the field `ENA`" ] pub enum ENAW { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENAW :: NO_CHANGE => false , ENAW :: UPDATE_CLOCK_SOURCE => true } } } # [ doc = r" Proxy" ] pub struct _ENAW < 'a > { w : & 'a mut W , } impl < 'a > _ENAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No change" ] # [ inline ] pub fn no_change ( self ) -> & 'a mut W { self . variant ( ENAW :: NO_CHANGE ) } # [ doc = "Update clock source" ] # [ inline ] pub fn update_clock_source ( self ) -> & 'a mut W { self . variant ( ENAW :: UPDATE_CLOCK_SOURCE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable main clock source update" ] # [ inline ] pub fn ena ( & self ) -> ENAR { ENAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable main clock source update" ] # [ inline ] pub fn ena ( & mut self ) -> _ENAW { _ENAW { w : self } } } } # [ doc = "System clock divider" ] pub struct SYSAHBCLKDIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System clock divider" ] pub mod sysahbclkdiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSAHBCLKDIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVR { bits : u8 , } impl DIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DIVW < 'a > { w : & 'a mut W , } impl < 'a > _DIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & self ) -> DIVR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & mut self ) -> _DIVW { _DIVW { w : self } } } } # [ doc = "System clock control" ] pub struct SYSAHBCLKCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System clock control" ] pub mod sysahbclkctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSAHBCLKCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SYS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSR { # [ doc = "Enable" ] ENABLE } impl SYSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SYSR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SYSR { match value { true => SYSR :: ENABLE , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == SYSR :: ENABLE } } # [ doc = "Possible values of the field `ROM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ROMR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl ROMR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ROMR :: DISABLE => false , ROMR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ROMR { match value { false => ROMR :: DISABLE , true => ROMR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == ROMR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == ROMR :: ENABLE } } # [ doc = "Possible values of the field `RAM0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RAM0R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl RAM0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RAM0R :: DISABLE => false , RAM0R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RAM0R { match value { false => RAM0R :: DISABLE , true => RAM0R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == RAM0R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == RAM0R :: ENABLE } } # [ doc = "Possible values of the field `FLASHREG`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLASHREGR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl FLASHREGR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FLASHREGR :: DISABLE => false , FLASHREGR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FLASHREGR { match value { false => FLASHREGR :: DISABLE , true => FLASHREGR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == FLASHREGR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == FLASHREGR :: ENABLE } } # [ doc = "Possible values of the field `FLASHARRAY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLASHARRAYR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl FLASHARRAYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FLASHARRAYR :: DISABLE => false , FLASHARRAYR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FLASHARRAYR { match value { false => FLASHARRAYR :: DISABLE , true => FLASHARRAYR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == FLASHARRAYR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == FLASHARRAYR :: ENABLE } } # [ doc = "Possible values of the field `I2C`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum I2CR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl I2CR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { I2CR :: DISABLE => false , I2CR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> I2CR { match value { false => I2CR :: DISABLE , true => I2CR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == I2CR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == I2CR :: ENABLE } } # [ doc = "Possible values of the field `GPIO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GPIOR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl GPIOR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { GPIOR :: DISABLE => false , GPIOR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> GPIOR { match value { false => GPIOR :: DISABLE , true => GPIOR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == GPIOR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == GPIOR :: ENABLE } } # [ doc = "Possible values of the field `CT16B0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CT16B0R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT16B0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CT16B0R :: DISABLE => false , CT16B0R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CT16B0R { match value { false => CT16B0R :: DISABLE , true => CT16B0R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == CT16B0R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == CT16B0R :: ENABLE } } # [ doc = "Possible values of the field `CT16B1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CT16B1R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT16B1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CT16B1R :: DISABLE => false , CT16B1R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CT16B1R { match value { false => CT16B1R :: DISABLE , true => CT16B1R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == CT16B1R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == CT16B1R :: ENABLE } } # [ doc = "Possible values of the field `CT32B0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CT32B0R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT32B0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CT32B0R :: DISABLE => false , CT32B0R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CT32B0R { match value { false => CT32B0R :: DISABLE , true => CT32B0R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == CT32B0R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == CT32B0R :: ENABLE } } # [ doc = "Possible values of the field `CT32B1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CT32B1R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT32B1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CT32B1R :: DISABLE => false , CT32B1R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CT32B1R { match value { false => CT32B1R :: DISABLE , true => CT32B1R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == CT32B1R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == CT32B1R :: ENABLE } } # [ doc = "Possible values of the field `SSP0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SSP0R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl SSP0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SSP0R :: DISABLE => false , SSP0R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SSP0R { match value { false => SSP0R :: DISABLE , true => SSP0R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == SSP0R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == SSP0R :: ENABLE } } # [ doc = "Possible values of the field `USART`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USARTR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl USARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USARTR :: DISABLE => false , USARTR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USARTR { match value { false => USARTR :: DISABLE , true => USARTR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == USARTR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == USARTR :: ENABLE } } # [ doc = "Possible values of the field `ADC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl ADCR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADCR :: DISABLE => false , ADCR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADCR { match value { false => ADCR :: DISABLE , true => ADCR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == ADCR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == ADCR :: ENABLE } } # [ doc = "Possible values of the field `USB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USBR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl USBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USBR :: DISABLE => false , USBR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USBR { match value { false => USBR :: DISABLE , true => USBR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == USBR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == USBR :: ENABLE } } # [ doc = "Possible values of the field `WWDT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WWDTR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl WWDTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WWDTR :: DISABLE => false , WWDTR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WWDTR { match value { false => WWDTR :: DISABLE , true => WWDTR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == WWDTR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == WWDTR :: ENABLE } } # [ doc = "Possible values of the field `IOCON`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IOCONR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl IOCONR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IOCONR :: DISABLE => false , IOCONR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IOCONR { match value { false => IOCONR :: DISABLE , true => IOCONR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == IOCONR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == IOCONR :: ENABLE } } # [ doc = "Possible values of the field `SSP1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SSP1R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl SSP1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SSP1R :: DISABLE => false , SSP1R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SSP1R { match value { false => SSP1R :: DISABLE , true => SSP1R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == SSP1R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == SSP1R :: ENABLE } } # [ doc = "Possible values of the field `PINT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINTR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl PINTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINTR :: DISABLE => false , PINTR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINTR { match value { false => PINTR :: DISABLE , true => PINTR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == PINTR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == PINTR :: ENABLE } } # [ doc = "Possible values of the field `GROUP0INT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GROUP0INTR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl GROUP0INTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { GROUP0INTR :: DISABLE => false , GROUP0INTR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> GROUP0INTR { match value { false => GROUP0INTR :: DISABLE , true => GROUP0INTR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == GROUP0INTR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == GROUP0INTR :: ENABLE } } # [ doc = "Possible values of the field `GROUP1INT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GROUP1INTR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl GROUP1INTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { GROUP1INTR :: DISABLE => false , GROUP1INTR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> GROUP1INTR { match value { false => GROUP1INTR :: DISABLE , true => GROUP1INTR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == GROUP1INTR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == GROUP1INTR :: ENABLE } } # [ doc = "Possible values of the field `RAM1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RAM1R { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl RAM1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RAM1R :: DISABLE => false , RAM1R :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RAM1R { match value { false => RAM1R :: DISABLE , true => RAM1R :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == RAM1R :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == RAM1R :: ENABLE } } # [ doc = "Possible values of the field `USBRAM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USBRAMR { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl USBRAMR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USBRAMR :: DISABLE => false , USBRAMR :: ENABLE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USBRAMR { match value { false => USBRAMR :: DISABLE , true => USBRAMR :: ENABLE , } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ] pub fn is_disable ( & self ) -> bool { * self == USBRAMR :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ] pub fn is_enable ( & self ) -> bool { * self == USBRAMR :: ENABLE } } # [ doc = "Values that can be written to the field `SYS`" ] pub enum SYSW { # [ doc = "Enable" ] ENABLE } impl SYSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYSW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _SYSW < 'a > { w : & 'a mut W , } impl < 'a > _SYSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( SYSW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ROM`" ] pub enum ROMW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl ROMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ROMW :: DISABLE => false , ROMW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _ROMW < 'a > { w : & 'a mut W , } impl < 'a > _ROMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ROMW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( ROMW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( ROMW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RAM0`" ] pub enum RAM0W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl RAM0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RAM0W :: DISABLE => false , RAM0W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _RAM0W < 'a > { w : & 'a mut W , } impl < 'a > _RAM0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RAM0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( RAM0W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( RAM0W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FLASHREG`" ] pub enum FLASHREGW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl FLASHREGW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FLASHREGW :: DISABLE => false , FLASHREGW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _FLASHREGW < 'a > { w : & 'a mut W , } impl < 'a > _FLASHREGW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FLASHREGW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( FLASHREGW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( FLASHREGW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FLASHARRAY`" ] pub enum FLASHARRAYW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl FLASHARRAYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FLASHARRAYW :: DISABLE => false , FLASHARRAYW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _FLASHARRAYW < 'a > { w : & 'a mut W , } impl < 'a > _FLASHARRAYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FLASHARRAYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( FLASHARRAYW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( FLASHARRAYW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `I2C`" ] pub enum I2CW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl I2CW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { I2CW :: DISABLE => false , I2CW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _I2CW < 'a > { w : & 'a mut W , } impl < 'a > _I2CW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : I2CW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( I2CW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( I2CW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `GPIO`" ] pub enum GPIOW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl GPIOW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { GPIOW :: DISABLE => false , GPIOW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _GPIOW < 'a > { w : & 'a mut W , } impl < 'a > _GPIOW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : GPIOW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( GPIOW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( GPIOW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CT16B0`" ] pub enum CT16B0W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT16B0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CT16B0W :: DISABLE => false , CT16B0W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _CT16B0W < 'a > { w : & 'a mut W , } impl < 'a > _CT16B0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CT16B0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( CT16B0W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( CT16B0W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CT16B1`" ] pub enum CT16B1W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT16B1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CT16B1W :: DISABLE => false , CT16B1W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _CT16B1W < 'a > { w : & 'a mut W , } impl < 'a > _CT16B1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CT16B1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( CT16B1W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( CT16B1W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CT32B0`" ] pub enum CT32B0W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT32B0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CT32B0W :: DISABLE => false , CT32B0W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _CT32B0W < 'a > { w : & 'a mut W , } impl < 'a > _CT32B0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CT32B0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( CT32B0W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( CT32B0W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CT32B1`" ] pub enum CT32B1W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl CT32B1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CT32B1W :: DISABLE => false , CT32B1W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _CT32B1W < 'a > { w : & 'a mut W , } impl < 'a > _CT32B1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CT32B1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( CT32B1W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( CT32B1W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SSP0`" ] pub enum SSP0W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl SSP0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SSP0W :: DISABLE => false , SSP0W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _SSP0W < 'a > { w : & 'a mut W , } impl < 'a > _SSP0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SSP0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SSP0W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( SSP0W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USART`" ] pub enum USARTW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl USARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USARTW :: DISABLE => false , USARTW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _USARTW < 'a > { w : & 'a mut W , } impl < 'a > _USARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( USARTW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( USARTW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADC`" ] pub enum ADCW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl ADCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADCW :: DISABLE => false , ADCW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _ADCW < 'a > { w : & 'a mut W , } impl < 'a > _ADCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADCW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( ADCW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( ADCW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USB`" ] pub enum USBW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl USBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USBW :: DISABLE => false , USBW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _USBW < 'a > { w : & 'a mut W , } impl < 'a > _USBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( USBW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( USBW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WWDT`" ] pub enum WWDTW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl WWDTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WWDTW :: DISABLE => false , WWDTW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _WWDTW < 'a > { w : & 'a mut W , } impl < 'a > _WWDTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WWDTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( WWDTW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( WWDTW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IOCON`" ] pub enum IOCONW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl IOCONW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IOCONW :: DISABLE => false , IOCONW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _IOCONW < 'a > { w : & 'a mut W , } impl < 'a > _IOCONW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IOCONW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( IOCONW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( IOCONW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SSP1`" ] pub enum SSP1W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl SSP1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SSP1W :: DISABLE => false , SSP1W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _SSP1W < 'a > { w : & 'a mut W , } impl < 'a > _SSP1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SSP1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SSP1W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( SSP1W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT`" ] pub enum PINTW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl PINTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINTW :: DISABLE => false , PINTW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _PINTW < 'a > { w : & 'a mut W , } impl < 'a > _PINTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( PINTW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( PINTW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `GROUP0INT`" ] pub enum GROUP0INTW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl GROUP0INTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { GROUP0INTW :: DISABLE => false , GROUP0INTW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _GROUP0INTW < 'a > { w : & 'a mut W , } impl < 'a > _GROUP0INTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : GROUP0INTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( GROUP0INTW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( GROUP0INTW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `GROUP1INT`" ] pub enum GROUP1INTW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl GROUP1INTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { GROUP1INTW :: DISABLE => false , GROUP1INTW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _GROUP1INTW < 'a > { w : & 'a mut W , } impl < 'a > _GROUP1INTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : GROUP1INTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( GROUP1INTW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( GROUP1INTW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RAM1`" ] pub enum RAM1W { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl RAM1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RAM1W :: DISABLE => false , RAM1W :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _RAM1W < 'a > { w : & 'a mut W , } impl < 'a > _RAM1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RAM1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( RAM1W :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( RAM1W :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USBRAM`" ] pub enum USBRAMW { # [ doc = "Disable" ] DISABLE , # [ doc = "Enable" ] ENABLE } impl USBRAMW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USBRAMW :: DISABLE => false , USBRAMW :: ENABLE => true } } } # [ doc = r" Proxy" ] pub struct _USBRAMW < 'a > { w : & 'a mut W , } impl < 'a > _USBRAMW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USBRAMW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable" ] # [ inline ] pub fn disable ( self ) -> & 'a mut W { self . variant ( USBRAMW :: DISABLE ) } # [ doc = "Enable" ] # [ inline ] pub fn enable ( self ) -> & 'a mut W { self . variant ( USBRAMW :: ENABLE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enables the clock for the AHB, the APB bridge, the Cortex-M0 FCLK and HCLK, SysCon, and the PMU. This bit is read only and always reads as 1." ] # [ inline ] pub fn sys ( & self ) -> SYSR { SYSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enables clock for ROM." ] # [ inline ] pub fn rom ( & self ) -> ROMR { ROMR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enables clock for RAM." ] # [ inline ] pub fn ram0 ( & self ) -> RAM0R { RAM0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enables clock for flash register interface." ] # [ inline ] pub fn flashreg ( & self ) -> FLASHREGR { FLASHREGR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enables clock for flash array access." ] # [ inline ] pub fn flasharray ( & self ) -> FLASHARRAYR { FLASHARRAYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Enables clock for I2C." ] # [ inline ] pub fn i2c ( & self ) -> I2CR { I2CR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Enables clock for GPIO port registers." ] # [ inline ] pub fn gpio ( & self ) -> GPIOR { GPIOR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enables clock for 16-bit counter/timer 0." ] # [ inline ] pub fn ct16b0 ( & self ) -> CT16B0R { CT16B0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Enables clock for 16-bit counter/timer 1." ] # [ inline ] pub fn ct16b1 ( & self ) -> CT16B1R { CT16B1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Enables clock for 32-bit counter/timer 0." ] # [ inline ] pub fn ct32b0 ( & self ) -> CT32B0R { CT32B0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Enables clock for 32-bit counter/timer 1." ] # [ inline ] pub fn ct32b1 ( & self ) -> CT32B1R { CT32B1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Enables clock for SSP0." ] # [ inline ] pub fn ssp0 ( & self ) -> SSP0R { SSP0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Enables clock for UART." ] # [ inline ] pub fn usart ( & self ) -> USARTR { USARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Enables clock for ADC." ] # [ inline ] pub fn adc ( & self ) -> ADCR { ADCR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Enables clock to the USB register interface." ] # [ inline ] pub fn usb ( & self ) -> USBR { USBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Enables clock for WWDT." ] # [ inline ] pub fn wwdt ( & self ) -> WWDTR { WWDTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Enables clock for I/O configuration block." ] # [ inline ] pub fn iocon ( & self ) -> IOCONR { IOCONR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Enables clock for SSP1." ] # [ inline ] pub fn ssp1 ( & self ) -> SSP1R { SSP1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Enables clock to GPIO Pin interrupts register interface." ] # [ inline ] pub fn pint ( & self ) -> PINTR { PINTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Enables clock to GPIO GROUP0 interrupt register interface." ] # [ inline ] pub fn group0int ( & self ) -> GROUP0INTR { GROUP0INTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Enables clock to GPIO GROUP1 interrupt register interface." ] # [ inline ] pub fn group1int ( & self ) -> GROUP1INTR { GROUP1INTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Enables SRAM1 block at address 0x2000 0000. See Section 3.1 for availability of this bit." ] # [ inline ] pub fn ram1 ( & self ) -> RAM1R { RAM1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Enables USB SRAM block at address 0x2000 4000." ] # [ inline ] pub fn usbram ( & self ) -> USBRAMR { USBRAMR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x3f } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enables the clock for the AHB, the APB bridge, the Cortex-M0 FCLK and HCLK, SysCon, and the PMU. This bit is read only and always reads as 1." ] # [ inline ] pub fn sys ( & mut self ) -> _SYSW { _SYSW { w : self } } # [ doc = "Bit 1 - Enables clock for ROM." ] # [ inline ] pub fn rom ( & mut self ) -> _ROMW { _ROMW { w : self } } # [ doc = "Bit 2 - Enables clock for RAM." ] # [ inline ] pub fn ram0 ( & mut self ) -> _RAM0W { _RAM0W { w : self } } # [ doc = "Bit 3 - Enables clock for flash register interface." ] # [ inline ] pub fn flashreg ( & mut self ) -> _FLASHREGW { _FLASHREGW { w : self } } # [ doc = "Bit 4 - Enables clock for flash array access." ] # [ inline ] pub fn flasharray ( & mut self ) -> _FLASHARRAYW { _FLASHARRAYW { w : self } } # [ doc = "Bit 5 - Enables clock for I2C." ] # [ inline ] pub fn i2c ( & mut self ) -> _I2CW { _I2CW { w : self } } # [ doc = "Bit 6 - Enables clock for GPIO port registers." ] # [ inline ] pub fn gpio ( & mut self ) -> _GPIOW { _GPIOW { w : self } } # [ doc = "Bit 7 - Enables clock for 16-bit counter/timer 0." ] # [ inline ] pub fn ct16b0 ( & mut self ) -> _CT16B0W { _CT16B0W { w : self } } # [ doc = "Bit 8 - Enables clock for 16-bit counter/timer 1." ] # [ inline ] pub fn ct16b1 ( & mut self ) -> _CT16B1W { _CT16B1W { w : self } } # [ doc = "Bit 9 - Enables clock for 32-bit counter/timer 0." ] # [ inline ] pub fn ct32b0 ( & mut self ) -> _CT32B0W { _CT32B0W { w : self } } # [ doc = "Bit 10 - Enables clock for 32-bit counter/timer 1." ] # [ inline ] pub fn ct32b1 ( & mut self ) -> _CT32B1W { _CT32B1W { w : self } } # [ doc = "Bit 11 - Enables clock for SSP0." ] # [ inline ] pub fn ssp0 ( & mut self ) -> _SSP0W { _SSP0W { w : self } } # [ doc = "Bit 12 - Enables clock for UART." ] # [ inline ] pub fn usart ( & mut self ) -> _USARTW { _USARTW { w : self } } # [ doc = "Bit 13 - Enables clock for ADC." ] # [ inline ] pub fn adc ( & mut self ) -> _ADCW { _ADCW { w : self } } # [ doc = "Bit 14 - Enables clock to the USB register interface." ] # [ inline ] pub fn usb ( & mut self ) -> _USBW { _USBW { w : self } } # [ doc = "Bit 15 - Enables clock for WWDT." ] # [ inline ] pub fn wwdt ( & mut self ) -> _WWDTW { _WWDTW { w : self } } # [ doc = "Bit 16 - Enables clock for I/O configuration block." ] # [ inline ] pub fn iocon ( & mut self ) -> _IOCONW { _IOCONW { w : self } } # [ doc = "Bit 18 - Enables clock for SSP1." ] # [ inline ] pub fn ssp1 ( & mut self ) -> _SSP1W { _SSP1W { w : self } } # [ doc = "Bit 19 - Enables clock to GPIO Pin interrupts register interface." ] # [ inline ] pub fn pint ( & mut self ) -> _PINTW { _PINTW { w : self } } # [ doc = "Bit 23 - Enables clock to GPIO GROUP0 interrupt register interface." ] # [ inline ] pub fn group0int ( & mut self ) -> _GROUP0INTW { _GROUP0INTW { w : self } } # [ doc = "Bit 24 - Enables clock to GPIO GROUP1 interrupt register interface." ] # [ inline ] pub fn group1int ( & mut self ) -> _GROUP1INTW { _GROUP1INTW { w : self } } # [ doc = "Bit 26 - Enables SRAM1 block at address 0x2000 0000. See Section 3.1 for availability of this bit." ] # [ inline ] pub fn ram1 ( & mut self ) -> _RAM1W { _RAM1W { w : self } } # [ doc = "Bit 27 - Enables USB SRAM block at address 0x2000 4000." ] # [ inline ] pub fn usbram ( & mut self ) -> _USBRAMW { _USBRAMW { w : self } } } } # [ doc = "SSP0 clock divider" ] pub struct SSP0CLKDIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "SSP0 clock divider" ] pub mod ssp0clkdiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SSP0CLKDIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVR { bits : u8 , } impl DIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DIVW < 'a > { w : & 'a mut W , } impl < 'a > _DIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - SPI0_PCLK clock divider values. 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & self ) -> DIVR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - SPI0_PCLK clock divider values. 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & mut self ) -> _DIVW { _DIVW { w : self } } } } # [ doc = "UART clock divider" ] pub struct UARTCLKDIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "UART clock divider" ] pub mod uartclkdiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: UARTCLKDIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVR { bits : u8 , } impl DIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DIVW < 'a > { w : & 'a mut W , } impl < 'a > _DIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - UART_PCLK clock divider values 0: Disable UART_PCLK. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & self ) -> DIVR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - UART_PCLK clock divider values 0: Disable UART_PCLK. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & mut self ) -> _DIVW { _DIVW { w : self } } } } # [ doc = "SSP1 clock divider" ] pub struct SSP1CLKDIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "SSP1 clock divider" ] pub mod ssp1clkdiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SSP1CLKDIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVR { bits : u8 , } impl DIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DIVW < 'a > { w : & 'a mut W , } impl < 'a > _DIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - SSP1_PCLK clock divider values 0: Disable SSP1_PCLK. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & self ) -> DIVR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - SSP1_PCLK clock divider values 0: Disable SSP1_PCLK. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & mut self ) -> _DIVW { _DIVW { w : self } } } } # [ doc = "USB clock source select" ] pub struct USBCLKSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB clock source select" ] pub mod usbclksel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: USBCLKSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELR { # [ doc = "USB PLL out" ] USB_PLL_OUT , # [ doc = "Main clock" ] MAIN_CLOCK , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELR :: USB_PLL_OUT => 0 , SELR :: MAIN_CLOCK => 0x01 , SELR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELR { match value { 0 => SELR :: USB_PLL_OUT , 1 => SELR :: MAIN_CLOCK , i => SELR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `USB_PLL_OUT`" ] # [ inline ] pub fn is_usb_pll_out ( & self ) -> bool { * self == SELR :: USB_PLL_OUT } # [ doc = "Checks if the value of the field is `MAIN_CLOCK`" ] # [ inline ] pub fn is_main_clock ( & self ) -> bool { * self == SELR :: MAIN_CLOCK } } # [ doc = "Values that can be written to the field `SEL`" ] pub enum SELW { # [ doc = "USB PLL out" ] USB_PLL_OUT , # [ doc = "Main clock" ] MAIN_CLOCK } impl SELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELW :: USB_PLL_OUT => 0 , SELW :: MAIN_CLOCK => 1 } } } # [ doc = r" Proxy" ] pub struct _SELW < 'a > { w : & 'a mut W , } impl < 'a > _SELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USB PLL out" ] # [ inline ] pub fn usb_pll_out ( self ) -> & 'a mut W { self . variant ( SELW :: USB_PLL_OUT ) } # [ doc = "Main clock" ] # [ inline ] pub fn main_clock ( self ) -> & 'a mut W { self . variant ( SELW :: MAIN_CLOCK ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - USB clock source. Values 0x2 and 0x3 are reserved." ] # [ inline ] pub fn sel ( & self ) -> SELR { SELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - USB clock source. Values 0x2 and 0x3 are reserved." ] # [ inline ] pub fn sel ( & mut self ) -> _SELW { _SELW { w : self } } } } # [ doc = "USB clock source update enable" ] pub struct USBCLKUEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB clock source update enable" ] pub mod usbclkuen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: USBCLKUEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENAR { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENAR :: NO_CHANGE => false , ENAR :: UPDATE_CLOCK_SOURCE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENAR { match value { false => ENAR :: NO_CHANGE , true => ENAR :: UPDATE_CLOCK_SOURCE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE`" ] # [ inline ] pub fn is_no_change ( & self ) -> bool { * self == ENAR :: NO_CHANGE } # [ doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`" ] # [ inline ] pub fn is_update_clock_source ( & self ) -> bool { * self == ENAR :: UPDATE_CLOCK_SOURCE } } # [ doc = "Values that can be written to the field `ENA`" ] pub enum ENAW { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENAW :: NO_CHANGE => false , ENAW :: UPDATE_CLOCK_SOURCE => true } } } # [ doc = r" Proxy" ] pub struct _ENAW < 'a > { w : & 'a mut W , } impl < 'a > _ENAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No change" ] # [ inline ] pub fn no_change ( self ) -> & 'a mut W { self . variant ( ENAW :: NO_CHANGE ) } # [ doc = "Update clock source" ] # [ inline ] pub fn update_clock_source ( self ) -> & 'a mut W { self . variant ( ENAW :: UPDATE_CLOCK_SOURCE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable USB clock source update" ] # [ inline ] pub fn ena ( & self ) -> ENAR { ENAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable USB clock source update" ] # [ inline ] pub fn ena ( & mut self ) -> _ENAW { _ENAW { w : self } } } } # [ doc = "USB clock source divider" ] pub struct USBCLKDIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB clock source divider" ] pub mod usbclkdiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: USBCLKDIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVR { bits : u8 , } impl DIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DIVW < 'a > { w : & 'a mut W , } impl < 'a > _DIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - USB clock divider values 0: Disable USB clock. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & self ) -> DIVR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - USB clock divider values 0: Disable USB clock. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & mut self ) -> _DIVW { _DIVW { w : self } } } } # [ doc = "CLKOUT clock source select" ] pub struct CLKOUTSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CLKOUT clock source select" ] pub mod clkoutsel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CLKOUTSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SELR { # [ doc = "IRC oscillator" ] IRC_OSCILLATOR , # [ doc = "Crystal oscillator (SYSOSC)" ] CRYSTAL_OSCILLATOR_ , # [ doc = "LF oscillator (watchdog oscillator)" ] LF_OSCILLATOR_WATCH , # [ doc = "Main clock" ] MAIN_CLOCK } impl SELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SELR :: IRC_OSCILLATOR => 0 , SELR :: CRYSTAL_OSCILLATOR_ => 0x01 , SELR :: LF_OSCILLATOR_WATCH => 0x02 , SELR :: MAIN_CLOCK => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SELR { match value { 0 => SELR :: IRC_OSCILLATOR , 1 => SELR :: CRYSTAL_OSCILLATOR_ , 2 => SELR :: LF_OSCILLATOR_WATCH , 3 => SELR :: MAIN_CLOCK , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `IRC_OSCILLATOR`" ] # [ inline ] pub fn is_irc_oscillator ( & self ) -> bool { * self == SELR :: IRC_OSCILLATOR } # [ doc = "Checks if the value of the field is `CRYSTAL_OSCILLATOR_`" ] # [ inline ] pub fn is_crystal_oscillator_ ( & self ) -> bool { * self == SELR :: CRYSTAL_OSCILLATOR_ } # [ doc = "Checks if the value of the field is `LF_OSCILLATOR_WATCH`" ] # [ inline ] pub fn is_lf_oscillator_watch ( & self ) -> bool { * self == SELR :: LF_OSCILLATOR_WATCH } # [ doc = "Checks if the value of the field is `MAIN_CLOCK`" ] # [ inline ] pub fn is_main_clock ( & self ) -> bool { * self == SELR :: MAIN_CLOCK } } # [ doc = "Values that can be written to the field `SEL`" ] pub enum SELW { # [ doc = "IRC oscillator" ] IRC_OSCILLATOR , # [ doc = "Crystal oscillator (SYSOSC)" ] CRYSTAL_OSCILLATOR_ , # [ doc = "LF oscillator (watchdog oscillator)" ] LF_OSCILLATOR_WATCH , # [ doc = "Main clock" ] MAIN_CLOCK } impl SELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SELW :: IRC_OSCILLATOR => 0 , SELW :: CRYSTAL_OSCILLATOR_ => 1 , SELW :: LF_OSCILLATOR_WATCH => 2 , SELW :: MAIN_CLOCK => 3 } } } # [ doc = r" Proxy" ] pub struct _SELW < 'a > { w : & 'a mut W , } impl < 'a > _SELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "IRC oscillator" ] # [ inline ] pub fn irc_oscillator ( self ) -> & 'a mut W { self . variant ( SELW :: IRC_OSCILLATOR ) } # [ doc = "Crystal oscillator (SYSOSC)" ] # [ inline ] pub fn crystal_oscillator_ ( self ) -> & 'a mut W { self . variant ( SELW :: CRYSTAL_OSCILLATOR_ ) } # [ doc = "LF oscillator (watchdog oscillator)" ] # [ inline ] pub fn lf_oscillator_watch ( self ) -> & 'a mut W { self . variant ( SELW :: LF_OSCILLATOR_WATCH ) } # [ doc = "Main clock" ] # [ inline ] pub fn main_clock ( self ) -> & 'a mut W { self . variant ( SELW :: MAIN_CLOCK ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - CLKOUT clock source" ] # [ inline ] pub fn sel ( & self ) -> SELR { SELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - CLKOUT clock source" ] # [ inline ] pub fn sel ( & mut self ) -> _SELW { _SELW { w : self } } } } # [ doc = "CLKOUT clock source update enable" ] pub struct CLKOUTUEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CLKOUT clock source update enable" ] pub mod clkoutuen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CLKOUTUEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENAR { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENAR :: NO_CHANGE => false , ENAR :: UPDATE_CLOCK_SOURCE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENAR { match value { false => ENAR :: NO_CHANGE , true => ENAR :: UPDATE_CLOCK_SOURCE , } } # [ doc = "Checks if the value of the field is `NO_CHANGE`" ] # [ inline ] pub fn is_no_change ( & self ) -> bool { * self == ENAR :: NO_CHANGE } # [ doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`" ] # [ inline ] pub fn is_update_clock_source ( & self ) -> bool { * self == ENAR :: UPDATE_CLOCK_SOURCE } } # [ doc = "Values that can be written to the field `ENA`" ] pub enum ENAW { # [ doc = "No change" ] NO_CHANGE , # [ doc = "Update clock source" ] UPDATE_CLOCK_SOURCE } impl ENAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENAW :: NO_CHANGE => false , ENAW :: UPDATE_CLOCK_SOURCE => true } } } # [ doc = r" Proxy" ] pub struct _ENAW < 'a > { w : & 'a mut W , } impl < 'a > _ENAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No change" ] # [ inline ] pub fn no_change ( self ) -> & 'a mut W { self . variant ( ENAW :: NO_CHANGE ) } # [ doc = "Update clock source" ] # [ inline ] pub fn update_clock_source ( self ) -> & 'a mut W { self . variant ( ENAW :: UPDATE_CLOCK_SOURCE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable CLKOUT clock source update" ] # [ inline ] pub fn ena ( & self ) -> ENAR { ENAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable CLKOUT clock source update" ] # [ inline ] pub fn ena ( & mut self ) -> _ENAW { _ENAW { w : self } } } } # [ doc = "CLKOUT clock divider" ] pub struct CLKOUTDIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CLKOUT clock divider" ] pub mod clkoutdiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CLKOUTDIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIVR { bits : u8 , } impl DIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DIVW < 'a > { w : & 'a mut W , } impl < 'a > _DIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - CLKOUT clock divider values 0: Disable CLKOUT clock divider. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & self ) -> DIVR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - CLKOUT clock divider values 0: Disable CLKOUT clock divider. 1: Divide by 1. to 255: Divide by 255." ] # [ inline ] pub fn div ( & mut self ) -> _DIVW { _DIVW { w : self } } } } # [ doc = "POR captured PIO status 0" ] pub struct PIOPORCAP0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "POR captured PIO status 0" ] pub mod pioporcap0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: PIOPORCAP0 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct PIOSTATR { bits : u32 , } impl PIOSTATR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - State of PIO0_23 through PIO0_0 at power-on reset" ] # [ inline ] pub fn piostat ( & self ) -> PIOSTATR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PIOSTATR { bits } } } } # [ doc = "POR captured PIO status 1" ] pub struct PIOPORCAP1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "POR captured PIO status 1" ] pub mod pioporcap1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: PIOPORCAP1 { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct PIOSTATR { bits : u32 , } impl PIOSTATR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - State of PIO1_31 through PIO1_0 at power-on reset" ] # [ inline ] pub fn piostat ( & self ) -> PIOSTATR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PIOSTATR { bits } } } } # [ doc = "Brown-Out Detect" ] pub struct BODCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Brown-Out Detect" ] pub mod bodctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: BODCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `BODRSTLEV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BODRSTLEVR { # [ doc = "Level 0: The reset assertion threshold voltage is 1.46 V; the reset de-assertion threshold voltage is 1.63 V." ] LEVEL_0_THE_RESET_A , # [ doc = "Level 1: The reset assertion threshold voltage is 2.06 V; the reset de-assertion threshold voltage is 2.15 V." ] LEVEL_1_THE_RESET_A , # [ doc = "Level 2: The reset assertion threshold voltage is 2.35 V; the reset de-assertion threshold voltage is 2.43 V." ] LEVEL_2_THE_RESET_A , # [ doc = "Level 3: The reset assertion threshold voltage is 2.63 V; the reset de-assertion threshold voltage is 2.71 V." ] LEVEL_3_THE_RESET_A } impl BODRSTLEVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { BODRSTLEVR :: LEVEL_0_THE_RESET_A => 0 , BODRSTLEVR :: LEVEL_1_THE_RESET_A => 0x01 , BODRSTLEVR :: LEVEL_2_THE_RESET_A => 0x02 , BODRSTLEVR :: LEVEL_3_THE_RESET_A => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> BODRSTLEVR { match value { 0 => BODRSTLEVR :: LEVEL_0_THE_RESET_A , 1 => BODRSTLEVR :: LEVEL_1_THE_RESET_A , 2 => BODRSTLEVR :: LEVEL_2_THE_RESET_A , 3 => BODRSTLEVR :: LEVEL_3_THE_RESET_A , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `LEVEL_0_THE_RESET_A`" ] # [ inline ] pub fn is_level_0_the_reset_a ( & self ) -> bool { * self == BODRSTLEVR :: LEVEL_0_THE_RESET_A } # [ doc = "Checks if the value of the field is `LEVEL_1_THE_RESET_A`" ] # [ inline ] pub fn is_level_1_the_reset_a ( & self ) -> bool { * self == BODRSTLEVR :: LEVEL_1_THE_RESET_A } # [ doc = "Checks if the value of the field is `LEVEL_2_THE_RESET_A`" ] # [ inline ] pub fn is_level_2_the_reset_a ( & self ) -> bool { * self == BODRSTLEVR :: LEVEL_2_THE_RESET_A } # [ doc = "Checks if the value of the field is `LEVEL_3_THE_RESET_A`" ] # [ inline ] pub fn is_level_3_the_reset_a ( & self ) -> bool { * self == BODRSTLEVR :: LEVEL_3_THE_RESET_A } } # [ doc = "Possible values of the field `BODINTVAL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BODINTVALR { # [ doc = "Level 0: Reserved." ] LEVEL_0_RESERVED_ , # [ doc = "Level 1:The interrupt assertion threshold voltage is 2.22 V; the interrupt de-assertion threshold voltage is 2.35 V." ] LEVEL_1THE_INTERRUP , # [ doc = "Level 2: The interrupt assertion threshold voltage is 2.52 V; the interrupt de-assertion threshold voltage is 2.66 V." ] LEVEL_2_THE_INTERRU , # [ doc = "Level 3: The interrupt assertion threshold voltage is 2.80 V; the interrupt de-assertion threshold voltage is 2.90 V." ] LEVEL_3_THE_INTERRU } impl BODINTVALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { BODINTVALR :: LEVEL_0_RESERVED_ => 0 , BODINTVALR :: LEVEL_1THE_INTERRUP => 0x01 , BODINTVALR :: LEVEL_2_THE_INTERRU => 0x02 , BODINTVALR :: LEVEL_3_THE_INTERRU => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> BODINTVALR { match value { 0 => BODINTVALR :: LEVEL_0_RESERVED_ , 1 => BODINTVALR :: LEVEL_1THE_INTERRUP , 2 => BODINTVALR :: LEVEL_2_THE_INTERRU , 3 => BODINTVALR :: LEVEL_3_THE_INTERRU , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `LEVEL_0_RESERVED_`" ] # [ inline ] pub fn is_level_0_reserved_ ( & self ) -> bool { * self == BODINTVALR :: LEVEL_0_RESERVED_ } # [ doc = "Checks if the value of the field is `LEVEL_1THE_INTERRUP`" ] # [ inline ] pub fn is_level_1the_interrup ( & self ) -> bool { * self == BODINTVALR :: LEVEL_1THE_INTERRUP } # [ doc = "Checks if the value of the field is `LEVEL_2_THE_INTERRU`" ] # [ inline ] pub fn is_level_2_the_interru ( & self ) -> bool { * self == BODINTVALR :: LEVEL_2_THE_INTERRU } # [ doc = "Checks if the value of the field is `LEVEL_3_THE_INTERRU`" ] # [ inline ] pub fn is_level_3_the_interru ( & self ) -> bool { * self == BODINTVALR :: LEVEL_3_THE_INTERRU } } # [ doc = "Possible values of the field `BODRSTENA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BODRSTENAR { # [ doc = "Disable reset function." ] DISABLE_RESET_FUNCTI , # [ doc = "Enable reset function." ] ENABLE_RESET_FUNCTIO } impl BODRSTENAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BODRSTENAR :: DISABLE_RESET_FUNCTI => false , BODRSTENAR :: ENABLE_RESET_FUNCTIO => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BODRSTENAR { match value { false => BODRSTENAR :: DISABLE_RESET_FUNCTI , true => BODRSTENAR :: ENABLE_RESET_FUNCTIO , } } # [ doc = "Checks if the value of the field is `DISABLE_RESET_FUNCTI`" ] # [ inline ] pub fn is_disable_reset_functi ( & self ) -> bool { * self == BODRSTENAR :: DISABLE_RESET_FUNCTI } # [ doc = "Checks if the value of the field is `ENABLE_RESET_FUNCTIO`" ] # [ inline ] pub fn is_enable_reset_functio ( & self ) -> bool { * self == BODRSTENAR :: ENABLE_RESET_FUNCTIO } } # [ doc = "Values that can be written to the field `BODRSTLEV`" ] pub enum BODRSTLEVW { # [ doc = "Level 0: The reset assertion threshold voltage is 1.46 V; the reset de-assertion threshold voltage is 1.63 V." ] LEVEL_0_THE_RESET_A , # [ doc = "Level 1: The reset assertion threshold voltage is 2.06 V; the reset de-assertion threshold voltage is 2.15 V." ] LEVEL_1_THE_RESET_A , # [ doc = "Level 2: The reset assertion threshold voltage is 2.35 V; the reset de-assertion threshold voltage is 2.43 V." ] LEVEL_2_THE_RESET_A , # [ doc = "Level 3: The reset assertion threshold voltage is 2.63 V; the reset de-assertion threshold voltage is 2.71 V." ] LEVEL_3_THE_RESET_A } impl BODRSTLEVW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { BODRSTLEVW :: LEVEL_0_THE_RESET_A => 0 , BODRSTLEVW :: LEVEL_1_THE_RESET_A => 1 , BODRSTLEVW :: LEVEL_2_THE_RESET_A => 2 , BODRSTLEVW :: LEVEL_3_THE_RESET_A => 3 } } } # [ doc = r" Proxy" ] pub struct _BODRSTLEVW < 'a > { w : & 'a mut W , } impl < 'a > _BODRSTLEVW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BODRSTLEVW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Level 0: The reset assertion threshold voltage is 1.46 V; the reset de-assertion threshold voltage is 1.63 V." ] # [ inline ] pub fn level_0_the_reset_a ( self ) -> & 'a mut W { self . variant ( BODRSTLEVW :: LEVEL_0_THE_RESET_A ) } # [ doc = "Level 1: The reset assertion threshold voltage is 2.06 V; the reset de-assertion threshold voltage is 2.15 V." ] # [ inline ] pub fn level_1_the_reset_a ( self ) -> & 'a mut W { self . variant ( BODRSTLEVW :: LEVEL_1_THE_RESET_A ) } # [ doc = "Level 2: The reset assertion threshold voltage is 2.35 V; the reset de-assertion threshold voltage is 2.43 V." ] # [ inline ] pub fn level_2_the_reset_a ( self ) -> & 'a mut W { self . variant ( BODRSTLEVW :: LEVEL_2_THE_RESET_A ) } # [ doc = "Level 3: The reset assertion threshold voltage is 2.63 V; the reset de-assertion threshold voltage is 2.71 V." ] # [ inline ] pub fn level_3_the_reset_a ( self ) -> & 'a mut W { self . variant ( BODRSTLEVW :: LEVEL_3_THE_RESET_A ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BODINTVAL`" ] pub enum BODINTVALW { # [ doc = "Level 0: Reserved." ] LEVEL_0_RESERVED_ , # [ doc = "Level 1:The interrupt assertion threshold voltage is 2.22 V; the interrupt de-assertion threshold voltage is 2.35 V." ] LEVEL_1THE_INTERRUP , # [ doc = "Level 2: The interrupt assertion threshold voltage is 2.52 V; the interrupt de-assertion threshold voltage is 2.66 V." ] LEVEL_2_THE_INTERRU , # [ doc = "Level 3: The interrupt assertion threshold voltage is 2.80 V; the interrupt de-assertion threshold voltage is 2.90 V." ] LEVEL_3_THE_INTERRU } impl BODINTVALW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { BODINTVALW :: LEVEL_0_RESERVED_ => 0 , BODINTVALW :: LEVEL_1THE_INTERRUP => 1 , BODINTVALW :: LEVEL_2_THE_INTERRU => 2 , BODINTVALW :: LEVEL_3_THE_INTERRU => 3 } } } # [ doc = r" Proxy" ] pub struct _BODINTVALW < 'a > { w : & 'a mut W , } impl < 'a > _BODINTVALW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BODINTVALW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Level 0: Reserved." ] # [ inline ] pub fn level_0_reserved_ ( self ) -> & 'a mut W { self . variant ( BODINTVALW :: LEVEL_0_RESERVED_ ) } # [ doc = "Level 1:The interrupt assertion threshold voltage is 2.22 V; the interrupt de-assertion threshold voltage is 2.35 V." ] # [ inline ] pub fn level_1the_interrup ( self ) -> & 'a mut W { self . variant ( BODINTVALW :: LEVEL_1THE_INTERRUP ) } # [ doc = "Level 2: The interrupt assertion threshold voltage is 2.52 V; the interrupt de-assertion threshold voltage is 2.66 V." ] # [ inline ] pub fn level_2_the_interru ( self ) -> & 'a mut W { self . variant ( BODINTVALW :: LEVEL_2_THE_INTERRU ) } # [ doc = "Level 3: The interrupt assertion threshold voltage is 2.80 V; the interrupt de-assertion threshold voltage is 2.90 V." ] # [ inline ] pub fn level_3_the_interru ( self ) -> & 'a mut W { self . variant ( BODINTVALW :: LEVEL_3_THE_INTERRU ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BODRSTENA`" ] pub enum BODRSTENAW { # [ doc = "Disable reset function." ] DISABLE_RESET_FUNCTI , # [ doc = "Enable reset function." ] ENABLE_RESET_FUNCTIO } impl BODRSTENAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BODRSTENAW :: DISABLE_RESET_FUNCTI => false , BODRSTENAW :: ENABLE_RESET_FUNCTIO => true } } } # [ doc = r" Proxy" ] pub struct _BODRSTENAW < 'a > { w : & 'a mut W , } impl < 'a > _BODRSTENAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BODRSTENAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable reset function." ] # [ inline ] pub fn disable_reset_functi ( self ) -> & 'a mut W { self . variant ( BODRSTENAW :: DISABLE_RESET_FUNCTI ) } # [ doc = "Enable reset function." ] # [ inline ] pub fn enable_reset_functio ( self ) -> & 'a mut W { self . variant ( BODRSTENAW :: ENABLE_RESET_FUNCTIO ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - BOD reset level" ] # [ inline ] pub fn bodrstlev ( & self ) -> BODRSTLEVR { BODRSTLEVR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 2:3 - BOD interrupt level" ] # [ inline ] pub fn bodintval ( & self ) -> BODINTVALR { BODINTVALR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 4 - BOD reset enable" ] # [ inline ] pub fn bodrstena ( & self ) -> BODRSTENAR { BODRSTENAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - BOD reset level" ] # [ inline ] pub fn bodrstlev ( & mut self ) -> _BODRSTLEVW { _BODRSTLEVW { w : self } } # [ doc = "Bits 2:3 - BOD interrupt level" ] # [ inline ] pub fn bodintval ( & mut self ) -> _BODINTVALW { _BODINTVALW { w : self } } # [ doc = "Bit 4 - BOD reset enable" ] # [ inline ] pub fn bodrstena ( & mut self ) -> _BODRSTENAW { _BODRSTENAW { w : self } } } } # [ doc = "System tick counter calibration" ] pub struct SYSTCKCAL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System tick counter calibration" ] pub mod systckcal { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSTCKCAL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct CALR { bits : u32 , } impl CALR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _CALW < 'a > { w : & 'a mut W , } impl < 'a > _CALW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x03ff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:25 - System tick timer calibration value" ] # [ inline ] pub fn cal ( & self ) -> CALR { let bits = { const MASK : u32 = 0x03ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; CALR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x04 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:25 - System tick timer calibration value" ] # [ inline ] pub fn cal ( & mut self ) -> _CALW { _CALW { w : self } } } } # [ doc = "IQR delay. Allows trade-off between interrupt latency and determinism." ] pub struct IRQLATENCY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "IQR delay. Allows trade-off between interrupt latency and determinism." ] pub mod irqlatency { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IRQLATENCY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct LATENCYR { bits : u8 , } impl LATENCYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _LATENCYW < 'a > { w : & 'a mut W , } impl < 'a > _LATENCYW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - 8-bit latency value" ] # [ inline ] pub fn latency ( & self ) -> LATENCYR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; LATENCYR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x10 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - 8-bit latency value" ] # [ inline ] pub fn latency ( & mut self ) -> _LATENCYW { _LATENCYW { w : self } } } } # [ doc = "NMI Source Control" ] pub struct NMISRC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "NMI Source Control" ] pub mod nmisrc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: NMISRC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct IRQNOR { bits : u8 , } impl IRQNOR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct NMIENR { bits : bool , } impl NMIENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _IRQNOW < 'a > { w : & 'a mut W , } impl < 'a > _IRQNOW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NMIENW < 'a > { w : & 'a mut W , } impl < 'a > _NMIENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:4 - The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 58 for the list of interrupt sources and their IRQ numbers." ] # [ inline ] pub fn irqno ( & self ) -> IRQNOR { let bits = { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; IRQNOR { bits } } # [ doc = "Bit 31 - Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0." ] # [ inline ] pub fn nmien ( & self ) -> NMIENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; NMIENR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:4 - The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 58 for the list of interrupt sources and their IRQ numbers." ] # [ inline ] pub fn irqno ( & mut self ) -> _IRQNOW { _IRQNOW { w : self } } # [ doc = "Bit 31 - Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0." ] # [ inline ] pub fn nmien ( & mut self ) -> _NMIENW { _NMIENW { w : self } } } } # [ doc = "GPIO Pin Interrupt Select register 0" ] pub struct PINTSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "GPIO Pin Interrupt Select register 0" ] pub mod pintsel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PINTSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct INTPINR { bits : u8 , } impl INTPINR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _INTPINW < 'a > { w : & 'a mut W , } impl < 'a > _INTPINW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x3f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:5 - Pin number select for pin interrupt. (PIO0_0 to PIO0_23 correspond to numbers 0 to 23 and PIO1_0 to PIO1_31 correspond to numbers 24 to 55)." ] # [ inline ] pub fn intpin ( & self ) -> INTPINR { let bits = { const MASK : u8 = 0x3f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; INTPINR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:5 - Pin number select for pin interrupt. (PIO0_0 to PIO0_23 correspond to numbers 0 to 23 and PIO1_0 to PIO1_31 correspond to numbers 24 to 55)." ] # [ inline ] pub fn intpin ( & mut self ) -> _INTPINW { _INTPINW { w : self } } } } # [ doc = "USB clock control" ] pub struct USBCLKCTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB clock control" ] pub mod usbclkctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: USBCLKCTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `AP_CLK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum AP_CLKR { # [ doc = "Under hardware control." ] UNDER_HARDWARE_CONTR , # [ doc = "Forced HIGH." ] FORCED_HIGH_ } impl AP_CLKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { AP_CLKR :: UNDER_HARDWARE_CONTR => false , AP_CLKR :: FORCED_HIGH_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> AP_CLKR { match value { false => AP_CLKR :: UNDER_HARDWARE_CONTR , true => AP_CLKR :: FORCED_HIGH_ , } } # [ doc = "Checks if the value of the field is `UNDER_HARDWARE_CONTR`" ] # [ inline ] pub fn is_under_hardware_contr ( & self ) -> bool { * self == AP_CLKR :: UNDER_HARDWARE_CONTR } # [ doc = "Checks if the value of the field is `FORCED_HIGH_`" ] # [ inline ] pub fn is_forced_high_ ( & self ) -> bool { * self == AP_CLKR :: FORCED_HIGH_ } } # [ doc = "Possible values of the field `POL_CLK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum POL_CLKR { # [ doc = "Falling edge of the USB need_clock triggers the USB wake-up (default)." ] FALLING_EDGE_OF_THE_ , # [ doc = "Rising edge of the USB need_clock triggers the USB wake-up." ] RISING_EDGE_OF_THE_U } impl POL_CLKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { POL_CLKR :: FALLING_EDGE_OF_THE_ => false , POL_CLKR :: RISING_EDGE_OF_THE_U => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> POL_CLKR { match value { false => POL_CLKR :: FALLING_EDGE_OF_THE_ , true => POL_CLKR :: RISING_EDGE_OF_THE_U , } } # [ doc = "Checks if the value of the field is `FALLING_EDGE_OF_THE_`" ] # [ inline ] pub fn is_falling_edge_of_the_ ( & self ) -> bool { * self == POL_CLKR :: FALLING_EDGE_OF_THE_ } # [ doc = "Checks if the value of the field is `RISING_EDGE_OF_THE_U`" ] # [ inline ] pub fn is_rising_edge_of_the_u ( & self ) -> bool { * self == POL_CLKR :: RISING_EDGE_OF_THE_U } } # [ doc = "Values that can be written to the field `AP_CLK`" ] pub enum AP_CLKW { # [ doc = "Under hardware control." ] UNDER_HARDWARE_CONTR , # [ doc = "Forced HIGH." ] FORCED_HIGH_ } impl AP_CLKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { AP_CLKW :: UNDER_HARDWARE_CONTR => false , AP_CLKW :: FORCED_HIGH_ => true } } } # [ doc = r" Proxy" ] pub struct _AP_CLKW < 'a > { w : & 'a mut W , } impl < 'a > _AP_CLKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : AP_CLKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Under hardware control." ] # [ inline ] pub fn under_hardware_contr ( self ) -> & 'a mut W { self . variant ( AP_CLKW :: UNDER_HARDWARE_CONTR ) } # [ doc = "Forced HIGH." ] # [ inline ] pub fn forced_high_ ( self ) -> & 'a mut W { self . variant ( AP_CLKW :: FORCED_HIGH_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `POL_CLK`" ] pub enum POL_CLKW { # [ doc = "Falling edge of the USB need_clock triggers the USB wake-up (default)." ] FALLING_EDGE_OF_THE_ , # [ doc = "Rising edge of the USB need_clock triggers the USB wake-up." ] RISING_EDGE_OF_THE_U } impl POL_CLKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { POL_CLKW :: FALLING_EDGE_OF_THE_ => false , POL_CLKW :: RISING_EDGE_OF_THE_U => true } } } # [ doc = r" Proxy" ] pub struct _POL_CLKW < 'a > { w : & 'a mut W , } impl < 'a > _POL_CLKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : POL_CLKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Falling edge of the USB need_clock triggers the USB wake-up (default)." ] # [ inline ] pub fn falling_edge_of_the_ ( self ) -> & 'a mut W { self . variant ( POL_CLKW :: FALLING_EDGE_OF_THE_ ) } # [ doc = "Rising edge of the USB need_clock triggers the USB wake-up." ] # [ inline ] pub fn rising_edge_of_the_u ( self ) -> & 'a mut W { self . variant ( POL_CLKW :: RISING_EDGE_OF_THE_U ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - USB need_clock signal control" ] # [ inline ] pub fn ap_clk ( & self ) -> AP_CLKR { AP_CLKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - USB need_clock polarity for triggering the USB wake-up interrupt" ] # [ inline ] pub fn pol_clk ( & self ) -> POL_CLKR { POL_CLKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - USB need_clock signal control" ] # [ inline ] pub fn ap_clk ( & mut self ) -> _AP_CLKW { _AP_CLKW { w : self } } # [ doc = "Bit 1 - USB need_clock polarity for triggering the USB wake-up interrupt" ] # [ inline ] pub fn pol_clk ( & mut self ) -> _POL_CLKW { _POL_CLKW { w : self } } } } # [ doc = "USB clock status" ] pub struct USBCLKST { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB clock status" ] pub mod usbclkst { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: USBCLKST { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `NEED_CLKST`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NEED_CLKSTR { # [ doc = "LOW" ] LOW , # [ doc = "HIGH" ] HIGH } impl NEED_CLKSTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { NEED_CLKSTR :: LOW => false , NEED_CLKSTR :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> NEED_CLKSTR { match value { false => NEED_CLKSTR :: LOW , true => NEED_CLKSTR :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == NEED_CLKSTR :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == NEED_CLKSTR :: HIGH } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - USB need_clock signal status" ] # [ inline ] pub fn need_clkst ( & self ) -> NEED_CLKSTR { NEED_CLKSTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "Start logic 0 interrupt wake-up enable register 0" ] pub struct STARTERP0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start logic 0 interrupt wake-up enable register 0" ] pub mod starterp0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: STARTERP0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PINT0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT0R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT0R :: DISABLED => false , PINT0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT0R { match value { false => PINT0R :: DISABLED , true => PINT0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT0R :: ENABLED } } # [ doc = "Possible values of the field `PINT1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT1R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT1R :: DISABLED => false , PINT1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT1R { match value { false => PINT1R :: DISABLED , true => PINT1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT1R :: ENABLED } } # [ doc = "Possible values of the field `PINT2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT2R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT2R :: DISABLED => false , PINT2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT2R { match value { false => PINT2R :: DISABLED , true => PINT2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT2R :: ENABLED } } # [ doc = "Possible values of the field `PINT3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT3R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT3R :: DISABLED => false , PINT3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT3R { match value { false => PINT3R :: DISABLED , true => PINT3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT3R :: ENABLED } } # [ doc = "Possible values of the field `PINT4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT4R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT4R :: DISABLED => false , PINT4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT4R { match value { false => PINT4R :: DISABLED , true => PINT4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT4R :: ENABLED } } # [ doc = "Possible values of the field `PINT5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT5R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT5R :: DISABLED => false , PINT5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT5R { match value { false => PINT5R :: DISABLED , true => PINT5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT5R :: ENABLED } } # [ doc = "Possible values of the field `PINT6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT6R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT6R :: DISABLED => false , PINT6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT6R { match value { false => PINT6R :: DISABLED , true => PINT6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT6R :: ENABLED } } # [ doc = "Possible values of the field `PINT7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PINT7R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PINT7R :: DISABLED => false , PINT7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PINT7R { match value { false => PINT7R :: DISABLED , true => PINT7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PINT7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PINT7R :: ENABLED } } # [ doc = "Values that can be written to the field `PINT0`" ] pub enum PINT0W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT0W :: DISABLED => false , PINT0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT0W < 'a > { w : & 'a mut W , } impl < 'a > _PINT0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT0W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT1`" ] pub enum PINT1W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT1W :: DISABLED => false , PINT1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT1W < 'a > { w : & 'a mut W , } impl < 'a > _PINT1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT1W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT2`" ] pub enum PINT2W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT2W :: DISABLED => false , PINT2W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT2W < 'a > { w : & 'a mut W , } impl < 'a > _PINT2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT2W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT2W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT3`" ] pub enum PINT3W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT3W :: DISABLED => false , PINT3W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT3W < 'a > { w : & 'a mut W , } impl < 'a > _PINT3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT3W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT3W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT4`" ] pub enum PINT4W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT4W :: DISABLED => false , PINT4W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT4W < 'a > { w : & 'a mut W , } impl < 'a > _PINT4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT4W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT4W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT5`" ] pub enum PINT5W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT5W :: DISABLED => false , PINT5W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT5W < 'a > { w : & 'a mut W , } impl < 'a > _PINT5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT5W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT5W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT6`" ] pub enum PINT6W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT6W :: DISABLED => false , PINT6W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT6W < 'a > { w : & 'a mut W , } impl < 'a > _PINT6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT6W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT6W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PINT7`" ] pub enum PINT7W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl PINT7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PINT7W :: DISABLED => false , PINT7W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PINT7W < 'a > { w : & 'a mut W , } impl < 'a > _PINT7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PINT7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PINT7W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PINT7W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin interrupt 0 wake-up" ] # [ inline ] pub fn pint0 ( & self ) -> PINT0R { PINT0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Pin interrupt 1 wake-up" ] # [ inline ] pub fn pint1 ( & self ) -> PINT1R { PINT1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Pin interrupt 2 wake-up" ] # [ inline ] pub fn pint2 ( & self ) -> PINT2R { PINT2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Pin interrupt 3 wake-up" ] # [ inline ] pub fn pint3 ( & self ) -> PINT3R { PINT3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Pin interrupt 4 wake-up" ] # [ inline ] pub fn pint4 ( & self ) -> PINT4R { PINT4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Pin interrupt 5 wake-up" ] # [ inline ] pub fn pint5 ( & self ) -> PINT5R { PINT5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Pin interrupt 6 wake-up" ] # [ inline ] pub fn pint6 ( & self ) -> PINT6R { PINT6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Pin interrupt 7 wake-up" ] # [ inline ] pub fn pint7 ( & self ) -> PINT7R { PINT7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Pin interrupt 0 wake-up" ] # [ inline ] pub fn pint0 ( & mut self ) -> _PINT0W { _PINT0W { w : self } } # [ doc = "Bit 1 - Pin interrupt 1 wake-up" ] # [ inline ] pub fn pint1 ( & mut self ) -> _PINT1W { _PINT1W { w : self } } # [ doc = "Bit 2 - Pin interrupt 2 wake-up" ] # [ inline ] pub fn pint2 ( & mut self ) -> _PINT2W { _PINT2W { w : self } } # [ doc = "Bit 3 - Pin interrupt 3 wake-up" ] # [ inline ] pub fn pint3 ( & mut self ) -> _PINT3W { _PINT3W { w : self } } # [ doc = "Bit 4 - Pin interrupt 4 wake-up" ] # [ inline ] pub fn pint4 ( & mut self ) -> _PINT4W { _PINT4W { w : self } } # [ doc = "Bit 5 - Pin interrupt 5 wake-up" ] # [ inline ] pub fn pint5 ( & mut self ) -> _PINT5W { _PINT5W { w : self } } # [ doc = "Bit 6 - Pin interrupt 6 wake-up" ] # [ inline ] pub fn pint6 ( & mut self ) -> _PINT6W { _PINT6W { w : self } } # [ doc = "Bit 7 - Pin interrupt 7 wake-up" ] # [ inline ] pub fn pint7 ( & mut self ) -> _PINT7W { _PINT7W { w : self } } } } # [ doc = "Start logic 1 interrupt wake-up enable register 1" ] pub struct STARTERP1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start logic 1 interrupt wake-up enable register 1" ] pub mod starterp1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: STARTERP1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `WWDTINT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WWDTINTR { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl WWDTINTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WWDTINTR :: DISABLED => false , WWDTINTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WWDTINTR { match value { false => WWDTINTR :: DISABLED , true => WWDTINTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == WWDTINTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == WWDTINTR :: ENABLED } } # [ doc = "Possible values of the field `BODINT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BODINTR { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl BODINTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BODINTR :: DISABLED => false , BODINTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BODINTR { match value { false => BODINTR :: DISABLED , true => BODINTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == BODINTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == BODINTR :: ENABLED } } # [ doc = "Possible values of the field `USB_WAKEUP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USB_WAKEUPR { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl USB_WAKEUPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USB_WAKEUPR :: DISABLED => false , USB_WAKEUPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USB_WAKEUPR { match value { false => USB_WAKEUPR :: DISABLED , true => USB_WAKEUPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == USB_WAKEUPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == USB_WAKEUPR :: ENABLED } } # [ doc = "Possible values of the field `GPIOINT0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GPIOINT0R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl GPIOINT0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { GPIOINT0R :: DISABLED => false , GPIOINT0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> GPIOINT0R { match value { false => GPIOINT0R :: DISABLED , true => GPIOINT0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == GPIOINT0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == GPIOINT0R :: ENABLED } } # [ doc = "Possible values of the field `GPIOINT1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GPIOINT1R { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl GPIOINT1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { GPIOINT1R :: DISABLED => false , GPIOINT1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> GPIOINT1R { match value { false => GPIOINT1R :: DISABLED , true => GPIOINT1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == GPIOINT1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == GPIOINT1R :: ENABLED } } # [ doc = "Values that can be written to the field `WWDTINT`" ] pub enum WWDTINTW { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl WWDTINTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WWDTINTW :: DISABLED => false , WWDTINTW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _WWDTINTW < 'a > { w : & 'a mut W , } impl < 'a > _WWDTINTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WWDTINTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( WWDTINTW :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( WWDTINTW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BODINT`" ] pub enum BODINTW { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl BODINTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BODINTW :: DISABLED => false , BODINTW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _BODINTW < 'a > { w : & 'a mut W , } impl < 'a > _BODINTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BODINTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( BODINTW :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( BODINTW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USB_WAKEUP`" ] pub enum USB_WAKEUPW { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl USB_WAKEUPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USB_WAKEUPW :: DISABLED => false , USB_WAKEUPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _USB_WAKEUPW < 'a > { w : & 'a mut W , } impl < 'a > _USB_WAKEUPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USB_WAKEUPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( USB_WAKEUPW :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( USB_WAKEUPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `GPIOINT0`" ] pub enum GPIOINT0W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl GPIOINT0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { GPIOINT0W :: DISABLED => false , GPIOINT0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _GPIOINT0W < 'a > { w : & 'a mut W , } impl < 'a > _GPIOINT0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : GPIOINT0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( GPIOINT0W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( GPIOINT0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `GPIOINT1`" ] pub enum GPIOINT1W { # [ doc = "Disabled" ] DISABLED , # [ doc = "Enabled" ] ENABLED } impl GPIOINT1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { GPIOINT1W :: DISABLED => false , GPIOINT1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _GPIOINT1W < 'a > { w : & 'a mut W , } impl < 'a > _GPIOINT1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : GPIOINT1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( GPIOINT1W :: DISABLED ) } # [ doc = "Enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( GPIOINT1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 12 - WWDT interrupt wake-up" ] # [ inline ] pub fn wwdtint ( & self ) -> WWDTINTR { WWDTINTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Brown Out Detect (BOD) interrupt wake-up" ] # [ inline ] pub fn bodint ( & self ) -> BODINTR { BODINTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - USB need_clock signal wake-up" ] # [ inline ] pub fn usb_wakeup ( & self ) -> USB_WAKEUPR { USB_WAKEUPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - GPIO GROUP0 interrupt wake-up" ] # [ inline ] pub fn gpioint0 ( & self ) -> GPIOINT0R { GPIOINT0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - GPIO GROUP1 interrupt wake-up" ] # [ inline ] pub fn gpioint1 ( & self ) -> GPIOINT1R { GPIOINT1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 12 - WWDT interrupt wake-up" ] # [ inline ] pub fn wwdtint ( & mut self ) -> _WWDTINTW { _WWDTINTW { w : self } } # [ doc = "Bit 13 - Brown Out Detect (BOD) interrupt wake-up" ] # [ inline ] pub fn bodint ( & mut self ) -> _BODINTW { _BODINTW { w : self } } # [ doc = "Bit 19 - USB need_clock signal wake-up" ] # [ inline ] pub fn usb_wakeup ( & mut self ) -> _USB_WAKEUPW { _USB_WAKEUPW { w : self } } # [ doc = "Bit 20 - GPIO GROUP0 interrupt wake-up" ] # [ inline ] pub fn gpioint0 ( & mut self ) -> _GPIOINT0W { _GPIOINT0W { w : self } } # [ doc = "Bit 21 - GPIO GROUP1 interrupt wake-up" ] # [ inline ] pub fn gpioint1 ( & mut self ) -> _GPIOINT1W { _GPIOINT1W { w : self } } } } # [ doc = "Power-down states in deep-sleep mode" ] pub struct PDSLEEPCFG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Power-down states in deep-sleep mode" ] pub mod pdsleepcfg { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PDSLEEPCFG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `BOD_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BOD_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl BOD_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BOD_PDR :: POWERED => false , BOD_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BOD_PDR { match value { false => BOD_PDR :: POWERED , true => BOD_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == BOD_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == BOD_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `WDTOSC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTOSC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl WDTOSC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WDTOSC_PDR :: POWERED => false , WDTOSC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WDTOSC_PDR { match value { false => WDTOSC_PDR :: POWERED , true => WDTOSC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == WDTOSC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == WDTOSC_PDR :: POWERED_DOWN } } # [ doc = "Values that can be written to the field `BOD_PD`" ] pub enum BOD_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl BOD_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BOD_PDW :: POWERED => false , BOD_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _BOD_PDW < 'a > { w : & 'a mut W , } impl < 'a > _BOD_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BOD_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( BOD_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( BOD_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WDTOSC_PD`" ] pub enum WDTOSC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl WDTOSC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WDTOSC_PDW :: POWERED => false , WDTOSC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _WDTOSC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _WDTOSC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WDTOSC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( WDTOSC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( WDTOSC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 3 - BOD power-down control for Deep-sleep and Power-down mode" ] # [ inline ] pub fn bod_pd ( & self ) -> BOD_PDR { BOD_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Watchdog oscillator power-down control for Deep-sleep and Power-down mode" ] # [ inline ] pub fn wdtosc_pd ( & self ) -> WDTOSC_PDR { WDTOSC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 3 - BOD power-down control for Deep-sleep and Power-down mode" ] # [ inline ] pub fn bod_pd ( & mut self ) -> _BOD_PDW { _BOD_PDW { w : self } } # [ doc = "Bit 6 - Watchdog oscillator power-down control for Deep-sleep and Power-down mode" ] # [ inline ] pub fn wdtosc_pd ( & mut self ) -> _WDTOSC_PDW { _WDTOSC_PDW { w : self } } } } # [ doc = "Power-down states for wake-up from deep-sleep" ] pub struct PDAWAKECFG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Power-down states for wake-up from deep-sleep" ] pub mod pdawakecfg { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PDAWAKECFG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `IRCOUT_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRCOUT_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRCOUT_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IRCOUT_PDR :: POWERED => false , IRCOUT_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IRCOUT_PDR { match value { false => IRCOUT_PDR :: POWERED , true => IRCOUT_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == IRCOUT_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == IRCOUT_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `IRC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IRC_PDR :: POWERED => false , IRC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IRC_PDR { match value { false => IRC_PDR :: POWERED , true => IRC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == IRC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == IRC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `FLASH_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLASH_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl FLASH_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FLASH_PDR :: POWERED => false , FLASH_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FLASH_PDR { match value { false => FLASH_PDR :: POWERED , true => FLASH_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == FLASH_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == FLASH_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `BOD_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BOD_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl BOD_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BOD_PDR :: POWERED => false , BOD_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BOD_PDR { match value { false => BOD_PDR :: POWERED , true => BOD_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == BOD_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == BOD_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `ADC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl ADC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADC_PDR :: POWERED => false , ADC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADC_PDR { match value { false => ADC_PDR :: POWERED , true => ADC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == ADC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == ADC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `SYSOSC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSOSC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSOSC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SYSOSC_PDR :: POWERED => false , SYSOSC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SYSOSC_PDR { match value { false => SYSOSC_PDR :: POWERED , true => SYSOSC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == SYSOSC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == SYSOSC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `WDTOSC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTOSC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl WDTOSC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WDTOSC_PDR :: POWERED => false , WDTOSC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WDTOSC_PDR { match value { false => WDTOSC_PDR :: POWERED , true => WDTOSC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == WDTOSC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == WDTOSC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `SYSPLL_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSPLL_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSPLL_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SYSPLL_PDR :: POWERED => false , SYSPLL_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SYSPLL_PDR { match value { false => SYSPLL_PDR :: POWERED , true => SYSPLL_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == SYSPLL_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == SYSPLL_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `USBPLL_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USBPLL_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl USBPLL_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USBPLL_PDR :: POWERED => false , USBPLL_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USBPLL_PDR { match value { false => USBPLL_PDR :: POWERED , true => USBPLL_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == USBPLL_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == USBPLL_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `USBPAD_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USBPAD_PDR { # [ doc = "USB transceiver powered" ] USB_TRANSCEIVER_POWERED , # [ doc = "USB transceiver powered down" ] USB_TRANSCEIVER_POWERED_DOWN } impl USBPAD_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USBPAD_PDR :: USB_TRANSCEIVER_POWERED => false , USBPAD_PDR :: USB_TRANSCEIVER_POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USBPAD_PDR { match value { false => USBPAD_PDR :: USB_TRANSCEIVER_POWERED , true => USBPAD_PDR :: USB_TRANSCEIVER_POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `USB_TRANSCEIVER_POWERED`" ] # [ inline ] pub fn is_usb_transceiver_powered ( & self ) -> bool { * self == USBPAD_PDR :: USB_TRANSCEIVER_POWERED } # [ doc = "Checks if the value of the field is `USB_TRANSCEIVER_POWERED_DOWN`" ] # [ inline ] pub fn is_usb_transceiver_powered_down ( & self ) -> bool { * self == USBPAD_PDR :: USB_TRANSCEIVER_POWERED_DOWN } } # [ doc = r" Value of the field" ] pub struct RESERVED_11R { bits : bool , } impl RESERVED_11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RESERVED_12R { bits : bool , } impl RESERVED_12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RESERVED_13_15R { bits : u8 , } impl RESERVED_13_15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct RESERVED_16_31R { bits : u16 , } impl RESERVED_16_31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = "Values that can be written to the field `IRCOUT_PD`" ] pub enum IRCOUT_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRCOUT_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IRCOUT_PDW :: POWERED => false , IRCOUT_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _IRCOUT_PDW < 'a > { w : & 'a mut W , } impl < 'a > _IRCOUT_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IRCOUT_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( IRCOUT_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( IRCOUT_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IRC_PD`" ] pub enum IRC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IRC_PDW :: POWERED => false , IRC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _IRC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _IRC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IRC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( IRC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( IRC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FLASH_PD`" ] pub enum FLASH_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl FLASH_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FLASH_PDW :: POWERED => false , FLASH_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _FLASH_PDW < 'a > { w : & 'a mut W , } impl < 'a > _FLASH_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FLASH_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( FLASH_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( FLASH_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BOD_PD`" ] pub enum BOD_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl BOD_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BOD_PDW :: POWERED => false , BOD_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _BOD_PDW < 'a > { w : & 'a mut W , } impl < 'a > _BOD_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BOD_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( BOD_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( BOD_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADC_PD`" ] pub enum ADC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl ADC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADC_PDW :: POWERED => false , ADC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _ADC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _ADC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( ADC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( ADC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SYSOSC_PD`" ] pub enum SYSOSC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSOSC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYSOSC_PDW :: POWERED => false , SYSOSC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _SYSOSC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _SYSOSC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYSOSC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( SYSOSC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( SYSOSC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WDTOSC_PD`" ] pub enum WDTOSC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl WDTOSC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WDTOSC_PDW :: POWERED => false , WDTOSC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _WDTOSC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _WDTOSC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WDTOSC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( WDTOSC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( WDTOSC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SYSPLL_PD`" ] pub enum SYSPLL_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSPLL_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYSPLL_PDW :: POWERED => false , SYSPLL_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _SYSPLL_PDW < 'a > { w : & 'a mut W , } impl < 'a > _SYSPLL_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYSPLL_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( SYSPLL_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( SYSPLL_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USBPLL_PD`" ] pub enum USBPLL_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl USBPLL_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USBPLL_PDW :: POWERED => false , USBPLL_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _USBPLL_PDW < 'a > { w : & 'a mut W , } impl < 'a > _USBPLL_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USBPLL_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( USBPLL_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( USBPLL_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USBPAD_PD`" ] pub enum USBPAD_PDW { # [ doc = "USB transceiver powered" ] USB_TRANSCEIVER_POWERED , # [ doc = "USB transceiver powered down" ] USB_TRANSCEIVER_POWERED_DOWN } impl USBPAD_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USBPAD_PDW :: USB_TRANSCEIVER_POWERED => false , USBPAD_PDW :: USB_TRANSCEIVER_POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _USBPAD_PDW < 'a > { w : & 'a mut W , } impl < 'a > _USBPAD_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USBPAD_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "USB transceiver powered" ] # [ inline ] pub fn usb_transceiver_powered ( self ) -> & 'a mut W { self . variant ( USBPAD_PDW :: USB_TRANSCEIVER_POWERED ) } # [ doc = "USB transceiver powered down" ] # [ inline ] pub fn usb_transceiver_powered_down ( self ) -> & 'a mut W { self . variant ( USBPAD_PDW :: USB_TRANSCEIVER_POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RESERVED_11W < 'a > { w : & 'a mut W , } impl < 'a > _RESERVED_11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RESERVED_12W < 'a > { w : & 'a mut W , } impl < 'a > _RESERVED_12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RESERVED_13_15W < 'a > { w : & 'a mut W , } impl < 'a > _RESERVED_13_15W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RESERVED_16_31W < 'a > { w : & 'a mut W , } impl < 'a > _RESERVED_16_31W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - IRC oscillator output wake-up configuration" ] # [ inline ] pub fn ircout_pd ( & self ) -> IRCOUT_PDR { IRCOUT_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - IRC oscillator power-down wake-up configuration" ] # [ inline ] pub fn irc_pd ( & self ) -> IRC_PDR { IRC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Flash wake-up configuration" ] # [ inline ] pub fn flash_pd ( & self ) -> FLASH_PDR { FLASH_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - BOD wake-up configuration" ] # [ inline ] pub fn bod_pd ( & self ) -> BOD_PDR { BOD_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - ADC wake-up configuration" ] # [ inline ] pub fn adc_pd ( & self ) -> ADC_PDR { ADC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Crystal oscillator wake-up configuration" ] # [ inline ] pub fn sysosc_pd ( & self ) -> SYSOSC_PDR { SYSOSC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Watchdog oscillator wake-up configuration" ] # [ inline ] pub fn wdtosc_pd ( & self ) -> WDTOSC_PDR { WDTOSC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - System PLL wake-up configuration" ] # [ inline ] pub fn syspll_pd ( & self ) -> SYSPLL_PDR { SYSPLL_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - USB PLL wake-up configuration" ] # [ inline ] pub fn usbpll_pd ( & self ) -> USBPLL_PDR { USBPLL_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - USB transceiver wake-up configuration" ] # [ inline ] pub fn usbpad_pd ( & self ) -> USBPAD_PDR { USBPAD_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Reserved. Always write this bit as 1." ] # [ inline ] pub fn reserved_11 ( & self ) -> RESERVED_11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RESERVED_11R { bits } } # [ doc = "Bit 12 - Reserved. Always write this bit as 0." ] # [ inline ] pub fn reserved_12 ( & self ) -> RESERVED_12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RESERVED_12R { bits } } # [ doc = "Bits 13:15 - Reserved. Always write these bits as 111." ] # [ inline ] pub fn reserved_13_15 ( & self ) -> RESERVED_13_15R { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; RESERVED_13_15R { bits } } # [ doc = "Bits 16:31 - Reserved" ] # [ inline ] pub fn reserved_16_31 ( & self ) -> RESERVED_16_31R { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; RESERVED_16_31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xedf0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - IRC oscillator output wake-up configuration" ] # [ inline ] pub fn ircout_pd ( & mut self ) -> _IRCOUT_PDW { _IRCOUT_PDW { w : self } } # [ doc = "Bit 1 - IRC oscillator power-down wake-up configuration" ] # [ inline ] pub fn irc_pd ( & mut self ) -> _IRC_PDW { _IRC_PDW { w : self } } # [ doc = "Bit 2 - Flash wake-up configuration" ] # [ inline ] pub fn flash_pd ( & mut self ) -> _FLASH_PDW { _FLASH_PDW { w : self } } # [ doc = "Bit 3 - BOD wake-up configuration" ] # [ inline ] pub fn bod_pd ( & mut self ) -> _BOD_PDW { _BOD_PDW { w : self } } # [ doc = "Bit 4 - ADC wake-up configuration" ] # [ inline ] pub fn adc_pd ( & mut self ) -> _ADC_PDW { _ADC_PDW { w : self } } # [ doc = "Bit 5 - Crystal oscillator wake-up configuration" ] # [ inline ] pub fn sysosc_pd ( & mut self ) -> _SYSOSC_PDW { _SYSOSC_PDW { w : self } } # [ doc = "Bit 6 - Watchdog oscillator wake-up configuration" ] # [ inline ] pub fn wdtosc_pd ( & mut self ) -> _WDTOSC_PDW { _WDTOSC_PDW { w : self } } # [ doc = "Bit 7 - System PLL wake-up configuration" ] # [ inline ] pub fn syspll_pd ( & mut self ) -> _SYSPLL_PDW { _SYSPLL_PDW { w : self } } # [ doc = "Bit 8 - USB PLL wake-up configuration" ] # [ inline ] pub fn usbpll_pd ( & mut self ) -> _USBPLL_PDW { _USBPLL_PDW { w : self } } # [ doc = "Bit 10 - USB transceiver wake-up configuration" ] # [ inline ] pub fn usbpad_pd ( & mut self ) -> _USBPAD_PDW { _USBPAD_PDW { w : self } } # [ doc = "Bit 11 - Reserved. Always write this bit as 1." ] # [ inline ] pub fn reserved_11 ( & mut self ) -> _RESERVED_11W { _RESERVED_11W { w : self } } # [ doc = "Bit 12 - Reserved. Always write this bit as 0." ] # [ inline ] pub fn reserved_12 ( & mut self ) -> _RESERVED_12W { _RESERVED_12W { w : self } } # [ doc = "Bits 13:15 - Reserved. Always write these bits as 111." ] # [ inline ] pub fn reserved_13_15 ( & mut self ) -> _RESERVED_13_15W { _RESERVED_13_15W { w : self } } # [ doc = "Bits 16:31 - Reserved" ] # [ inline ] pub fn reserved_16_31 ( & mut self ) -> _RESERVED_16_31W { _RESERVED_16_31W { w : self } } } } # [ doc = "Power configuration register" ] pub struct PDRUNCFG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Power configuration register" ] pub mod pdruncfg { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PDRUNCFG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `IRCOUT_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRCOUT_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRCOUT_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IRCOUT_PDR :: POWERED => false , IRCOUT_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IRCOUT_PDR { match value { false => IRCOUT_PDR :: POWERED , true => IRCOUT_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == IRCOUT_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == IRCOUT_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `IRC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IRC_PDR :: POWERED => false , IRC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IRC_PDR { match value { false => IRC_PDR :: POWERED , true => IRC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == IRC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == IRC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `FLASH_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLASH_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl FLASH_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FLASH_PDR :: POWERED => false , FLASH_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FLASH_PDR { match value { false => FLASH_PDR :: POWERED , true => FLASH_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == FLASH_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == FLASH_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `BOD_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BOD_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl BOD_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BOD_PDR :: POWERED => false , BOD_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BOD_PDR { match value { false => BOD_PDR :: POWERED , true => BOD_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == BOD_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == BOD_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `ADC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl ADC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADC_PDR :: POWERED => false , ADC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADC_PDR { match value { false => ADC_PDR :: POWERED , true => ADC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == ADC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == ADC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `SYSOSC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSOSC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSOSC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SYSOSC_PDR :: POWERED => false , SYSOSC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SYSOSC_PDR { match value { false => SYSOSC_PDR :: POWERED , true => SYSOSC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == SYSOSC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == SYSOSC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `WDTOSC_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTOSC_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl WDTOSC_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WDTOSC_PDR :: POWERED => false , WDTOSC_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WDTOSC_PDR { match value { false => WDTOSC_PDR :: POWERED , true => WDTOSC_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == WDTOSC_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == WDTOSC_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `SYSPLL_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSPLL_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSPLL_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SYSPLL_PDR :: POWERED => false , SYSPLL_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SYSPLL_PDR { match value { false => SYSPLL_PDR :: POWERED , true => SYSPLL_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == SYSPLL_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == SYSPLL_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `USBPLL_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USBPLL_PDR { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl USBPLL_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USBPLL_PDR :: POWERED => false , USBPLL_PDR :: POWERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USBPLL_PDR { match value { false => USBPLL_PDR :: POWERED , true => USBPLL_PDR :: POWERED_DOWN , } } # [ doc = "Checks if the value of the field is `POWERED`" ] # [ inline ] pub fn is_powered ( & self ) -> bool { * self == USBPLL_PDR :: POWERED } # [ doc = "Checks if the value of the field is `POWERED_DOWN`" ] # [ inline ] pub fn is_powered_down ( & self ) -> bool { * self == USBPLL_PDR :: POWERED_DOWN } } # [ doc = "Possible values of the field `USBPAD_PD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USBPAD_PDR { # [ doc = "USB transceiver powered" ] USB_TRANSCEIVER_POWEERED , # [ doc = "USB transceiver powered down (suspend mode)" ] USB_TRANSCEIVER_POWEERED_DOWN } impl USBPAD_PDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { USBPAD_PDR :: USB_TRANSCEIVER_POWEERED => false , USBPAD_PDR :: USB_TRANSCEIVER_POWEERED_DOWN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> USBPAD_PDR { match value { false => USBPAD_PDR :: USB_TRANSCEIVER_POWEERED , true => USBPAD_PDR :: USB_TRANSCEIVER_POWEERED_DOWN , } } # [ doc = "Checks if the value of the field is `USB_TRANSCEIVER_POWEERED`" ] # [ inline ] pub fn is_usb_transceiver_poweered ( & self ) -> bool { * self == USBPAD_PDR :: USB_TRANSCEIVER_POWEERED } # [ doc = "Checks if the value of the field is `USB_TRANSCEIVER_POWEERED_DOWN`" ] # [ inline ] pub fn is_usb_transceiver_poweered_down ( & self ) -> bool { * self == USBPAD_PDR :: USB_TRANSCEIVER_POWEERED_DOWN } } # [ doc = "Values that can be written to the field `IRCOUT_PD`" ] pub enum IRCOUT_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRCOUT_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IRCOUT_PDW :: POWERED => false , IRCOUT_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _IRCOUT_PDW < 'a > { w : & 'a mut W , } impl < 'a > _IRCOUT_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IRCOUT_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( IRCOUT_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( IRCOUT_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IRC_PD`" ] pub enum IRC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl IRC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IRC_PDW :: POWERED => false , IRC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _IRC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _IRC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IRC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( IRC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( IRC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FLASH_PD`" ] pub enum FLASH_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl FLASH_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FLASH_PDW :: POWERED => false , FLASH_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _FLASH_PDW < 'a > { w : & 'a mut W , } impl < 'a > _FLASH_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FLASH_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( FLASH_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( FLASH_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BOD_PD`" ] pub enum BOD_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl BOD_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BOD_PDW :: POWERED => false , BOD_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _BOD_PDW < 'a > { w : & 'a mut W , } impl < 'a > _BOD_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BOD_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( BOD_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( BOD_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADC_PD`" ] pub enum ADC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl ADC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADC_PDW :: POWERED => false , ADC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _ADC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _ADC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( ADC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( ADC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SYSOSC_PD`" ] pub enum SYSOSC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSOSC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYSOSC_PDW :: POWERED => false , SYSOSC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _SYSOSC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _SYSOSC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYSOSC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( SYSOSC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( SYSOSC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WDTOSC_PD`" ] pub enum WDTOSC_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl WDTOSC_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WDTOSC_PDW :: POWERED => false , WDTOSC_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _WDTOSC_PDW < 'a > { w : & 'a mut W , } impl < 'a > _WDTOSC_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WDTOSC_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( WDTOSC_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( WDTOSC_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SYSPLL_PD`" ] pub enum SYSPLL_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl SYSPLL_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYSPLL_PDW :: POWERED => false , SYSPLL_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _SYSPLL_PDW < 'a > { w : & 'a mut W , } impl < 'a > _SYSPLL_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYSPLL_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( SYSPLL_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( SYSPLL_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USBPLL_PD`" ] pub enum USBPLL_PDW { # [ doc = "Powered" ] POWERED , # [ doc = "Powered down" ] POWERED_DOWN } impl USBPLL_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USBPLL_PDW :: POWERED => false , USBPLL_PDW :: POWERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _USBPLL_PDW < 'a > { w : & 'a mut W , } impl < 'a > _USBPLL_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USBPLL_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Powered" ] # [ inline ] pub fn powered ( self ) -> & 'a mut W { self . variant ( USBPLL_PDW :: POWERED ) } # [ doc = "Powered down" ] # [ inline ] pub fn powered_down ( self ) -> & 'a mut W { self . variant ( USBPLL_PDW :: POWERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `USBPAD_PD`" ] pub enum USBPAD_PDW { # [ doc = "USB transceiver powered" ] USB_TRANSCEIVER_POWEERED , # [ doc = "USB transceiver powered down (suspend mode)" ] USB_TRANSCEIVER_POWEERED_DOWN } impl USBPAD_PDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { USBPAD_PDW :: USB_TRANSCEIVER_POWEERED => false , USBPAD_PDW :: USB_TRANSCEIVER_POWEERED_DOWN => true } } } # [ doc = r" Proxy" ] pub struct _USBPAD_PDW < 'a > { w : & 'a mut W , } impl < 'a > _USBPAD_PDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : USBPAD_PDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "USB transceiver powered" ] # [ inline ] pub fn usb_transceiver_poweered ( self ) -> & 'a mut W { self . variant ( USBPAD_PDW :: USB_TRANSCEIVER_POWEERED ) } # [ doc = "USB transceiver powered down (suspend mode)" ] # [ inline ] pub fn usb_transceiver_poweered_down ( self ) -> & 'a mut W { self . variant ( USBPAD_PDW :: USB_TRANSCEIVER_POWEERED_DOWN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - IRC oscillator output power-down" ] # [ inline ] pub fn ircout_pd ( & self ) -> IRCOUT_PDR { IRCOUT_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - IRC oscillator power-down" ] # [ inline ] pub fn irc_pd ( & self ) -> IRC_PDR { IRC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Flash power-down" ] # [ inline ] pub fn flash_pd ( & self ) -> FLASH_PDR { FLASH_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - BOD power-down" ] # [ inline ] pub fn bod_pd ( & self ) -> BOD_PDR { BOD_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - ADC power-down" ] # [ inline ] pub fn adc_pd ( & self ) -> ADC_PDR { ADC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Crystal oscillator power-down" ] # [ inline ] pub fn sysosc_pd ( & self ) -> SYSOSC_PDR { SYSOSC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Watchdog oscillator power-down" ] # [ inline ] pub fn wdtosc_pd ( & self ) -> WDTOSC_PDR { WDTOSC_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - System PLL power-down" ] # [ inline ] pub fn syspll_pd ( & self ) -> SYSPLL_PDR { SYSPLL_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - USB PLL power-down" ] # [ inline ] pub fn usbpll_pd ( & self ) -> USBPLL_PDR { USBPLL_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - USB transceiver power-down configuration" ] # [ inline ] pub fn usbpad_pd ( & self ) -> USBPAD_PDR { USBPAD_PDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xedf0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - IRC oscillator output power-down" ] # [ inline ] pub fn ircout_pd ( & mut self ) -> _IRCOUT_PDW { _IRCOUT_PDW { w : self } } # [ doc = "Bit 1 - IRC oscillator power-down" ] # [ inline ] pub fn irc_pd ( & mut self ) -> _IRC_PDW { _IRC_PDW { w : self } } # [ doc = "Bit 2 - Flash power-down" ] # [ inline ] pub fn flash_pd ( & mut self ) -> _FLASH_PDW { _FLASH_PDW { w : self } } # [ doc = "Bit 3 - BOD power-down" ] # [ inline ] pub fn bod_pd ( & mut self ) -> _BOD_PDW { _BOD_PDW { w : self } } # [ doc = "Bit 4 - ADC power-down" ] # [ inline ] pub fn adc_pd ( & mut self ) -> _ADC_PDW { _ADC_PDW { w : self } } # [ doc = "Bit 5 - Crystal oscillator power-down" ] # [ inline ] pub fn sysosc_pd ( & mut self ) -> _SYSOSC_PDW { _SYSOSC_PDW { w : self } } # [ doc = "Bit 6 - Watchdog oscillator power-down" ] # [ inline ] pub fn wdtosc_pd ( & mut self ) -> _WDTOSC_PDW { _WDTOSC_PDW { w : self } } # [ doc = "Bit 7 - System PLL power-down" ] # [ inline ] pub fn syspll_pd ( & mut self ) -> _SYSPLL_PDW { _SYSPLL_PDW { w : self } } # [ doc = "Bit 8 - USB PLL power-down" ] # [ inline ] pub fn usbpll_pd ( & mut self ) -> _USBPLL_PDW { _USBPLL_PDW { w : self } } # [ doc = "Bit 10 - USB transceiver power-down configuration" ] # [ inline ] pub fn usbpad_pd ( & mut self ) -> _USBPAD_PDW { _USBPAD_PDW { w : self } } } } # [ doc = "Device ID" ] pub struct DEVICE_ID { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device ID" ] pub mod device_id { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: DEVICE_ID { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct DEVICEIDR { bits : u32 , } impl DEVICEIDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Device ID numbers for LPC11Uxx parts LPC11U12FHN33/201 = 0x095C 802B/0x295C 802B LPC11U12FBD48/201 = 0x095C 802B/0x295C 802B LPC11U13FBD48/201 = 0x097A 802B/0x297A 802B LPC11U14FHN33/201 = 0x0998 802B/0x2998 802B LPC11U14FHI33/201 = 0x2998 802B LPC11U14FBD48/201 = 0x0998 802B/0x2998 802B LPC11U14FET48/201 = 0x0998 802B/0x2998 802B LPC11U23FBD48/301 = 0x2972 402B LPC11U24FHI33/301 = 0x2988 402B LPC11U24FBD48/301 = 0x2988 402B LPC11U24FET48/301 = 0x2988 402B LPC11U24FHN33/401 = 0x2980 002B LPC11U24FBD48/401 = 0x2980 002B LPC11U24FBD64/401 = 0x2980 002B" ] # [ inline ] pub fn deviceid ( & self ) -> DEVICEIDR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; DEVICEIDR { bits } } } } } # [ doc = "GPIO pin interrupt" ] pub struct GPIO_PIN_INT { _marker : PhantomData < * const ( ) > } unsafe impl Send for GPIO_PIN_INT { } impl GPIO_PIN_INT { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const gpio_pin_int :: RegisterBlock { 0x4004_c000 as * const _ } } impl Deref for GPIO_PIN_INT { type Target = gpio_pin_int :: RegisterBlock ; fn deref ( & self ) -> & gpio_pin_int :: RegisterBlock { unsafe { & * GPIO_PIN_INT :: ptr ( ) } } } # [ doc = "GPIO pin interrupt" ] pub mod gpio_pin_int { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Pin Interrupt Mode register" ] pub isel : ISEL , # [ doc = "0x04 - Pin Interrupt Enable (Rising) register" ] pub ienr : IENR , # [ doc = "0x08 - Set Pin Interrupt Enable (Rising) register" ] pub sienr : SIENR , # [ doc = "0x0c - Clear Pin Interrupt Enable (Rising) register" ] pub cienr : CIENR , # [ doc = "0x10 - Pin Interrupt Enable Falling Edge / Active Level register" ] pub ienf : IENF , # [ doc = "0x14 - Set Pin Interrupt Enable Falling Edge / Active Level register" ] pub sienf : SIENF , # [ doc = "0x18 - Clear Pin Interrupt Enable Falling Edge / Active Level address" ] pub cienf : CIENF , # [ doc = "0x1c - Pin Interrupt Rising Edge register" ] pub rise : RISE , # [ doc = "0x20 - Pin Interrupt Falling Edge register" ] pub fall : FALL , # [ doc = "0x24 - Pin Interrupt Status register" ] pub ist : IST , } # [ doc = "Pin Interrupt Mode register" ] pub struct ISEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin Interrupt Mode register" ] pub mod isel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ISEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PMODE0R { bits : bool , } impl PMODE0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PMODE1R { bits : bool , } impl PMODE1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PMODE2R { bits : bool , } impl PMODE2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PMODE3R { bits : bool , } impl PMODE3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PMODE4R { bits : bool , } impl PMODE4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PMODE5R { bits : bool , } impl PMODE5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PMODE6R { bits : bool , } impl PMODE6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PMODE7R { bits : bool , } impl PMODE7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _PMODE0W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PMODE1W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PMODE2W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PMODE3W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PMODE4W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PMODE5W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PMODE6W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PMODE7W < 'a > { w : & 'a mut W , } impl < 'a > _PMODE7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode0 ( & self ) -> PMODE0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE0R { bits } } # [ doc = "Bit 1 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode1 ( & self ) -> PMODE1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE1R { bits } } # [ doc = "Bit 2 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode2 ( & self ) -> PMODE2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE2R { bits } } # [ doc = "Bit 3 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode3 ( & self ) -> PMODE3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE3R { bits } } # [ doc = "Bit 4 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode4 ( & self ) -> PMODE4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE4R { bits } } # [ doc = "Bit 5 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode5 ( & self ) -> PMODE5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE5R { bits } } # [ doc = "Bit 6 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode6 ( & self ) -> PMODE6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE6R { bits } } # [ doc = "Bit 7 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode7 ( & self ) -> PMODE7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PMODE7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode0 ( & mut self ) -> _PMODE0W { _PMODE0W { w : self } } # [ doc = "Bit 1 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode1 ( & mut self ) -> _PMODE1W { _PMODE1W { w : self } } # [ doc = "Bit 2 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode2 ( & mut self ) -> _PMODE2W { _PMODE2W { w : self } } # [ doc = "Bit 3 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode3 ( & mut self ) -> _PMODE3W { _PMODE3W { w : self } } # [ doc = "Bit 4 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode4 ( & mut self ) -> _PMODE4W { _PMODE4W { w : self } } # [ doc = "Bit 5 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode5 ( & mut self ) -> _PMODE5W { _PMODE5W { w : self } } # [ doc = "Bit 6 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode6 ( & mut self ) -> _PMODE6W { _PMODE6W { w : self } } # [ doc = "Bit 7 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive" ] # [ inline ] pub fn pmode7 ( & mut self ) -> _PMODE7W { _PMODE7W { w : self } } } } # [ doc = "Pin Interrupt Enable (Rising) register" ] pub struct IENR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin Interrupt Enable (Rising) register" ] pub mod ienr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IENR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ENRL0R { bits : bool , } impl ENRL0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENRL1R { bits : bool , } impl ENRL1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENRL2R { bits : bool , } impl ENRL2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENRL3R { bits : bool , } impl ENRL3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENRL4R { bits : bool , } impl ENRL4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENRL5R { bits : bool , } impl ENRL5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENRL6R { bits : bool , } impl ENRL6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENRL7R { bits : bool , } impl ENRL7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _ENRL0W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENRL1W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENRL2W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENRL3W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENRL4W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENRL5W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENRL6W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENRL7W < 'a > { w : & 'a mut W , } impl < 'a > _ENRL7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl0 ( & self ) -> ENRL0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL0R { bits } } # [ doc = "Bit 1 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl1 ( & self ) -> ENRL1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL1R { bits } } # [ doc = "Bit 2 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl2 ( & self ) -> ENRL2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL2R { bits } } # [ doc = "Bit 3 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl3 ( & self ) -> ENRL3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL3R { bits } } # [ doc = "Bit 4 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl4 ( & self ) -> ENRL4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL4R { bits } } # [ doc = "Bit 5 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl5 ( & self ) -> ENRL5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL5R { bits } } # [ doc = "Bit 6 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl6 ( & self ) -> ENRL6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL6R { bits } } # [ doc = "Bit 7 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl7 ( & self ) -> ENRL7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENRL7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl0 ( & mut self ) -> _ENRL0W { _ENRL0W { w : self } } # [ doc = "Bit 1 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl1 ( & mut self ) -> _ENRL1W { _ENRL1W { w : self } } # [ doc = "Bit 2 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl2 ( & mut self ) -> _ENRL2W { _ENRL2W { w : self } } # [ doc = "Bit 3 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl3 ( & mut self ) -> _ENRL3W { _ENRL3W { w : self } } # [ doc = "Bit 4 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl4 ( & mut self ) -> _ENRL4W { _ENRL4W { w : self } } # [ doc = "Bit 5 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl5 ( & mut self ) -> _ENRL5W { _ENRL5W { w : self } } # [ doc = "Bit 6 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl6 ( & mut self ) -> _ENRL6W { _ENRL6W { w : self } } # [ doc = "Bit 7 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn enrl7 ( & mut self ) -> _ENRL7W { _ENRL7W { w : self } } } } # [ doc = "Set Pin Interrupt Enable (Rising) register" ] pub struct SIENR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Set Pin Interrupt Enable (Rising) register" ] pub mod sienr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SIENR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _SETENRL0W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENRL1W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENRL2W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENRL3W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENRL4W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENRL5W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENRL6W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENRL7W < 'a > { w : & 'a mut W , } impl < 'a > _SETENRL7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl0 ( & mut self ) -> _SETENRL0W { _SETENRL0W { w : self } } # [ doc = "Bit 1 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl1 ( & mut self ) -> _SETENRL1W { _SETENRL1W { w : self } } # [ doc = "Bit 2 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl2 ( & mut self ) -> _SETENRL2W { _SETENRL2W { w : self } } # [ doc = "Bit 3 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl3 ( & mut self ) -> _SETENRL3W { _SETENRL3W { w : self } } # [ doc = "Bit 4 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl4 ( & mut self ) -> _SETENRL4W { _SETENRL4W { w : self } } # [ doc = "Bit 5 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl5 ( & mut self ) -> _SETENRL5W { _SETENRL5W { w : self } } # [ doc = "Bit 6 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl6 ( & mut self ) -> _SETENRL6W { _SETENRL6W { w : self } } # [ doc = "Bit 7 - Ones written to this address set bits in the PINTEN_R, thus enabling interrupts. Bit n sets bit n in the PINTEN_R register. 0 = No operation. 1 = Enable rising edge or level interrupt." ] # [ inline ] pub fn setenrl7 ( & mut self ) -> _SETENRL7W { _SETENRL7W { w : self } } } } # [ doc = "Clear Pin Interrupt Enable (Rising) register" ] pub struct CIENR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clear Pin Interrupt Enable (Rising) register" ] pub mod cienr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CIENR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _CENRL0W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENRL1W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENRL2W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENRL3W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENRL4W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENRL5W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENRL6W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENRL7W < 'a > { w : & 'a mut W , } impl < 'a > _CENRL7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl0 ( & mut self ) -> _CENRL0W { _CENRL0W { w : self } } # [ doc = "Bit 1 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl1 ( & mut self ) -> _CENRL1W { _CENRL1W { w : self } } # [ doc = "Bit 2 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl2 ( & mut self ) -> _CENRL2W { _CENRL2W { w : self } } # [ doc = "Bit 3 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl3 ( & mut self ) -> _CENRL3W { _CENRL3W { w : self } } # [ doc = "Bit 4 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl4 ( & mut self ) -> _CENRL4W { _CENRL4W { w : self } } # [ doc = "Bit 5 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl5 ( & mut self ) -> _CENRL5W { _CENRL5W { w : self } } # [ doc = "Bit 6 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl6 ( & mut self ) -> _CENRL6W { _CENRL6W { w : self } } # [ doc = "Bit 7 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt." ] # [ inline ] pub fn cenrl7 ( & mut self ) -> _CENRL7W { _CENRL7W { w : self } } } } # [ doc = "Pin Interrupt Enable Falling Edge / Active Level register" ] pub struct IENF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin Interrupt Enable Falling Edge / Active Level register" ] pub mod ienf { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IENF { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ENAF0R { bits : bool , } impl ENAF0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENAF1R { bits : bool , } impl ENAF1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENAF2R { bits : bool , } impl ENAF2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENAF3R { bits : bool , } impl ENAF3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENAF4R { bits : bool , } impl ENAF4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENAF5R { bits : bool , } impl ENAF5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENAF6R { bits : bool , } impl ENAF6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENAF7R { bits : bool , } impl ENAF7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _ENAF0W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENAF1W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENAF2W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENAF3W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENAF4W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENAF5W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENAF6W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENAF7W < 'a > { w : & 'a mut W , } impl < 'a > _ENAF7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf0 ( & self ) -> ENAF0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF0R { bits } } # [ doc = "Bit 1 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf1 ( & self ) -> ENAF1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF1R { bits } } # [ doc = "Bit 2 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf2 ( & self ) -> ENAF2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF2R { bits } } # [ doc = "Bit 3 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf3 ( & self ) -> ENAF3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF3R { bits } } # [ doc = "Bit 4 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf4 ( & self ) -> ENAF4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF4R { bits } } # [ doc = "Bit 5 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf5 ( & self ) -> ENAF5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF5R { bits } } # [ doc = "Bit 6 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf6 ( & self ) -> ENAF6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF6R { bits } } # [ doc = "Bit 7 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf7 ( & self ) -> ENAF7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENAF7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf0 ( & mut self ) -> _ENAF0W { _ENAF0W { w : self } } # [ doc = "Bit 1 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf1 ( & mut self ) -> _ENAF1W { _ENAF1W { w : self } } # [ doc = "Bit 2 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf2 ( & mut self ) -> _ENAF2W { _ENAF2W { w : self } } # [ doc = "Bit 3 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf3 ( & mut self ) -> _ENAF3W { _ENAF3W { w : self } } # [ doc = "Bit 4 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf4 ( & mut self ) -> _ENAF4W { _ENAF4W { w : self } } # [ doc = "Bit 5 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf5 ( & mut self ) -> _ENAF5W { _ENAF5W { w : self } } # [ doc = "Bit 6 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf6 ( & mut self ) -> _ENAF6W { _ENAF6W { w : self } } # [ doc = "Bit 7 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH." ] # [ inline ] pub fn enaf7 ( & mut self ) -> _ENAF7W { _ENAF7W { w : self } } } } # [ doc = "Set Pin Interrupt Enable Falling Edge / Active Level register" ] pub struct SIENF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Set Pin Interrupt Enable Falling Edge / Active Level register" ] pub mod sienf { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SIENF { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _SETENAF0W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENAF1W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENAF2W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENAF3W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENAF4W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENAF5W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENAF6W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETENAF7W < 'a > { w : & 'a mut W , } impl < 'a > _SETENAF7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf0 ( & mut self ) -> _SETENAF0W { _SETENAF0W { w : self } } # [ doc = "Bit 1 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf1 ( & mut self ) -> _SETENAF1W { _SETENAF1W { w : self } } # [ doc = "Bit 2 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf2 ( & mut self ) -> _SETENAF2W { _SETENAF2W { w : self } } # [ doc = "Bit 3 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf3 ( & mut self ) -> _SETENAF3W { _SETENAF3W { w : self } } # [ doc = "Bit 4 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf4 ( & mut self ) -> _SETENAF4W { _SETENAF4W { w : self } } # [ doc = "Bit 5 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf5 ( & mut self ) -> _SETENAF5W { _SETENAF5W { w : self } } # [ doc = "Bit 6 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf6 ( & mut self ) -> _SETENAF6W { _SETENAF6W { w : self } } # [ doc = "Bit 7 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt." ] # [ inline ] pub fn setenaf7 ( & mut self ) -> _SETENAF7W { _SETENAF7W { w : self } } } } # [ doc = "Clear Pin Interrupt Enable Falling Edge / Active Level address" ] pub struct CIENF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clear Pin Interrupt Enable Falling Edge / Active Level address" ] pub mod cienf { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CIENF { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _CENAF0W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENAF1W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENAF2W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENAF3W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENAF4W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENAF5W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENAF6W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CENAF7W < 'a > { w : & 'a mut W , } impl < 'a > _CENAF7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf0 ( & mut self ) -> _CENAF0W { _CENAF0W { w : self } } # [ doc = "Bit 1 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf1 ( & mut self ) -> _CENAF1W { _CENAF1W { w : self } } # [ doc = "Bit 2 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf2 ( & mut self ) -> _CENAF2W { _CENAF2W { w : self } } # [ doc = "Bit 3 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf3 ( & mut self ) -> _CENAF3W { _CENAF3W { w : self } } # [ doc = "Bit 4 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf4 ( & mut self ) -> _CENAF4W { _CENAF4W { w : self } } # [ doc = "Bit 5 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf5 ( & mut self ) -> _CENAF5W { _CENAF5W { w : self } } # [ doc = "Bit 6 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf6 ( & mut self ) -> _CENAF6W { _CENAF6W { w : self } } # [ doc = "Bit 7 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled." ] # [ inline ] pub fn cenaf7 ( & mut self ) -> _CENAF7W { _CENAF7W { w : self } } } } # [ doc = "Pin Interrupt Rising Edge register" ] pub struct RISE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin Interrupt Rising Edge register" ] pub mod rise { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RISE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct RDET0R { bits : bool , } impl RDET0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RDET1R { bits : bool , } impl RDET1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RDET2R { bits : bool , } impl RDET2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RDET3R { bits : bool , } impl RDET3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RDET4R { bits : bool , } impl RDET4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RDET5R { bits : bool , } impl RDET5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RDET6R { bits : bool , } impl RDET6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct RDET7R { bits : bool , } impl RDET7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _RDET0W < 'a > { w : & 'a mut W , } impl < 'a > _RDET0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RDET1W < 'a > { w : & 'a mut W , } impl < 'a > _RDET1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RDET2W < 'a > { w : & 'a mut W , } impl < 'a > _RDET2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RDET3W < 'a > { w : & 'a mut W , } impl < 'a > _RDET3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RDET4W < 'a > { w : & 'a mut W , } impl < 'a > _RDET4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RDET5W < 'a > { w : & 'a mut W , } impl < 'a > _RDET5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RDET6W < 'a > { w : & 'a mut W , } impl < 'a > _RDET6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _RDET7W < 'a > { w : & 'a mut W , } impl < 'a > _RDET7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet0 ( & self ) -> RDET0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET0R { bits } } # [ doc = "Bit 1 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet1 ( & self ) -> RDET1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET1R { bits } } # [ doc = "Bit 2 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet2 ( & self ) -> RDET2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET2R { bits } } # [ doc = "Bit 3 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet3 ( & self ) -> RDET3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET3R { bits } } # [ doc = "Bit 4 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet4 ( & self ) -> RDET4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET4R { bits } } # [ doc = "Bit 5 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet5 ( & self ) -> RDET5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET5R { bits } } # [ doc = "Bit 6 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet6 ( & self ) -> RDET6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET6R { bits } } # [ doc = "Bit 7 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet7 ( & self ) -> RDET7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RDET7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet0 ( & mut self ) -> _RDET0W { _RDET0W { w : self } } # [ doc = "Bit 1 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet1 ( & mut self ) -> _RDET1W { _RDET1W { w : self } } # [ doc = "Bit 2 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet2 ( & mut self ) -> _RDET2W { _RDET2W { w : self } } # [ doc = "Bit 3 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet3 ( & mut self ) -> _RDET3W { _RDET3W { w : self } } # [ doc = "Bit 4 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet4 ( & mut self ) -> _RDET4W { _RDET4W { w : self } } # [ doc = "Bit 5 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet5 ( & mut self ) -> _RDET5W { _RDET5W { w : self } } # [ doc = "Bit 6 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet6 ( & mut self ) -> _RDET6W { _RDET6W { w : self } } # [ doc = "Bit 7 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin." ] # [ inline ] pub fn rdet7 ( & mut self ) -> _RDET7W { _RDET7W { w : self } } } } # [ doc = "Pin Interrupt Falling Edge register" ] pub struct FALL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin Interrupt Falling Edge register" ] pub mod fall { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FALL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct FDET0R { bits : bool , } impl FDET0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FDET1R { bits : bool , } impl FDET1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FDET2R { bits : bool , } impl FDET2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FDET3R { bits : bool , } impl FDET3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FDET4R { bits : bool , } impl FDET4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FDET5R { bits : bool , } impl FDET5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FDET6R { bits : bool , } impl FDET6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FDET7R { bits : bool , } impl FDET7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _FDET0W < 'a > { w : & 'a mut W , } impl < 'a > _FDET0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDET1W < 'a > { w : & 'a mut W , } impl < 'a > _FDET1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDET2W < 'a > { w : & 'a mut W , } impl < 'a > _FDET2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDET3W < 'a > { w : & 'a mut W , } impl < 'a > _FDET3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDET4W < 'a > { w : & 'a mut W , } impl < 'a > _FDET4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDET5W < 'a > { w : & 'a mut W , } impl < 'a > _FDET5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDET6W < 'a > { w : & 'a mut W , } impl < 'a > _FDET6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FDET7W < 'a > { w : & 'a mut W , } impl < 'a > _FDET7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet0 ( & self ) -> FDET0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET0R { bits } } # [ doc = "Bit 1 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet1 ( & self ) -> FDET1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET1R { bits } } # [ doc = "Bit 2 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet2 ( & self ) -> FDET2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET2R { bits } } # [ doc = "Bit 3 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet3 ( & self ) -> FDET3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET3R { bits } } # [ doc = "Bit 4 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet4 ( & self ) -> FDET4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET4R { bits } } # [ doc = "Bit 5 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet5 ( & self ) -> FDET5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET5R { bits } } # [ doc = "Bit 6 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet6 ( & self ) -> FDET6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET6R { bits } } # [ doc = "Bit 7 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet7 ( & self ) -> FDET7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FDET7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet0 ( & mut self ) -> _FDET0W { _FDET0W { w : self } } # [ doc = "Bit 1 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet1 ( & mut self ) -> _FDET1W { _FDET1W { w : self } } # [ doc = "Bit 2 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet2 ( & mut self ) -> _FDET2W { _FDET2W { w : self } } # [ doc = "Bit 3 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet3 ( & mut self ) -> _FDET3W { _FDET3W { w : self } } # [ doc = "Bit 4 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet4 ( & mut self ) -> _FDET4W { _FDET4W { w : self } } # [ doc = "Bit 5 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet5 ( & mut self ) -> _FDET5W { _FDET5W { w : self } } # [ doc = "Bit 6 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet6 ( & mut self ) -> _FDET6W { _FDET6W { w : self } } # [ doc = "Bit 7 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin." ] # [ inline ] pub fn fdet7 ( & mut self ) -> _FDET7W { _FDET7W { w : self } } } } # [ doc = "Pin Interrupt Status register" ] pub struct IST { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin Interrupt Status register" ] pub mod ist { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IST { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PSTAT0R { bits : bool , } impl PSTAT0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PSTAT1R { bits : bool , } impl PSTAT1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PSTAT2R { bits : bool , } impl PSTAT2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PSTAT3R { bits : bool , } impl PSTAT3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PSTAT4R { bits : bool , } impl PSTAT4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PSTAT5R { bits : bool , } impl PSTAT5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PSTAT6R { bits : bool , } impl PSTAT6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PSTAT7R { bits : bool , } impl PSTAT7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _PSTAT0W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSTAT1W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSTAT2W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSTAT3W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSTAT4W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSTAT5W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSTAT6W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSTAT7W < 'a > { w : & 'a mut W , } impl < 'a > _PSTAT7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat0 ( & self ) -> PSTAT0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT0R { bits } } # [ doc = "Bit 1 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat1 ( & self ) -> PSTAT1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT1R { bits } } # [ doc = "Bit 2 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat2 ( & self ) -> PSTAT2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT2R { bits } } # [ doc = "Bit 3 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat3 ( & self ) -> PSTAT3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT3R { bits } } # [ doc = "Bit 4 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat4 ( & self ) -> PSTAT4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT4R { bits } } # [ doc = "Bit 5 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat5 ( & self ) -> PSTAT5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT5R { bits } } # [ doc = "Bit 6 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat6 ( & self ) -> PSTAT6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT6R { bits } } # [ doc = "Bit 7 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat7 ( & self ) -> PSTAT7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PSTAT7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat0 ( & mut self ) -> _PSTAT0W { _PSTAT0W { w : self } } # [ doc = "Bit 1 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat1 ( & mut self ) -> _PSTAT1W { _PSTAT1W { w : self } } # [ doc = "Bit 2 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat2 ( & mut self ) -> _PSTAT2W { _PSTAT2W { w : self } } # [ doc = "Bit 3 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat3 ( & mut self ) -> _PSTAT3W { _PSTAT3W { w : self } } # [ doc = "Bit 4 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat4 ( & mut self ) -> _PSTAT4W { _PSTAT4W { w : self } } # [ doc = "Bit 5 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat5 ( & mut self ) -> _PSTAT5W { _PSTAT5W { w : self } } # [ doc = "Bit 6 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat6 ( & mut self ) -> _PSTAT6W { _PSTAT6W { w : self } } # [ doc = "Bit 7 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the PINTENT_F register)." ] # [ inline ] pub fn pstat7 ( & mut self ) -> _PSTAT7W { _PSTAT7W { w : self } } } } } # [ doc = "SSP1" ] pub struct SSP1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SSP1 { } impl SSP1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ssp0 :: RegisterBlock { 0x4005_8000 as * const _ } } impl Deref for SSP1 { type Target = ssp0 :: RegisterBlock ; fn deref ( & self ) -> & ssp0 :: RegisterBlock { unsafe { & * SSP1 :: ptr ( ) } } } # [ doc = "GPIO group interrupt" ] pub struct GPIO_GROUP_INT0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for GPIO_GROUP_INT0 { } impl GPIO_GROUP_INT0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const gpio_group_int0 :: RegisterBlock { 0x4005_c000 as * const _ } } impl Deref for GPIO_GROUP_INT0 { type Target = gpio_group_int0 :: RegisterBlock ; fn deref ( & self ) -> & gpio_group_int0 :: RegisterBlock { unsafe { & * GPIO_GROUP_INT0 :: ptr ( ) } } } # [ doc = "GPIO group interrupt" ] pub mod gpio_group_int0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - GPIO grouped interrupt control register" ] pub ctrl : CTRL , _reserved0 : [ u8 ; 28usize ] , # [ doc = "0x20 - GPIO grouped interrupt port 0 polarity register" ] pub port_pol : [ PORT_POL ; 2 ] , _reserved1 : [ u8 ; 24usize ] , # [ doc = "0x40 - GPIO grouped interrupt port 0/1 enable register" ] pub port_ena : [ PORT_ENA ; 2 ] , } # [ doc = "GPIO grouped interrupt control register" ] pub struct CTRL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "GPIO grouped interrupt control register" ] pub mod ctrl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CTRL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `INT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTR { # [ doc = "No interrupt request is pending." ] NO_INTERRUPT_REQUEST , # [ doc = "Interrupt request is active." ] INTERRUPT_REQUEST_IS } impl INTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INTR :: NO_INTERRUPT_REQUEST => false , INTR :: INTERRUPT_REQUEST_IS => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INTR { match value { false => INTR :: NO_INTERRUPT_REQUEST , true => INTR :: INTERRUPT_REQUEST_IS , } } # [ doc = "Checks if the value of the field is `NO_INTERRUPT_REQUEST`" ] # [ inline ] pub fn is_no_interrupt_request ( & self ) -> bool { * self == INTR :: NO_INTERRUPT_REQUEST } # [ doc = "Checks if the value of the field is `INTERRUPT_REQUEST_IS`" ] # [ inline ] pub fn is_interrupt_request_is ( & self ) -> bool { * self == INTR :: INTERRUPT_REQUEST_IS } } # [ doc = "Possible values of the field `COMB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMBR { # [ doc = "OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity)." ] OR_FUNCTIONALITY_A_ , # [ doc = "AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity)." ] AND_FUNCTIONALITY_A } impl COMBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMBR :: OR_FUNCTIONALITY_A_ => false , COMBR :: AND_FUNCTIONALITY_A => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMBR { match value { false => COMBR :: OR_FUNCTIONALITY_A_ , true => COMBR :: AND_FUNCTIONALITY_A , } } # [ doc = "Checks if the value of the field is `OR_FUNCTIONALITY_A_`" ] # [ inline ] pub fn is_or_functionality_a_ ( & self ) -> bool { * self == COMBR :: OR_FUNCTIONALITY_A_ } # [ doc = "Checks if the value of the field is `AND_FUNCTIONALITY_A`" ] # [ inline ] pub fn is_and_functionality_a ( & self ) -> bool { * self == COMBR :: AND_FUNCTIONALITY_A } } # [ doc = "Possible values of the field `TRIG`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TRIGR { # [ doc = "Edge-triggered" ] EDGE_TRIGGERED , # [ doc = "Level-triggered" ] LEVEL_TRIGGERED } impl TRIGR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TRIGR :: EDGE_TRIGGERED => false , TRIGR :: LEVEL_TRIGGERED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TRIGR { match value { false => TRIGR :: EDGE_TRIGGERED , true => TRIGR :: LEVEL_TRIGGERED , } } # [ doc = "Checks if the value of the field is `EDGE_TRIGGERED`" ] # [ inline ] pub fn is_edge_triggered ( & self ) -> bool { * self == TRIGR :: EDGE_TRIGGERED } # [ doc = "Checks if the value of the field is `LEVEL_TRIGGERED`" ] # [ inline ] pub fn is_level_triggered ( & self ) -> bool { * self == TRIGR :: LEVEL_TRIGGERED } } # [ doc = "Values that can be written to the field `INT`" ] pub enum INTW { # [ doc = "No interrupt request is pending." ] NO_INTERRUPT_REQUEST , # [ doc = "Interrupt request is active." ] INTERRUPT_REQUEST_IS } impl INTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INTW :: NO_INTERRUPT_REQUEST => false , INTW :: INTERRUPT_REQUEST_IS => true } } } # [ doc = r" Proxy" ] pub struct _INTW < 'a > { w : & 'a mut W , } impl < 'a > _INTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No interrupt request is pending." ] # [ inline ] pub fn no_interrupt_request ( self ) -> & 'a mut W { self . variant ( INTW :: NO_INTERRUPT_REQUEST ) } # [ doc = "Interrupt request is active." ] # [ inline ] pub fn interrupt_request_is ( self ) -> & 'a mut W { self . variant ( INTW :: INTERRUPT_REQUEST_IS ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMB`" ] pub enum COMBW { # [ doc = "OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity)." ] OR_FUNCTIONALITY_A_ , # [ doc = "AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity)." ] AND_FUNCTIONALITY_A } impl COMBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMBW :: OR_FUNCTIONALITY_A_ => false , COMBW :: AND_FUNCTIONALITY_A => true } } } # [ doc = r" Proxy" ] pub struct _COMBW < 'a > { w : & 'a mut W , } impl < 'a > _COMBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity)." ] # [ inline ] pub fn or_functionality_a_ ( self ) -> & 'a mut W { self . variant ( COMBW :: OR_FUNCTIONALITY_A_ ) } # [ doc = "AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity)." ] # [ inline ] pub fn and_functionality_a ( self ) -> & 'a mut W { self . variant ( COMBW :: AND_FUNCTIONALITY_A ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `TRIG`" ] pub enum TRIGW { # [ doc = "Edge-triggered" ] EDGE_TRIGGERED , # [ doc = "Level-triggered" ] LEVEL_TRIGGERED } impl TRIGW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TRIGW :: EDGE_TRIGGERED => false , TRIGW :: LEVEL_TRIGGERED => true } } } # [ doc = r" Proxy" ] pub struct _TRIGW < 'a > { w : & 'a mut W , } impl < 'a > _TRIGW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TRIGW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Edge-triggered" ] # [ inline ] pub fn edge_triggered ( self ) -> & 'a mut W { self . variant ( TRIGW :: EDGE_TRIGGERED ) } # [ doc = "Level-triggered" ] # [ inline ] pub fn level_triggered ( self ) -> & 'a mut W { self . variant ( TRIGW :: LEVEL_TRIGGERED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Group interrupt status. This bit is cleared by writing a one to it. Writing zero has no effect." ] # [ inline ] pub fn int ( & self ) -> INTR { INTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Combine enabled inputs for group interrupt" ] # [ inline ] pub fn comb ( & self ) -> COMBR { COMBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Group interrupt trigger" ] # [ inline ] pub fn trig ( & self ) -> TRIGR { TRIGR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Group interrupt status. This bit is cleared by writing a one to it. Writing zero has no effect." ] # [ inline ] pub fn int ( & mut self ) -> _INTW { _INTW { w : self } } # [ doc = "Bit 1 - Combine enabled inputs for group interrupt" ] # [ inline ] pub fn comb ( & mut self ) -> _COMBW { _COMBW { w : self } } # [ doc = "Bit 2 - Group interrupt trigger" ] # [ inline ] pub fn trig ( & mut self ) -> _TRIGW { _TRIGW { w : self } } } } # [ doc = "GPIO grouped interrupt port 0 polarity register" ] pub struct PORT_POL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "GPIO grouped interrupt port 0 polarity register" ] pub mod port_pol { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PORT_POL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct POL_0R { bits : bool , } impl POL_0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_1R { bits : bool , } impl POL_1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_2R { bits : bool , } impl POL_2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_3R { bits : bool , } impl POL_3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_4R { bits : bool , } impl POL_4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_5R { bits : bool , } impl POL_5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_6R { bits : bool , } impl POL_6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_7R { bits : bool , } impl POL_7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_8R { bits : bool , } impl POL_8R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_9R { bits : bool , } impl POL_9R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_10R { bits : bool , } impl POL_10R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_11R { bits : bool , } impl POL_11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_12R { bits : bool , } impl POL_12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_13R { bits : bool , } impl POL_13R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_14R { bits : bool , } impl POL_14R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_15R { bits : bool , } impl POL_15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_16R { bits : bool , } impl POL_16R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_17R { bits : bool , } impl POL_17R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_18R { bits : bool , } impl POL_18R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_19R { bits : bool , } impl POL_19R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_20R { bits : bool , } impl POL_20R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_21R { bits : bool , } impl POL_21R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_22R { bits : bool , } impl POL_22R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_23R { bits : bool , } impl POL_23R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_24R { bits : bool , } impl POL_24R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_25R { bits : bool , } impl POL_25R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_26R { bits : bool , } impl POL_26R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_27R { bits : bool , } impl POL_27R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_28R { bits : bool , } impl POL_28R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_29R { bits : bool , } impl POL_29R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_30R { bits : bool , } impl POL_30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct POL_31R { bits : bool , } impl POL_31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _POL_0W < 'a > { w : & 'a mut W , } impl < 'a > _POL_0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_1W < 'a > { w : & 'a mut W , } impl < 'a > _POL_1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_2W < 'a > { w : & 'a mut W , } impl < 'a > _POL_2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_3W < 'a > { w : & 'a mut W , } impl < 'a > _POL_3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_4W < 'a > { w : & 'a mut W , } impl < 'a > _POL_4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_5W < 'a > { w : & 'a mut W , } impl < 'a > _POL_5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_6W < 'a > { w : & 'a mut W , } impl < 'a > _POL_6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_7W < 'a > { w : & 'a mut W , } impl < 'a > _POL_7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_8W < 'a > { w : & 'a mut W , } impl < 'a > _POL_8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_9W < 'a > { w : & 'a mut W , } impl < 'a > _POL_9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_10W < 'a > { w : & 'a mut W , } impl < 'a > _POL_10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_11W < 'a > { w : & 'a mut W , } impl < 'a > _POL_11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_12W < 'a > { w : & 'a mut W , } impl < 'a > _POL_12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_13W < 'a > { w : & 'a mut W , } impl < 'a > _POL_13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_14W < 'a > { w : & 'a mut W , } impl < 'a > _POL_14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_15W < 'a > { w : & 'a mut W , } impl < 'a > _POL_15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_16W < 'a > { w : & 'a mut W , } impl < 'a > _POL_16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_17W < 'a > { w : & 'a mut W , } impl < 'a > _POL_17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_18W < 'a > { w : & 'a mut W , } impl < 'a > _POL_18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_19W < 'a > { w : & 'a mut W , } impl < 'a > _POL_19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_20W < 'a > { w : & 'a mut W , } impl < 'a > _POL_20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_21W < 'a > { w : & 'a mut W , } impl < 'a > _POL_21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_22W < 'a > { w : & 'a mut W , } impl < 'a > _POL_22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_23W < 'a > { w : & 'a mut W , } impl < 'a > _POL_23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_24W < 'a > { w : & 'a mut W , } impl < 'a > _POL_24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_25W < 'a > { w : & 'a mut W , } impl < 'a > _POL_25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_26W < 'a > { w : & 'a mut W , } impl < 'a > _POL_26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_27W < 'a > { w : & 'a mut W , } impl < 'a > _POL_27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_28W < 'a > { w : & 'a mut W , } impl < 'a > _POL_28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_29W < 'a > { w : & 'a mut W , } impl < 'a > _POL_29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_30W < 'a > { w : & 'a mut W , } impl < 'a > _POL_30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _POL_31W < 'a > { w : & 'a mut W , } impl < 'a > _POL_31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Configure pin polarity of port pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1 . 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_0 ( & self ) -> POL_0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_0R { bits } } # [ doc = "Bit 1 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_1 ( & self ) -> POL_1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_1R { bits } } # [ doc = "Bit 2 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_2 ( & self ) -> POL_2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_2R { bits } } # [ doc = "Bit 3 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_3 ( & self ) -> POL_3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_3R { bits } } # [ doc = "Bit 4 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_4 ( & self ) -> POL_4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_4R { bits } } # [ doc = "Bit 5 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_5 ( & self ) -> POL_5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_5R { bits } } # [ doc = "Bit 6 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_6 ( & self ) -> POL_6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_6R { bits } } # [ doc = "Bit 7 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_7 ( & self ) -> POL_7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_7R { bits } } # [ doc = "Bit 8 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_8 ( & self ) -> POL_8R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_8R { bits } } # [ doc = "Bit 9 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_9 ( & self ) -> POL_9R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_9R { bits } } # [ doc = "Bit 10 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_10 ( & self ) -> POL_10R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_10R { bits } } # [ doc = "Bit 11 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_11 ( & self ) -> POL_11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_11R { bits } } # [ doc = "Bit 12 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_12 ( & self ) -> POL_12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_12R { bits } } # [ doc = "Bit 13 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_13 ( & self ) -> POL_13R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_13R { bits } } # [ doc = "Bit 14 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_14 ( & self ) -> POL_14R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_14R { bits } } # [ doc = "Bit 15 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_15 ( & self ) -> POL_15R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_15R { bits } } # [ doc = "Bit 16 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_16 ( & self ) -> POL_16R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_16R { bits } } # [ doc = "Bit 17 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_17 ( & self ) -> POL_17R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_17R { bits } } # [ doc = "Bit 18 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_18 ( & self ) -> POL_18R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_18R { bits } } # [ doc = "Bit 19 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_19 ( & self ) -> POL_19R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_19R { bits } } # [ doc = "Bit 20 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_20 ( & self ) -> POL_20R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_20R { bits } } # [ doc = "Bit 21 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_21 ( & self ) -> POL_21R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_21R { bits } } # [ doc = "Bit 22 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_22 ( & self ) -> POL_22R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_22R { bits } } # [ doc = "Bit 23 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_23 ( & self ) -> POL_23R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_23R { bits } } # [ doc = "Bit 24 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_24 ( & self ) -> POL_24R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_24R { bits } } # [ doc = "Bit 25 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_25 ( & self ) -> POL_25R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_25R { bits } } # [ doc = "Bit 26 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_26 ( & self ) -> POL_26R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_26R { bits } } # [ doc = "Bit 27 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_27 ( & self ) -> POL_27R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_27R { bits } } # [ doc = "Bit 28 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_28 ( & self ) -> POL_28R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_28R { bits } } # [ doc = "Bit 29 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_29 ( & self ) -> POL_29R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_29R { bits } } # [ doc = "Bit 30 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_30 ( & self ) -> POL_30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_30R { bits } } # [ doc = "Bit 31 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_31 ( & self ) -> POL_31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; POL_31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Configure pin polarity of port pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1 . 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_0 ( & mut self ) -> _POL_0W { _POL_0W { w : self } } # [ doc = "Bit 1 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_1 ( & mut self ) -> _POL_1W { _POL_1W { w : self } } # [ doc = "Bit 2 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_2 ( & mut self ) -> _POL_2W { _POL_2W { w : self } } # [ doc = "Bit 3 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_3 ( & mut self ) -> _POL_3W { _POL_3W { w : self } } # [ doc = "Bit 4 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_4 ( & mut self ) -> _POL_4W { _POL_4W { w : self } } # [ doc = "Bit 5 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_5 ( & mut self ) -> _POL_5W { _POL_5W { w : self } } # [ doc = "Bit 6 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_6 ( & mut self ) -> _POL_6W { _POL_6W { w : self } } # [ doc = "Bit 7 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_7 ( & mut self ) -> _POL_7W { _POL_7W { w : self } } # [ doc = "Bit 8 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_8 ( & mut self ) -> _POL_8W { _POL_8W { w : self } } # [ doc = "Bit 9 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_9 ( & mut self ) -> _POL_9W { _POL_9W { w : self } } # [ doc = "Bit 10 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_10 ( & mut self ) -> _POL_10W { _POL_10W { w : self } } # [ doc = "Bit 11 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_11 ( & mut self ) -> _POL_11W { _POL_11W { w : self } } # [ doc = "Bit 12 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_12 ( & mut self ) -> _POL_12W { _POL_12W { w : self } } # [ doc = "Bit 13 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_13 ( & mut self ) -> _POL_13W { _POL_13W { w : self } } # [ doc = "Bit 14 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_14 ( & mut self ) -> _POL_14W { _POL_14W { w : self } } # [ doc = "Bit 15 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_15 ( & mut self ) -> _POL_15W { _POL_15W { w : self } } # [ doc = "Bit 16 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_16 ( & mut self ) -> _POL_16W { _POL_16W { w : self } } # [ doc = "Bit 17 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_17 ( & mut self ) -> _POL_17W { _POL_17W { w : self } } # [ doc = "Bit 18 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_18 ( & mut self ) -> _POL_18W { _POL_18W { w : self } } # [ doc = "Bit 19 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_19 ( & mut self ) -> _POL_19W { _POL_19W { w : self } } # [ doc = "Bit 20 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_20 ( & mut self ) -> _POL_20W { _POL_20W { w : self } } # [ doc = "Bit 21 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_21 ( & mut self ) -> _POL_21W { _POL_21W { w : self } } # [ doc = "Bit 22 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_22 ( & mut self ) -> _POL_22W { _POL_22W { w : self } } # [ doc = "Bit 23 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_23 ( & mut self ) -> _POL_23W { _POL_23W { w : self } } # [ doc = "Bit 24 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_24 ( & mut self ) -> _POL_24W { _POL_24W { w : self } } # [ doc = "Bit 25 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_25 ( & mut self ) -> _POL_25W { _POL_25W { w : self } } # [ doc = "Bit 26 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_26 ( & mut self ) -> _POL_26W { _POL_26W { w : self } } # [ doc = "Bit 27 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_27 ( & mut self ) -> _POL_27W { _POL_27W { w : self } } # [ doc = "Bit 28 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_28 ( & mut self ) -> _POL_28W { _POL_28W { w : self } } # [ doc = "Bit 29 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_29 ( & mut self ) -> _POL_29W { _POL_29W { w : self } } # [ doc = "Bit 30 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_30 ( & mut self ) -> _POL_30W { _POL_30W { w : self } } # [ doc = "Bit 31 - Configure pin polarity of port 0/1 pins for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt." ] # [ inline ] pub fn pol_31 ( & mut self ) -> _POL_31W { _POL_31W { w : self } } } } # [ doc = "GPIO grouped interrupt port 0/1 enable register" ] pub struct PORT_ENA { register : :: vcell :: VolatileCell < u32 > } # [ doc = "GPIO grouped interrupt port 0/1 enable register" ] pub mod port_ena { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PORT_ENA { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ENA_0R { bits : bool , } impl ENA_0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_1R { bits : bool , } impl ENA_1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_2R { bits : bool , } impl ENA_2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_3R { bits : bool , } impl ENA_3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_4R { bits : bool , } impl ENA_4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_5R { bits : bool , } impl ENA_5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_6R { bits : bool , } impl ENA_6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_7R { bits : bool , } impl ENA_7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_8R { bits : bool , } impl ENA_8R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_9R { bits : bool , } impl ENA_9R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_10R { bits : bool , } impl ENA_10R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_11R { bits : bool , } impl ENA_11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_12R { bits : bool , } impl ENA_12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_13R { bits : bool , } impl ENA_13R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_14R { bits : bool , } impl ENA_14R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_15R { bits : bool , } impl ENA_15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_16R { bits : bool , } impl ENA_16R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_17R { bits : bool , } impl ENA_17R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_18R { bits : bool , } impl ENA_18R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_19R { bits : bool , } impl ENA_19R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_20R { bits : bool , } impl ENA_20R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_21R { bits : bool , } impl ENA_21R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_22R { bits : bool , } impl ENA_22R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_23R { bits : bool , } impl ENA_23R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_24R { bits : bool , } impl ENA_24R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_25R { bits : bool , } impl ENA_25R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_26R { bits : bool , } impl ENA_26R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_27R { bits : bool , } impl ENA_27R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_28R { bits : bool , } impl ENA_28R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_29R { bits : bool , } impl ENA_29R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_30R { bits : bool , } impl ENA_30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ENA_31R { bits : bool , } impl ENA_31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _ENA_0W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_1W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_2W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_3W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_4W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_5W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_6W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_7W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_8W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_9W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_10W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_11W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_12W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_13W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_14W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_15W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_16W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_17W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_18W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_19W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_20W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_21W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_22W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_23W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_24W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_25W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_26W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_27W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_28W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_29W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_30W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ENA_31W < 'a > { w : & 'a mut W , } impl < 'a > _ENA_31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_0 ( & self ) -> ENA_0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_0R { bits } } # [ doc = "Bit 1 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_1 ( & self ) -> ENA_1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_1R { bits } } # [ doc = "Bit 2 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_2 ( & self ) -> ENA_2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_2R { bits } } # [ doc = "Bit 3 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_3 ( & self ) -> ENA_3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_3R { bits } } # [ doc = "Bit 4 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_4 ( & self ) -> ENA_4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_4R { bits } } # [ doc = "Bit 5 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_5 ( & self ) -> ENA_5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_5R { bits } } # [ doc = "Bit 6 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_6 ( & self ) -> ENA_6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_6R { bits } } # [ doc = "Bit 7 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_7 ( & self ) -> ENA_7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_7R { bits } } # [ doc = "Bit 8 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_8 ( & self ) -> ENA_8R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_8R { bits } } # [ doc = "Bit 9 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_9 ( & self ) -> ENA_9R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_9R { bits } } # [ doc = "Bit 10 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_10 ( & self ) -> ENA_10R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_10R { bits } } # [ doc = "Bit 11 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_11 ( & self ) -> ENA_11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_11R { bits } } # [ doc = "Bit 12 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_12 ( & self ) -> ENA_12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_12R { bits } } # [ doc = "Bit 13 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_13 ( & self ) -> ENA_13R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_13R { bits } } # [ doc = "Bit 14 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_14 ( & self ) -> ENA_14R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_14R { bits } } # [ doc = "Bit 15 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_15 ( & self ) -> ENA_15R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_15R { bits } } # [ doc = "Bit 16 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_16 ( & self ) -> ENA_16R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_16R { bits } } # [ doc = "Bit 17 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_17 ( & self ) -> ENA_17R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_17R { bits } } # [ doc = "Bit 18 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_18 ( & self ) -> ENA_18R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_18R { bits } } # [ doc = "Bit 19 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_19 ( & self ) -> ENA_19R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_19R { bits } } # [ doc = "Bit 20 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_20 ( & self ) -> ENA_20R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_20R { bits } } # [ doc = "Bit 21 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_21 ( & self ) -> ENA_21R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_21R { bits } } # [ doc = "Bit 22 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_22 ( & self ) -> ENA_22R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_22R { bits } } # [ doc = "Bit 23 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_23 ( & self ) -> ENA_23R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_23R { bits } } # [ doc = "Bit 24 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_24 ( & self ) -> ENA_24R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_24R { bits } } # [ doc = "Bit 25 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_25 ( & self ) -> ENA_25R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_25R { bits } } # [ doc = "Bit 26 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_26 ( & self ) -> ENA_26R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_26R { bits } } # [ doc = "Bit 27 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_27 ( & self ) -> ENA_27R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_27R { bits } } # [ doc = "Bit 28 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_28 ( & self ) -> ENA_28R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_28R { bits } } # [ doc = "Bit 29 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_29 ( & self ) -> ENA_29R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_29R { bits } } # [ doc = "Bit 30 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_30 ( & self ) -> ENA_30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_30R { bits } } # [ doc = "Bit 31 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_31 ( & self ) -> ENA_31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ENA_31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_0 ( & mut self ) -> _ENA_0W { _ENA_0W { w : self } } # [ doc = "Bit 1 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_1 ( & mut self ) -> _ENA_1W { _ENA_1W { w : self } } # [ doc = "Bit 2 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_2 ( & mut self ) -> _ENA_2W { _ENA_2W { w : self } } # [ doc = "Bit 3 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_3 ( & mut self ) -> _ENA_3W { _ENA_3W { w : self } } # [ doc = "Bit 4 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_4 ( & mut self ) -> _ENA_4W { _ENA_4W { w : self } } # [ doc = "Bit 5 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_5 ( & mut self ) -> _ENA_5W { _ENA_5W { w : self } } # [ doc = "Bit 6 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_6 ( & mut self ) -> _ENA_6W { _ENA_6W { w : self } } # [ doc = "Bit 7 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_7 ( & mut self ) -> _ENA_7W { _ENA_7W { w : self } } # [ doc = "Bit 8 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_8 ( & mut self ) -> _ENA_8W { _ENA_8W { w : self } } # [ doc = "Bit 9 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_9 ( & mut self ) -> _ENA_9W { _ENA_9W { w : self } } # [ doc = "Bit 10 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_10 ( & mut self ) -> _ENA_10W { _ENA_10W { w : self } } # [ doc = "Bit 11 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_11 ( & mut self ) -> _ENA_11W { _ENA_11W { w : self } } # [ doc = "Bit 12 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_12 ( & mut self ) -> _ENA_12W { _ENA_12W { w : self } } # [ doc = "Bit 13 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_13 ( & mut self ) -> _ENA_13W { _ENA_13W { w : self } } # [ doc = "Bit 14 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_14 ( & mut self ) -> _ENA_14W { _ENA_14W { w : self } } # [ doc = "Bit 15 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_15 ( & mut self ) -> _ENA_15W { _ENA_15W { w : self } } # [ doc = "Bit 16 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_16 ( & mut self ) -> _ENA_16W { _ENA_16W { w : self } } # [ doc = "Bit 17 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_17 ( & mut self ) -> _ENA_17W { _ENA_17W { w : self } } # [ doc = "Bit 18 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_18 ( & mut self ) -> _ENA_18W { _ENA_18W { w : self } } # [ doc = "Bit 19 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_19 ( & mut self ) -> _ENA_19W { _ENA_19W { w : self } } # [ doc = "Bit 20 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_20 ( & mut self ) -> _ENA_20W { _ENA_20W { w : self } } # [ doc = "Bit 21 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_21 ( & mut self ) -> _ENA_21W { _ENA_21W { w : self } } # [ doc = "Bit 22 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_22 ( & mut self ) -> _ENA_22W { _ENA_22W { w : self } } # [ doc = "Bit 23 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_23 ( & mut self ) -> _ENA_23W { _ENA_23W { w : self } } # [ doc = "Bit 24 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_24 ( & mut self ) -> _ENA_24W { _ENA_24W { w : self } } # [ doc = "Bit 25 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_25 ( & mut self ) -> _ENA_25W { _ENA_25W { w : self } } # [ doc = "Bit 26 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_26 ( & mut self ) -> _ENA_26W { _ENA_26W { w : self } } # [ doc = "Bit 27 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_27 ( & mut self ) -> _ENA_27W { _ENA_27W { w : self } } # [ doc = "Bit 28 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_28 ( & mut self ) -> _ENA_28W { _ENA_28W { w : self } } # [ doc = "Bit 29 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_29 ( & mut self ) -> _ENA_29W { _ENA_29W { w : self } } # [ doc = "Bit 30 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_30 ( & mut self ) -> _ENA_30W { _ENA_30W { w : self } } # [ doc = "Bit 31 - Enable port 0/1 pin for group interrupt. Bit n corresponds to pin P0/1_n of port 0/1. 0 = the port 0/1 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0/1 pin is enabled and contributes to the grouped interrupt." ] # [ inline ] pub fn ena_31 ( & mut self ) -> _ENA_31W { _ENA_31W { w : self } } } } } # [ doc = "GPIO_GROUP_INT1" ] pub struct GPIO_GROUP_INT1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for GPIO_GROUP_INT1 { } impl GPIO_GROUP_INT1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const gpio_group_int0 :: RegisterBlock { 0x4006_0000 as * const _ } } impl Deref for GPIO_GROUP_INT1 { type Target = gpio_group_int0 :: RegisterBlock ; fn deref ( & self ) -> & gpio_group_int0 :: RegisterBlock { unsafe { & * GPIO_GROUP_INT1 :: ptr ( ) } } } # [ doc = "USB2.0 device controller" ] pub struct USB { _marker : PhantomData < * const ( ) > } unsafe impl Send for USB { } impl USB { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const usb :: RegisterBlock { 0x4008_0000 as * const _ } } impl Deref for USB { type Target = usb :: RegisterBlock ; fn deref ( & self ) -> & usb :: RegisterBlock { unsafe { & * USB :: ptr ( ) } } } # [ doc = "USB2.0 device controller" ] pub mod usb { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - USB Device Command/Status register" ] pub devcmdstat : DEVCMDSTAT , # [ doc = "0x04 - USB Info register" ] pub info : INFO , # [ doc = "0x08 - USB EP Command/Status List start address" ] pub epliststart : EPLISTSTART , # [ doc = "0x0c - USB Data buffer start address" ] pub databufstart : DATABUFSTART , # [ doc = "0x10 - Link Power Management register" ] pub lpm : LPM , # [ doc = "0x14 - USB Endpoint skip" ] pub epskip : EPSKIP , # [ doc = "0x18 - USB Endpoint Buffer in use" ] pub epinuse : EPINUSE , # [ doc = "0x1c - USB Endpoint Buffer Configuration register" ] pub epbufcfg : EPBUFCFG , # [ doc = "0x20 - USB interrupt status register" ] pub intstat : INTSTAT , # [ doc = "0x24 - USB interrupt enable register" ] pub inten : INTEN , # [ doc = "0x28 - USB set interrupt status register" ] pub intsetstat : INTSETSTAT , # [ doc = "0x2c - USB interrupt routing register" ] pub introuting : INTROUTING , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0x34 - USB Endpoint toggle register" ] pub eptoggle : EPTOGGLE , } # [ doc = "USB Device Command/Status register" ] pub struct DEVCMDSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB Device Command/Status register" ] pub mod devcmdstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DEVCMDSTAT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DEV_ADDRR { bits : u8 , } impl DEV_ADDRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct DEV_ENR { bits : bool , } impl DEV_ENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETUPR { bits : bool , } impl SETUPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Possible values of the field `PLL_ON`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PLL_ONR { # [ doc = "USB_NeedClk functional" ] USB_NEEDCLK_FUNCTION , # [ doc = "USB_NeedClk always 1. Clock will not be stopped in case of suspend." ] USB_NEEDCLK_ALWAYS_1 } impl PLL_ONR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PLL_ONR :: USB_NEEDCLK_FUNCTION => false , PLL_ONR :: USB_NEEDCLK_ALWAYS_1 => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PLL_ONR { match value { false => PLL_ONR :: USB_NEEDCLK_FUNCTION , true => PLL_ONR :: USB_NEEDCLK_ALWAYS_1 , } } # [ doc = "Checks if the value of the field is `USB_NEEDCLK_FUNCTION`" ] # [ inline ] pub fn is_usb_needclk_function ( & self ) -> bool { * self == PLL_ONR :: USB_NEEDCLK_FUNCTION } # [ doc = "Checks if the value of the field is `USB_NEEDCLK_ALWAYS_1`" ] # [ inline ] pub fn is_usb_needclk_always_1 ( & self ) -> bool { * self == PLL_ONR :: USB_NEEDCLK_ALWAYS_1 } } # [ doc = "Possible values of the field `LPM_SUP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LPM_SUPR { # [ doc = "LPM not supported." ] LPM_NOT_SUPPORTED_ , # [ doc = "LPM supported." ] LPM_SUPPORTED_ } impl LPM_SUPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LPM_SUPR :: LPM_NOT_SUPPORTED_ => false , LPM_SUPR :: LPM_SUPPORTED_ => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LPM_SUPR { match value { false => LPM_SUPR :: LPM_NOT_SUPPORTED_ , true => LPM_SUPR :: LPM_SUPPORTED_ , } } # [ doc = "Checks if the value of the field is `LPM_NOT_SUPPORTED_`" ] # [ inline ] pub fn is_lpm_not_supported_ ( & self ) -> bool { * self == LPM_SUPR :: LPM_NOT_SUPPORTED_ } # [ doc = "Checks if the value of the field is `LPM_SUPPORTED_`" ] # [ inline ] pub fn is_lpm_supported_ ( & self ) -> bool { * self == LPM_SUPR :: LPM_SUPPORTED_ } } # [ doc = "Possible values of the field `INTONNAK_AO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTONNAK_AOR { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_AOR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INTONNAK_AOR :: ACKNOW => false , INTONNAK_AOR :: ACKNOW_NAK => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INTONNAK_AOR { match value { false => INTONNAK_AOR :: ACKNOW , true => INTONNAK_AOR :: ACKNOW_NAK , } } # [ doc = "Checks if the value of the field is `ACKNOW`" ] # [ inline ] pub fn is_acknow ( & self ) -> bool { * self == INTONNAK_AOR :: ACKNOW } # [ doc = "Checks if the value of the field is `ACKNOW_NAK`" ] # [ inline ] pub fn is_acknow_nak ( & self ) -> bool { * self == INTONNAK_AOR :: ACKNOW_NAK } } # [ doc = "Possible values of the field `INTONNAK_AI`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTONNAK_AIR { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_AIR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INTONNAK_AIR :: ACKNOW => false , INTONNAK_AIR :: ACKNOW_NAK => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INTONNAK_AIR { match value { false => INTONNAK_AIR :: ACKNOW , true => INTONNAK_AIR :: ACKNOW_NAK , } } # [ doc = "Checks if the value of the field is `ACKNOW`" ] # [ inline ] pub fn is_acknow ( & self ) -> bool { * self == INTONNAK_AIR :: ACKNOW } # [ doc = "Checks if the value of the field is `ACKNOW_NAK`" ] # [ inline ] pub fn is_acknow_nak ( & self ) -> bool { * self == INTONNAK_AIR :: ACKNOW_NAK } } # [ doc = "Possible values of the field `INTONNAK_CO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTONNAK_COR { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_COR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INTONNAK_COR :: ACKNOW => false , INTONNAK_COR :: ACKNOW_NAK => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INTONNAK_COR { match value { false => INTONNAK_COR :: ACKNOW , true => INTONNAK_COR :: ACKNOW_NAK , } } # [ doc = "Checks if the value of the field is `ACKNOW`" ] # [ inline ] pub fn is_acknow ( & self ) -> bool { * self == INTONNAK_COR :: ACKNOW } # [ doc = "Checks if the value of the field is `ACKNOW_NAK`" ] # [ inline ] pub fn is_acknow_nak ( & self ) -> bool { * self == INTONNAK_COR :: ACKNOW_NAK } } # [ doc = "Possible values of the field `INTONNAK_CI`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTONNAK_CIR { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_CIR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INTONNAK_CIR :: ACKNOW => false , INTONNAK_CIR :: ACKNOW_NAK => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INTONNAK_CIR { match value { false => INTONNAK_CIR :: ACKNOW , true => INTONNAK_CIR :: ACKNOW_NAK , } } # [ doc = "Checks if the value of the field is `ACKNOW`" ] # [ inline ] pub fn is_acknow ( & self ) -> bool { * self == INTONNAK_CIR :: ACKNOW } # [ doc = "Checks if the value of the field is `ACKNOW_NAK`" ] # [ inline ] pub fn is_acknow_nak ( & self ) -> bool { * self == INTONNAK_CIR :: ACKNOW_NAK } } # [ doc = r" Value of the field" ] pub struct DCONR { bits : bool , } impl DCONR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DSUSR { bits : bool , } impl DSUSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct LPM_SUSR { bits : bool , } impl LPM_SUSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct LPM_REWPR { bits : bool , } impl LPM_REWPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DCON_CR { bits : bool , } impl DCON_CR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DSUS_CR { bits : bool , } impl DSUS_CR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DRES_CR { bits : bool , } impl DRES_CR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct VBUSDEBOUNCEDR { bits : bool , } impl VBUSDEBOUNCEDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _DEV_ADDRW < 'a > { w : & 'a mut W , } impl < 'a > _DEV_ADDRW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DEV_ENW < 'a > { w : & 'a mut W , } impl < 'a > _DEV_ENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETUPW < 'a > { w : & 'a mut W , } impl < 'a > _SETUPW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PLL_ON`" ] pub enum PLL_ONW { # [ doc = "USB_NeedClk functional" ] USB_NEEDCLK_FUNCTION , # [ doc = "USB_NeedClk always 1. Clock will not be stopped in case of suspend." ] USB_NEEDCLK_ALWAYS_1 } impl PLL_ONW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PLL_ONW :: USB_NEEDCLK_FUNCTION => false , PLL_ONW :: USB_NEEDCLK_ALWAYS_1 => true } } } # [ doc = r" Proxy" ] pub struct _PLL_ONW < 'a > { w : & 'a mut W , } impl < 'a > _PLL_ONW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PLL_ONW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "USB_NeedClk functional" ] # [ inline ] pub fn usb_needclk_function ( self ) -> & 'a mut W { self . variant ( PLL_ONW :: USB_NEEDCLK_FUNCTION ) } # [ doc = "USB_NeedClk always 1. Clock will not be stopped in case of suspend." ] # [ inline ] pub fn usb_needclk_always_1 ( self ) -> & 'a mut W { self . variant ( PLL_ONW :: USB_NEEDCLK_ALWAYS_1 ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `LPM_SUP`" ] pub enum LPM_SUPW { # [ doc = "LPM not supported." ] LPM_NOT_SUPPORTED_ , # [ doc = "LPM supported." ] LPM_SUPPORTED_ } impl LPM_SUPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { LPM_SUPW :: LPM_NOT_SUPPORTED_ => false , LPM_SUPW :: LPM_SUPPORTED_ => true } } } # [ doc = r" Proxy" ] pub struct _LPM_SUPW < 'a > { w : & 'a mut W , } impl < 'a > _LPM_SUPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : LPM_SUPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "LPM not supported." ] # [ inline ] pub fn lpm_not_supported_ ( self ) -> & 'a mut W { self . variant ( LPM_SUPW :: LPM_NOT_SUPPORTED_ ) } # [ doc = "LPM supported." ] # [ inline ] pub fn lpm_supported_ ( self ) -> & 'a mut W { self . variant ( LPM_SUPW :: LPM_SUPPORTED_ ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INTONNAK_AO`" ] pub enum INTONNAK_AOW { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_AOW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INTONNAK_AOW :: ACKNOW => false , INTONNAK_AOW :: ACKNOW_NAK => true } } } # [ doc = r" Proxy" ] pub struct _INTONNAK_AOW < 'a > { w : & 'a mut W , } impl < 'a > _INTONNAK_AOW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INTONNAK_AOW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Only acknowledged packets generate an interrupt" ] # [ inline ] pub fn acknow ( self ) -> & 'a mut W { self . variant ( INTONNAK_AOW :: ACKNOW ) } # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] # [ inline ] pub fn acknow_nak ( self ) -> & 'a mut W { self . variant ( INTONNAK_AOW :: ACKNOW_NAK ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INTONNAK_AI`" ] pub enum INTONNAK_AIW { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_AIW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INTONNAK_AIW :: ACKNOW => false , INTONNAK_AIW :: ACKNOW_NAK => true } } } # [ doc = r" Proxy" ] pub struct _INTONNAK_AIW < 'a > { w : & 'a mut W , } impl < 'a > _INTONNAK_AIW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INTONNAK_AIW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Only acknowledged packets generate an interrupt" ] # [ inline ] pub fn acknow ( self ) -> & 'a mut W { self . variant ( INTONNAK_AIW :: ACKNOW ) } # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] # [ inline ] pub fn acknow_nak ( self ) -> & 'a mut W { self . variant ( INTONNAK_AIW :: ACKNOW_NAK ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INTONNAK_CO`" ] pub enum INTONNAK_COW { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_COW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INTONNAK_COW :: ACKNOW => false , INTONNAK_COW :: ACKNOW_NAK => true } } } # [ doc = r" Proxy" ] pub struct _INTONNAK_COW < 'a > { w : & 'a mut W , } impl < 'a > _INTONNAK_COW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INTONNAK_COW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Only acknowledged packets generate an interrupt" ] # [ inline ] pub fn acknow ( self ) -> & 'a mut W { self . variant ( INTONNAK_COW :: ACKNOW ) } # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] # [ inline ] pub fn acknow_nak ( self ) -> & 'a mut W { self . variant ( INTONNAK_COW :: ACKNOW_NAK ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INTONNAK_CI`" ] pub enum INTONNAK_CIW { # [ doc = "Only acknowledged packets generate an interrupt" ] ACKNOW , # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] ACKNOW_NAK } impl INTONNAK_CIW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INTONNAK_CIW :: ACKNOW => false , INTONNAK_CIW :: ACKNOW_NAK => true } } } # [ doc = r" Proxy" ] pub struct _INTONNAK_CIW < 'a > { w : & 'a mut W , } impl < 'a > _INTONNAK_CIW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INTONNAK_CIW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Only acknowledged packets generate an interrupt" ] # [ inline ] pub fn acknow ( self ) -> & 'a mut W { self . variant ( INTONNAK_CIW :: ACKNOW ) } # [ doc = "Both acknowledged and NAKed packets generate interrupts." ] # [ inline ] pub fn acknow_nak ( self ) -> & 'a mut W { self . variant ( INTONNAK_CIW :: ACKNOW_NAK ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DCONW < 'a > { w : & 'a mut W , } impl < 'a > _DCONW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DSUSW < 'a > { w : & 'a mut W , } impl < 'a > _DSUSW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _LPM_SUSW < 'a > { w : & 'a mut W , } impl < 'a > _LPM_SUSW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _LPM_REWPW < 'a > { w : & 'a mut W , } impl < 'a > _LPM_REWPW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DCON_CW < 'a > { w : & 'a mut W , } impl < 'a > _DCON_CW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DSUS_CW < 'a > { w : & 'a mut W , } impl < 'a > _DSUS_CW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DRES_CW < 'a > { w : & 'a mut W , } impl < 'a > _DRES_CW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _VBUSDEBOUNCEDW < 'a > { w : & 'a mut W , } impl < 'a > _VBUSDEBOUNCEDW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:6 - USB device address. After bus reset, the address is reset to 0x00. If the enable bit is set, the device will respond on packets for function address DEV_ADDR. When receiving a SetAddress Control Request from the USB host, software must program the new address before completing the status phase of the SetAddress Control Request." ] # [ inline ] pub fn dev_addr ( & self ) -> DEV_ADDRR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DEV_ADDRR { bits } } # [ doc = "Bit 7 - USB device enable. If this bit is set, the HW will start responding on packets for function address DEV_ADDR." ] # [ inline ] pub fn dev_en ( & self ) -> DEV_ENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DEV_ENR { bits } } # [ doc = "Bit 8 - SETUP token received. If a SETUP token is received and acknowledged by the device, this bit is set. As long as this bit is set all received IN and OUT tokens will be NAKed by HW. SW must clear this bit by writing a one. If this bit is zero, HW will handle the tokens to the CTRL EP0 as indicated by the CTRL EP0 IN and OUT data information programmed by SW." ] # [ inline ] pub fn setup ( & self ) -> SETUPR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETUPR { bits } } # [ doc = "Bit 9 - Always PLL Clock on:" ] # [ inline ] pub fn pll_on ( & self ) -> PLL_ONR { PLL_ONR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - LPM Supported:" ] # [ inline ] pub fn lpm_sup ( & self ) -> LPM_SUPR { LPM_SUPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Interrupt on NAK for interrupt and bulk OUT EP" ] # [ inline ] pub fn intonnak_ao ( & self ) -> INTONNAK_AOR { INTONNAK_AOR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Interrupt on NAK for interrupt and bulk IN EP" ] # [ inline ] pub fn intonnak_ai ( & self ) -> INTONNAK_AIR { INTONNAK_AIR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Interrupt on NAK for control OUT EP" ] # [ inline ] pub fn intonnak_co ( & self ) -> INTONNAK_COR { INTONNAK_COR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Interrupt on NAK for control IN EP" ] # [ inline ] pub fn intonnak_ci ( & self ) -> INTONNAK_CIR { INTONNAK_CIR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Device status - connect. The connect bit must be set by SW to indicate that the device must signal a connect. The pull-up resistor on USB_DP will be enabled when this bit is set and the VbusDebounced bit is one." ] # [ inline ] pub fn dcon ( & self ) -> DCONR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DCONR { bits } } # [ doc = "Bit 17 - Device status - suspend. The suspend bit indicates the current suspend state. It is set to 1 when the device hasn't seen any activity on its upstream port for more than 3 milliseconds. It is reset to 0 on any activity. When the device is suspended (Suspend bit DSUS = 1) and the software writes a 0 to it, the device will generate a remote wake-up. This will only happen when the device is connected (Connect bit = 1). When the device is not connected or not suspended, a writing a 0 has no effect. Writing a 1 never has an effect." ] # [ inline ] pub fn dsus ( & self ) -> DSUSR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DSUSR { bits } } # [ doc = "Bit 19 - Device status - LPM Suspend. This bit represents the current LPM suspend state. It is set to 1 by HW when the device has acknowledged the LPM request from the USB host and the Token Retry Time of 10us has elapsed. When the device is in the LPM suspended state (LPM suspend bit = 1) and the software writes a zero to this bit, the device will generate a remote walk-up. Software can only write a zero to this bit when the LPM_REWP bit is set to 1. HW resets this bit when it receives a host initiated resume. HW only updates the LPM_SUS bit when the LPM_SUPP bit is equal to one." ] # [ inline ] pub fn lpm_sus ( & self ) -> LPM_SUSR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; LPM_SUSR { bits } } # [ doc = "Bit 20 - LPM Remote Wake-up Enabled by USB host. HW sets this bit to one when the bRemoteWake bit in the LPM extended token is set to 1. HW will reset this bit to 0 when it receives the host initiated LPM resume, when a remote wake-up is sent by the device or when a USB bus reset is received. Software can use this bit to check if the remote wake-up feature is enabled by the host for the LPM transaction." ] # [ inline ] pub fn lpm_rewp ( & self ) -> LPM_REWPR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; LPM_REWPR { bits } } # [ doc = "Bit 24 - Device status - connect change. The Connect Change bit is set when the device's pull-up resistor is disconnected because VBus disappeared. The bit is reset by writing a one to it." ] # [ inline ] pub fn dcon_c ( & self ) -> DCON_CR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DCON_CR { bits } } # [ doc = "Bit 25 - Device status - suspend change. The suspend change bit is set to 1 when the suspend bit toggles. The suspend bit can toggle because: - The device goes in the suspended state - The device is disconnected - The device receives resume signaling on its upstream port. The bit is reset by writing a one to it." ] # [ inline ] pub fn dsus_c ( & self ) -> DSUS_CR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DSUS_CR { bits } } # [ doc = "Bit 26 - Device status - reset change. This bit is set when the device received a bus reset. On a bus reset the device will automatically go to the default state (unconfigured and responding to address 0). The bit is reset by writing a one to it." ] # [ inline ] pub fn dres_c ( & self ) -> DRES_CR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DRES_CR { bits } } # [ doc = "Bit 28 - This bit indicates if Vbus is detected or not. The bit raises immediately when Vbus becomes high. It drops to zero if Vbus is low for at least 3 ms. If this bit is high and the DCon bit is set, the HW will enable the pull-up resistor to signal a connect." ] # [ inline ] pub fn vbusdebounced ( & self ) -> VBUSDEBOUNCEDR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; VBUSDEBOUNCEDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x0800 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:6 - USB device address. After bus reset, the address is reset to 0x00. If the enable bit is set, the device will respond on packets for function address DEV_ADDR. When receiving a SetAddress Control Request from the USB host, software must program the new address before completing the status phase of the SetAddress Control Request." ] # [ inline ] pub fn dev_addr ( & mut self ) -> _DEV_ADDRW { _DEV_ADDRW { w : self } } # [ doc = "Bit 7 - USB device enable. If this bit is set, the HW will start responding on packets for function address DEV_ADDR." ] # [ inline ] pub fn dev_en ( & mut self ) -> _DEV_ENW { _DEV_ENW { w : self } } # [ doc = "Bit 8 - SETUP token received. If a SETUP token is received and acknowledged by the device, this bit is set. As long as this bit is set all received IN and OUT tokens will be NAKed by HW. SW must clear this bit by writing a one. If this bit is zero, HW will handle the tokens to the CTRL EP0 as indicated by the CTRL EP0 IN and OUT data information programmed by SW." ] # [ inline ] pub fn setup ( & mut self ) -> _SETUPW { _SETUPW { w : self } } # [ doc = "Bit 9 - Always PLL Clock on:" ] # [ inline ] pub fn pll_on ( & mut self ) -> _PLL_ONW { _PLL_ONW { w : self } } # [ doc = "Bit 11 - LPM Supported:" ] # [ inline ] pub fn lpm_sup ( & mut self ) -> _LPM_SUPW { _LPM_SUPW { w : self } } # [ doc = "Bit 12 - Interrupt on NAK for interrupt and bulk OUT EP" ] # [ inline ] pub fn intonnak_ao ( & mut self ) -> _INTONNAK_AOW { _INTONNAK_AOW { w : self } } # [ doc = "Bit 13 - Interrupt on NAK for interrupt and bulk IN EP" ] # [ inline ] pub fn intonnak_ai ( & mut self ) -> _INTONNAK_AIW { _INTONNAK_AIW { w : self } } # [ doc = "Bit 14 - Interrupt on NAK for control OUT EP" ] # [ inline ] pub fn intonnak_co ( & mut self ) -> _INTONNAK_COW { _INTONNAK_COW { w : self } } # [ doc = "Bit 15 - Interrupt on NAK for control IN EP" ] # [ inline ] pub fn intonnak_ci ( & mut self ) -> _INTONNAK_CIW { _INTONNAK_CIW { w : self } } # [ doc = "Bit 16 - Device status - connect. The connect bit must be set by SW to indicate that the device must signal a connect. The pull-up resistor on USB_DP will be enabled when this bit is set and the VbusDebounced bit is one." ] # [ inline ] pub fn dcon ( & mut self ) -> _DCONW { _DCONW { w : self } } # [ doc = "Bit 17 - Device status - suspend. The suspend bit indicates the current suspend state. It is set to 1 when the device hasn't seen any activity on its upstream port for more than 3 milliseconds. It is reset to 0 on any activity. When the device is suspended (Suspend bit DSUS = 1) and the software writes a 0 to it, the device will generate a remote wake-up. This will only happen when the device is connected (Connect bit = 1). When the device is not connected or not suspended, a writing a 0 has no effect. Writing a 1 never has an effect." ] # [ inline ] pub fn dsus ( & mut self ) -> _DSUSW { _DSUSW { w : self } } # [ doc = "Bit 19 - Device status - LPM Suspend. This bit represents the current LPM suspend state. It is set to 1 by HW when the device has acknowledged the LPM request from the USB host and the Token Retry Time of 10us has elapsed. When the device is in the LPM suspended state (LPM suspend bit = 1) and the software writes a zero to this bit, the device will generate a remote walk-up. Software can only write a zero to this bit when the LPM_REWP bit is set to 1. HW resets this bit when it receives a host initiated resume. HW only updates the LPM_SUS bit when the LPM_SUPP bit is equal to one." ] # [ inline ] pub fn lpm_sus ( & mut self ) -> _LPM_SUSW { _LPM_SUSW { w : self } } # [ doc = "Bit 20 - LPM Remote Wake-up Enabled by USB host. HW sets this bit to one when the bRemoteWake bit in the LPM extended token is set to 1. HW will reset this bit to 0 when it receives the host initiated LPM resume, when a remote wake-up is sent by the device or when a USB bus reset is received. Software can use this bit to check if the remote wake-up feature is enabled by the host for the LPM transaction." ] # [ inline ] pub fn lpm_rewp ( & mut self ) -> _LPM_REWPW { _LPM_REWPW { w : self } } # [ doc = "Bit 24 - Device status - connect change. The Connect Change bit is set when the device's pull-up resistor is disconnected because VBus disappeared. The bit is reset by writing a one to it." ] # [ inline ] pub fn dcon_c ( & mut self ) -> _DCON_CW { _DCON_CW { w : self } } # [ doc = "Bit 25 - Device status - suspend change. The suspend change bit is set to 1 when the suspend bit toggles. The suspend bit can toggle because: - The device goes in the suspended state - The device is disconnected - The device receives resume signaling on its upstream port. The bit is reset by writing a one to it." ] # [ inline ] pub fn dsus_c ( & mut self ) -> _DSUS_CW { _DSUS_CW { w : self } } # [ doc = "Bit 26 - Device status - reset change. This bit is set when the device received a bus reset. On a bus reset the device will automatically go to the default state (unconfigured and responding to address 0). The bit is reset by writing a one to it." ] # [ inline ] pub fn dres_c ( & mut self ) -> _DRES_CW { _DRES_CW { w : self } } # [ doc = "Bit 28 - This bit indicates if Vbus is detected or not. The bit raises immediately when Vbus becomes high. It drops to zero if Vbus is low for at least 3 ms. If this bit is high and the DCon bit is set, the HW will enable the pull-up resistor to signal a connect." ] # [ inline ] pub fn vbusdebounced ( & mut self ) -> _VBUSDEBOUNCEDW { _VBUSDEBOUNCEDW { w : self } } } } # [ doc = "USB Info register" ] pub struct INFO { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB Info register" ] pub mod info { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INFO { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct FRAME_NRR { bits : u16 , } impl FRAME_NRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = "Possible values of the field `ERR_CODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERR_CODER { # [ doc = "No error" ] NO_ERROR , # [ doc = "PID encoding error" ] PID_ENCODING_ERROR , # [ doc = "PID unknown" ] PID_UNKNOWN , # [ doc = "Packet unexpected" ] PACKET_UNEXPECTED , # [ doc = "Token CRC error" ] TOKEN_CRC_ERROR , # [ doc = "Data CRC error" ] DATA_CRC_ERROR , # [ doc = "Time out" ] TIME_OUT , # [ doc = "Babble" ] BABBLE , # [ doc = "Truncated EOP" ] TRUNCATED_EOP , # [ doc = "Sent/Received NAK" ] SENTRECEIVED_NAK , # [ doc = "Sent Stall" ] SENT_STALL , # [ doc = "Overrun" ] OVERRUN , # [ doc = "Sent empty packet" ] SENT_EMPTY_PACKET , # [ doc = "Bitstuff error" ] BITSTUFF_ERROR , # [ doc = "Sync error" ] SYNC_ERROR , # [ doc = "Wrong data toggle" ] WRONG_DATA_TOGGLE } impl ERR_CODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ERR_CODER :: NO_ERROR => 0 , ERR_CODER :: PID_ENCODING_ERROR => 0x01 , ERR_CODER :: PID_UNKNOWN => 0x02 , ERR_CODER :: PACKET_UNEXPECTED => 0x03 , ERR_CODER :: TOKEN_CRC_ERROR => 0x04 , ERR_CODER :: DATA_CRC_ERROR => 0x05 , ERR_CODER :: TIME_OUT => 0x06 , ERR_CODER :: BABBLE => 0x07 , ERR_CODER :: TRUNCATED_EOP => 0x08 , ERR_CODER :: SENTRECEIVED_NAK => 0x09 , ERR_CODER :: SENT_STALL => 0x0a , ERR_CODER :: OVERRUN => 0x0b , ERR_CODER :: SENT_EMPTY_PACKET => 0x0c , ERR_CODER :: BITSTUFF_ERROR => 0x0d , ERR_CODER :: SYNC_ERROR => 0x0e , ERR_CODER :: WRONG_DATA_TOGGLE => 0x0f } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ERR_CODER { match value { 0 => ERR_CODER :: NO_ERROR , 1 => ERR_CODER :: PID_ENCODING_ERROR , 2 => ERR_CODER :: PID_UNKNOWN , 3 => ERR_CODER :: PACKET_UNEXPECTED , 4 => ERR_CODER :: TOKEN_CRC_ERROR , 5 => ERR_CODER :: DATA_CRC_ERROR , 6 => ERR_CODER :: TIME_OUT , 7 => ERR_CODER :: BABBLE , 8 => ERR_CODER :: TRUNCATED_EOP , 9 => ERR_CODER :: SENTRECEIVED_NAK , 10 => ERR_CODER :: SENT_STALL , 11 => ERR_CODER :: OVERRUN , 12 => ERR_CODER :: SENT_EMPTY_PACKET , 13 => ERR_CODER :: BITSTUFF_ERROR , 14 => ERR_CODER :: SYNC_ERROR , 15 => ERR_CODER :: WRONG_DATA_TOGGLE , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `NO_ERROR`" ] # [ inline ] pub fn is_no_error ( & self ) -> bool { * self == ERR_CODER :: NO_ERROR } # [ doc = "Checks if the value of the field is `PID_ENCODING_ERROR`" ] # [ inline ] pub fn is_pid_encoding_error ( & self ) -> bool { * self == ERR_CODER :: PID_ENCODING_ERROR } # [ doc = "Checks if the value of the field is `PID_UNKNOWN`" ] # [ inline ] pub fn is_pid_unknown ( & self ) -> bool { * self == ERR_CODER :: PID_UNKNOWN } # [ doc = "Checks if the value of the field is `PACKET_UNEXPECTED`" ] # [ inline ] pub fn is_packet_unexpected ( & self ) -> bool { * self == ERR_CODER :: PACKET_UNEXPECTED } # [ doc = "Checks if the value of the field is `TOKEN_CRC_ERROR`" ] # [ inline ] pub fn is_token_crc_error ( & self ) -> bool { * self == ERR_CODER :: TOKEN_CRC_ERROR } # [ doc = "Checks if the value of the field is `DATA_CRC_ERROR`" ] # [ inline ] pub fn is_data_crc_error ( & self ) -> bool { * self == ERR_CODER :: DATA_CRC_ERROR } # [ doc = "Checks if the value of the field is `TIME_OUT`" ] # [ inline ] pub fn is_time_out ( & self ) -> bool { * self == ERR_CODER :: TIME_OUT } # [ doc = "Checks if the value of the field is `BABBLE`" ] # [ inline ] pub fn is_babble ( & self ) -> bool { * self == ERR_CODER :: BABBLE } # [ doc = "Checks if the value of the field is `TRUNCATED_EOP`" ] # [ inline ] pub fn is_truncated_eop ( & self ) -> bool { * self == ERR_CODER :: TRUNCATED_EOP } # [ doc = "Checks if the value of the field is `SENTRECEIVED_NAK`" ] # [ inline ] pub fn is_sentreceived_nak ( & self ) -> bool { * self == ERR_CODER :: SENTRECEIVED_NAK } # [ doc = "Checks if the value of the field is `SENT_STALL`" ] # [ inline ] pub fn is_sent_stall ( & self ) -> bool { * self == ERR_CODER :: SENT_STALL } # [ doc = "Checks if the value of the field is `OVERRUN`" ] # [ inline ] pub fn is_overrun ( & self ) -> bool { * self == ERR_CODER :: OVERRUN } # [ doc = "Checks if the value of the field is `SENT_EMPTY_PACKET`" ] # [ inline ] pub fn is_sent_empty_packet ( & self ) -> bool { * self == ERR_CODER :: SENT_EMPTY_PACKET } # [ doc = "Checks if the value of the field is `BITSTUFF_ERROR`" ] # [ inline ] pub fn is_bitstuff_error ( & self ) -> bool { * self == ERR_CODER :: BITSTUFF_ERROR } # [ doc = "Checks if the value of the field is `SYNC_ERROR`" ] # [ inline ] pub fn is_sync_error ( & self ) -> bool { * self == ERR_CODER :: SYNC_ERROR } # [ doc = "Checks if the value of the field is `WRONG_DATA_TOGGLE`" ] # [ inline ] pub fn is_wrong_data_toggle ( & self ) -> bool { * self == ERR_CODER :: WRONG_DATA_TOGGLE } } # [ doc = r" Proxy" ] pub struct _FRAME_NRW < 'a > { w : & 'a mut W , } impl < 'a > _FRAME_NRW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x07ff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERR_CODE`" ] pub enum ERR_CODEW { # [ doc = "No error" ] NO_ERROR , # [ doc = "PID encoding error" ] PID_ENCODING_ERROR , # [ doc = "PID unknown" ] PID_UNKNOWN , # [ doc = "Packet unexpected" ] PACKET_UNEXPECTED , # [ doc = "Token CRC error" ] TOKEN_CRC_ERROR , # [ doc = "Data CRC error" ] DATA_CRC_ERROR , # [ doc = "Time out" ] TIME_OUT , # [ doc = "Babble" ] BABBLE , # [ doc = "Truncated EOP" ] TRUNCATED_EOP , # [ doc = "Sent/Received NAK" ] SENTRECEIVED_NAK , # [ doc = "Sent Stall" ] SENT_STALL , # [ doc = "Overrun" ] OVERRUN , # [ doc = "Sent empty packet" ] SENT_EMPTY_PACKET , # [ doc = "Bitstuff error" ] BITSTUFF_ERROR , # [ doc = "Sync error" ] SYNC_ERROR , # [ doc = "Wrong data toggle" ] WRONG_DATA_TOGGLE } impl ERR_CODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ERR_CODEW :: NO_ERROR => 0 , ERR_CODEW :: PID_ENCODING_ERROR => 1 , ERR_CODEW :: PID_UNKNOWN => 2 , ERR_CODEW :: PACKET_UNEXPECTED => 3 , ERR_CODEW :: TOKEN_CRC_ERROR => 4 , ERR_CODEW :: DATA_CRC_ERROR => 5 , ERR_CODEW :: TIME_OUT => 6 , ERR_CODEW :: BABBLE => 7 , ERR_CODEW :: TRUNCATED_EOP => 8 , ERR_CODEW :: SENTRECEIVED_NAK => 9 , ERR_CODEW :: SENT_STALL => 10 , ERR_CODEW :: OVERRUN => 11 , ERR_CODEW :: SENT_EMPTY_PACKET => 12 , ERR_CODEW :: BITSTUFF_ERROR => 13 , ERR_CODEW :: SYNC_ERROR => 14 , ERR_CODEW :: WRONG_DATA_TOGGLE => 15 } } } # [ doc = r" Proxy" ] pub struct _ERR_CODEW < 'a > { w : & 'a mut W , } impl < 'a > _ERR_CODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERR_CODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "No error" ] # [ inline ] pub fn no_error ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: NO_ERROR ) } # [ doc = "PID encoding error" ] # [ inline ] pub fn pid_encoding_error ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: PID_ENCODING_ERROR ) } # [ doc = "PID unknown" ] # [ inline ] pub fn pid_unknown ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: PID_UNKNOWN ) } # [ doc = "Packet unexpected" ] # [ inline ] pub fn packet_unexpected ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: PACKET_UNEXPECTED ) } # [ doc = "Token CRC error" ] # [ inline ] pub fn token_crc_error ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: TOKEN_CRC_ERROR ) } # [ doc = "Data CRC error" ] # [ inline ] pub fn data_crc_error ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: DATA_CRC_ERROR ) } # [ doc = "Time out" ] # [ inline ] pub fn time_out ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: TIME_OUT ) } # [ doc = "Babble" ] # [ inline ] pub fn babble ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: BABBLE ) } # [ doc = "Truncated EOP" ] # [ inline ] pub fn truncated_eop ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: TRUNCATED_EOP ) } # [ doc = "Sent/Received NAK" ] # [ inline ] pub fn sentreceived_nak ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: SENTRECEIVED_NAK ) } # [ doc = "Sent Stall" ] # [ inline ] pub fn sent_stall ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: SENT_STALL ) } # [ doc = "Overrun" ] # [ inline ] pub fn overrun ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: OVERRUN ) } # [ doc = "Sent empty packet" ] # [ inline ] pub fn sent_empty_packet ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: SENT_EMPTY_PACKET ) } # [ doc = "Bitstuff error" ] # [ inline ] pub fn bitstuff_error ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: BITSTUFF_ERROR ) } # [ doc = "Sync error" ] # [ inline ] pub fn sync_error ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: SYNC_ERROR ) } # [ doc = "Wrong data toggle" ] # [ inline ] pub fn wrong_data_toggle ( self ) -> & 'a mut W { self . variant ( ERR_CODEW :: WRONG_DATA_TOGGLE ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:10 - Frame number. This contains the frame number of the last successfully received SOF. In case no SOF was received by the device at the beginning of a frame, the frame number returned is that of the last successfully received SOF. In case the SOF frame number contained a CRC error, the frame number returned will be the corrupted frame number as received by the device." ] # [ inline ] pub fn frame_nr ( & self ) -> FRAME_NRR { let bits = { const MASK : u16 = 0x07ff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; FRAME_NRR { bits } } # [ doc = "Bits 11:14 - The error code which last occurred:" ] # [ inline ] pub fn err_code ( & self ) -> ERR_CODER { ERR_CODER :: _from ( { const MASK : u8 = 0x0f ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:10 - Frame number. This contains the frame number of the last successfully received SOF. In case no SOF was received by the device at the beginning of a frame, the frame number returned is that of the last successfully received SOF. In case the SOF frame number contained a CRC error, the frame number returned will be the corrupted frame number as received by the device." ] # [ inline ] pub fn frame_nr ( & mut self ) -> _FRAME_NRW { _FRAME_NRW { w : self } } # [ doc = "Bits 11:14 - The error code which last occurred:" ] # [ inline ] pub fn err_code ( & mut self ) -> _ERR_CODEW { _ERR_CODEW { w : self } } } } # [ doc = "USB EP Command/Status List start address" ] pub struct EPLISTSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB EP Command/Status List start address" ] pub mod epliststart { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EPLISTSTART { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EP_LISTR { bits : u32 , } impl EP_LISTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _EP_LISTW < 'a > { w : & 'a mut W , } impl < 'a > _EP_LISTW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 8:31 - Start address of the USB EP Command/Status List." ] # [ inline ] pub fn ep_list ( & self ) -> EP_LISTR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; EP_LISTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 8:31 - Start address of the USB EP Command/Status List." ] # [ inline ] pub fn ep_list ( & mut self ) -> _EP_LISTW { _EP_LISTW { w : self } } } } # [ doc = "USB Data buffer start address" ] pub struct DATABUFSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB Data buffer start address" ] pub mod databufstart { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DATABUFSTART { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DA_BUFR { bits : u16 , } impl DA_BUFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _DA_BUFW < 'a > { w : & 'a mut W , } impl < 'a > _DA_BUFW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 22:31 - Start address of the buffer pointer page where all endpoint data buffers are located." ] # [ inline ] pub fn da_buf ( & self ) -> DA_BUFR { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; DA_BUFR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 22:31 - Start address of the buffer pointer page where all endpoint data buffers are located." ] # [ inline ] pub fn da_buf ( & mut self ) -> _DA_BUFW { _DA_BUFW { w : self } } } } # [ doc = "Link Power Management register" ] pub struct LPM { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Link Power Management register" ] pub mod lpm { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: LPM { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct HIRD_HWR { bits : u8 , } impl HIRD_HWR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct HIRD_SWR { bits : u8 , } impl HIRD_SWR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct DATA_PENDINGR { bits : bool , } impl DATA_PENDINGR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _HIRD_HWW < 'a > { w : & 'a mut W , } impl < 'a > _HIRD_HWW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _HIRD_SWW < 'a > { w : & 'a mut W , } impl < 'a > _HIRD_SWW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DATA_PENDINGW < 'a > { w : & 'a mut W , } impl < 'a > _DATA_PENDINGW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Host Initiated Resume Duration - HW. This is the HIRD value from the last received LPM token" ] # [ inline ] pub fn hird_hw ( & self ) -> HIRD_HWR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; HIRD_HWR { bits } } # [ doc = "Bits 4:7 - Host Initiated Resume Duration - SW. This is the time duration required by the USB device system to come out of LPM initiated suspend after receiving the host initiated LPM resume." ] # [ inline ] pub fn hird_sw ( & self ) -> HIRD_SWR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; HIRD_SWR { bits } } # [ doc = "Bit 8 - As long as this bit is set to one and LPM supported bit is set to one, HW will return a NYET handshake on every LPM token it receives. If LPM supported bit is set to one and this bit is zero, HW will return an ACK handshake on every LPM token it receives. If SW has still data pending and LPM is supported, it must set this bit to 1." ] # [ inline ] pub fn data_pending ( & self ) -> DATA_PENDINGR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DATA_PENDINGR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:3 - Host Initiated Resume Duration - HW. This is the HIRD value from the last received LPM token" ] # [ inline ] pub fn hird_hw ( & mut self ) -> _HIRD_HWW { _HIRD_HWW { w : self } } # [ doc = "Bits 4:7 - Host Initiated Resume Duration - SW. This is the time duration required by the USB device system to come out of LPM initiated suspend after receiving the host initiated LPM resume." ] # [ inline ] pub fn hird_sw ( & mut self ) -> _HIRD_SWW { _HIRD_SWW { w : self } } # [ doc = "Bit 8 - As long as this bit is set to one and LPM supported bit is set to one, HW will return a NYET handshake on every LPM token it receives. If LPM supported bit is set to one and this bit is zero, HW will return an ACK handshake on every LPM token it receives. If SW has still data pending and LPM is supported, it must set this bit to 1." ] # [ inline ] pub fn data_pending ( & mut self ) -> _DATA_PENDINGW { _DATA_PENDINGW { w : self } } } } # [ doc = "USB Endpoint skip" ] pub struct EPSKIP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB Endpoint skip" ] pub mod epskip { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EPSKIP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct SKIPR { bits : u32 , } impl SKIPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _SKIPW < 'a > { w : & 'a mut W , } impl < 'a > _SKIPW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x3fff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:29 - Endpoint skip: Writing 1 to one of these bits, will indicate to HW that it must deactivate the buffer assigned to this endpoint and return control back to software. When HW has deactivated the endpoint, it will clear this bit, but it will not modify the EPINUSE bit. An interrupt will be generated when the Active bit goes from 1 to 0. Note: In case of double-buffering, HW will only clear the Active bit of the buffer indicated by the EPINUSE bit." ] # [ inline ] pub fn skip ( & self ) -> SKIPR { let bits = { const MASK : u32 = 0x3fff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; SKIPR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:29 - Endpoint skip: Writing 1 to one of these bits, will indicate to HW that it must deactivate the buffer assigned to this endpoint and return control back to software. When HW has deactivated the endpoint, it will clear this bit, but it will not modify the EPINUSE bit. An interrupt will be generated when the Active bit goes from 1 to 0. Note: In case of double-buffering, HW will only clear the Active bit of the buffer indicated by the EPINUSE bit." ] # [ inline ] pub fn skip ( & mut self ) -> _SKIPW { _SKIPW { w : self } } } } # [ doc = "USB Endpoint Buffer in use" ] pub struct EPINUSE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB Endpoint Buffer in use" ] pub mod epinuse { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EPINUSE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct BUFR { bits : u8 , } impl BUFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _BUFW < 'a > { w : & 'a mut W , } impl < 'a > _BUFW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 2:9 - Buffer in use: This register has one bit per physical endpoint. 0: HW is accessing buffer 0. 1: HW is accessing buffer 1." ] # [ inline ] pub fn buf ( & self ) -> BUFR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; BUFR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 2:9 - Buffer in use: This register has one bit per physical endpoint. 0: HW is accessing buffer 0. 1: HW is accessing buffer 1." ] # [ inline ] pub fn buf ( & mut self ) -> _BUFW { _BUFW { w : self } } } } # [ doc = "USB Endpoint Buffer Configuration register" ] pub struct EPBUFCFG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB Endpoint Buffer Configuration register" ] pub mod epbufcfg { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EPBUFCFG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct BUF_SBR { bits : u8 , } impl BUF_SBR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _BUF_SBW < 'a > { w : & 'a mut W , } impl < 'a > _BUF_SBW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 2:9 - Buffer usage: This register has one bit per physical endpoint. 0: Single-buffer. 1: Double-buffer. If the bit is set to single-buffer (0), it will not toggle the corresponding EPINUSE bit when it clears the active bit. If the bit is set to double-buffer (1), HW will toggle the EPINUSE bit when it clears the Active bit for the buffer." ] # [ inline ] pub fn buf_sb ( & self ) -> BUF_SBR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; BUF_SBR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 2:9 - Buffer usage: This register has one bit per physical endpoint. 0: Single-buffer. 1: Double-buffer. If the bit is set to single-buffer (0), it will not toggle the corresponding EPINUSE bit when it clears the active bit. If the bit is set to double-buffer (1), HW will toggle the EPINUSE bit when it clears the Active bit for the buffer." ] # [ inline ] pub fn buf_sb ( & mut self ) -> _BUF_SBW { _BUF_SBW { w : self } } } } # [ doc = "USB interrupt status register" ] pub struct INTSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB interrupt status register" ] pub mod intstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTSTAT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EP0OUTR { bits : bool , } impl EP0OUTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP0INR { bits : bool , } impl EP0INR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP1OUTR { bits : bool , } impl EP1OUTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP1INR { bits : bool , } impl EP1INR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP2OUTR { bits : bool , } impl EP2OUTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP2INR { bits : bool , } impl EP2INR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP3OUTR { bits : bool , } impl EP3OUTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP3INR { bits : bool , } impl EP3INR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP4OUTR { bits : bool , } impl EP4OUTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct EP4INR { bits : bool , } impl EP4INR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct FRAME_INTR { bits : bool , } impl FRAME_INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DEV_INTR { bits : bool , } impl DEV_INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _EP0OUTW < 'a > { w : & 'a mut W , } impl < 'a > _EP0OUTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP0INW < 'a > { w : & 'a mut W , } impl < 'a > _EP0INW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP1OUTW < 'a > { w : & 'a mut W , } impl < 'a > _EP1OUTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP1INW < 'a > { w : & 'a mut W , } impl < 'a > _EP1INW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP2OUTW < 'a > { w : & 'a mut W , } impl < 'a > _EP2OUTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP2INW < 'a > { w : & 'a mut W , } impl < 'a > _EP2INW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP3OUTW < 'a > { w : & 'a mut W , } impl < 'a > _EP3OUTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP3INW < 'a > { w : & 'a mut W , } impl < 'a > _EP3INW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP4OUTW < 'a > { w : & 'a mut W , } impl < 'a > _EP4OUTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _EP4INW < 'a > { w : & 'a mut W , } impl < 'a > _EP4INW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FRAME_INTW < 'a > { w : & 'a mut W , } impl < 'a > _FRAME_INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DEV_INTW < 'a > { w : & 'a mut W , } impl < 'a > _DEV_INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Interrupt status register bit for the Control EP0 OUT direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software or a SETUP packet is successfully received for the control EP0. If the IntOnNAK_CO is set, this bit will also be set when a NAK is transmitted for the Control EP0 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep0out ( & self ) -> EP0OUTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP0OUTR { bits } } # [ doc = "Bit 1 - Interrupt status register bit for the Control EP0 IN direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_CI is set, this bit will also be set when a NAK is transmitted for the Control EP0 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep0in ( & self ) -> EP0INR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP0INR { bits } } # [ doc = "Bit 2 - Interrupt status register bit for the EP1 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP1 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep1out ( & self ) -> EP1OUTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP1OUTR { bits } } # [ doc = "Bit 3 - Interrupt status register bit for the EP1 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP1 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep1in ( & self ) -> EP1INR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP1INR { bits } } # [ doc = "Bit 4 - Interrupt status register bit for the EP2 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP2 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep2out ( & self ) -> EP2OUTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP2OUTR { bits } } # [ doc = "Bit 5 - Interrupt status register bit for the EP2 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP2 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep2in ( & self ) -> EP2INR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP2INR { bits } } # [ doc = "Bit 6 - Interrupt status register bit for the EP3 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP3 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep3out ( & self ) -> EP3OUTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP3OUTR { bits } } # [ doc = "Bit 7 - Interrupt status register bit for the EP3 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP3 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep3in ( & self ) -> EP3INR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP3INR { bits } } # [ doc = "Bit 8 - Interrupt status register bit for the EP4 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP4 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep4out ( & self ) -> EP4OUTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP4OUTR { bits } } # [ doc = "Bit 9 - Interrupt status register bit for the EP4 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP4 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep4in ( & self ) -> EP4INR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; EP4INR { bits } } # [ doc = "Bit 30 - Frame interrupt. This bit is set to one every millisecond when the VbusDebounced bit and the DCON bit are set. This bit can be used by software when handling isochronous endpoints. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn frame_int ( & self ) -> FRAME_INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FRAME_INTR { bits } } # [ doc = "Bit 31 - Device status interrupt. This bit is set by HW when one of the bits in the Device Status Change register are set. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn dev_int ( & self ) -> DEV_INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DEV_INTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Interrupt status register bit for the Control EP0 OUT direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software or a SETUP packet is successfully received for the control EP0. If the IntOnNAK_CO is set, this bit will also be set when a NAK is transmitted for the Control EP0 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep0out ( & mut self ) -> _EP0OUTW { _EP0OUTW { w : self } } # [ doc = "Bit 1 - Interrupt status register bit for the Control EP0 IN direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_CI is set, this bit will also be set when a NAK is transmitted for the Control EP0 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep0in ( & mut self ) -> _EP0INW { _EP0INW { w : self } } # [ doc = "Bit 2 - Interrupt status register bit for the EP1 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP1 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep1out ( & mut self ) -> _EP1OUTW { _EP1OUTW { w : self } } # [ doc = "Bit 3 - Interrupt status register bit for the EP1 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP1 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep1in ( & mut self ) -> _EP1INW { _EP1INW { w : self } } # [ doc = "Bit 4 - Interrupt status register bit for the EP2 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP2 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep2out ( & mut self ) -> _EP2OUTW { _EP2OUTW { w : self } } # [ doc = "Bit 5 - Interrupt status register bit for the EP2 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP2 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep2in ( & mut self ) -> _EP2INW { _EP2INW { w : self } } # [ doc = "Bit 6 - Interrupt status register bit for the EP3 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP3 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep3out ( & mut self ) -> _EP3OUTW { _EP3OUTW { w : self } } # [ doc = "Bit 7 - Interrupt status register bit for the EP3 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP3 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep3in ( & mut self ) -> _EP3INW { _EP3INW { w : self } } # [ doc = "Bit 8 - Interrupt status register bit for the EP4 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP4 OUT direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep4out ( & mut self ) -> _EP4OUTW { _EP4OUTW { w : self } } # [ doc = "Bit 9 - Interrupt status register bit for the EP4 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP4 IN direction. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn ep4in ( & mut self ) -> _EP4INW { _EP4INW { w : self } } # [ doc = "Bit 30 - Frame interrupt. This bit is set to one every millisecond when the VbusDebounced bit and the DCON bit are set. This bit can be used by software when handling isochronous endpoints. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn frame_int ( & mut self ) -> _FRAME_INTW { _FRAME_INTW { w : self } } # [ doc = "Bit 31 - Device status interrupt. This bit is set by HW when one of the bits in the Device Status Change register are set. Software can clear this bit by writing a one to it." ] # [ inline ] pub fn dev_int ( & mut self ) -> _DEV_INTW { _DEV_INTW { w : self } } } } # [ doc = "USB interrupt enable register" ] pub struct INTEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB interrupt enable register" ] pub mod inten { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EP_INT_ENR { bits : u16 , } impl EP_INT_ENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct FRAME_INT_ENR { bits : bool , } impl FRAME_INT_ENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DEV_INT_ENR { bits : bool , } impl DEV_INT_ENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _EP_INT_ENW < 'a > { w : & 'a mut W , } impl < 'a > _EP_INT_ENW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FRAME_INT_ENW < 'a > { w : & 'a mut W , } impl < 'a > _FRAME_INT_ENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DEV_INT_ENW < 'a > { w : & 'a mut W , } impl < 'a > _DEV_INT_ENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:9 - If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit." ] # [ inline ] pub fn ep_int_en ( & self ) -> EP_INT_ENR { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; EP_INT_ENR { bits } } # [ doc = "Bit 30 - If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit." ] # [ inline ] pub fn frame_int_en ( & self ) -> FRAME_INT_ENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FRAME_INT_ENR { bits } } # [ doc = "Bit 31 - If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit." ] # [ inline ] pub fn dev_int_en ( & self ) -> DEV_INT_ENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DEV_INT_ENR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:9 - If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit." ] # [ inline ] pub fn ep_int_en ( & mut self ) -> _EP_INT_ENW { _EP_INT_ENW { w : self } } # [ doc = "Bit 30 - If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit." ] # [ inline ] pub fn frame_int_en ( & mut self ) -> _FRAME_INT_ENW { _FRAME_INT_ENW { w : self } } # [ doc = "Bit 31 - If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit." ] # [ inline ] pub fn dev_int_en ( & mut self ) -> _DEV_INT_ENW { _DEV_INT_ENW { w : self } } } } # [ doc = "USB set interrupt status register" ] pub struct INTSETSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB set interrupt status register" ] pub mod intsetstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTSETSTAT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct EP_SET_INTR { bits : u16 , } impl EP_SET_INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct FRAME_SET_INTR { bits : bool , } impl FRAME_SET_INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DEV_SET_INTR { bits : bool , } impl DEV_SET_INTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _EP_SET_INTW < 'a > { w : & 'a mut W , } impl < 'a > _EP_SET_INTW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FRAME_SET_INTW < 'a > { w : & 'a mut W , } impl < 'a > _FRAME_SET_INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DEV_SET_INTW < 'a > { w : & 'a mut W , } impl < 'a > _DEV_SET_INTW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:9 - If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned." ] # [ inline ] pub fn ep_set_int ( & self ) -> EP_SET_INTR { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; EP_SET_INTR { bits } } # [ doc = "Bit 30 - If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned." ] # [ inline ] pub fn frame_set_int ( & self ) -> FRAME_SET_INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; FRAME_SET_INTR { bits } } # [ doc = "Bit 31 - If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned." ] # [ inline ] pub fn dev_set_int ( & self ) -> DEV_SET_INTR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DEV_SET_INTR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:9 - If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned." ] # [ inline ] pub fn ep_set_int ( & mut self ) -> _EP_SET_INTW { _EP_SET_INTW { w : self } } # [ doc = "Bit 30 - If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned." ] # [ inline ] pub fn frame_set_int ( & mut self ) -> _FRAME_SET_INTW { _FRAME_SET_INTW { w : self } } # [ doc = "Bit 31 - If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned." ] # [ inline ] pub fn dev_set_int ( & mut self ) -> _DEV_SET_INTW { _DEV_SET_INTW { w : self } } } } # [ doc = "USB interrupt routing register" ] pub struct INTROUTING { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB interrupt routing register" ] pub mod introuting { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTROUTING { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ROUTE_INT9_0R { bits : u16 , } impl ROUTE_INT9_0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct ROUTE_INT30R { bits : bool , } impl ROUTE_INT30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct ROUTE_INT31R { bits : bool , } impl ROUTE_INT31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _ROUTE_INT9_0W < 'a > { w : & 'a mut W , } impl < 'a > _ROUTE_INT9_0W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ROUTE_INT30W < 'a > { w : & 'a mut W , } impl < 'a > _ROUTE_INT30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _ROUTE_INT31W < 'a > { w : & 'a mut W , } impl < 'a > _ROUTE_INT31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:9 - This bit can control on which hardware interrupt line the interrupt will be generated: 0: IRQ interrupt line is selected for this interrupt bit 1: FIQ interrupt line is selected for this interrupt bit" ] # [ inline ] pub fn route_int9_0 ( & self ) -> ROUTE_INT9_0R { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; ROUTE_INT9_0R { bits } } # [ doc = "Bit 30 - This bit can control on which hardware interrupt line the interrupt will be generated: 0: IRQ interrupt line is selected for this interrupt bit 1: FIQ interrupt line is selected for this interrupt bit" ] # [ inline ] pub fn route_int30 ( & self ) -> ROUTE_INT30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ROUTE_INT30R { bits } } # [ doc = "Bit 31 - This bit can control on which hardware interrupt line the interrupt will be generated: 0: IRQ interrupt line is selected for this interrupt bit 1: FIQ interrupt line is selected for this interrupt bit" ] # [ inline ] pub fn route_int31 ( & self ) -> ROUTE_INT31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; ROUTE_INT31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:9 - This bit can control on which hardware interrupt line the interrupt will be generated: 0: IRQ interrupt line is selected for this interrupt bit 1: FIQ interrupt line is selected for this interrupt bit" ] # [ inline ] pub fn route_int9_0 ( & mut self ) -> _ROUTE_INT9_0W { _ROUTE_INT9_0W { w : self } } # [ doc = "Bit 30 - This bit can control on which hardware interrupt line the interrupt will be generated: 0: IRQ interrupt line is selected for this interrupt bit 1: FIQ interrupt line is selected for this interrupt bit" ] # [ inline ] pub fn route_int30 ( & mut self ) -> _ROUTE_INT30W { _ROUTE_INT30W { w : self } } # [ doc = "Bit 31 - This bit can control on which hardware interrupt line the interrupt will be generated: 0: IRQ interrupt line is selected for this interrupt bit 1: FIQ interrupt line is selected for this interrupt bit" ] # [ inline ] pub fn route_int31 ( & mut self ) -> _ROUTE_INT31W { _ROUTE_INT31W { w : self } } } } # [ doc = "USB Endpoint toggle register" ] pub struct EPTOGGLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "USB Endpoint toggle register" ] pub mod eptoggle { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: EPTOGGLE { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct TOGGLER { bits : u16 , } impl TOGGLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:9 - Endpoint data toggle: This field indicates the current value of the data toggle for the corresponding endpoint." ] # [ inline ] pub fn toggle ( & self ) -> TOGGLER { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; TOGGLER { bits } } } } } # [ doc = "GPIO port" ] pub struct GPIO_PORT { _marker : PhantomData < * const ( ) > } unsafe impl Send for GPIO_PORT { } impl GPIO_PORT { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const gpio_port :: RegisterBlock { 0x5000_0000 as * const _ } } impl Deref for GPIO_PORT { type Target = gpio_port :: RegisterBlock ; fn deref ( & self ) -> & gpio_port :: RegisterBlock { unsafe { & * GPIO_PORT :: ptr ( ) } } } # [ doc = "GPIO port" ] pub mod gpio_port { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Byte pin registers port 0; pins PIO0_0 to PIO0_31" ] pub b0 : [ B0 ; 32 ] , # [ doc = "0x20 - Byte pin registers port 1" ] pub b132 : B1 , # [ doc = "0x21 - Byte pin registers port 1" ] pub b133 : B1 , # [ doc = "0x22 - Byte pin registers port 1" ] pub b134 : B1 , # [ doc = "0x23 - Byte pin registers port 1" ] pub b135 : B1 , # [ doc = "0x24 - Byte pin registers port 1" ] pub b136 : B1 , # [ doc = "0x25 - Byte pin registers port 1" ] pub b137 : B1 , # [ doc = "0x26 - Byte pin registers port 1" ] pub b138 : B1 , # [ doc = "0x27 - Byte pin registers port 1" ] pub b139 : B1 , # [ doc = "0x28 - Byte pin registers port 1" ] pub b140 : B1 , # [ doc = "0x29 - Byte pin registers port 1" ] pub b141 : B1 , # [ doc = "0x2a - Byte pin registers port 1" ] pub b142 : B1 , # [ doc = "0x2b - Byte pin registers port 1" ] pub b143 : B1 , # [ doc = "0x2c - Byte pin registers port 1" ] pub b144 : B1 , # [ doc = "0x2d - Byte pin registers port 1" ] pub b145 : B1 , # [ doc = "0x2e - Byte pin registers port 1" ] pub b146 : B1 , # [ doc = "0x2f - Byte pin registers port 1" ] pub b147 : B1 , # [ doc = "0x30 - Byte pin registers port 1" ] pub b148 : B1 , # [ doc = "0x31 - Byte pin registers port 1" ] pub b149 : B1 , # [ doc = "0x32 - Byte pin registers port 1" ] pub b150 : B1 , # [ doc = "0x33 - Byte pin registers port 1" ] pub b151 : B1 , # [ doc = "0x34 - Byte pin registers port 1" ] pub b152 : B1 , # [ doc = "0x35 - Byte pin registers port 1" ] pub b153 : B1 , # [ doc = "0x36 - Byte pin registers port 1" ] pub b154 : B1 , # [ doc = "0x37 - Byte pin registers port 1" ] pub b155 : B1 , # [ doc = "0x38 - Byte pin registers port 1" ] pub b156 : B1 , # [ doc = "0x39 - Byte pin registers port 1" ] pub b157 : B1 , # [ doc = "0x3a - Byte pin registers port 1" ] pub b158 : B1 , # [ doc = "0x3b - Byte pin registers port 1" ] pub b159 : B1 , # [ doc = "0x3c - Byte pin registers port 1" ] pub b160 : B1 , # [ doc = "0x3d - Byte pin registers port 1" ] pub b161 : B1 , # [ doc = "0x3e - Byte pin registers port 1" ] pub b162 : B1 , # [ doc = "0x3f - Byte pin registers port 1" ] pub b163 : B1 , _reserved0 : [ u8 ; 4032usize ] , # [ doc = "0x1000 - Word pin registers port 0" ] pub w_0 : [ W_0 ; 32 ] , # [ doc = "0x1080 - Word pin registers port 1" ] pub w_132 : W_1 , # [ doc = "0x1084 - Word pin registers port 1" ] pub w_133 : W_1 , # [ doc = "0x1088 - Word pin registers port 1" ] pub w_134 : W_1 , # [ doc = "0x108c - Word pin registers port 1" ] pub w_135 : W_1 , # [ doc = "0x1090 - Word pin registers port 1" ] pub w_136 : W_1 , # [ doc = "0x1094 - Word pin registers port 1" ] pub w_137 : W_1 , # [ doc = "0x1098 - Word pin registers port 1" ] pub w_138 : W_1 , # [ doc = "0x109c - Word pin registers port 1" ] pub w_139 : W_1 , # [ doc = "0x10a0 - Word pin registers port 1" ] pub w_140 : W_1 , # [ doc = "0x10a4 - Word pin registers port 1" ] pub w_141 : W_1 , # [ doc = "0x10a8 - Word pin registers port 1" ] pub w_142 : W_1 , # [ doc = "0x10ac - Word pin registers port 1" ] pub w_143 : W_1 , # [ doc = "0x10b0 - Word pin registers port 1" ] pub w_144 : W_1 , # [ doc = "0x10b4 - Word pin registers port 1" ] pub w_145 : W_1 , # [ doc = "0x10b8 - Word pin registers port 1" ] pub w_146 : W_1 , # [ doc = "0x10bc - Word pin registers port 1" ] pub w_147 : W_1 , # [ doc = "0x10c0 - Word pin registers port 1" ] pub w_148 : W_1 , # [ doc = "0x10c4 - Word pin registers port 1" ] pub w_149 : W_1 , # [ doc = "0x10c8 - Word pin registers port 1" ] pub w_150 : W_1 , # [ doc = "0x10cc - Word pin registers port 1" ] pub w_151 : W_1 , # [ doc = "0x10d0 - Word pin registers port 1" ] pub w_152 : W_1 , # [ doc = "0x10d4 - Word pin registers port 1" ] pub w_153 : W_1 , # [ doc = "0x10d8 - Word pin registers port 1" ] pub w_154 : W_1 , # [ doc = "0x10dc - Word pin registers port 1" ] pub w_155 : W_1 , # [ doc = "0x10e0 - Word pin registers port 1" ] pub w_156 : W_1 , # [ doc = "0x10e4 - Word pin registers port 1" ] pub w_157 : W_1 , # [ doc = "0x10e8 - Word pin registers port 1" ] pub w_158 : W_1 , # [ doc = "0x10ec - Word pin registers port 1" ] pub w_159 : W_1 , # [ doc = "0x10f0 - Word pin registers port 1" ] pub w_160 : W_1 , # [ doc = "0x10f4 - Word pin registers port 1" ] pub w_161 : W_1 , # [ doc = "0x10f8 - Word pin registers port 1" ] pub w_162 : W_1 , # [ doc = "0x10fc - Word pin registers port 1" ] pub w_163 : W_1 , _reserved1 : [ u8 ; 3840usize ] , # [ doc = "0x2000 - Direction registers port 0/1" ] pub dir : [ DIR ; 2 ] , _reserved2 : [ u8 ; 120usize ] , # [ doc = "0x2080 - Mask register port 0/1" ] pub mask : [ MASK ; 2 ] , _reserved3 : [ u8 ; 120usize ] , # [ doc = "0x2100 - Portpin register port 0" ] pub pin : [ PIN ; 2 ] , _reserved4 : [ u8 ; 120usize ] , # [ doc = "0x2180 - Masked port register port 0/1" ] pub mpin : [ MPIN ; 2 ] , _reserved5 : [ u8 ; 120usize ] , # [ doc = "0x2200 - Write: Set register for port 0/1 Read: output bits for port 0/1" ] pub set : [ SET ; 2 ] , _reserved6 : [ u8 ; 120usize ] , # [ doc = "0x2280 - Clear port 0/1" ] pub clr : [ CLR ; 2 ] , _reserved7 : [ u8 ; 120usize ] , # [ doc = "0x2300 - Toggle port 0/1" ] pub not : [ NOT ; 2 ] , } # [ doc = "Byte pin registers port 0; pins PIO0_0 to PIO0_31" ] pub struct B0 { register : :: vcell :: VolatileCell < u8 > } # [ doc = "Byte pin registers port 0; pins PIO0_0 to PIO0_31" ] pub mod b0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u8 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u8 , } impl super :: B0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PBYTER { bits : bool , } impl PBYTER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _PBYTEW < 'a > { w : & 'a mut W , } impl < 'a > _PBYTEW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u8 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u8 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } # [ doc = "Bit 0 - Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit." ] # [ inline ] pub fn pbyte ( & self ) -> PBYTER { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u8 ) != 0 } ; PBYTER { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u8 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit." ] # [ inline ] pub fn pbyte ( & mut self ) -> _PBYTEW { _PBYTEW { w : self } } } } # [ doc = "Byte pin registers port 1" ] pub struct B1 { register : :: vcell :: VolatileCell < u8 > } # [ doc = "Byte pin registers port 1" ] pub mod b1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u8 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u8 , } impl super :: B1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PBYTER { bits : bool , } impl PBYTER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _PBYTEW < 'a > { w : & 'a mut W , } impl < 'a > _PBYTEW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u8 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u8 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } # [ doc = "Bit 0 - Read: state of the pin P1_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit." ] # [ inline ] pub fn pbyte ( & self ) -> PBYTER { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u8 ) != 0 } ; PBYTER { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u8 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Read: state of the pin P1_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit." ] # [ inline ] pub fn pbyte ( & mut self ) -> _PBYTEW { _PBYTEW { w : self } } } } # [ doc = "Word pin registers port 0" ] pub struct W_0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Word pin registers port 0" ] pub mod w_0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: W_0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PWORDR { bits : u32 , } impl PWORDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _PWORDW < 'a > { w : & 'a mut W , } impl < 'a > _PWORDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Read 0: pin is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit." ] # [ inline ] pub fn pword ( & self ) -> PWORDR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PWORDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Read 0: pin is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit." ] # [ inline ] pub fn pword ( & mut self ) -> _PWORDW { _PWORDW { w : self } } } } # [ doc = "Word pin registers port 1" ] pub struct W_1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Word pin registers port 1" ] pub mod w_1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: W_1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PWORDR { bits : u32 , } impl PWORDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _PWORDW < 'a > { w : & 'a mut W , } impl < 'a > _PWORDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Read 0: pin is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit." ] # [ inline ] pub fn pword ( & self ) -> PWORDR { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PWORDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Read 0: pin is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit." ] # [ inline ] pub fn pword ( & mut self ) -> _PWORDW { _PWORDW { w : self } } } } # [ doc = "Direction registers port 0/1" ] pub struct DIR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Direction registers port 0/1" ] pub mod dir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DIR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DIRP0R { bits : bool , } impl DIRP0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP1R { bits : bool , } impl DIRP1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP2R { bits : bool , } impl DIRP2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP3R { bits : bool , } impl DIRP3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP4R { bits : bool , } impl DIRP4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP5R { bits : bool , } impl DIRP5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP6R { bits : bool , } impl DIRP6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP7R { bits : bool , } impl DIRP7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP8R { bits : bool , } impl DIRP8R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP9R { bits : bool , } impl DIRP9R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP10R { bits : bool , } impl DIRP10R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP11R { bits : bool , } impl DIRP11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP12R { bits : bool , } impl DIRP12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP13R { bits : bool , } impl DIRP13R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP14R { bits : bool , } impl DIRP14R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP15R { bits : bool , } impl DIRP15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP16R { bits : bool , } impl DIRP16R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP17R { bits : bool , } impl DIRP17R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP18R { bits : bool , } impl DIRP18R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP19R { bits : bool , } impl DIRP19R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP20R { bits : bool , } impl DIRP20R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP21R { bits : bool , } impl DIRP21R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP22R { bits : bool , } impl DIRP22R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP23R { bits : bool , } impl DIRP23R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP24R { bits : bool , } impl DIRP24R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP25R { bits : bool , } impl DIRP25R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP26R { bits : bool , } impl DIRP26R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP27R { bits : bool , } impl DIRP27R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP28R { bits : bool , } impl DIRP28R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP29R { bits : bool , } impl DIRP29R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP30R { bits : bool , } impl DIRP30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIRP31R { bits : bool , } impl DIRP31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _DIRP0W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP1W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP2W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP3W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP4W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP5W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP6W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP7W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP8W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP9W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP10W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP11W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP12W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP13W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP14W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP15W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP16W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP17W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP18W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP19W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP20W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP21W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP22W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP23W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP24W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP25W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP26W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP27W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP28W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP29W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP30W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIRP31W < 'a > { w : & 'a mut W , } impl < 'a > _DIRP31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp0 ( & self ) -> DIRP0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP0R { bits } } # [ doc = "Bit 1 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp1 ( & self ) -> DIRP1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP1R { bits } } # [ doc = "Bit 2 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp2 ( & self ) -> DIRP2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP2R { bits } } # [ doc = "Bit 3 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp3 ( & self ) -> DIRP3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP3R { bits } } # [ doc = "Bit 4 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp4 ( & self ) -> DIRP4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP4R { bits } } # [ doc = "Bit 5 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp5 ( & self ) -> DIRP5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP5R { bits } } # [ doc = "Bit 6 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp6 ( & self ) -> DIRP6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP6R { bits } } # [ doc = "Bit 7 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp7 ( & self ) -> DIRP7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP7R { bits } } # [ doc = "Bit 8 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp8 ( & self ) -> DIRP8R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP8R { bits } } # [ doc = "Bit 9 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp9 ( & self ) -> DIRP9R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP9R { bits } } # [ doc = "Bit 10 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp10 ( & self ) -> DIRP10R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP10R { bits } } # [ doc = "Bit 11 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp11 ( & self ) -> DIRP11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP11R { bits } } # [ doc = "Bit 12 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp12 ( & self ) -> DIRP12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP12R { bits } } # [ doc = "Bit 13 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp13 ( & self ) -> DIRP13R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP13R { bits } } # [ doc = "Bit 14 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp14 ( & self ) -> DIRP14R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP14R { bits } } # [ doc = "Bit 15 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp15 ( & self ) -> DIRP15R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP15R { bits } } # [ doc = "Bit 16 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp16 ( & self ) -> DIRP16R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP16R { bits } } # [ doc = "Bit 17 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp17 ( & self ) -> DIRP17R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP17R { bits } } # [ doc = "Bit 18 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp18 ( & self ) -> DIRP18R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP18R { bits } } # [ doc = "Bit 19 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp19 ( & self ) -> DIRP19R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP19R { bits } } # [ doc = "Bit 20 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp20 ( & self ) -> DIRP20R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP20R { bits } } # [ doc = "Bit 21 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp21 ( & self ) -> DIRP21R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP21R { bits } } # [ doc = "Bit 22 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp22 ( & self ) -> DIRP22R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP22R { bits } } # [ doc = "Bit 23 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp23 ( & self ) -> DIRP23R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP23R { bits } } # [ doc = "Bit 24 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp24 ( & self ) -> DIRP24R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP24R { bits } } # [ doc = "Bit 25 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp25 ( & self ) -> DIRP25R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP25R { bits } } # [ doc = "Bit 26 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp26 ( & self ) -> DIRP26R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP26R { bits } } # [ doc = "Bit 27 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp27 ( & self ) -> DIRP27R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP27R { bits } } # [ doc = "Bit 28 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp28 ( & self ) -> DIRP28R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP28R { bits } } # [ doc = "Bit 29 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp29 ( & self ) -> DIRP29R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP29R { bits } } # [ doc = "Bit 30 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp30 ( & self ) -> DIRP30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP30R { bits } } # [ doc = "Bit 31 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp31 ( & self ) -> DIRP31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIRP31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp0 ( & mut self ) -> _DIRP0W { _DIRP0W { w : self } } # [ doc = "Bit 1 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp1 ( & mut self ) -> _DIRP1W { _DIRP1W { w : self } } # [ doc = "Bit 2 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp2 ( & mut self ) -> _DIRP2W { _DIRP2W { w : self } } # [ doc = "Bit 3 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp3 ( & mut self ) -> _DIRP3W { _DIRP3W { w : self } } # [ doc = "Bit 4 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp4 ( & mut self ) -> _DIRP4W { _DIRP4W { w : self } } # [ doc = "Bit 5 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp5 ( & mut self ) -> _DIRP5W { _DIRP5W { w : self } } # [ doc = "Bit 6 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp6 ( & mut self ) -> _DIRP6W { _DIRP6W { w : self } } # [ doc = "Bit 7 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp7 ( & mut self ) -> _DIRP7W { _DIRP7W { w : self } } # [ doc = "Bit 8 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp8 ( & mut self ) -> _DIRP8W { _DIRP8W { w : self } } # [ doc = "Bit 9 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp9 ( & mut self ) -> _DIRP9W { _DIRP9W { w : self } } # [ doc = "Bit 10 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp10 ( & mut self ) -> _DIRP10W { _DIRP10W { w : self } } # [ doc = "Bit 11 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp11 ( & mut self ) -> _DIRP11W { _DIRP11W { w : self } } # [ doc = "Bit 12 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp12 ( & mut self ) -> _DIRP12W { _DIRP12W { w : self } } # [ doc = "Bit 13 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp13 ( & mut self ) -> _DIRP13W { _DIRP13W { w : self } } # [ doc = "Bit 14 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp14 ( & mut self ) -> _DIRP14W { _DIRP14W { w : self } } # [ doc = "Bit 15 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp15 ( & mut self ) -> _DIRP15W { _DIRP15W { w : self } } # [ doc = "Bit 16 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp16 ( & mut self ) -> _DIRP16W { _DIRP16W { w : self } } # [ doc = "Bit 17 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp17 ( & mut self ) -> _DIRP17W { _DIRP17W { w : self } } # [ doc = "Bit 18 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp18 ( & mut self ) -> _DIRP18W { _DIRP18W { w : self } } # [ doc = "Bit 19 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp19 ( & mut self ) -> _DIRP19W { _DIRP19W { w : self } } # [ doc = "Bit 20 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp20 ( & mut self ) -> _DIRP20W { _DIRP20W { w : self } } # [ doc = "Bit 21 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp21 ( & mut self ) -> _DIRP21W { _DIRP21W { w : self } } # [ doc = "Bit 22 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp22 ( & mut self ) -> _DIRP22W { _DIRP22W { w : self } } # [ doc = "Bit 23 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp23 ( & mut self ) -> _DIRP23W { _DIRP23W { w : self } } # [ doc = "Bit 24 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp24 ( & mut self ) -> _DIRP24W { _DIRP24W { w : self } } # [ doc = "Bit 25 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp25 ( & mut self ) -> _DIRP25W { _DIRP25W { w : self } } # [ doc = "Bit 26 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp26 ( & mut self ) -> _DIRP26W { _DIRP26W { w : self } } # [ doc = "Bit 27 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp27 ( & mut self ) -> _DIRP27W { _DIRP27W { w : self } } # [ doc = "Bit 28 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp28 ( & mut self ) -> _DIRP28W { _DIRP28W { w : self } } # [ doc = "Bit 29 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp29 ( & mut self ) -> _DIRP29W { _DIRP29W { w : self } } # [ doc = "Bit 30 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp30 ( & mut self ) -> _DIRP30W { _DIRP30W { w : self } } # [ doc = "Bit 31 - Selects pin direction for pin P0/1_n (bit 0 = P0/1_0, bit 1 = P0_1, ..., bit 31 = P0/1_31). 0 = input. 1 = output." ] # [ inline ] pub fn dirp31 ( & mut self ) -> _DIRP31W { _DIRP31W { w : self } } } } # [ doc = "Mask register port 0/1" ] pub struct MASK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Mask register port 0/1" ] pub mod mask { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MASK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MASKP0R { bits : bool , } impl MASKP0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP1R { bits : bool , } impl MASKP1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP2R { bits : bool , } impl MASKP2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP3R { bits : bool , } impl MASKP3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP4R { bits : bool , } impl MASKP4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP5R { bits : bool , } impl MASKP5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP6R { bits : bool , } impl MASKP6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP7R { bits : bool , } impl MASKP7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP8R { bits : bool , } impl MASKP8R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP9R { bits : bool , } impl MASKP9R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP10R { bits : bool , } impl MASKP10R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP11R { bits : bool , } impl MASKP11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP12R { bits : bool , } impl MASKP12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP13R { bits : bool , } impl MASKP13R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP14R { bits : bool , } impl MASKP14R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP15R { bits : bool , } impl MASKP15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP16R { bits : bool , } impl MASKP16R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP17R { bits : bool , } impl MASKP17R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP18R { bits : bool , } impl MASKP18R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP19R { bits : bool , } impl MASKP19R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP20R { bits : bool , } impl MASKP20R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP21R { bits : bool , } impl MASKP21R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP22R { bits : bool , } impl MASKP22R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP23R { bits : bool , } impl MASKP23R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP24R { bits : bool , } impl MASKP24R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP25R { bits : bool , } impl MASKP25R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP26R { bits : bool , } impl MASKP26R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP27R { bits : bool , } impl MASKP27R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP28R { bits : bool , } impl MASKP28R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP29R { bits : bool , } impl MASKP29R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP30R { bits : bool , } impl MASKP30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MASKP31R { bits : bool , } impl MASKP31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _MASKP0W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP1W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP2W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP3W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP4W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP5W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP6W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP7W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP8W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP9W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP10W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP11W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP12W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP13W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP14W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP15W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP16W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP17W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP18W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP19W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP20W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP21W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP22W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP23W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP24W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP25W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP26W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP27W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP28W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP29W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP30W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MASKP31W < 'a > { w : & 'a mut W , } impl < 'a > _MASKP31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp0 ( & self ) -> MASKP0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP0R { bits } } # [ doc = "Bit 1 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp1 ( & self ) -> MASKP1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP1R { bits } } # [ doc = "Bit 2 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp2 ( & self ) -> MASKP2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP2R { bits } } # [ doc = "Bit 3 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp3 ( & self ) -> MASKP3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP3R { bits } } # [ doc = "Bit 4 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp4 ( & self ) -> MASKP4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP4R { bits } } # [ doc = "Bit 5 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp5 ( & self ) -> MASKP5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP5R { bits } } # [ doc = "Bit 6 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp6 ( & self ) -> MASKP6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP6R { bits } } # [ doc = "Bit 7 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp7 ( & self ) -> MASKP7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP7R { bits } } # [ doc = "Bit 8 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp8 ( & self ) -> MASKP8R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP8R { bits } } # [ doc = "Bit 9 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp9 ( & self ) -> MASKP9R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP9R { bits } } # [ doc = "Bit 10 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp10 ( & self ) -> MASKP10R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP10R { bits } } # [ doc = "Bit 11 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp11 ( & self ) -> MASKP11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP11R { bits } } # [ doc = "Bit 12 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp12 ( & self ) -> MASKP12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP12R { bits } } # [ doc = "Bit 13 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp13 ( & self ) -> MASKP13R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP13R { bits } } # [ doc = "Bit 14 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp14 ( & self ) -> MASKP14R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP14R { bits } } # [ doc = "Bit 15 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp15 ( & self ) -> MASKP15R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP15R { bits } } # [ doc = "Bit 16 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp16 ( & self ) -> MASKP16R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP16R { bits } } # [ doc = "Bit 17 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp17 ( & self ) -> MASKP17R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP17R { bits } } # [ doc = "Bit 18 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp18 ( & self ) -> MASKP18R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP18R { bits } } # [ doc = "Bit 19 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp19 ( & self ) -> MASKP19R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP19R { bits } } # [ doc = "Bit 20 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp20 ( & self ) -> MASKP20R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP20R { bits } } # [ doc = "Bit 21 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp21 ( & self ) -> MASKP21R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP21R { bits } } # [ doc = "Bit 22 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp22 ( & self ) -> MASKP22R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP22R { bits } } # [ doc = "Bit 23 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp23 ( & self ) -> MASKP23R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP23R { bits } } # [ doc = "Bit 24 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp24 ( & self ) -> MASKP24R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP24R { bits } } # [ doc = "Bit 25 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp25 ( & self ) -> MASKP25R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP25R { bits } } # [ doc = "Bit 26 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp26 ( & self ) -> MASKP26R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP26R { bits } } # [ doc = "Bit 27 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp27 ( & self ) -> MASKP27R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP27R { bits } } # [ doc = "Bit 28 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp28 ( & self ) -> MASKP28R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP28R { bits } } # [ doc = "Bit 29 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp29 ( & self ) -> MASKP29R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP29R { bits } } # [ doc = "Bit 30 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp30 ( & self ) -> MASKP30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP30R { bits } } # [ doc = "Bit 31 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp31 ( & self ) -> MASKP31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MASKP31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp0 ( & mut self ) -> _MASKP0W { _MASKP0W { w : self } } # [ doc = "Bit 1 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp1 ( & mut self ) -> _MASKP1W { _MASKP1W { w : self } } # [ doc = "Bit 2 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp2 ( & mut self ) -> _MASKP2W { _MASKP2W { w : self } } # [ doc = "Bit 3 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp3 ( & mut self ) -> _MASKP3W { _MASKP3W { w : self } } # [ doc = "Bit 4 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp4 ( & mut self ) -> _MASKP4W { _MASKP4W { w : self } } # [ doc = "Bit 5 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp5 ( & mut self ) -> _MASKP5W { _MASKP5W { w : self } } # [ doc = "Bit 6 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp6 ( & mut self ) -> _MASKP6W { _MASKP6W { w : self } } # [ doc = "Bit 7 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp7 ( & mut self ) -> _MASKP7W { _MASKP7W { w : self } } # [ doc = "Bit 8 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp8 ( & mut self ) -> _MASKP8W { _MASKP8W { w : self } } # [ doc = "Bit 9 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp9 ( & mut self ) -> _MASKP9W { _MASKP9W { w : self } } # [ doc = "Bit 10 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp10 ( & mut self ) -> _MASKP10W { _MASKP10W { w : self } } # [ doc = "Bit 11 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp11 ( & mut self ) -> _MASKP11W { _MASKP11W { w : self } } # [ doc = "Bit 12 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp12 ( & mut self ) -> _MASKP12W { _MASKP12W { w : self } } # [ doc = "Bit 13 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp13 ( & mut self ) -> _MASKP13W { _MASKP13W { w : self } } # [ doc = "Bit 14 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp14 ( & mut self ) -> _MASKP14W { _MASKP14W { w : self } } # [ doc = "Bit 15 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp15 ( & mut self ) -> _MASKP15W { _MASKP15W { w : self } } # [ doc = "Bit 16 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp16 ( & mut self ) -> _MASKP16W { _MASKP16W { w : self } } # [ doc = "Bit 17 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp17 ( & mut self ) -> _MASKP17W { _MASKP17W { w : self } } # [ doc = "Bit 18 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp18 ( & mut self ) -> _MASKP18W { _MASKP18W { w : self } } # [ doc = "Bit 19 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp19 ( & mut self ) -> _MASKP19W { _MASKP19W { w : self } } # [ doc = "Bit 20 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp20 ( & mut self ) -> _MASKP20W { _MASKP20W { w : self } } # [ doc = "Bit 21 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp21 ( & mut self ) -> _MASKP21W { _MASKP21W { w : self } } # [ doc = "Bit 22 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp22 ( & mut self ) -> _MASKP22W { _MASKP22W { w : self } } # [ doc = "Bit 23 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp23 ( & mut self ) -> _MASKP23W { _MASKP23W { w : self } } # [ doc = "Bit 24 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp24 ( & mut self ) -> _MASKP24W { _MASKP24W { w : self } } # [ doc = "Bit 25 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp25 ( & mut self ) -> _MASKP25W { _MASKP25W { w : self } } # [ doc = "Bit 26 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp26 ( & mut self ) -> _MASKP26W { _MASKP26W { w : self } } # [ doc = "Bit 27 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp27 ( & mut self ) -> _MASKP27W { _MASKP27W { w : self } } # [ doc = "Bit 28 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp28 ( & mut self ) -> _MASKP28W { _MASKP28W { w : self } } # [ doc = "Bit 29 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp29 ( & mut self ) -> _MASKP29W { _MASKP29W { w : self } } # [ doc = "Bit 30 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp30 ( & mut self ) -> _MASKP30W { _MASKP30W { w : self } } # [ doc = "Bit 31 - Controls which bits corresponding to P0/1_n are active in the P0/1 PIN register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected." ] # [ inline ] pub fn maskp31 ( & mut self ) -> _MASKP31W { _MASKP31W { w : self } } } } # [ doc = "Portpin register port 0" ] pub struct PIN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Portpin register port 0" ] pub mod pin { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PORT0R { bits : bool , } impl PORT0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT1R { bits : bool , } impl PORT1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT2R { bits : bool , } impl PORT2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT3R { bits : bool , } impl PORT3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT4R { bits : bool , } impl PORT4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT5R { bits : bool , } impl PORT5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT6R { bits : bool , } impl PORT6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT7R { bits : bool , } impl PORT7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT8R { bits : bool , } impl PORT8R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT9R { bits : bool , } impl PORT9R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT10R { bits : bool , } impl PORT10R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT11R { bits : bool , } impl PORT11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT12R { bits : bool , } impl PORT12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT13R { bits : bool , } impl PORT13R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT14R { bits : bool , } impl PORT14R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT15R { bits : bool , } impl PORT15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT16R { bits : bool , } impl PORT16R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT17R { bits : bool , } impl PORT17R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT18R { bits : bool , } impl PORT18R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT19R { bits : bool , } impl PORT19R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT20R { bits : bool , } impl PORT20R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT21R { bits : bool , } impl PORT21R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT22R { bits : bool , } impl PORT22R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT23R { bits : bool , } impl PORT23R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT24R { bits : bool , } impl PORT24R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT25R { bits : bool , } impl PORT25R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT26R { bits : bool , } impl PORT26R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT27R { bits : bool , } impl PORT27R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT28R { bits : bool , } impl PORT28R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT29R { bits : bool , } impl PORT29R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT30R { bits : bool , } impl PORT30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct PORT31R { bits : bool , } impl PORT31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _PORT0W < 'a > { w : & 'a mut W , } impl < 'a > _PORT0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT1W < 'a > { w : & 'a mut W , } impl < 'a > _PORT1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT2W < 'a > { w : & 'a mut W , } impl < 'a > _PORT2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT3W < 'a > { w : & 'a mut W , } impl < 'a > _PORT3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT4W < 'a > { w : & 'a mut W , } impl < 'a > _PORT4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT5W < 'a > { w : & 'a mut W , } impl < 'a > _PORT5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT6W < 'a > { w : & 'a mut W , } impl < 'a > _PORT6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT7W < 'a > { w : & 'a mut W , } impl < 'a > _PORT7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT8W < 'a > { w : & 'a mut W , } impl < 'a > _PORT8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT9W < 'a > { w : & 'a mut W , } impl < 'a > _PORT9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT10W < 'a > { w : & 'a mut W , } impl < 'a > _PORT10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT11W < 'a > { w : & 'a mut W , } impl < 'a > _PORT11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT12W < 'a > { w : & 'a mut W , } impl < 'a > _PORT12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT13W < 'a > { w : & 'a mut W , } impl < 'a > _PORT13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT14W < 'a > { w : & 'a mut W , } impl < 'a > _PORT14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT15W < 'a > { w : & 'a mut W , } impl < 'a > _PORT15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT16W < 'a > { w : & 'a mut W , } impl < 'a > _PORT16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT17W < 'a > { w : & 'a mut W , } impl < 'a > _PORT17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT18W < 'a > { w : & 'a mut W , } impl < 'a > _PORT18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT19W < 'a > { w : & 'a mut W , } impl < 'a > _PORT19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT20W < 'a > { w : & 'a mut W , } impl < 'a > _PORT20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT21W < 'a > { w : & 'a mut W , } impl < 'a > _PORT21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT22W < 'a > { w : & 'a mut W , } impl < 'a > _PORT22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT23W < 'a > { w : & 'a mut W , } impl < 'a > _PORT23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT24W < 'a > { w : & 'a mut W , } impl < 'a > _PORT24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT25W < 'a > { w : & 'a mut W , } impl < 'a > _PORT25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT26W < 'a > { w : & 'a mut W , } impl < 'a > _PORT26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT27W < 'a > { w : & 'a mut W , } impl < 'a > _PORT27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT28W < 'a > { w : & 'a mut W , } impl < 'a > _PORT28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT29W < 'a > { w : & 'a mut W , } impl < 'a > _PORT29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT30W < 'a > { w : & 'a mut W , } impl < 'a > _PORT30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PORT31W < 'a > { w : & 'a mut W , } impl < 'a > _PORT31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port0 ( & self ) -> PORT0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT0R { bits } } # [ doc = "Bit 1 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port1 ( & self ) -> PORT1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT1R { bits } } # [ doc = "Bit 2 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port2 ( & self ) -> PORT2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT2R { bits } } # [ doc = "Bit 3 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port3 ( & self ) -> PORT3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT3R { bits } } # [ doc = "Bit 4 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port4 ( & self ) -> PORT4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT4R { bits } } # [ doc = "Bit 5 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port5 ( & self ) -> PORT5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT5R { bits } } # [ doc = "Bit 6 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port6 ( & self ) -> PORT6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT6R { bits } } # [ doc = "Bit 7 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port7 ( & self ) -> PORT7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT7R { bits } } # [ doc = "Bit 8 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port8 ( & self ) -> PORT8R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT8R { bits } } # [ doc = "Bit 9 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port9 ( & self ) -> PORT9R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT9R { bits } } # [ doc = "Bit 10 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port10 ( & self ) -> PORT10R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT10R { bits } } # [ doc = "Bit 11 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port11 ( & self ) -> PORT11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT11R { bits } } # [ doc = "Bit 12 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port12 ( & self ) -> PORT12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT12R { bits } } # [ doc = "Bit 13 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port13 ( & self ) -> PORT13R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT13R { bits } } # [ doc = "Bit 14 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port14 ( & self ) -> PORT14R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT14R { bits } } # [ doc = "Bit 15 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port15 ( & self ) -> PORT15R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT15R { bits } } # [ doc = "Bit 16 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port16 ( & self ) -> PORT16R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT16R { bits } } # [ doc = "Bit 17 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port17 ( & self ) -> PORT17R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT17R { bits } } # [ doc = "Bit 18 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port18 ( & self ) -> PORT18R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT18R { bits } } # [ doc = "Bit 19 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port19 ( & self ) -> PORT19R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT19R { bits } } # [ doc = "Bit 20 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port20 ( & self ) -> PORT20R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT20R { bits } } # [ doc = "Bit 21 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port21 ( & self ) -> PORT21R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT21R { bits } } # [ doc = "Bit 22 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port22 ( & self ) -> PORT22R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT22R { bits } } # [ doc = "Bit 23 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port23 ( & self ) -> PORT23R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT23R { bits } } # [ doc = "Bit 24 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port24 ( & self ) -> PORT24R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT24R { bits } } # [ doc = "Bit 25 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port25 ( & self ) -> PORT25R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT25R { bits } } # [ doc = "Bit 26 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port26 ( & self ) -> PORT26R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT26R { bits } } # [ doc = "Bit 27 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port27 ( & self ) -> PORT27R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT27R { bits } } # [ doc = "Bit 28 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port28 ( & self ) -> PORT28R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT28R { bits } } # [ doc = "Bit 29 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port29 ( & self ) -> PORT29R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT29R { bits } } # [ doc = "Bit 30 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port30 ( & self ) -> PORT30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT30R { bits } } # [ doc = "Bit 31 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port31 ( & self ) -> PORT31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; PORT31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port0 ( & mut self ) -> _PORT0W { _PORT0W { w : self } } # [ doc = "Bit 1 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port1 ( & mut self ) -> _PORT1W { _PORT1W { w : self } } # [ doc = "Bit 2 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port2 ( & mut self ) -> _PORT2W { _PORT2W { w : self } } # [ doc = "Bit 3 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port3 ( & mut self ) -> _PORT3W { _PORT3W { w : self } } # [ doc = "Bit 4 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port4 ( & mut self ) -> _PORT4W { _PORT4W { w : self } } # [ doc = "Bit 5 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port5 ( & mut self ) -> _PORT5W { _PORT5W { w : self } } # [ doc = "Bit 6 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port6 ( & mut self ) -> _PORT6W { _PORT6W { w : self } } # [ doc = "Bit 7 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port7 ( & mut self ) -> _PORT7W { _PORT7W { w : self } } # [ doc = "Bit 8 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port8 ( & mut self ) -> _PORT8W { _PORT8W { w : self } } # [ doc = "Bit 9 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port9 ( & mut self ) -> _PORT9W { _PORT9W { w : self } } # [ doc = "Bit 10 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port10 ( & mut self ) -> _PORT10W { _PORT10W { w : self } } # [ doc = "Bit 11 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port11 ( & mut self ) -> _PORT11W { _PORT11W { w : self } } # [ doc = "Bit 12 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port12 ( & mut self ) -> _PORT12W { _PORT12W { w : self } } # [ doc = "Bit 13 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port13 ( & mut self ) -> _PORT13W { _PORT13W { w : self } } # [ doc = "Bit 14 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port14 ( & mut self ) -> _PORT14W { _PORT14W { w : self } } # [ doc = "Bit 15 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port15 ( & mut self ) -> _PORT15W { _PORT15W { w : self } } # [ doc = "Bit 16 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port16 ( & mut self ) -> _PORT16W { _PORT16W { w : self } } # [ doc = "Bit 17 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port17 ( & mut self ) -> _PORT17W { _PORT17W { w : self } } # [ doc = "Bit 18 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port18 ( & mut self ) -> _PORT18W { _PORT18W { w : self } } # [ doc = "Bit 19 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port19 ( & mut self ) -> _PORT19W { _PORT19W { w : self } } # [ doc = "Bit 20 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port20 ( & mut self ) -> _PORT20W { _PORT20W { w : self } } # [ doc = "Bit 21 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port21 ( & mut self ) -> _PORT21W { _PORT21W { w : self } } # [ doc = "Bit 22 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port22 ( & mut self ) -> _PORT22W { _PORT22W { w : self } } # [ doc = "Bit 23 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port23 ( & mut self ) -> _PORT23W { _PORT23W { w : self } } # [ doc = "Bit 24 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port24 ( & mut self ) -> _PORT24W { _PORT24W { w : self } } # [ doc = "Bit 25 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port25 ( & mut self ) -> _PORT25W { _PORT25W { w : self } } # [ doc = "Bit 26 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port26 ( & mut self ) -> _PORT26W { _PORT26W { w : self } } # [ doc = "Bit 27 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port27 ( & mut self ) -> _PORT27W { _PORT27W { w : self } } # [ doc = "Bit 28 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port28 ( & mut self ) -> _PORT28W { _PORT28W { w : self } } # [ doc = "Bit 29 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port29 ( & mut self ) -> _PORT29W { _PORT29W { w : self } } # [ doc = "Bit 30 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port30 ( & mut self ) -> _PORT30W { _PORT30W { w : self } } # [ doc = "Bit 31 - Reads pin states or loads output bits (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit." ] # [ inline ] pub fn port31 ( & mut self ) -> _PORT31W { _PORT31W { w : self } } } } # [ doc = "Masked port register port 0/1" ] pub struct MPIN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Masked port register port 0/1" ] pub mod mpin { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MPIN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MPORTP0R { bits : bool , } impl MPORTP0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP1R { bits : bool , } impl MPORTP1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP2R { bits : bool , } impl MPORTP2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP3R { bits : bool , } impl MPORTP3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP4R { bits : bool , } impl MPORTP4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP5R { bits : bool , } impl MPORTP5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP6R { bits : bool , } impl MPORTP6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP7R { bits : bool , } impl MPORTP7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP8R { bits : bool , } impl MPORTP8R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP9R { bits : bool , } impl MPORTP9R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP10R { bits : bool , } impl MPORTP10R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP11R { bits : bool , } impl MPORTP11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP12R { bits : bool , } impl MPORTP12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP13R { bits : bool , } impl MPORTP13R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP14R { bits : bool , } impl MPORTP14R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP15R { bits : bool , } impl MPORTP15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP16R { bits : bool , } impl MPORTP16R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP17R { bits : bool , } impl MPORTP17R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP18R { bits : bool , } impl MPORTP18R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP19R { bits : bool , } impl MPORTP19R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP20R { bits : bool , } impl MPORTP20R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP21R { bits : bool , } impl MPORTP21R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP22R { bits : bool , } impl MPORTP22R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP23R { bits : bool , } impl MPORTP23R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP24R { bits : bool , } impl MPORTP24R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP25R { bits : bool , } impl MPORTP25R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP26R { bits : bool , } impl MPORTP26R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP27R { bits : bool , } impl MPORTP27R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP28R { bits : bool , } impl MPORTP28R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP29R { bits : bool , } impl MPORTP29R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP30R { bits : bool , } impl MPORTP30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct MPORTP31R { bits : bool , } impl MPORTP31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _MPORTP0W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP1W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP2W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP3W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP4W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP5W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP6W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP7W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP8W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP9W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP10W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP11W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP12W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP13W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP14W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP15W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP16W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP17W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP18W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP19W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP20W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP21W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP22W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP23W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP24W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP25W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP26W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP27W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP28W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP29W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP30W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _MPORTP31W < 'a > { w : & 'a mut W , } impl < 'a > _MPORTP31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp0 ( & self ) -> MPORTP0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP0R { bits } } # [ doc = "Bit 1 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp1 ( & self ) -> MPORTP1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP1R { bits } } # [ doc = "Bit 2 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp2 ( & self ) -> MPORTP2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP2R { bits } } # [ doc = "Bit 3 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp3 ( & self ) -> MPORTP3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP3R { bits } } # [ doc = "Bit 4 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp4 ( & self ) -> MPORTP4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP4R { bits } } # [ doc = "Bit 5 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp5 ( & self ) -> MPORTP5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP5R { bits } } # [ doc = "Bit 6 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp6 ( & self ) -> MPORTP6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP6R { bits } } # [ doc = "Bit 7 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp7 ( & self ) -> MPORTP7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP7R { bits } } # [ doc = "Bit 8 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp8 ( & self ) -> MPORTP8R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP8R { bits } } # [ doc = "Bit 9 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp9 ( & self ) -> MPORTP9R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP9R { bits } } # [ doc = "Bit 10 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp10 ( & self ) -> MPORTP10R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP10R { bits } } # [ doc = "Bit 11 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp11 ( & self ) -> MPORTP11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP11R { bits } } # [ doc = "Bit 12 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp12 ( & self ) -> MPORTP12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP12R { bits } } # [ doc = "Bit 13 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp13 ( & self ) -> MPORTP13R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP13R { bits } } # [ doc = "Bit 14 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp14 ( & self ) -> MPORTP14R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP14R { bits } } # [ doc = "Bit 15 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp15 ( & self ) -> MPORTP15R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP15R { bits } } # [ doc = "Bit 16 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp16 ( & self ) -> MPORTP16R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP16R { bits } } # [ doc = "Bit 17 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp17 ( & self ) -> MPORTP17R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP17R { bits } } # [ doc = "Bit 18 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp18 ( & self ) -> MPORTP18R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP18R { bits } } # [ doc = "Bit 19 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp19 ( & self ) -> MPORTP19R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP19R { bits } } # [ doc = "Bit 20 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp20 ( & self ) -> MPORTP20R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP20R { bits } } # [ doc = "Bit 21 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp21 ( & self ) -> MPORTP21R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP21R { bits } } # [ doc = "Bit 22 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp22 ( & self ) -> MPORTP22R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP22R { bits } } # [ doc = "Bit 23 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp23 ( & self ) -> MPORTP23R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP23R { bits } } # [ doc = "Bit 24 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp24 ( & self ) -> MPORTP24R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP24R { bits } } # [ doc = "Bit 25 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp25 ( & self ) -> MPORTP25R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP25R { bits } } # [ doc = "Bit 26 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp26 ( & self ) -> MPORTP26R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP26R { bits } } # [ doc = "Bit 27 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp27 ( & self ) -> MPORTP27R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP27R { bits } } # [ doc = "Bit 28 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp28 ( & self ) -> MPORTP28R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP28R { bits } } # [ doc = "Bit 29 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp29 ( & self ) -> MPORTP29R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP29R { bits } } # [ doc = "Bit 30 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp30 ( & self ) -> MPORTP30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP30R { bits } } # [ doc = "Bit 31 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp31 ( & self ) -> MPORTP31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; MPORTP31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp0 ( & mut self ) -> _MPORTP0W { _MPORTP0W { w : self } } # [ doc = "Bit 1 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp1 ( & mut self ) -> _MPORTP1W { _MPORTP1W { w : self } } # [ doc = "Bit 2 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp2 ( & mut self ) -> _MPORTP2W { _MPORTP2W { w : self } } # [ doc = "Bit 3 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp3 ( & mut self ) -> _MPORTP3W { _MPORTP3W { w : self } } # [ doc = "Bit 4 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp4 ( & mut self ) -> _MPORTP4W { _MPORTP4W { w : self } } # [ doc = "Bit 5 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp5 ( & mut self ) -> _MPORTP5W { _MPORTP5W { w : self } } # [ doc = "Bit 6 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp6 ( & mut self ) -> _MPORTP6W { _MPORTP6W { w : self } } # [ doc = "Bit 7 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp7 ( & mut self ) -> _MPORTP7W { _MPORTP7W { w : self } } # [ doc = "Bit 8 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp8 ( & mut self ) -> _MPORTP8W { _MPORTP8W { w : self } } # [ doc = "Bit 9 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp9 ( & mut self ) -> _MPORTP9W { _MPORTP9W { w : self } } # [ doc = "Bit 10 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp10 ( & mut self ) -> _MPORTP10W { _MPORTP10W { w : self } } # [ doc = "Bit 11 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp11 ( & mut self ) -> _MPORTP11W { _MPORTP11W { w : self } } # [ doc = "Bit 12 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp12 ( & mut self ) -> _MPORTP12W { _MPORTP12W { w : self } } # [ doc = "Bit 13 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp13 ( & mut self ) -> _MPORTP13W { _MPORTP13W { w : self } } # [ doc = "Bit 14 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp14 ( & mut self ) -> _MPORTP14W { _MPORTP14W { w : self } } # [ doc = "Bit 15 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp15 ( & mut self ) -> _MPORTP15W { _MPORTP15W { w : self } } # [ doc = "Bit 16 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp16 ( & mut self ) -> _MPORTP16W { _MPORTP16W { w : self } } # [ doc = "Bit 17 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp17 ( & mut self ) -> _MPORTP17W { _MPORTP17W { w : self } } # [ doc = "Bit 18 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp18 ( & mut self ) -> _MPORTP18W { _MPORTP18W { w : self } } # [ doc = "Bit 19 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp19 ( & mut self ) -> _MPORTP19W { _MPORTP19W { w : self } } # [ doc = "Bit 20 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp20 ( & mut self ) -> _MPORTP20W { _MPORTP20W { w : self } } # [ doc = "Bit 21 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp21 ( & mut self ) -> _MPORTP21W { _MPORTP21W { w : self } } # [ doc = "Bit 22 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp22 ( & mut self ) -> _MPORTP22W { _MPORTP22W { w : self } } # [ doc = "Bit 23 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp23 ( & mut self ) -> _MPORTP23W { _MPORTP23W { w : self } } # [ doc = "Bit 24 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp24 ( & mut self ) -> _MPORTP24W { _MPORTP24W { w : self } } # [ doc = "Bit 25 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp25 ( & mut self ) -> _MPORTP25W { _MPORTP25W { w : self } } # [ doc = "Bit 26 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp26 ( & mut self ) -> _MPORTP26W { _MPORTP26W { w : self } } # [ doc = "Bit 27 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp27 ( & mut self ) -> _MPORTP27W { _MPORTP27W { w : self } } # [ doc = "Bit 28 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp28 ( & mut self ) -> _MPORTP28W { _MPORTP28W { w : self } } # [ doc = "Bit 29 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp29 ( & mut self ) -> _MPORTP29W { _MPORTP29W { w : self } } # [ doc = "Bit 30 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp30 ( & mut self ) -> _MPORTP30W { _MPORTP30W { w : self } } # [ doc = "Bit 31 - Masked port register (bit 0 = P0/1_0, bit 1 = P0/1_1, ..., bit 31 = P0/1_31). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0." ] # [ inline ] pub fn mportp31 ( & mut self ) -> _MPORTP31W { _MPORTP31W { w : self } } } } # [ doc = "Write: Set register for port 0/1 Read: output bits for port 0/1" ] pub struct SET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Write: Set register for port 0/1 Read: output bits for port 0/1" ] pub mod set { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct SETP0R { bits : bool , } impl SETP0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP1R { bits : bool , } impl SETP1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP2R { bits : bool , } impl SETP2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP3R { bits : bool , } impl SETP3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP4R { bits : bool , } impl SETP4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP5R { bits : bool , } impl SETP5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP6R { bits : bool , } impl SETP6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP7R { bits : bool , } impl SETP7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP8R { bits : bool , } impl SETP8R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP9R { bits : bool , } impl SETP9R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP10R { bits : bool , } impl SETP10R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP11R { bits : bool , } impl SETP11R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP12R { bits : bool , } impl SETP12R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP13R { bits : bool , } impl SETP13R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP14R { bits : bool , } impl SETP14R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP15R { bits : bool , } impl SETP15R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP16R { bits : bool , } impl SETP16R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP17R { bits : bool , } impl SETP17R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP18R { bits : bool , } impl SETP18R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP19R { bits : bool , } impl SETP19R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP20R { bits : bool , } impl SETP20R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP21R { bits : bool , } impl SETP21R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP22R { bits : bool , } impl SETP22R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP23R { bits : bool , } impl SETP23R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP24R { bits : bool , } impl SETP24R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP25R { bits : bool , } impl SETP25R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP26R { bits : bool , } impl SETP26R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP27R { bits : bool , } impl SETP27R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP28R { bits : bool , } impl SETP28R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP29R { bits : bool , } impl SETP29R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP30R { bits : bool , } impl SETP30R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SETP31R { bits : bool , } impl SETP31R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _SETP0W < 'a > { w : & 'a mut W , } impl < 'a > _SETP0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP1W < 'a > { w : & 'a mut W , } impl < 'a > _SETP1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP2W < 'a > { w : & 'a mut W , } impl < 'a > _SETP2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP3W < 'a > { w : & 'a mut W , } impl < 'a > _SETP3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP4W < 'a > { w : & 'a mut W , } impl < 'a > _SETP4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP5W < 'a > { w : & 'a mut W , } impl < 'a > _SETP5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP6W < 'a > { w : & 'a mut W , } impl < 'a > _SETP6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP7W < 'a > { w : & 'a mut W , } impl < 'a > _SETP7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP8W < 'a > { w : & 'a mut W , } impl < 'a > _SETP8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP9W < 'a > { w : & 'a mut W , } impl < 'a > _SETP9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP10W < 'a > { w : & 'a mut W , } impl < 'a > _SETP10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP11W < 'a > { w : & 'a mut W , } impl < 'a > _SETP11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP12W < 'a > { w : & 'a mut W , } impl < 'a > _SETP12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP13W < 'a > { w : & 'a mut W , } impl < 'a > _SETP13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP14W < 'a > { w : & 'a mut W , } impl < 'a > _SETP14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP15W < 'a > { w : & 'a mut W , } impl < 'a > _SETP15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP16W < 'a > { w : & 'a mut W , } impl < 'a > _SETP16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP17W < 'a > { w : & 'a mut W , } impl < 'a > _SETP17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP18W < 'a > { w : & 'a mut W , } impl < 'a > _SETP18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP19W < 'a > { w : & 'a mut W , } impl < 'a > _SETP19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP20W < 'a > { w : & 'a mut W , } impl < 'a > _SETP20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP21W < 'a > { w : & 'a mut W , } impl < 'a > _SETP21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP22W < 'a > { w : & 'a mut W , } impl < 'a > _SETP22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP23W < 'a > { w : & 'a mut W , } impl < 'a > _SETP23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP24W < 'a > { w : & 'a mut W , } impl < 'a > _SETP24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP25W < 'a > { w : & 'a mut W , } impl < 'a > _SETP25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP26W < 'a > { w : & 'a mut W , } impl < 'a > _SETP26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP27W < 'a > { w : & 'a mut W , } impl < 'a > _SETP27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP28W < 'a > { w : & 'a mut W , } impl < 'a > _SETP28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP29W < 'a > { w : & 'a mut W , } impl < 'a > _SETP29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP30W < 'a > { w : & 'a mut W , } impl < 'a > _SETP30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SETP31W < 'a > { w : & 'a mut W , } impl < 'a > _SETP31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp0 ( & self ) -> SETP0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP0R { bits } } # [ doc = "Bit 1 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp1 ( & self ) -> SETP1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP1R { bits } } # [ doc = "Bit 2 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp2 ( & self ) -> SETP2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP2R { bits } } # [ doc = "Bit 3 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp3 ( & self ) -> SETP3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP3R { bits } } # [ doc = "Bit 4 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp4 ( & self ) -> SETP4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP4R { bits } } # [ doc = "Bit 5 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp5 ( & self ) -> SETP5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP5R { bits } } # [ doc = "Bit 6 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp6 ( & self ) -> SETP6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP6R { bits } } # [ doc = "Bit 7 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp7 ( & self ) -> SETP7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP7R { bits } } # [ doc = "Bit 8 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp8 ( & self ) -> SETP8R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP8R { bits } } # [ doc = "Bit 9 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp9 ( & self ) -> SETP9R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP9R { bits } } # [ doc = "Bit 10 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp10 ( & self ) -> SETP10R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP10R { bits } } # [ doc = "Bit 11 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp11 ( & self ) -> SETP11R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP11R { bits } } # [ doc = "Bit 12 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp12 ( & self ) -> SETP12R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP12R { bits } } # [ doc = "Bit 13 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp13 ( & self ) -> SETP13R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP13R { bits } } # [ doc = "Bit 14 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp14 ( & self ) -> SETP14R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP14R { bits } } # [ doc = "Bit 15 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp15 ( & self ) -> SETP15R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP15R { bits } } # [ doc = "Bit 16 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp16 ( & self ) -> SETP16R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP16R { bits } } # [ doc = "Bit 17 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp17 ( & self ) -> SETP17R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP17R { bits } } # [ doc = "Bit 18 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp18 ( & self ) -> SETP18R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP18R { bits } } # [ doc = "Bit 19 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp19 ( & self ) -> SETP19R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP19R { bits } } # [ doc = "Bit 20 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp20 ( & self ) -> SETP20R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP20R { bits } } # [ doc = "Bit 21 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp21 ( & self ) -> SETP21R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP21R { bits } } # [ doc = "Bit 22 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp22 ( & self ) -> SETP22R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP22R { bits } } # [ doc = "Bit 23 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp23 ( & self ) -> SETP23R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP23R { bits } } # [ doc = "Bit 24 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp24 ( & self ) -> SETP24R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP24R { bits } } # [ doc = "Bit 25 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp25 ( & self ) -> SETP25R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP25R { bits } } # [ doc = "Bit 26 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp26 ( & self ) -> SETP26R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP26R { bits } } # [ doc = "Bit 27 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp27 ( & self ) -> SETP27R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP27R { bits } } # [ doc = "Bit 28 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp28 ( & self ) -> SETP28R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP28R { bits } } # [ doc = "Bit 29 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp29 ( & self ) -> SETP29R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP29R { bits } } # [ doc = "Bit 30 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp30 ( & self ) -> SETP30R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP30R { bits } } # [ doc = "Bit 31 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp31 ( & self ) -> SETP31R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SETP31R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp0 ( & mut self ) -> _SETP0W { _SETP0W { w : self } } # [ doc = "Bit 1 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp1 ( & mut self ) -> _SETP1W { _SETP1W { w : self } } # [ doc = "Bit 2 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp2 ( & mut self ) -> _SETP2W { _SETP2W { w : self } } # [ doc = "Bit 3 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp3 ( & mut self ) -> _SETP3W { _SETP3W { w : self } } # [ doc = "Bit 4 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp4 ( & mut self ) -> _SETP4W { _SETP4W { w : self } } # [ doc = "Bit 5 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp5 ( & mut self ) -> _SETP5W { _SETP5W { w : self } } # [ doc = "Bit 6 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp6 ( & mut self ) -> _SETP6W { _SETP6W { w : self } } # [ doc = "Bit 7 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp7 ( & mut self ) -> _SETP7W { _SETP7W { w : self } } # [ doc = "Bit 8 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp8 ( & mut self ) -> _SETP8W { _SETP8W { w : self } } # [ doc = "Bit 9 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp9 ( & mut self ) -> _SETP9W { _SETP9W { w : self } } # [ doc = "Bit 10 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp10 ( & mut self ) -> _SETP10W { _SETP10W { w : self } } # [ doc = "Bit 11 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp11 ( & mut self ) -> _SETP11W { _SETP11W { w : self } } # [ doc = "Bit 12 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp12 ( & mut self ) -> _SETP12W { _SETP12W { w : self } } # [ doc = "Bit 13 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp13 ( & mut self ) -> _SETP13W { _SETP13W { w : self } } # [ doc = "Bit 14 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp14 ( & mut self ) -> _SETP14W { _SETP14W { w : self } } # [ doc = "Bit 15 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp15 ( & mut self ) -> _SETP15W { _SETP15W { w : self } } # [ doc = "Bit 16 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp16 ( & mut self ) -> _SETP16W { _SETP16W { w : self } } # [ doc = "Bit 17 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp17 ( & mut self ) -> _SETP17W { _SETP17W { w : self } } # [ doc = "Bit 18 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp18 ( & mut self ) -> _SETP18W { _SETP18W { w : self } } # [ doc = "Bit 19 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp19 ( & mut self ) -> _SETP19W { _SETP19W { w : self } } # [ doc = "Bit 20 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp20 ( & mut self ) -> _SETP20W { _SETP20W { w : self } } # [ doc = "Bit 21 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp21 ( & mut self ) -> _SETP21W { _SETP21W { w : self } } # [ doc = "Bit 22 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp22 ( & mut self ) -> _SETP22W { _SETP22W { w : self } } # [ doc = "Bit 23 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp23 ( & mut self ) -> _SETP23W { _SETP23W { w : self } } # [ doc = "Bit 24 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp24 ( & mut self ) -> _SETP24W { _SETP24W { w : self } } # [ doc = "Bit 25 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp25 ( & mut self ) -> _SETP25W { _SETP25W { w : self } } # [ doc = "Bit 26 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp26 ( & mut self ) -> _SETP26W { _SETP26W { w : self } } # [ doc = "Bit 27 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp27 ( & mut self ) -> _SETP27W { _SETP27W { w : self } } # [ doc = "Bit 28 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp28 ( & mut self ) -> _SETP28W { _SETP28W { w : self } } # [ doc = "Bit 29 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp29 ( & mut self ) -> _SETP29W { _SETP29W { w : self } } # [ doc = "Bit 30 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp30 ( & mut self ) -> _SETP30W { _SETP30W { w : self } } # [ doc = "Bit 31 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit." ] # [ inline ] pub fn setp31 ( & mut self ) -> _SETP31W { _SETP31W { w : self } } } } # [ doc = "Clear port 0/1" ] pub struct CLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clear port 0/1" ] pub mod clr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CLR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _CLRP00W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP00W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP01W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP01W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP02W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP02W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP03W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP03W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP04W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP04W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP05W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP05W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP06W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP06W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP07W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP07W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP08W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP08W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP09W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP09W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP010W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP010W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP011W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP011W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP012W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP012W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP013W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP013W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP014W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP014W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP015W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP015W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP016W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP016W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP017W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP017W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP018W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP018W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP019W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP019W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP020W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP020W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP021W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP021W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP022W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP022W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP023W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP023W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP024W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP024W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP025W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP025W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP026W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP026W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP027W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP027W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP028W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP028W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP029W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP029W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP030W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP030W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _CLRP031W < 'a > { w : & 'a mut W , } impl < 'a > _CLRP031W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp00 ( & mut self ) -> _CLRP00W { _CLRP00W { w : self } } # [ doc = "Bit 1 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp01 ( & mut self ) -> _CLRP01W { _CLRP01W { w : self } } # [ doc = "Bit 2 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp02 ( & mut self ) -> _CLRP02W { _CLRP02W { w : self } } # [ doc = "Bit 3 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp03 ( & mut self ) -> _CLRP03W { _CLRP03W { w : self } } # [ doc = "Bit 4 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp04 ( & mut self ) -> _CLRP04W { _CLRP04W { w : self } } # [ doc = "Bit 5 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp05 ( & mut self ) -> _CLRP05W { _CLRP05W { w : self } } # [ doc = "Bit 6 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp06 ( & mut self ) -> _CLRP06W { _CLRP06W { w : self } } # [ doc = "Bit 7 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp07 ( & mut self ) -> _CLRP07W { _CLRP07W { w : self } } # [ doc = "Bit 8 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp08 ( & mut self ) -> _CLRP08W { _CLRP08W { w : self } } # [ doc = "Bit 9 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp09 ( & mut self ) -> _CLRP09W { _CLRP09W { w : self } } # [ doc = "Bit 10 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp010 ( & mut self ) -> _CLRP010W { _CLRP010W { w : self } } # [ doc = "Bit 11 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp011 ( & mut self ) -> _CLRP011W { _CLRP011W { w : self } } # [ doc = "Bit 12 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp012 ( & mut self ) -> _CLRP012W { _CLRP012W { w : self } } # [ doc = "Bit 13 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp013 ( & mut self ) -> _CLRP013W { _CLRP013W { w : self } } # [ doc = "Bit 14 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp014 ( & mut self ) -> _CLRP014W { _CLRP014W { w : self } } # [ doc = "Bit 15 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp015 ( & mut self ) -> _CLRP015W { _CLRP015W { w : self } } # [ doc = "Bit 16 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp016 ( & mut self ) -> _CLRP016W { _CLRP016W { w : self } } # [ doc = "Bit 17 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp017 ( & mut self ) -> _CLRP017W { _CLRP017W { w : self } } # [ doc = "Bit 18 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp018 ( & mut self ) -> _CLRP018W { _CLRP018W { w : self } } # [ doc = "Bit 19 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp019 ( & mut self ) -> _CLRP019W { _CLRP019W { w : self } } # [ doc = "Bit 20 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp020 ( & mut self ) -> _CLRP020W { _CLRP020W { w : self } } # [ doc = "Bit 21 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp021 ( & mut self ) -> _CLRP021W { _CLRP021W { w : self } } # [ doc = "Bit 22 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp022 ( & mut self ) -> _CLRP022W { _CLRP022W { w : self } } # [ doc = "Bit 23 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp023 ( & mut self ) -> _CLRP023W { _CLRP023W { w : self } } # [ doc = "Bit 24 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp024 ( & mut self ) -> _CLRP024W { _CLRP024W { w : self } } # [ doc = "Bit 25 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp025 ( & mut self ) -> _CLRP025W { _CLRP025W { w : self } } # [ doc = "Bit 26 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp026 ( & mut self ) -> _CLRP026W { _CLRP026W { w : self } } # [ doc = "Bit 27 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp027 ( & mut self ) -> _CLRP027W { _CLRP027W { w : self } } # [ doc = "Bit 28 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp028 ( & mut self ) -> _CLRP028W { _CLRP028W { w : self } } # [ doc = "Bit 29 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp029 ( & mut self ) -> _CLRP029W { _CLRP029W { w : self } } # [ doc = "Bit 30 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp030 ( & mut self ) -> _CLRP030W { _CLRP030W { w : self } } # [ doc = "Bit 31 - Clear output bits: 0 = No operation. 1 = Clear output bit." ] # [ inline ] pub fn clrp031 ( & mut self ) -> _CLRP031W { _CLRP031W { w : self } } } } # [ doc = "Toggle port 0/1" ] pub struct NOT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Toggle port 0/1" ] pub mod not { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: NOT { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _NOTP0W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP1W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP2W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP3W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP4W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP5W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP6W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP7W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP8W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP8W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP9W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP9W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP10W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP10W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP11W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP11W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP12W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP12W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP13W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP13W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP14W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP14W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP15W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP15W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP16W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP16W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP17W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP17W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP18W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP18W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP19W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP19W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP20W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP20W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP21W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP21W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP22W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP22W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP23W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP23W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP24W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP24W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP25W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP25W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP26W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP26W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP27W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP27W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP28W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP28W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP29W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP29W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP30W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP30W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _NOTP31W < 'a > { w : & 'a mut W , } impl < 'a > _NOTP31W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp0 ( & mut self ) -> _NOTP0W { _NOTP0W { w : self } } # [ doc = "Bit 1 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp1 ( & mut self ) -> _NOTP1W { _NOTP1W { w : self } } # [ doc = "Bit 2 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp2 ( & mut self ) -> _NOTP2W { _NOTP2W { w : self } } # [ doc = "Bit 3 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp3 ( & mut self ) -> _NOTP3W { _NOTP3W { w : self } } # [ doc = "Bit 4 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp4 ( & mut self ) -> _NOTP4W { _NOTP4W { w : self } } # [ doc = "Bit 5 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp5 ( & mut self ) -> _NOTP5W { _NOTP5W { w : self } } # [ doc = "Bit 6 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp6 ( & mut self ) -> _NOTP6W { _NOTP6W { w : self } } # [ doc = "Bit 7 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp7 ( & mut self ) -> _NOTP7W { _NOTP7W { w : self } } # [ doc = "Bit 8 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp8 ( & mut self ) -> _NOTP8W { _NOTP8W { w : self } } # [ doc = "Bit 9 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp9 ( & mut self ) -> _NOTP9W { _NOTP9W { w : self } } # [ doc = "Bit 10 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp10 ( & mut self ) -> _NOTP10W { _NOTP10W { w : self } } # [ doc = "Bit 11 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp11 ( & mut self ) -> _NOTP11W { _NOTP11W { w : self } } # [ doc = "Bit 12 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp12 ( & mut self ) -> _NOTP12W { _NOTP12W { w : self } } # [ doc = "Bit 13 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp13 ( & mut self ) -> _NOTP13W { _NOTP13W { w : self } } # [ doc = "Bit 14 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp14 ( & mut self ) -> _NOTP14W { _NOTP14W { w : self } } # [ doc = "Bit 15 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp15 ( & mut self ) -> _NOTP15W { _NOTP15W { w : self } } # [ doc = "Bit 16 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp16 ( & mut self ) -> _NOTP16W { _NOTP16W { w : self } } # [ doc = "Bit 17 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp17 ( & mut self ) -> _NOTP17W { _NOTP17W { w : self } } # [ doc = "Bit 18 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp18 ( & mut self ) -> _NOTP18W { _NOTP18W { w : self } } # [ doc = "Bit 19 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp19 ( & mut self ) -> _NOTP19W { _NOTP19W { w : self } } # [ doc = "Bit 20 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp20 ( & mut self ) -> _NOTP20W { _NOTP20W { w : self } } # [ doc = "Bit 21 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp21 ( & mut self ) -> _NOTP21W { _NOTP21W { w : self } } # [ doc = "Bit 22 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp22 ( & mut self ) -> _NOTP22W { _NOTP22W { w : self } } # [ doc = "Bit 23 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp23 ( & mut self ) -> _NOTP23W { _NOTP23W { w : self } } # [ doc = "Bit 24 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp24 ( & mut self ) -> _NOTP24W { _NOTP24W { w : self } } # [ doc = "Bit 25 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp25 ( & mut self ) -> _NOTP25W { _NOTP25W { w : self } } # [ doc = "Bit 26 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp26 ( & mut self ) -> _NOTP26W { _NOTP26W { w : self } } # [ doc = "Bit 27 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp27 ( & mut self ) -> _NOTP27W { _NOTP27W { w : self } } # [ doc = "Bit 28 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp28 ( & mut self ) -> _NOTP28W { _NOTP28W { w : self } } # [ doc = "Bit 29 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp29 ( & mut self ) -> _NOTP29W { _NOTP29W { w : self } } # [ doc = "Bit 30 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp30 ( & mut self ) -> _NOTP30W { _NOTP30W { w : self } } # [ doc = "Bit 31 - Toggle output bits: 0 = no operation. 1 = Toggle output bit." ] # [ inline ] pub fn notp31 ( & mut self ) -> _NOTP31W { _NOTP31W { w : self } } } } } # [ allow ( renamed_and_removed_lints ) ] # [ allow ( private_no_mangle_statics ) ] # [ no_mangle ] static mut DEVICE_PERIPHERALS : bool = false ; # [ doc = r" All the peripherals" ] # [ allow ( non_snake_case ) ] pub struct Peripherals { # [ doc = "I2C" ] pub I2C : I2C , # [ doc = "WWDT" ] pub WWDT : WWDT , # [ doc = "USART" ] pub USART : USART , # [ doc = "CT16B0" ] pub CT16B0 : CT16B0 , # [ doc = "CT16B1" ] pub CT16B1 : CT16B1 , # [ doc = "CT32B0" ] pub CT32B0 : CT32B0 , # [ doc = "CT32B1" ] pub CT32B1 : CT32B1 , # [ doc = "ADC" ] pub ADC : ADC , # [ doc = "PMU" ] pub PMU : PMU , # [ doc = "FLASHCTRL" ] pub FLASHCTRL : FLASHCTRL , # [ doc = "SSP0" ] pub SSP0 : SSP0 , # [ doc = "IOCON" ] pub IOCON : IOCON , # [ doc = "SYSCON" ] pub SYSCON : SYSCON , # [ doc = "GPIO_PIN_INT" ] pub GPIO_PIN_INT : GPIO_PIN_INT , # [ doc = "SSP1" ] pub SSP1 : SSP1 , # [ doc = "GPIO_GROUP_INT0" ] pub GPIO_GROUP_INT0 : GPIO_GROUP_INT0 , # [ doc = "GPIO_GROUP_INT1" ] pub GPIO_GROUP_INT1 : GPIO_GROUP_INT1 , # [ doc = "USB" ] pub USB : USB , # [ doc = "GPIO_PORT" ] pub GPIO_PORT : GPIO_PORT , } impl Peripherals { # [ doc = r" Returns all the peripherals *once*" ] # [ inline ] pub fn take ( ) -> Option < Self > { cortex_m :: interrupt :: free ( | _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some ( unsafe { Peripherals :: steal ( ) } ) } } ) } # [ doc = r" Unchecked version of `Peripherals::take`" ] pub unsafe fn steal ( ) -> Self { debug_assert ! ( ! DEVICE_PERIPHERALS ) ; DEVICE_PERIPHERALS = true ; Peripherals { I2C : I2C { _marker : PhantomData } , WWDT : WWDT { _marker : PhantomData } , USART : USART { _marker : PhantomData } , CT16B0 : CT16B0 { _marker : PhantomData } , CT16B1 : CT16B1 { _marker : PhantomData } , CT32B0 : CT32B0 { _marker : PhantomData } , CT32B1 : CT32B1 { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , PMU : PMU { _marker : PhantomData } , FLASHCTRL : FLASHCTRL { _marker : PhantomData } , SSP0 : SSP0 { _marker : PhantomData } , IOCON : IOCON { _marker : PhantomData } , SYSCON : SYSCON { _marker : PhantomData } , GPIO_PIN_INT : GPIO_PIN_INT { _marker : PhantomData } , SSP1 : SSP1 { _marker : PhantomData } , GPIO_GROUP_INT0 : GPIO_GROUP_INT0 { _marker : PhantomData } , GPIO_GROUP_INT1 : GPIO_GROUP_INT1 { _marker : PhantomData } , USB : USB { _marker : PhantomData } , GPIO_PORT : GPIO_PORT { _marker : PhantomData } , } } }
